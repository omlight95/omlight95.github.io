<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在go语言中，我们可以很方便的用defer关闭一个打开的文件、释放一个Redis连接，或者解锁一个Mutex。而且Go语言在设计上保证，即使发生panic，所有的defer调用也能够被执行。不过多个defer函数是按照定义顺序倒序执行的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang defer原理">
<meta property="og:url" content="http://example.com/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Omlight&#39;s Blog">
<meta property="og:description" content="在go语言中，我们可以很方便的用defer关闭一个打开的文件、释放一个Redis连接，或者解锁一个Mutex。而且Go语言在设计上保证，即使发生panic，所有的defer调用也能够被执行。不过多个defer函数是按照定义顺序倒序执行的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/4633c7d0f13146e98629e4aa28a41897.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/aede08b2153d4207acfda6f0cfcabefc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/3acc4c115ed148e288623124b9271fc4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/5fd309d14f104c8cab7a9958769887fc.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/6398a8b53ce3467383089c008ac673f8.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/524f3dcc39704a839926a4937b14a11a.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/7fa8fc9013ea4cf69f30e78cf3d6cde3.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/a03cdb95ef2f4d0496dfb127f87293e1.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2a0b0654034e4c8f90d7e3093fc6159f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2aa40dc14734494daf50d6003df58cc5.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/35f5899cabd84fe48dbd24c40902ce08.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/9485c414068445c8890f7de2623b8842.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b946fc19c85742a099fd3b67b1521f03.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/c90468fd3fbc41a3a3f2ea67b0936ebe.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/b031a359cf12415b9521b5e71a6ff0fd.png">
<meta property="article:published_time" content="2022-09-07T15:18:15.336Z">
<meta property="article:modified_time" content="2022-11-21T14:31:32.275Z">
<meta property="article:author" content="Omlight">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/4633c7d0f13146e98629e4aa28a41897.png">

<link rel="canonical" href="http://example.com/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Golang defer原理 | Omlight's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fb965384e6867949ee72c7e67224e414";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
	</div>
	<a target="_blank" rel="noopener" href="https://github.com/omlight95" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Omlight's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不知乘月几人归，落月摇情满江树</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Omlight">
      <meta itemprop="description" content="gopher">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Omlight's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Golang defer原理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-07 23:18:15" itemprop="dateCreated datePublished" datetime="2022-09-07T23:18:15+08:00">2022-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-21 22:31:32" itemprop="dateModified" datetime="2022-11-21T22:31:32+08:00">2022-11-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
                </span>
            </span>

          
            <span id="/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/" class="post-meta-item leancloud_visitors" data-flag-title="Golang defer原理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">在go语言中，我们可以很方便的用defer关闭一个打开的文件、释放一个Redis连接，或者解锁一个Mutex。而且Go语言在设计上保证，即使发生panic，所有的defer调用也能够被执行。不过多个defer函数是按照定义顺序倒序执行的。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="defer1-12"><a href="#defer1-12" class="headerlink" title="defer1.12"></a>defer1.12</h2><h3 id="defer延迟和倒序的机制"><a href="#defer延迟和倒序的机制" class="headerlink" title="defer延迟和倒序的机制"></a>defer延迟和倒序的机制</h3><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>在go语言中，我们可以很方便的用defer关闭一个打开的文件、释放一个Redis连接，或者解锁一个Mutex。而且Go语言在设计上保证，即使发生panic，所有的defer调用也能够被执行。不过多个defer函数是按照定义顺序倒序执行的。</p>
<p>我们通过一个例子来解释defer函数的延迟与倒序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> A()</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一段代码，在Go1.12中编译以后的伪指令是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := runtime.deferproc(<span class="number">0</span>, A) <span class="comment">// 经过recover返回时r为1，否则为0</span></span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中与defer指令相关的有两个部分。第一部分是<code>deferproc</code>，它负责保存要执行的函数信息,我们称之为defer<code>注册</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span></span><br></pre></td></tr></table></figure>


<p>从函数原型来看，<code>deferproc</code>函数有两个参数，第一个是被注册的defer函数的参数加返回值共占多少字节；第二个参数是一个<code>runtime.funcval</code>结构体的指针，也就是一个<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_49723651/article/details/121362988">Function Value</a>。</p>
<p>与defer指令相关的第二部分就是<code>deferreturn</code>，它被编译器插入到函数返回以前调用，负责执行已经注册的defer函数。所以defer函数之所以能延迟到函数返回前执行，就是因为先注册，后调用。</p>
<h4 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h4><p>再来看看defer函数为什么会倒序执行。<br>defer注册信息会保存到defer链表。每个goroutine在运行时都对应一个<code>runtime.g</code>结构体，其中有一个<code>_defer</code>字段，保存的就是defer链表的头指针。<br><img src="https://img-blog.csdnimg.cn/4633c7d0f13146e98629e4aa28a41897.png" alt="在这里插入图片描述"></p>
<p>deferproc新注册的defr信息会添加到链表头。defer return执行时也从链表头开始，所以defer才会表现为倒序执行。</p>
<h3 id="defer链表项"><a href="#defer链表项" class="headerlink" title="defer链表项"></a>defer链表项</h3><p>defer链表链起来的是一个一个_defer结构体。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    sp        <span class="type">uintptr</span> <span class="comment">// sp at time of defer</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic <span class="comment">// panic that is running defer</span></span><br><span class="line">    link      *_defer</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>siz  由deferproc第一个参数传入，就是defer函数参数加返回值的总大小。<br>这段空间会直接分配在_defer结构体后面，用于在注册时保存给defer函数传入的参数，并在执行时直接拷贝到defer函数的调用者栈上。</p>
</li>
<li><p>started  标识defer函数是否已经开始执行；</p>
</li>
<li><p>sp  就是注册defer函数的函数栈指针；</p>
</li>
<li><p>pc  是deferproc函数返回后要继续执行的指令地址；</p>
</li>
<li><p>fn  由deferproc的第二个参数传入，也就是被注册的defer函数；</p>
</li>
<li><p>_panic  是触发defer函数执行的panic指针，正常流程执行defer时它就是nil；</p>
</li>
<li><p>link  自然是链到之前注册的那个_defer结构体。</p>
</li>
</ul>
<p>这一篇我们只关注正常流程下defer函数的执行，不考虑panic或runtime.Goexit()的情况。</p>
<h3 id="defer传参机制"><a href="#defer传参机制" class="headerlink" title="defer传参机制"></a>defer传参机制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> A1(a)</span><br><span class="line">    </span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里函数A注册了一个defer函数A1，在A的函数栈帧中，局部变量区域存储a&#x3D;1，b&#x3D;2。</p>
<p><img src="https://img-blog.csdnimg.cn/aede08b2153d4207acfda6f0cfcabefc.png" alt="在这里插入图片描述"></p>
<p>到deferproc函数注册defer函数A1时。<br>第一个参数是A1的参数加返回值共占多少字节。A1没有返回值，64位下一个整型参数占用8字节。<br>第二个参数是函数A1。前面我们介绍过，没有捕获列表的Function Value，在编译阶段会做出优化，就是在只读数据段分配一个共用的funcval结构体。如下图中，函数A1的指令入口地址为addr1。在只读数据段分配的指向A1指令入口的funcval结构体地址为addr2，所以deferproc函数第二个参数就是addr2。</p>
<p><img src="https://img-blog.csdnimg.cn/3acc4c115ed148e288623124b9271fc4.png" alt="在这里插入图片描述"></p>
<p>额外要注意的是，deferproc函数调用时，编译器会在它自己的两个参数后面，开辟一段空间，用于存放defer函数A1的返回值和参数。这一段空间会在注册defer时，直接拷贝到_defer结构体的后面。A1只有一个参数a&#x3D;1，放在deferproc函数自己的两个参数之后。注意deferproc函数的返回值空间并没有分配在调用者栈上，而是放到了寄存器中，这和recover有关,且先忽略。</p>
<p><img src="https://img-blog.csdnimg.cn/5fd309d14f104c8cab7a9958769887fc.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/6398a8b53ce3467383089c008ac673f8.png" alt="在这里插入图片描述"></p>
<p>然后这个_defer结构体就被添加到defer链表头，deferproc注册结束。</p>
<p><em>注意：<br>频繁的堆分配势必影响性能，所以Go语言会预分配不同规格的deferpool，执行时从空闲_defer中取一个出来用。没有空闲的或者没有大小合适的，再进行堆分配。用完以后，再放回空闲_defer池。这样可以避免频繁的堆分配与回收。</em></p>
<p>deferproc结束后，接下来会执行到a&#x3D;a+b这一步，所以，局部变量a被置为3。接下来会输出：a&#x3D;3，b&#x3D;2。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数A编译后的伪指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    r := runtime.deferproc(<span class="number">8</span>, A1，<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)<span class="comment">//3,2</span></span><br><span class="line"></span><br><span class="line">    runtime.deferreturn()<span class="comment">//执行defer链表</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后就到deferreturn执行defer链表这里了。从当前goroutine找到链表头上的这个_defer结构体，通过_defer.fn找到defer函数的funcval结构体，进而拿到函数A1的入口地址。接下来就可以调用A1了。</p>
<p><img src="https://img-blog.csdnimg.cn/524f3dcc39704a839926a4937b14a11a.png" alt="在这里插入图片描述"></p>
<p>调用A1时，会把_defer后面的参数与返回值整个拷贝到A1的调用者栈上。然后A1开始执行，输出参数值a&#x3D;1。这个例子的关键，是defer函数的参数在注册时拷贝到堆上，执行时再拷贝到栈上。</p>
<h3 id="defer-闭包"><a href="#defer-闭包" class="headerlink" title="defer+闭包"></a>defer+闭包</h3><p>既然deferproc注册的是一个Function Value，下面就来看看有捕获列表时是什么情况。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        a = a+b</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;(b)</span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个例子中，defer函数不止要传递局部变量<code>b</code>做参数，还捕获了外层函数的局部变量<code>a</code>，形成闭包。匿名函数会由编译器按照<code>A_func1</code>这样的形式命名。如下图所示，假设这个闭包函数的指令入口地址为<code>addr1</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/7fa8fc9013ea4cf69f30e78cf3d6cde3.png" alt="在这里插入图片描述"></p>
<p>上图中，由于捕获变量a除了初始化赋值外还被修改过，所以A的局部变量a改为堆分配，栈上只存它的地址。创建闭包对象时，会堆分配一个<code>funcval</code>结构体，<code>funcval.fn</code>指向闭包函数入口<code>addr1</code>，捕获列表中存储a在堆上的地址。而这个<code>funcval</code>结构体本身的地址addr2，就是<code>deferproc</code>执行时,_defer结构体中的fn的值。别忘了，传给defer函数的参数b&#x3D;2，也要拷贝到_defer结构体后面。</p>
<p><img src="https://img-blog.csdnimg.cn/a03cdb95ef2f4d0496dfb127f87293e1.png" alt="在这里插入图片描述"></p>
<p>上图所示_defer结构体被添加到defer链表头以后，deferproc注册结束。继续执行后面的逻辑。到a&#x3D;a+b这里，a被置为3。下一步输出a&#x3D;3，b&#x3D;2。</p>
<p>接下来，deferreturn执行注册的defer函数时，要把参数b拷贝到栈上的参数空间。还记得闭包函数执行时怎样找到对应的捕获列表吗？通过寄存器存储的funcval地址加上偏移，找到捕获变量a的地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例代码编译后的伪指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a ：= <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *a = <span class="number">1</span></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line">    r := runtime.deferproc(<span class="number">8</span>, A_func1，<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    *a = *a + b</span><br><span class="line">    fmt.Println(*a, b)<span class="comment">//3,2</span></span><br><span class="line"></span><br><span class="line">    runtime.deferreturn()<span class="comment">//执行defer链表</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A_func1</span><span class="params">(b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a := (<span class="type">int</span> *)([DX]+<span class="number">8</span>)</span><br><span class="line">    *a = *a + b</span><br><span class="line">    fmt.Println(*a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要注意捕获变量a在堆上分配，闭包函数执行时，捕获变量a&#x3D;3，参数b&#x3D;2。</p>
<p><img src="https://img-blog.csdnimg.cn/2a0b0654034e4c8f90d7e3093fc6159f.png" alt="在这里插入图片描述"></p>
<p>所以，接下来在defer函数中，捕获变量a被置为5，最终输出a&#x3D;5，b&#x3D;2。这个例子中，最关键的是分清defer传参与闭包捕获变量的实现机制。</p>
<h3 id="defer-A-B-c"><a href="#defer-A-B-c" class="headerlink" title="defer ( A ( B ( c ) ) )"></a>defer ( A ( B ( c ) ) )</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a++</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> A(B(a))</span><br><span class="line">    a++</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个例子中，main函数注册的defer函数是A，所以，defer链表项中_defer.fn存储的是A的funcval指针。但是deferproc执行时，需要保存A的参数到_defer结构体后面。这就需要在defer注册时拿到B的返回值。</p>
<p>既然B会在defer注册时执行，那么对B(a)求值时a&#x3D;1。函数B的返回值就是2，也就是defer注册时保存的参数值为2，所以defer函数A执行时就会输出3。</p>
<h3 id="defer嵌套"><a href="#defer嵌套" class="headerlink" title="defer嵌套"></a>defer嵌套</h3><p>这一次，我们抛开各种细节，只关注defer链表随着defer函数的注册与执行究竟会如何变化。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> B1()</span><br><span class="line">    <span class="keyword">defer</span> B2()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有defer函数都正常执行......</span></span><br></pre></td></tr></table></figure>

<p>这个例子中函数A注册两个defer，我们用函数名标记为A1和A2。</p>
<p><img src="https://img-blog.csdnimg.cn/2aa40dc14734494daf50d6003df58cc5.png" alt="在这里插入图片描述"></p>
<p>到函数A返回前执行deferreturn时，会判断defer链表头上的defer是不是A注册的。方法就是判断_defer结构体记录的sp是否等于A的栈指针.如果是A注册的，就保存defer函数调用的相关信息，然后把这一项从defer链表中移除，然后调用函数A2，A2执行时又注册两个defer，记为B1和B2。</p>
<p><img src="https://img-blog.csdnimg.cn/35f5899cabd84fe48dbd24c40902ce08.png" alt="在这里插入图片描述"></p>
<p>函数A2返回前同样去执行defer链表，同样判断是否是自己注册的defer函数。所以B2执行，之后B1执行。此时A2仍然不知道自己注册的defer函数已经执行完了，直到下一个_defer.sp不等于A2的栈指针，A2注册的defer执行完，A2就可以结束了。</p>
<p><img src="https://img-blog.csdnimg.cn/9485c414068445c8890f7de2623b8842.png" alt="在这里插入图片描述"></p>
<p>因为A1是函数A注册的defer函数，所以又回到A的defer执行流程。A1结束后，defer链表为空，函数A结束。<br>这个例子的关键是defer链表注册时添加链表项，执行时移除链表项的用法。</p>
<h3 id="defer1-12性能问题"><a href="#defer1-12性能问题" class="headerlink" title="defer1.12性能问题"></a>defer1.12性能问题</h3><p>defer1.12的性能问题主要缘于两个方面：</p>
<ol>
<li>_defer结构体堆分配，即使有预分配的deferpool，也需要去堆上获取与释放。而且defer函数的参数还要在注册时从栈拷贝到堆，执行时又要从堆拷贝到栈。</li>
<li>defer信息保存到链表，而链表操作比较慢。</li>
</ol>
<h2 id="defer1-13"><a href="#defer1-13" class="headerlink" title="defer1.13"></a>defer1.13</h2><p>Go1.13中defer性能的优化点，主要集中在减少defer结构体堆分配。我们通过一个例子，看看它是怎样做到的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> B(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>像这样一段代码，在Go1.13中编译后的伪指令是这样的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="keyword">struct</span> &#123;</span><br><span class="line">        runtime._defer</span><br><span class="line">        i <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    d.siz = <span class="number">0</span></span><br><span class="line">    d.fn = B</span><br><span class="line">    d.i = <span class="number">10</span></span><br><span class="line">    r := runtime.deferprocStack(&amp;d._defer)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意上面的结构体d，它由两部分组成，一个是<code>runtime._defer</code>结构体，一个是传给defer函数B的参数。它们被定义为函数A的局部变量，执行阶段会分配在函数栈帧的局部变量区域。接下来的<code>runtime.deferprocStack</code>则会把栈上分配的_defer结构体注册到defer链表。通过这样的方式避免在堆上分配_defer结构体。</p>
<p><img src="https://img-blog.csdnimg.cn/b946fc19c85742a099fd3b67b1521f03.png" alt="在这里插入图片描述"></p>
<p>值得注意的是，1.13版本中并不是所有defer都能够在栈上分配。循环中的defer，无论是显示的for循环，还是goto形成的隐式循环，都只能使用1.12版本中的处理方式在堆上分配。即使只执行一次的for循环也是一样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示循环</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; n; i++&#123;</span><br><span class="line">    <span class="keyword">defer</span> B(i)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式循环</span></span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">defer</span> B()</span><br><span class="line">    <span class="keyword">if</span> i&lt;n &#123;</span><br><span class="line">        n++</span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>所以Go1.13中，runtime._defer结构体增加了一个字段heap，用于标识是否为堆分配。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    heap      <span class="type">bool</span>       <span class="comment">//标识是否为堆分配</span></span><br><span class="line">    sp        <span class="type">uintptr</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic</span><br><span class="line">    link      *_defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>defer函数的执行在1.13中没有变化，依然通过deferreturn实现，依然需要把_defer结构体后面的参数与返回值空间，拷贝到defer函数的调用者栈上。只不过不是从堆上拷贝到栈上，而是从栈上的局部变量空间拷贝到参数空间。</p>
<p><img src="https://img-blog.csdnimg.cn/c90468fd3fbc41a3a3f2ea67b0936ebe.png" alt="在这里插入图片描述"></p>
<p>1.13版本的defer减少了_defer结构体的堆分配，但是仍然要使用defer链表。官方提供的性能优化在30%左右。</p>
<h2 id="defer1-14"><a href="#defer1-14" class="headerlink" title="defer1.14"></a>defer1.14</h2><p>减少_defer结构体的堆分配，也是1.14版本中defer性能优化要持续践行的策略。但是具体做法与1.13版本不同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> A1(i, <span class="number">2</span>*i)</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">defer</span> A2(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a,b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">(m,n <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面这个例子中，函数A注册两个defer函数A1和A2，不过函数A2要到执行阶段根据条件判断是否要执行。先看defer函数A1这部分编译后的伪指令，Go1.14中会把A1需要的参数定义为局部变量，并在函数返回前直接调用A1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">        </span><br><span class="line">    A1（a, b）</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过这样的方式不仅不用构建_defer结构体，也用不到defer链表，但是到defer函数A2这里就行不通了。因为A2不一定要被执行，这要在执行阶段根据参数i的值来决定。</p>
<p>Go1.14通过增加一个标识变量df来解决这类问题。用df中的每一位对应标识当前函数中的一个defer函数是否要执行。</p>
<p><img src="https://img-blog.csdnimg.cn/b031a359cf12415b9521b5e71a6ff0fd.png" alt="在这里插入图片描述"></p>
<p>例如，函数A1要被执行，所以就通过df |&#x3D; 1把df第一位置为1；在函数返回前再通过df&amp;1判断是否要调用函数A1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    df |= <span class="number">1</span>      </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//code to do something</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以像A2这样有条件执行的defer函数就可以像下面这样处理了。根据条件判断是否要把对应标识位置为1，函数返回前同样要根据标识符来判断是否要调用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line">    <span class="comment">//A1的参数</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    df |= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//A2的参数</span></span><br><span class="line">    <span class="keyword">var</span> m,n <span class="type">string</span> = <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line">        df |= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//code to do something</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//判断A2是否要调用</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">2</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">2</span></span><br><span class="line">        A2(m, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断A1是否要调用</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//省略部分与recover相关的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Go1.14把defer函数在当前函数内展开并直接调用，这种方式被称为open coded defer。这种方式不仅不用创建_defer结构体，也脱离了defer链表的束缚。不过这种方式依然不适用于循环中的defer，所以1.12版本defer的处理方式是一直保留的。</p>
<p><strong>注意：</strong></p>
<p>但是，必须要强调的是，我们一直在梳理的都是程序正常执行时defer的处理逻辑。一旦发生panic或者调用了runtime.Goexit函数，在这之后的正常逻辑就都不会执行了，而是直接去执行defer链表。那些使用open coded defer在函数内展开，因而没有被注册到链表的defer函数要通过栈扫描的方式来发现。</p>
<p>Go1.14中runtime._defer结构体又增加了几个字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    heap      <span class="type">bool</span></span><br><span class="line">    openDefer <span class="type">bool</span>           <span class="comment">//1</span></span><br><span class="line">    sp        <span class="type">uintptr</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic</span><br><span class="line">    link      *_defer </span><br><span class="line">    fd        unsafe.Pointer <span class="comment">//2</span></span><br><span class="line">    varp      <span class="type">uintptr</span>        <span class="comment">//3</span></span><br><span class="line">    framepc   <span class="type">uintptr</span>  </span><br></pre></td></tr></table></figure>


<p>借助这些信息，panic处理流程可以通过栈扫描的方式找到这些没有被注册到defer链表的defer函数，并按照正确的顺序执行。<br>所以，实际上Go1.14版本中defer的确变快了，但panic变得更慢了……</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/07/Go/Golang%20%E9%97%AD%E5%8C%85/" rel="prev" title="Golang 闭包">
      <i class="fa fa-chevron-left"></i> Golang 闭包
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/09/07/Go/Golang%20slice%E4%BC%A0%E5%8F%82%E9%99%B7%E9%98%B1/" rel="next" title="Golang slice传参陷阱">
      Golang slice传参陷阱 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#defer1-12"><span class="nav-number">1.</span> <span class="nav-text">defer1.12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E5%BB%B6%E8%BF%9F%E5%92%8C%E5%80%92%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">defer延迟和倒序的机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%B6%E8%BF%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">延迟</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%92%E5%BA%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">倒序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E9%93%BE%E8%A1%A8%E9%A1%B9"><span class="nav-number">1.2.</span> <span class="nav-text">defer链表项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E4%BC%A0%E5%8F%82%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">defer传参机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-%E9%97%AD%E5%8C%85"><span class="nav-number">1.4.</span> <span class="nav-text">defer+闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer-A-B-c"><span class="nav-number">1.5.</span> <span class="nav-text">defer ( A ( B ( c ) ) )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer%E5%B5%8C%E5%A5%97"><span class="nav-number">1.6.</span> <span class="nav-text">defer嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defer1-12%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="nav-number">1.7.</span> <span class="nav-text">defer1.12性能问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer1-13"><span class="nav-number">2.</span> <span class="nav-text">defer1.13</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#defer1-14"><span class="nav-number">3.</span> <span class="nav-text">defer1.14</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Omlight"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Omlight</p>
  <div class="site-description" itemprop="description">gopher</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">142</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/omlight95" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;omlight95" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_49723651?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_49723651?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa custom csdn fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Omlight</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'NYxlvPYAXEonmQ80BtgDUD58-gzGzoHsz',
      appKey     : 'su4psizeZXLgtHkhviTz7tct',
      placeholder: "欢迎畅所欲言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-Hans' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
