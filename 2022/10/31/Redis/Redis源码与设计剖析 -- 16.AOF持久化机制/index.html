<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="除了RDB持久化功能之外，Redis 还提供了AOF ( Append Only File )持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是以日志的方式记录Redis服务器所执行的写命令来记录数据库状态的。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码与设计剖析 -- 16.AOF持久化机制">
<meta property="og:url" content="http://example.com/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2016.AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Omlight&#39;s Blog">
<meta property="og:description" content="除了RDB持久化功能之外，Redis 还提供了AOF ( Append Only File )持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是以日志的方式记录Redis服务器所执行的写命令来记录数据库状态的。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/cd21b2ed93784cdab270ca389fc3de5f.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/49187a5cd71c4098836858d9939a4b92.png">
<meta property="article:published_time" content="2022-10-31T09:26:43.728Z">
<meta property="article:modified_time" content="2022-10-31T11:27:17.841Z">
<meta property="article:author" content="Omlight">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/cd21b2ed93784cdab270ca389fc3de5f.png">

<link rel="canonical" href="http://example.com/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2016.AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis源码与设计剖析 -- 16.AOF持久化机制 | Omlight's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fb965384e6867949ee72c7e67224e414";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
	</div>
	<a target="_blank" rel="noopener" href="https://github.com/omlight95" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Omlight's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不知乘月几人归，落月摇情满江树</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2016.AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Omlight">
      <meta itemprop="description" content="gopher">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Omlight's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis源码与设计剖析 -- 16.AOF持久化机制
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-31 17:26:43 / 修改时间：19:27:17" itemprop="dateCreated datePublished" datetime="2022-10-31T17:26:43+08:00">2022-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <span id="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2016.AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="Redis源码与设计剖析 -- 16.AOF持久化机制" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2016.AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2016.AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">除了RDB持久化功能之外，Redis 还提供了AOF ( Append Only File )持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是以日志的方式记录Redis服务器所执行的写命令来记录数据库状态的。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-AOF-介绍"><a href="#1-AOF-介绍" class="headerlink" title="1. AOF 介绍"></a>1. AOF 介绍</h2><p>除了RDB持久化功能之外，Redis 还提供了<code>AOF ( Append Only File )</code>持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是以日志的方式记录Redis服务器所执行的<code>写命令</code>来记录数据库状态的，重启时再重新执行AOF文件中的命令达到恢复数据的目的，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/cd21b2ed93784cdab270ca389fc3de5f.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-AOF的优缺点"><a href="#1-1-AOF的优缺点" class="headerlink" title="1.1 AOF的优缺点"></a>1.1 AOF的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li>该机制可以带来更高的数据安全性，即数据持久性.</li>
<li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容.</li>
<li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作. 事实上，我们也可以通过该文件完成数据的重建.</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>相对于RDB，AOF远大于RDB，修复速度也比RDB慢.</li>
<li>AOF运行效率也比RDB慢，因此默认RDB操作.</li>
</ul>
<h2 id="2-AOF持久化的实现"><a href="#2-AOF持久化的实现" class="headerlink" title="2. AOF持久化的实现"></a>2. AOF持久化的实现</h2><h3 id="2-1-命令写入磁盘"><a href="#2-1-命令写入磁盘" class="headerlink" title="2.1 命令写入磁盘"></a>2.1 命令写入磁盘</h3><h4 id="2-1-1-命令追加"><a href="#2-1-1-命令追加" class="headerlink" title="2.1.1 命令追加"></a>2.1.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾：</p>
<p>缓冲区由<code>SDS</code>实现，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// AOF缓冲区</span></span><br><span class="line">	<span class="comment">// 在进入事件循环之前写入</span></span><br><span class="line">	sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>在执行<code>AOF</code>文件写入的时候，Redis会直接向这个<code>SDS</code>类型的缓冲区中写入<code>文本协议格式</code>，如下所示：</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="number">2</span>\r\n$<span class="number">6</span>\r\nSELECT\r\n$<span class="number">1</span>\r\n0\r\n*<span class="number">5</span>\r\n$<span class="number">4</span>\r\nSADD\r\n$<span class="number">3</span>\r\nkey\r\n$<span class="number">2</span>\r\nm3\r\n$<span class="number">2</span>\r\nm2\r\n$<span class="number">2</span>\r\nm1\r\n</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>*2表示接下来是一行新的命令，该命令由2个单词组成； $6表示第一个单词有6个字符，即SELECT； $1表示第二个单词有1个字符，即0。</li>
<li>*5表示接下来是一行新的命令，该命令由5个单词组成； $4表示第一个单词有4个字符，即SADD； $3表示第二个单词有3个字符，即key； $2表示第三个单词有2个字符，即m3； $2表示第四个单词有2个字符，即m2； $2表示第四个单词有2个字符，即m1。</li>
</ul>
<p>所以这两条命令就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT <span class="number">0</span></span><br><span class="line">SADD key m3 m2 m1</span><br></pre></td></tr></table></figure>

<p>文本协议具有很高的可读性，可以直接进行修改。而且，文本协议还具有很好的兼容性，而且协议采用了<code>\r\n</code>换行符，所以每次写入命令只需执行追加操作.</p>
<p><strong>追加命令到缓冲区中</strong></p>
<p>源码中使用<code>catAppendOnlyGenericCommand()</code>函数实现了追加命令到缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据传入的命令和命令参数，将他们还原成协议格式</span></span><br><span class="line"><span class="comment">// 每次传入一行命令</span></span><br><span class="line"><span class="comment">// 参数： 缓冲区 命令单词数 命令</span></span><br><span class="line">sds <span class="title function_">catAppendOnlyGenericCommand</span><span class="params">(sds dst, <span class="type">int</span> argc, robj **argv)</span> &#123;</span><br><span class="line">		<span class="comment">// 临时缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> len, j;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式：&quot;*&lt;argc&gt;\r\n&quot;</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="comment">// long long类型转C字符串，成功返回转换后字符串长度，失败返回0</span></span><br><span class="line">    <span class="comment">//这里是将命令的单词个数存入buf中，然后返回len，len作为临时缓冲区buf的下标</span></span><br><span class="line">    len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,argc);</span><br><span class="line">    buf[len++] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">    buf[len++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 拼接到dst的后面</span></span><br><span class="line">    dst = sdscatlen(dst,buf,len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的参数，建立命令的格式：$&lt;command_len&gt;\r\n&lt;command&gt;\r\n</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        o = getDecodedObject(argv[j]);  <span class="comment">//解码成字符串对象</span></span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">        <span class="comment">// 表示每个单词的长度</span></span><br><span class="line">        len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,sdslen(o-&gt;ptr));</span><br><span class="line">        buf[len++] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">        buf[len++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        dst = sdscatlen(dst,buf,len);</span><br><span class="line">        <span class="comment">// 命令本体</span></span><br><span class="line">        dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">        dst = sdscatlen(dst,<span class="string">&quot;\r\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 引用计数减一</span></span><br><span class="line">        <span class="comment">// 当引用对象等于1时，在操作引用计数减1，直接释放对象的ptr和对象空间</span></span><br><span class="line">        decrRefCount(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst; <span class="comment">//返回还原后的协议内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>追加过期命令的键</strong></p>
<p><code>catAppendOnlyGenericCommand()</code>函数只是追加一个普通的键，然而一个过期命令的键，需要全部转换为<code>PEXPIREAT</code>，因为必须将相对时间设置为绝对时间，否则还原数据库时，就无法得知该键是否过期，Redis的<code>catAppendOnlyExpireAtCommand()</code>函数实现了这个功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用sds表示一个 PEXPIREAT 命令，seconds为生存时间，cmd为指定转换的指令</span></span><br><span class="line"><span class="comment">// 这个函数用来转换 EXPIRE and PEXPIRE 命令成 PEXPIREAT ，以便在AOF时，时间总是一个绝对值</span></span><br><span class="line">sds <span class="title function_">catAppendOnlyExpireAtCommand</span><span class="params">(sds buf, <span class="keyword">struct</span> redisCommand *cmd, robj *key, robj *seconds)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> when;</span><br><span class="line">    robj *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we can use strtoll */</span></span><br><span class="line">    <span class="comment">// 解码成字符串对象，以便使用strtoll函数</span></span><br><span class="line">    seconds = getDecodedObject(seconds);</span><br><span class="line">    <span class="comment">// 取出过期值，long long类型</span></span><br><span class="line">    when = strtoll(seconds-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* Convert argument into milliseconds for EXPIRE, SETEX, EXPIREAT */</span></span><br><span class="line">    <span class="comment">// 将 EXPIRE, SETEX, EXPIREAT 参数的秒转换成毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == setexCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Convert into absolute time for EXPIRE, PEXPIRE, SETEX, PSETEX */</span></span><br><span class="line">    <span class="comment">// 将 EXPIRE, PEXPIRE, SETEX, PSETEX 命令的参数，从相对时间设置为绝对时间</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when += mstime();</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 PEXPIREAT 命令对象</span></span><br><span class="line">    argv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;PEXPIREAT&quot;</span>,<span class="number">9</span>);</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    argv[<span class="number">2</span>] = createStringObjectFromLongLong(when);</span><br><span class="line">    <span class="comment">// 将命令还原成协议格式，追加到buf</span></span><br><span class="line">    buf = catAppendOnlyGenericCommand(buf, <span class="number">3</span>, argv);</span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 返回buf</span></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>这两个函数都是实现的底层功能，最后它们都会被<code>feedAppendOnlyFile()</code>函数调用.</p>
<h4 id="2-1-2-AOF文件写入"><a href="#2-1-2-AOF文件写入" class="headerlink" title="2.1.2 AOF文件写入"></a>2.1.2 AOF文件写入</h4><p><code>feedAppendOnlyFile()</code>函数会创建一个空的简单<code>动态字符串（sds）</code>，将当前所有追加命令操作都追加到这个sds中，最终将这个sds追加到<code>server.aof_buf</code>. 还有就是，这个函数在写入键之前，需要显式的写入一个<code>SELECT</code>命令，以正确的将所有键还原到正确的数据库中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将命令追加到AOF文件中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">feedAppendOnlyFile</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="type">int</span> dictid, robj **argv, <span class="type">int</span> argc)</span> &#123;</span><br><span class="line">    sds buf = sdsempty();   <span class="comment">//设置一个空sds</span></span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用SELECT命令，显式的设置当前数据库</span></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">        <span class="type">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">&quot;%d&quot;</span>,dictid);</span><br><span class="line">        <span class="comment">// 构造SELECT命令的协议格式</span></span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;</span>,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        <span class="comment">// 执行AOF时，当前的数据库ID</span></span><br><span class="line">        server.aof_selected_db = dictid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 EXPIRE/PEXPIRE/EXPIREAT 三个命令，则要转换成 PEXPIREAT 命令</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        <span class="comment">/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 SETEX/PSETEX 命令，则转换成 SET and PEXPIREAT</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">        <span class="comment">/* Translate SETEX/PSETEX to SET and PEXPIREAT */</span></span><br><span class="line">        <span class="comment">// SETEX key seconds value</span></span><br><span class="line">        <span class="comment">// 构建SET命令对象</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;SET&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 将SET命令按协议格式追加到buf中</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 将SETEX/PSETEX命令和键对象按协议格式追加到buf中</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他命令直接按协议格式转换，然后追加到buf中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在进行AOF，则将命令追加到AOF的缓存中，在重新进入事件循环之前，这些命令会被冲洗到磁盘上，并向client回复</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果后台正在进行重写，那么将命令追加到重写缓存区中，以便我们记录重写的AOF文件于当前数据库的差异</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="type">unsigned</span> <span class="type">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-AOF文件同步"><a href="#2-1-3-AOF文件同步" class="headerlink" title="2.1.3 AOF文件同步"></a>2.1.3 AOF文件同步</h4><p>Redis的服务器进程就是一一个<code>事件循环（loop）</code>，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像<code>serverCron()</code>函数这样需要定时运行的函数.<br>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到<code>aof_buf</code>缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用<code>flushAppendOnlyFile()</code>函数，考虑是否需要将<code>aof_buf</code>缓冲区中的内容写入和保存到AOF文件里面.</p>
<p><code>flushAppendOnlyFile()</code>函数的行为由服务器配置的<code>appendfsync</code>选项的值来决定，各个不同值产生的行为如下表所示：</p>
<br>

<table>
<thead>
<tr>
<th>appendfsync选项的值</th>
<th>flushAppendOnlyFile函数的行为</th>
</tr>
</thead>
<tbody><tr>
<td>AOF_FSYNC_ALWAYS</td>
<td>命令写入aof_buf后调用系统fsync和操作同步到AOF文件，fsync完成后进程程返回</td>
</tr>
<tr>
<td>AOF_FSYNC_EVERYSEC</td>
<td>命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由进程每秒调用一次</td>
</tr>
<tr>
<td>AOF_FSYNC_NO</td>
<td>命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘由操作由操作系统负责</td>
</tr>
</tbody></table>
<br>

<p>如果用户没有主动为appendfsync选项设置值,那么appendfsync选项的默认值为everysec。</p>
<br>

<p>我们再来了解一下，<code>write</code>和<code>fsync</code>操作，在系统中都做了哪些事：</p>
<p><strong>write</strong></p>
<p>会触发<code>延迟写（delayed write）机制</code>。Linux在内核提供<code>页缓冲</code>区用来提高IO性能，因此，write操作在将数据写入操作系统的缓冲区后就直接返回，而不一定触发同步到磁盘的操作。只有在页空间写满，或者达到特定的时间周期，才会同步到磁盘。因此单纯的write操作也是有数据丢失的风险。</p>
<p><strong>fsync 和 fdatasync</strong></p>
<p>为此，系统提供了fsync 和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p>
<p>接下来看看同步的源码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将AOF缓存写到磁盘中</span></span><br><span class="line"><span class="comment">// 因为我们需要在回复client之前对AOF执行写操作，唯一的机会是在事件loop中，因此累计所有的AOF到缓存中，在下一次重新进入事件loop之前将缓存写到AOF文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于force参数</span></span><br><span class="line"><span class="comment">// 当fsync被设置为每秒执行一次，如果后台仍有线程正在执行fsync操作，我们可能会延迟flush操作，因为write操作可能会被阻塞，当发生这种情况时，说明需要尽快的执行flush操作，会调用 serverCron() 函数。</span></span><br><span class="line"><span class="comment">// 然而如果force被设置为1，我们会无视后台的fsync，直接进行写入操作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AOF_WRITE_LOG_ERROR_RATE 30</span></span><br><span class="line"><span class="comment">// 将AOF缓存冲洗到磁盘中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushAppendOnlyFile</span><span class="params">(<span class="type">int</span> force)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="type">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓冲区中没有数据，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步策略是每秒同步一次</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        <span class="comment">// AOF同步操作是否在后台正在运行</span></span><br><span class="line">        sync_in_progress = bioPendingJobsOfType(BIO_AOF_FSYNC) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步策略是每秒同步一次，且不是强制同步的</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">// 根据这个同步策略，且没有设置强制执行，我们在后台执行同步</span></span><br><span class="line">        <span class="comment">// 如果同步已经在后台执行，那么可以延迟两秒，如果设置了force，那么服务器会阻塞在write操作上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果后台正在执行同步</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="comment">// 延迟执行flush操作的开始时间为0，表示之前没有延迟过write</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 之前没有延迟过write操作，那么将延迟write操作的开始时间保存下来，然后就直接返回</span></span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 如果之前延迟过write操作，如果没到2秒，直接返回，不执行write</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里，表示后台正在执行fsync，但是延迟时间已经超过2秒</span></span><br><span class="line">            <span class="comment">// 那么执行write操作，此时write会被阻塞</span></span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行write操作，保证写操作是原子操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟检测开始的时间</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="comment">// 将缓冲区的内容写到AOF文件中</span></span><br><span class="line">    nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    <span class="comment">// 设置延迟的时间 = 当前的时间 - 开始的时间</span></span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    <span class="comment">// 捕获不同造成延迟write的事件</span></span><br><span class="line">    <span class="comment">// 如果正在后台执行同步fsync</span></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-write-pending-fsync&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-pending-fsync&quot;</span>,latency);</span><br><span class="line">    <span class="comment">// 如果正在执行AOF或正在执行RDB</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-write-active-child&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-active-child&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-write-alone&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-alone&quot;</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将latency和&quot;aof-write&quot;关联到延迟诊断字典中</span></span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write&quot;</span>,latency);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行了write，所以清零延迟flush的时间</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果写入的字节数不等于缓存的字节数，发生异常错误</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="type">signed</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制日志的频率每行30秒</span></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果写入错误，写errno到日志</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error writing to the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果是写了一部分，发生错误</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Short write while writing to &quot;</span></span><br><span class="line">                                       <span class="string">&quot;the AOF file: (nwritten=%lld, &quot;</span></span><br><span class="line">                                       <span class="string">&quot;expected=%lld)&quot;</span>,</span><br><span class="line">                                       (<span class="type">long</span> <span class="type">long</span>)nwritten,</span><br><span class="line">                                       (<span class="type">long</span> <span class="type">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将追加的内容截断，删除了追加的内容，恢复成原来的文件</span></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">&quot;Could not remove short write &quot;</span></span><br><span class="line">                             <span class="string">&quot;from the append-only file.  Redis may refuse &quot;</span></span><br><span class="line">                             <span class="string">&quot;to load the AOF the next time it starts.  &quot;</span></span><br><span class="line">                             <span class="string">&quot;ftruncate: %s&quot;</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是写入的策略为每次写入就同步，无法恢复这种策略的写，因为我们已经告知使用者，已经将写的数据同步到磁盘了，因此直接退出程序</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置执行write操作的状态</span></span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line">            <span class="comment">// 如果只写入了局部，没有办法用ftruncate()函数去恢复原来的AOF文件</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 只能更新当前的AOF文件的大小</span></span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                <span class="comment">// 删除AOF缓冲区写入的字节数</span></span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* We&#x27;ll try again on the next call... */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nwritten == (signed)sdslen(server.aof_buf</span></span><br><span class="line">    <span class="comment">// 执行write写入成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></span><br><span class="line"><span class="comment">         * OK state and log the event. */</span></span><br><span class="line">        <span class="comment">// 更新最近一次写的状态为 C_OK</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只能更新当前的AOF文件的大小</span></span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个缓存足够小，小于4K，那么重用这个缓存，否则释放AOF缓存</span></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        sdsclear(server.aof_buf);   <span class="comment">//将缓存内容清空，重用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdsfree(server.aof_buf);    <span class="comment">//释放缓存空间</span></span><br><span class="line">        server.aof_buf = sdsempty();<span class="comment">//创建一个新缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果no-appendfsync-on-rewrite被设置为yes，表示正在执行重写，则不执行fsync</span></span><br><span class="line">    <span class="comment">// 或者正在执行 BGSAVE 或 BGWRITEAOF，也不执行</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</span><br><span class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行fsync进行同步，每次写入都同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        <span class="comment">// 设置延迟检测开始的时间</span></span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        <span class="comment">// Linux下调用fdatasync()函数更高效的执行同步</span></span><br><span class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let&#x27;s try to get this data on the disk */</span></span><br><span class="line">        <span class="comment">// 设置延迟的时间 = 当前的时间 - 开始的时间</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-fsync-always&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-fsync-always&quot;</span>,latency);</span><br><span class="line">        <span class="comment">// 更新最近一次执行同步的时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每秒执行一次同步，当前时间大于上一次执行同步的时间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="comment">// 如果没有正在执行同步，那么在后台开一个线程执行同步</span></span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</span><br><span class="line">        <span class="comment">// 更新最近一次执行同步的时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-AOF文件重写"><a href="#2-2-AOF文件重写" class="headerlink" title="2.2 AOF文件重写"></a>2.2 AOF文件重写</h3><p>为了解决AOF文件体积膨胀的问题，Redis 提供了AOF文件重写（rewrite）功能. 通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件.</p>
<p>新文件有以下特性：</p>
<ul>
<li>进程内已经超时的数据不在写入文件.</li>
<li>无效命令不在写入文件.</li>
<li>多条写的命令合并成一个.</li>
</ul>
<p><strong>触发机制</strong></p>
<ul>
<li>手动触发：<code>BGREWRITEAOF</code> 命令.</li>
<li>自动触发：根据<code>redis.conf</code>的两个参数确定触发的时机.<ul>
<li>auto-aof-rewrite-percentage.<br>100：当前AOF的文件空间<code>（aof_current_size）</code>和上一次重写后AOF文件空间<code>（aof_base_size）</code>的比值.</li>
<li>auto-aof-rewrite-min-size 64mb：表示运行AOF重写时文件最小的体积.</li>
<li>自动触发时机 &#x3D; (aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp; (aof_current_size - aof_base_size) &#x2F; aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage).</li>
</ul>
</li>
</ul>
<p><strong>重写的实现</strong></p>
<p>AOF重写操作可能会进行大量的写入操作，可能造成长时间阻塞,这时候服务器将无法处理客户端发来的命令请求.</p>
<p>所以Redis决定<code>fork()</code>一个子进程在后台执行。这样做可以达到两个目的：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求.</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性.</li>
</ul>
<p>不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致.</p>
<p>为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中：</p>
<p><img src="https://img-blog.csdnimg.cn/49187a5cd71c4098836858d9939a4b92.png" alt="在这里插入图片描述"></p>
<p>接下来我们来看源码实现：</p>
<p>首先是AOF重写缓冲区的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AOF缓冲区大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    <span class="comment">/* 10 MB per block */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AOF块缓冲区结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aofrwblock</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前已经使用的和可用的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used, <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[AOF_RW_BUF_BLOCK_SIZE];</span><br><span class="line">&#125; aofrwblock;</span><br></pre></td></tr></table></figure>
<p>重写缓冲区并不是一个大块的内存空间，而是一些内存块的链表，每个内存块的大小为10MB，这样就组成了一个重写缓冲区.</p>
<p>因此当客户端发来命令时，会执行以下操作：</p>
<ol>
<li>执行客户端的命令.</li>
<li>将执行后的写命令追加到AOF缓冲区<code>（server.aof_buf）</code>中.</li>
<li>将执行后的写命令追加到AOF重写缓冲区<code>（server.aof_rewrite_buf_blocks）</code>中.</li>
</ol>
<p>后台执行重写的操作源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是BGREWRITEAOF的工作步骤</span></span><br><span class="line"><span class="comment">// 1. 用户调用BGREWRITEAOF</span></span><br><span class="line"><span class="comment">// 2. Redis调用这个函数，它执行fork()</span></span><br><span class="line"><span class="comment">//      2.1 子进程在临时文件中执行重写操作</span></span><br><span class="line"><span class="comment">//      2.2 父进程将累计的差异数据追加到server.aof_rewrite_buf中</span></span><br><span class="line"><span class="comment">// 3. 当子进程完成2.1</span></span><br><span class="line"><span class="comment">// 4. 父进程会捕捉到子进程的退出码，如果是OK，那么追加累计的差异数据到临时文件，并且对临时文件rename，用它代替旧的AOF文件，然后就完成AOF的重写。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在进行重写或正在进行RDB持久化操作，则返回C_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 创建父子进程间通信的管道</span></span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 记录fork()开始时间</span></span><br><span class="line">    start = ustime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="comment">// 关闭监听的套接字</span></span><br><span class="line">        closeListeningSockets(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置进程名字</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建临时文件</span></span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">        <span class="comment">// 对临时文件进行AOF重写</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            <span class="comment">// 获取子进程使用的内存空间大小</span></span><br><span class="line">            <span class="type">size_t</span> private_dirty = zmalloc_get_private_dirty();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">&quot;AOF rewrite: %zu MB of memory used by copy-on-write&quot;</span>,</span><br><span class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功退出子进程</span></span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异常退出子进程</span></span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="comment">// 设置fork()函数消耗的时间</span></span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        <span class="comment">// 计算fork的速率，GB/每秒</span></span><br><span class="line">        server.stat_fork_rate = (<span class="type">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></span><br><span class="line">        <span class="comment">// 将&quot;fork&quot;和fork消耗的时间关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;fork&quot;</span>,server.stat_fork_time/<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Background append only file rewriting started by pid %d&quot;</span>,childpid);</span><br><span class="line">        <span class="comment">// 将AOF日程标志清零</span></span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// AOF开始的时间</span></span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 设置AOF重写的子进程pid</span></span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        <span class="comment">// 在AOF或RDB期间，不能对哈希表进行resize操作</span></span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        <span class="comment">// 将aof_selected_db设置为-1，强制让feedAppendOnlyFile函数执行时，执行一个select命令</span></span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 清空脚本缓存</span></span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务器主进程执行了<code>fork</code>操作生成一个子进程执行<code>rewriteAppendOnlyFile()</code>函数进行对临时文件的重写操作。</p>
<p><code>rewriteAppendOnlyFile()</code>函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写一系列的命令，用来完全重建数据集到filename文件中，被 REWRITEAOF and BGREWRITEAOF调用</span></span><br><span class="line"><span class="comment">// 为了使重建数据集的命令数量最小，Redis会使用 可变参的命令，例如RPUSH, SADD 和 ZADD。</span></span><br><span class="line"><span class="comment">// 然而每次单个命令的元素数量不能超过AOF_REWRITE_ITEMS_PER_CMD</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rewriteAppendOnlyFile</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    rio aof;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = mstime();</span><br><span class="line">    <span class="type">char</span> byte;</span><br><span class="line">    <span class="type">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时文件的名字保存到tmpfile中</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-%d.aof&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个空sds给 保存子进程AOF时差异累计数据的sds</span></span><br><span class="line">    server.aof_child_diff = sdsempty();</span><br><span class="line">    <span class="comment">// 初始化rio为文件io对象</span></span><br><span class="line">    rioInitWithFile(&amp;aof,fp);</span><br><span class="line">    <span class="comment">// 如果开启了增量时同步，防止在缓存中累计太多命令，造成写入时IO阻塞时间过长</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</span><br><span class="line">        <span class="comment">// 设置自动同步的字节数限制为AOF_AUTOSYNC_BYTES = 32MB</span></span><br><span class="line">        rioSetAutoSync(&amp;aof,AOF_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        <span class="comment">// 按照格式构建 SELECT 命令内容</span></span><br><span class="line">        <span class="type">char</span> selectcmd[] = <span class="string">&quot;*2\r\n$6\r\nSELECT\r\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 当前数据库指针</span></span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        <span class="comment">// 数据库的键值对字典</span></span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="comment">// 如果数据库中没有键值对则跳过当前数据库</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 创建一个安全的字典迭代器</span></span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line">        <span class="keyword">if</span> (!di) &#123;</span><br><span class="line">            <span class="comment">// 创建失败返回C_ERR</span></span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将SELECT 命令写入AOF文件，确保后面的命令能正确载入到数据库</span></span><br><span class="line">        <span class="keyword">if</span> (rioWrite(&amp;aof,selectcmd,<span class="keyword">sizeof</span>(selectcmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="comment">// 将数据库的ID吸入AOF文件</span></span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,j) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历保存当前数据的键值对的字典</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr;</span><br><span class="line">            robj key, *o;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> expiretime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前节点保存的键值</span></span><br><span class="line">            keystr = dictGetKey(de);</span><br><span class="line">            <span class="comment">// 当前节点保存的值对象</span></span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">            <span class="comment">// 初始化一个在栈中分配的键对象</span></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该键值对的过期时间</span></span><br><span class="line">            expiretime = getExpire(db,&amp;key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前键已经过期，则跳过该键</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据值的对象类型，将键值对写到AOF文件中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 值为字符串类型对象</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type == OBJ_STRING) &#123;</span><br><span class="line">                <span class="type">char</span> cmd[]=<span class="string">&quot;*3\r\n$3\r\nSET\r\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 按格式写入SET命令</span></span><br><span class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="comment">/* Key and value */</span></span><br><span class="line">                <span class="comment">// 按格式写入键值对对象</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为列表类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">                <span class="comment">// 重建一个列表对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteListObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为集合类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">                <span class="comment">// 重建一个集合对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为有序集合类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">                <span class="comment">// 重建一个有序集合对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为哈希类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH) &#123;</span><br><span class="line">                <span class="comment">// 重建一个哈希对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteHashObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;Unknown object type&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果该键有过期时间，且没过期，写入过期时间</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> cmd[]=<span class="string">&quot;*3\r\n$9\r\nPEXPIREAT\r\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 将过期键时间全都以Unix时间写入</span></span><br><span class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在rio的缓存中每次写了10M，就从父进程读累计的差异，保存到子进程的aof_child_diff中</span></span><br><span class="line">            <span class="keyword">if</span> (aof.processed_bytes &gt; processed+<span class="number">1024</span>*<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新已写的字节数</span></span><br><span class="line">                processed = aof.processed_bytes;</span><br><span class="line">                <span class="comment">// 从父进程读累计写入的缓冲区的差异，在重写结束时链接到文件的结尾</span></span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);    <span class="comment">//释放字典迭代器</span></span><br><span class="line">        di = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当父进程仍然在发送数据时，先执行一个缓慢的同步，以便下一次最中的同步更快</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次从父进程读取几次数据，以获得更多的数据，我们无法一直读取，因为服务器从client接受的数据总是比发送给子进程要快，所以当数据来临的时候，我们尝试从在循环中多次读取。</span></span><br><span class="line">    <span class="comment">// 如果在20ms之内没有新的数据到来，那么我们终止读取</span></span><br><span class="line">    <span class="type">int</span> nodata = <span class="number">0</span>;</span><br><span class="line">    <span class="type">mstime_t</span> start = mstime();  <span class="comment">//读取的开始时间</span></span><br><span class="line">    <span class="comment">// 在20ms之内等待数据到来</span></span><br><span class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="comment">// 在1ms之内，查看从父进程读数据的fd是否变成可读的，若不可读则aeWait()函数返回0</span></span><br><span class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodata++;   <span class="comment">//更新新数据到来的时间，超过20ms则退出while循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当管道的读端可读时，清零nodata</span></span><br><span class="line">        nodata = <span class="number">0</span>; <span class="comment">/* Start counting from zero, we stop on N *contiguous* timeouts. */</span></span><br><span class="line">        <span class="comment">// 从父进程读累计写入的缓冲区的差异，在重写结束时链接到文件的结尾</span></span><br><span class="line">        aofReadDiffFromParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求父进程停止发送累计差异数据</span></span><br><span class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 将从父进程读ack的fd设置为非阻塞模式</span></span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 在5000ms之内，从fd读1个字节的数据保存在byte中，查看byte是否是&#x27;!&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> ||</span><br><span class="line">        byte != <span class="string">&#x27;!&#x27;</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 如果收到的是父进程发来的&#x27;!&#x27;，则打印日志</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Parent agreed to stop sending diffs. Finalizing AOF...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次从父进程读累计写入的缓冲区的差异</span></span><br><span class="line">    aofReadDiffFromParent();</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">&quot;Concatenating %.2f MB of AOF diff received from parent.&quot;</span>,</span><br><span class="line">        (<span class="type">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">    <span class="comment">// 将子进程aof_child_diff中保存的差异数据写到AOF文件中</span></span><br><span class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次冲洗文件缓冲区，执行同步操作</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;   <span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子性的将临时文件的名字，改成appendonly.aof</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error moving temp append only file on the final destination: %s&quot;</span>, strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;SYNC append only file rewrite performed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写错误处理</span></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error writing append only file on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>我们可以看到在关闭文件之前，多次执行了从重写缓冲区做读操作的<code>aofReadDiffFromParent()</code>. 在最后执行了<code>rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)</code>操作，这就是把AOF重写缓冲区保存服务器主进程新命令追加写到AOF文件中，以此保证了AOF文件的数据状态和数据库的状态一致.</p>
<p><strong>父子进程之间的通信</strong></p>
<p>整个重写的过程中，父子进行通信的地方只有一个，那就是最后父进程在子进程做重写操作完成时，把子进程重写操作期间所执行的新命令发送给子进程的重写缓冲区，子进程然后将重写缓冲区的数据追加到AOF文件中.</p>
<p>而父进程是如何将差异数据发送给子进程呢？Redis中使用的是管道技术.</p>
<h3 id="2-3-AOF文件载入"><a href="#2-3-AOF文件载入" class="headerlink" title="2.3 AOF文件载入"></a>2.3 AOF文件载入</h3><p>因为Redis命令总是在一个客户端中执行，因此，为了载入AOF文件，需要创建一个关闭监听套接字的伪客户端.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行AOF文件中的命令</span></span><br><span class="line"><span class="comment">// 成功返回C_OK，出现非致命错误返回C_ERR，例如AOF文件长度为0，出现致命错误打印日志退出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadAppendOnlyFile</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> *<span class="title">fakeClient</span>;</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>); <span class="comment">//以读打开AOF文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="type">int</span> old_aof_state = server.aof_state;   <span class="comment">//备份当前AOF的状态</span></span><br><span class="line">    <span class="type">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="type">off_t</span> valid_up_to = <span class="number">0</span>; <span class="comment">/* Offset of the latest well-formed command loaded. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件打开，但是大小为0，则返回C_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件打开失败，打印日志，退出</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily disable AOF, to prevent EXEC from feeding a MULTI</span></span><br><span class="line"><span class="comment">     * to the same file we&#x27;re about to read. */</span></span><br><span class="line">    <span class="comment">// 暂时关闭AOF，防止在执行MULTI时，EXEC命令被传播到AOF文件中</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个伪client</span></span><br><span class="line">    fakeClient = createFakeClient();</span><br><span class="line">    <span class="comment">// 设置载入的状态信息</span></span><br><span class="line">    startLoading(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> argc, j;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Serve the clients from time to time */</span></span><br><span class="line">        <span class="comment">// 间隔性的处理client请求</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="comment">// ftello(fp)返回当前文件载入的偏移量</span></span><br><span class="line">            <span class="comment">// 设置载入时server的状态信息，更新当前载入的进度</span></span><br><span class="line">            loadingProgress(ftello(fp));</span><br><span class="line">            <span class="comment">// 在服务器被阻塞的状态下，仍然能处理请求</span></span><br><span class="line">            <span class="comment">// 因为当前处于载入状态，当client的请求到来时，总是返回loading的状态错误</span></span><br><span class="line">            processEventsWhileBlocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一行文件内容读到buf中，遇到&quot;\r\n&quot;停止</span></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(fp))   <span class="comment">//如果文件已经读完了或数据库为空，则跳出while循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查文件格式 &quot;*&lt;argc&gt;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        <span class="comment">// 取出命令参数个数</span></span><br><span class="line">        argc = atoi(buf+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;  <span class="comment">//至少一个参数，就是当前命令</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配参数列表空间</span></span><br><span class="line">        argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        <span class="comment">// 设置伪client的参数列表</span></span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历参数列表</span></span><br><span class="line">        <span class="comment">// &quot;$&lt;command_len&gt;\r\n&lt;command&gt;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="comment">// 读一行内容到buf中，遇到&quot;\r\n&quot;停止</span></span><br><span class="line">            <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查格式</span></span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">            <span class="comment">// 读出参数的长度len</span></span><br><span class="line">            len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 初始化一个len长度的sds</span></span><br><span class="line">            argsds = sdsnewlen(<span class="literal">NULL</span>,len);</span><br><span class="line">            <span class="comment">// 从文件中读出一个len字节长度，将值保存到argsds中</span></span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                sdsfree(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个字符串对象保存读出的参数argsds</span></span><br><span class="line">            argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line">            <span class="comment">// 读两个字节，跳过&quot;\r\n&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr; <span class="comment">/* discard CRLF */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Command lookup */</span></span><br><span class="line">        <span class="comment">// 查找命令</span></span><br><span class="line">        cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>, (<span class="type">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Run the command in the context of a fake client */</span></span><br><span class="line">        <span class="comment">// 调用伪client执行命令</span></span><br><span class="line">        cmd-&gt;proc(fakeClient);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The fake client should not have a reply */</span></span><br><span class="line">        <span class="comment">// 伪client不应该有回复</span></span><br><span class="line">        serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* The fake client should never get blocked */</span></span><br><span class="line">        <span class="comment">// 伪client不应该是阻塞的</span></span><br><span class="line">        serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Clean up. Command code may have changed argv/argc so we use the</span></span><br><span class="line"><span class="comment">         * argv/argc of the client instead of the local variables. */</span></span><br><span class="line">        <span class="comment">// 释放伪client的参数列表</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        <span class="comment">// 更新已载入且命令合法的当前文件的偏移量</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This point can only be reached when EOF is reached without errors.</span></span><br><span class="line"><span class="comment">     * If the client is in the middle of a MULTI/EXEC, log error and quit. */</span></span><br><span class="line">    <span class="comment">// 执行到这里，说明AOF文件的所有内容都被正确的读取</span></span><br><span class="line">    <span class="comment">// 如果伪client处于 MULTI/EXEC 的环境中，还有检测文件是否包含正确事物的结束，调到uxeof</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) <span class="keyword">goto</span> uxeof;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 载入成功</span></span><br><span class="line">loaded_ok: <span class="comment">/* DB loaded, cleanup and return C_OK to the caller. */</span></span><br><span class="line">    fclose(fp); <span class="comment">//关闭文件</span></span><br><span class="line">    freeFakeClient(fakeClient); <span class="comment">//释放伪client</span></span><br><span class="line">    server.aof_state = old_aof_state;   <span class="comment">//还原AOF状态</span></span><br><span class="line">    stopLoading();  <span class="comment">//设置载入完成的状态</span></span><br><span class="line">    aofUpdateCurrentSize(); <span class="comment">//更新服务器状态，当前AOF文件的大小</span></span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size; <span class="comment">//更新重写的大小</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 载入时读错误，如果feof(fp)为真，则直接执行 uxeof</span></span><br><span class="line">readerr: <span class="comment">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="comment">// 退出前释放伪client的空间</span></span><br><span class="line">        <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unrecoverable error reading the append only file: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不被预期的AOF文件结束格式</span></span><br><span class="line">uxeof: <span class="comment">/* Unexpected AOF end of file. */</span></span><br><span class="line">    <span class="comment">// 如果发现末尾结束格式不完整则自动截掉,成功加载前面正确的数据。</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Warning: short read while loading the AOF file !!!&quot;</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Truncating the AOF at offset %llu !!!&quot;</span>,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) valid_up_to);</span><br><span class="line">        <span class="comment">// 截断文件到正确加载的位置</span></span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || truncate(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Last valid command offset is invalid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error truncating the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure the AOF file descriptor points to the end of the</span></span><br><span class="line"><span class="comment">             * file after the truncate call. */</span></span><br><span class="line">            <span class="comment">// 确保截断后的文件指针指向文件的末尾</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; lseek(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t seek the end of the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;AOF loaded anyway because aof-load-truncated is enabled&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok; <span class="comment">//跳转到loaded_ok，表截断成功，成功加载前面正确的数据。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出前释放伪client的空间</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式错误</span></span><br><span class="line">fmterr: <span class="comment">/* Format error. */</span></span><br><span class="line">    <span class="comment">// 退出前释放伪client的空间</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2015.RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" rel="prev" title="Redis源码与设计剖析 -- 15.RDB持久化机制">
      <i class="fa fa-chevron-left"></i> Redis源码与设计剖析 -- 15.RDB持久化机制
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2017.Redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" rel="next" title="Redis源码与设计剖析 -- 17.Redis事件处理">
      Redis源码与设计剖析 -- 17.Redis事件处理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-AOF-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">1. AOF 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-AOF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 AOF的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-AOF%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">2. AOF持久化的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%91%BD%E4%BB%A4%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 命令写入磁盘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-%E5%91%BD%E4%BB%A4%E8%BF%BD%E5%8A%A0"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 命令追加</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-AOF%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 AOF文件写入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3-AOF%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 AOF文件同步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-AOF%E6%96%87%E4%BB%B6%E9%87%8D%E5%86%99"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 AOF文件重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-AOF%E6%96%87%E4%BB%B6%E8%BD%BD%E5%85%A5"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 AOF文件载入</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Omlight"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Omlight</p>
  <div class="site-description" itemprop="description">gopher</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">94</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/omlight95" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;omlight95" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_49723651?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_49723651?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa custom csdn fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Omlight</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'NYxlvPYAXEonmQ80BtgDUD58-gzGzoHsz',
      appKey     : 'su4psizeZXLgtHkhviTz7tct',
      placeholder: "欢迎畅所欲言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-Hans' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
