<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis网络连接库对应的文件是networking.c，这个文件主要负责客户端的创建与释放、命令接收与命令回复、Redis通信协议分析、CLIENT 命令的实现。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码与设计剖析 -- 18.Redis网络连接库分析">
<meta property="og:url" content="http://example.com/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2018.Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Omlight&#39;s Blog">
<meta property="og:description" content="Redis网络连接库对应的文件是networking.c，这个文件主要负责客户端的创建与释放、命令接收与命令回复、Redis通信协议分析、CLIENT 命令的实现。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-31T09:27:10.789Z">
<meta property="article:modified_time" content="2022-10-31T11:30:28.648Z">
<meta property="article:author" content="Omlight">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2018.Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%88%86%E6%9E%90/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis源码与设计剖析 -- 18.Redis网络连接库分析 | Omlight's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?fb965384e6867949ee72c7e67224e414";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband">
	</div>
	<a target="_blank" rel="noopener" href="https://github.com/omlight95" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Omlight's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">不知乘月几人归，落月摇情满江树</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2018.Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Omlight">
      <meta itemprop="description" content="gopher">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Omlight's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis源码与设计剖析 -- 18.Redis网络连接库分析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-10-31 17:27:10 / 修改时间：19:30:28" itemprop="dateCreated datePublished" datetime="2022-10-31T17:27:10+08:00">2022-10-31</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <span id="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2018.Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%88%86%E6%9E%90/" class="post-meta-item leancloud_visitors" data-flag-title="Redis源码与设计剖析 -- 18.Redis网络连接库分析" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2018.Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%88%86%E6%9E%90/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2018.Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%88%86%E6%9E%90/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">Redis网络连接库对应的文件是networking.c，这个文件主要负责客户端的创建与释放、命令接收与命令回复、Redis通信协议分析、CLIENT 命令的实现。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-Redis网络连接库介绍"><a href="#1-Redis网络连接库介绍" class="headerlink" title="1. Redis网络连接库介绍"></a>1. Redis网络连接库介绍</h2><p>Redis网络连接库对应的文件是<code>networking.c</code>，这个文件主要负责：</p>
<ul>
<li>客户端的创建与释放.</li>
<li>命令接收与命令回复.</li>
<li>Redis通信协议分析.</li>
<li>CLIENT 命令的实现.</li>
</ul>
<h2 id="2-客户端的创建与释放"><a href="#2-客户端的创建与释放" class="headerlink" title="2. 客户端的创建与释放"></a>2. 客户端的创建与释放</h2><h3 id="2-1-客户端的创建"><a href="#2-1-客户端的创建" class="headerlink" title="2.1 客户端的创建"></a>2.1 客户端的创建</h3><p>Redis服务器是一个同时与多个客户端建立连接的程序. 当客户端连接上服务器时，服务器会建立一个<code>server.h/client</code>结构来保存客户端的状态信息.<br><code>server.h/client</code>结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// client独一无二的ID</span></span><br><span class="line">    <span class="type">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    <span class="comment">// client的套接字</span></span><br><span class="line">    <span class="type">int</span> fd;                 <span class="comment">/* Client socket. */</span></span><br><span class="line">    <span class="comment">// 指向当前的数据库</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line">    <span class="comment">// 保存指向数据库的ID</span></span><br><span class="line">    <span class="type">int</span> dictid;             <span class="comment">/* ID of the currently SELECTed DB. */</span></span><br><span class="line">    <span class="comment">// client的名字</span></span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME. */</span></span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="comment">// 输入缓存的峰值</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size. */</span></span><br><span class="line">    <span class="comment">// client输入命令时，参数的数量</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    <span class="comment">// client输入命令的参数列表</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="comment">// 保存客户端执行命令的历史记录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    <span class="comment">// 请求协议类型，内联或者多条命令</span></span><br><span class="line">    <span class="type">int</span> reqtype;            <span class="comment">/* Request protocol type: PROTO_REQ_* */</span></span><br><span class="line">    <span class="comment">// 参数列表中未读取命令参数的数量，读取一个，该值减1</span></span><br><span class="line">    <span class="type">int</span> multibulklen;       <span class="comment">/* Number of multi bulk arguments left to read. */</span></span><br><span class="line">    <span class="comment">// 命令内容的长度</span></span><br><span class="line">    <span class="type">long</span> bulklen;           <span class="comment">/* Length of bulk argument in multi bulk request. */</span></span><br><span class="line">    <span class="comment">// 回复缓存列表，用于发送大于固定回复缓冲区的回复</span></span><br><span class="line">    <span class="built_in">list</span> *reply;            <span class="comment">/* List of reply objects to send to the client. */</span></span><br><span class="line">    <span class="comment">// 回复缓存列表对象的总字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list. */</span></span><br><span class="line">    <span class="comment">// 已发送的字节数或对象的字节数</span></span><br><span class="line">    <span class="type">size_t</span> sentlen;         <span class="comment">/* Amount of bytes already sent in the current</span></span><br><span class="line"><span class="comment">                               buffer or object being sent. */</span></span><br><span class="line">    <span class="comment">// client创建所需时间</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           <span class="comment">/* Client creation time. */</span></span><br><span class="line">    <span class="comment">// 最后一次和服务器交互的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; <span class="comment">/* Time of the last interaction, used for timeout */</span></span><br><span class="line">    <span class="comment">// 客户端的输出缓冲区超过软性限制的时间，记录输出缓冲区第一次到达软性限制的时间</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="comment">// client状态的标志</span></span><br><span class="line">    <span class="type">int</span> flags;              <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line">    <span class="comment">// 认证标志，0表示未认证，1表示已认证</span></span><br><span class="line">    <span class="type">int</span> authenticated;      <span class="comment">/* When requirepass is non-NULL. */</span></span><br><span class="line">    <span class="comment">// 从节点的复制状态</span></span><br><span class="line">    <span class="type">int</span> replstate;          <span class="comment">/* Replication state if this is a slave. */</span></span><br><span class="line">    <span class="comment">// 在ack上设置从节点的写处理器，是否在slave向master发送ack，</span></span><br><span class="line">    <span class="type">int</span> repl_put_online_on_ack; <span class="comment">/* Install slave write handler on ACK. */</span></span><br><span class="line">    <span class="comment">// 保存主服务器传来的RDB文件的文件描述符</span></span><br><span class="line">    <span class="type">int</span> repldbfd;           <span class="comment">/* Replication DB file descriptor. */</span></span><br><span class="line">    <span class="comment">// 读取主服务器传来的RDB文件的偏移量</span></span><br><span class="line">    <span class="type">off_t</span> repldboff;        <span class="comment">/* Replication DB file offset. */</span></span><br><span class="line">    <span class="comment">// 主服务器传来的RDB文件的大小</span></span><br><span class="line">    <span class="type">off_t</span> repldbsize;       <span class="comment">/* Replication DB file size. */</span></span><br><span class="line">    <span class="comment">// 主服务器传来的RDB文件的大小，符合协议的字符串形式</span></span><br><span class="line">    sds replpreamble;       <span class="comment">/* Replication DB preamble. */</span></span><br><span class="line">    <span class="comment">// replication复制的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> reploff;      <span class="comment">/* Replication offset if this is our master. */</span></span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_off; <span class="comment">/* Replication ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量所用的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_time;<span class="comment">/* Replication ack time, if this is a slave. */</span></span><br><span class="line">    <span class="comment">// FULLRESYNC回复给从节点的offset</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> psync_initial_offset; <span class="comment">/* FULLRESYNC reply offset other slaves</span></span><br><span class="line"><span class="comment">                                       copying this slave output buffer</span></span><br><span class="line"><span class="comment">                                       should use. */</span></span><br><span class="line">    <span class="type">char</span> replrunid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* Master run id if is a master. */</span></span><br><span class="line">    <span class="comment">// 从节点的端口号</span></span><br><span class="line">    <span class="type">int</span> slave_listening_port; <span class="comment">/* As configured with: REPLCONF listening-port */</span></span><br><span class="line">    <span class="comment">// 从节点IP地址</span></span><br><span class="line">    <span class="type">char</span> slave_ip[NET_IP_STR_LEN]; <span class="comment">/* Optionally given by REPLCONF ip-address */</span></span><br><span class="line">    <span class="comment">// 从节点的功能</span></span><br><span class="line">    <span class="type">int</span> slave_capa;         <span class="comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事物状态</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    <span class="type">int</span> btype;              <span class="comment">/* Type of blocking op if CLIENT_BLOCKED. */</span></span><br><span class="line">    <span class="comment">// 阻塞的状态</span></span><br><span class="line">    blockingState bpop;     <span class="comment">/* blocking state */</span></span><br><span class="line">    <span class="comment">// 最近一个写全局的复制偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> woff;         <span class="comment">/* Last write global replication offset. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控列表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="comment">// 订阅频道</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    <span class="comment">// 订阅的模式</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    <span class="comment">// 被缓存的ID</span></span><br><span class="line">    sds peerid;             <span class="comment">/* Cached peer ID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Response buffer */</span></span><br><span class="line">    <span class="comment">// 回复固定缓冲区的偏移量</span></span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    <span class="comment">// 回复固定缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[PROTO_REPLY_CHUNK_BYTES];</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>

<p>创建客户端的源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的client</span></span><br><span class="line">client *<span class="title function_">createClient</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));    <span class="comment">//分配空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果fd为-1，表示创建的是一个无网络连接的伪客户端，用于执行lua脚本的时候</span></span><br><span class="line">    <span class="comment">// 如果fd不等于-1，表示创建一个有网络连接的客户端</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置fd为非阻塞模式</span></span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 禁止使用 Nagle 算法，client向内核递交的每个数据包都会立即发送给server出去，TCP_NODELAY</span></span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 如果开启了tcpkeepalive，则设置 SO_KEEPALIVE</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            <span class="comment">// 设置tcp连接的keep alive选项</span></span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 创建一个文件事件状态el，且监听读事件，开始接受命令的输入</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认选0号数据库</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置client的ID</span></span><br><span class="line">    c-&gt;id = server.next_client_id++;</span><br><span class="line">    <span class="comment">// client的套接字</span></span><br><span class="line">    c-&gt;fd = fd;</span><br><span class="line">    <span class="comment">// client的名字</span></span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 回复固定(静态)缓冲区的偏移量</span></span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输入缓存区</span></span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    <span class="comment">// 输入缓存区的峰值</span></span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 请求协议类型，内联或者多条命令，初始化为0</span></span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 参数个数</span></span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 参数列表</span></span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 当前执行的命令和最近一次执行的命令</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查询缓冲区剩余未读取命令的数量</span></span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读入参数的长度</span></span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 已发的字节数</span></span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// client的状态</span></span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置创建client的时间和最后一次互动的时间</span></span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 认证状态</span></span><br><span class="line">    c-&gt;authenticated = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// replication复制的状态，初始为无</span></span><br><span class="line">    c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">    <span class="comment">// 设置从节点的写处理器为ack，是否在slave向master发送ack</span></span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// replication复制的偏移量</span></span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量</span></span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量所用的时间</span></span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从节点的端口号</span></span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从节点IP地址</span></span><br><span class="line">    c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 从节点的功能</span></span><br><span class="line">    c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line">    <span class="comment">// 回复链表</span></span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    <span class="comment">// 回复链表的字节数</span></span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复缓冲区的内存大小软限制</span></span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复链表的释放和复制方法</span></span><br><span class="line">    listSetFreeMethod(c-&gt;reply,decrRefCountVoid);</span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    <span class="comment">// 阻塞超过时间</span></span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 造成阻塞的键字典</span></span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 存储解除阻塞的键，用于保存PUSH入元素的键，也就是dstkey</span></span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 阻塞状态</span></span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 要达到的复制偏移量</span></span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 全局的复制偏移量</span></span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 监控的键</span></span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    <span class="comment">// 订阅频道</span></span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 订阅模式</span></span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    <span class="comment">// 被缓存的peerid，peerid就是 ip:port</span></span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 订阅发布模式的释放和比较方法</span></span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line">    <span class="comment">// 将真正的client放在服务器的客户端链表中</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients,c);</span><br><span class="line">    <span class="comment">// 初始化client的事物状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据创建的文件描述符<code>fd</code>，可以创建用于不同场景下的<code>client</code>. 这个<code>fd</code>就是服务器接收客户端<code>connect</code>后所返回的文件描述符.</p>
<ul>
<li><code>fd == -1</code>，表示创建一个无网络连接的客户端。主要用于执行 lua 脚本时.</li>
<li><code>fd != -1</code>，表示接收到一个正常的客户端连接，则会创建一个有网络连接的客户端，也就是创建一个文件事件，来监听这个fd是否可读，当客户端发送数据，则事件被触发.</li>
</ul>
<p>创建客户端的过程，会将<code>server.h/client</code>结构的所有成员初始化，接下里会介绍部分重点的成员.</p>
<p><code>int id</code>：服务器对于每一个连接进来的都会创建一个ID，客户端的ID从1开始。每次重启服务器会刷新.<br><code>int fd</code>：当前客户端状态描述符。分为无网络连接的客户端和有网络连接的客户端.<br><code>int flags</code>：客户端状态的标志.<br><code>robj *name</code>：默认创建的客户端是没有名字的，可以通过<code>CLIENT SETNAME</code>命令设置名字. 后面会介绍该命令的实现.<br><code>int reqtype</code>：请求协议的类型. 因为Redis服务器支持<code>Telnet</code>的连接，因此Telnet命令请求协议类型是<code>PROTO_REQ_INLINE</code>，而<code>redis-cli</code>命令请求的协议类型是<code>PROTO_REQ_MULTIBULK</code>.</p>
<p>用于保存服务器接受客户端命令的成员：</p>
<p><code>sds querybuf</code>：保存客户端发来命令请求的输入缓冲区. 以Redis通信协议的方式保存.<br><code>size_t querybuf_peak</code>：保存输入缓冲区的峰值.<br><code>int argc</code>：命令参数个数.<br><code>robj *argv</code>：命令参数列表.</p>
<p>用于保存服务器给客户端回复的成员：</p>
<p><code>char buf[16*1024]</code>：保存执行完命令所得命令回复信息的静态缓冲区，它的大小是固定的，所以主要保存的是一些比较短的回复. 分配<code>client</code>结构空间时，就会分配一个<code>16K</code>的大小.<br><code>int bufpos</code>：记录静态缓冲区的偏移量，也就是buf数组已经使用的字节数.<br><code>list *reply</code>：保存命令回复的链表. 因为静态缓冲区大小固定，主要保存固定长度的命令回复，当处理一些返回大量回复的命令，则会将命令回复以链表的形式连接起来.<br><code>unsigned long long reply_bytes</code>：保存回复链表的字节数.<br><code>size_t sentlen</code>：已发送回复的字节数.</p>
<h3 id="2-2-客户端的释放"><a href="#2-2-客户端的释放" class="headerlink" title="2.2 客户端的释放"></a>2.2 客户端的释放</h3><p>客户端释放的函数是<code>freeClient()</code>，主要就是释放各种数据结构和清空一些缓冲区等操作，这里就不再列出源码.</p>
<p>我们可以重点关注一下异步释放客户端，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步释放client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeClientAsync</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是已经即将关闭或者是lua脚本的伪client，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP || c-&gt;flags &amp; CLIENT_LUA) <span class="keyword">return</span>;</span><br><span class="line">    c-&gt;flags |= CLIENT_CLOSE_ASAP;</span><br><span class="line">    <span class="comment">// 将client加入到即将关闭的client链表中</span></span><br><span class="line">    <span class="comment">// server.clients_to_close 中保存着服务器中所有待关闭的链表</span></span><br><span class="line">    listAddNodeTail(server.clients_to_close,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置异步释放客户端的目的主要是：防止底层函数正在向客户端的输出缓冲区写数据的时候，关闭客户端，这样是不安全的. Redis会安排客户端在<code>serverCron()</code>函数的安全时间释放它.</p>
<p>当然也可以取消异步释放，那么就会调用<code>freeClient()</code>函数立即释放，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消设置异步释放的client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeClientsInAsyncFreeQueue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有即将关闭的client</span></span><br><span class="line">    <span class="keyword">while</span> (listLength(server.clients_to_close)) &#123;</span><br><span class="line">        listNode *ln = listFirst(server.clients_to_close);</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消立即关闭的标志</span></span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_CLOSE_ASAP;</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="comment">// 从即将关闭的client链表中删除</span></span><br><span class="line">        listDelNode(server.clients_to_close,ln);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-命令接收与命令回复"><a href="#3-命令接收与命令回复" class="headerlink" title="3. 命令接收与命令回复"></a>3. 命令接收与命令回复</h2><h3 id="3-1-命令接收"><a href="#3-1-命令接收" class="headerlink" title="3.1 命令接收"></a>3.1 命令接收</h3><p>当客户端连接上Redis服务器后，服务器会得到一个文件描述符<code>fd</code>，而且服务器会监听该文件描述符的读事件，这些在<code>createClient()</code>函数中. 那么当客户端发送了命令，触发了<code>AE_READABLE</code>事件，那么就会调用回调函数<code>readQueryFromClient()</code>来从文件描述符fd中读发来的命令，并保存在输入缓冲区<code>querybuf</code>中. 而这个回调函数就是我们在Redis事件处理一文中所提到的指向回调函数的指针<code>rfileProc</code>和<code>wfileProc</code>. 那么，我们先来分析<code>readQueryFromClient</code>函数. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取client的输入缓冲区的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    client *c = (client*) privdata;</span><br><span class="line">    <span class="type">int</span> nread, readlen;</span><br><span class="line">    <span class="type">size_t</span> qblen;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入的长度，默认16MB</span></span><br><span class="line">    readlen = PROTO_IOBUF_LEN;</span><br><span class="line">    <span class="comment">// 如果是多条请求，根据请求的大小，设置读入的长度readlen</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> remaining = (<span class="type">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓冲区的长度</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 更新缓冲区的峰值</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    <span class="comment">// 扩展缓冲区的大小</span></span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// 将client发来的命令，读入到输入缓冲区中</span></span><br><span class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen);</span><br><span class="line">    <span class="comment">// 读操作出错</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">&quot;Reading from client: %s&quot;</span>,strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 读操作完成</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新输入缓冲区的已用大小和未用大小。</span></span><br><span class="line">    sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">    <span class="comment">// 设置最后一次服务器和client交互的时间</span></span><br><span class="line">    c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 如果是主节点，则更新复制操作的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;reploff += nread;</span><br><span class="line">    <span class="comment">// 更新从网络输入的字节数</span></span><br><span class="line">    server.stat_net_input_bytes += nread;</span><br><span class="line">    <span class="comment">// 如果输入缓冲区长度超过服务器设置的最大缓冲区长度</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        <span class="comment">// 将client信息转换为sds</span></span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入缓冲区保存在bytes中</span></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        <span class="comment">// 打印到日志</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span>, ci, bytes);</span><br><span class="line">        <span class="comment">// 释放空间</span></span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理client输入的命令内容</span></span><br><span class="line">    processInputBuffer(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这个<code>readQueryFromClient()</code>函数是read函数的封装，从文件描述符<code>fd</code>中读出数据到输入缓冲区<code>querybuf</code>中，并更新输入缓冲区的峰值<code>querybuf_peak</code>，而且会检查读的长度，如果大于了<code>server.client_max_querybuf_len</code>则会退出，而这个阀值在服务器初始化为<code>PROTO_MAX_QUERYBUF_LEN (1024*1024*1024)</code>也就是<code>1G</code>大小.</p>
<p>回忆之前的各种命令实现，都是通过client的argv和argc这两个成员来处理的. 因此，服务器还需要将输入缓冲区<code>querybuf</code>中的数据，处理成参数列表的对象，也就是上面的<code>processInputBuffer()</code>函数. 源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理client输入的命令内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">processInputBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    server.current_client = c;</span><br><span class="line">    <span class="comment">// 一直读输入缓冲区的内容</span></span><br><span class="line">    <span class="keyword">while</span>(sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">        <span class="comment">// 如果处于暂停状态，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; clientsArePaused()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果client处于被阻塞状态，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_BLOCKED) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果client处于关闭状态，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是未知的请求类型，则判定请求类型</span></span><br><span class="line">        <span class="keyword">if</span> (!c-&gt;reqtype) &#123;</span><br><span class="line">            <span class="comment">// 如果是&quot;*&quot;开头，则是多条请求，是client发来的</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;querybuf[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_MULTIBULK;</span><br><span class="line">            <span class="comment">// 否则就是内联请求，是Telnet发来的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_INLINE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是内联请求</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">            <span class="comment">// 处理Telnet发来的内联命令，并创建成对象，保存在client的参数列表中</span></span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果是多条请求</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK) &#123;</span><br><span class="line">            <span class="comment">// 将client的querybuf中的协议内容转换为client的参数列表中的对象</span></span><br><span class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">&quot;Unknown request type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数为0，则重置client</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">            resetClient(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Only reset the client when the command was executed. */</span></span><br><span class="line">            <span class="comment">// 执行命令成功后重置client</span></span><br><span class="line">            <span class="keyword">if</span> (processCommand(c) == C_OK)</span><br><span class="line">                resetClient(c);</span><br><span class="line">            <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行成功，则将用于崩溃报告的client设置为NULL</span></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>redis-cli</code>命令请求的协议类型是<code>PROTO_REQ_MULTIBULK</code>，进而调用<code>processMultibulkBuffer()</code>函数来处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将client的querybuf中的协议内容转换为client的参数列表中的对象</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">processMultibulkBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *newline = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>, ok;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数列表中命令数量为0，因此先分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* The client should have been reset */</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;argc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Multi bulk length cannot be read without a \r\n */</span></span><br><span class="line">        <span class="comment">// 查询第一个换行符</span></span><br><span class="line">        newline = <span class="built_in">strchr</span>(c-&gt;querybuf,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">        <span class="comment">// 没有找到\r\n，表示不符合协议，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; PROTO_INLINE_MAX_SIZE) &#123;</span><br><span class="line">                addReplyError(c,<span class="string">&quot;Protocol error: too big mbulk count string&quot;</span>);</span><br><span class="line">                setProtocolError(c,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Buffer should also contain \n */</span></span><br><span class="line">        <span class="comment">// 检查格式</span></span><br><span class="line">        <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="type">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We know for sure there is a whole line since newline != NULL,</span></span><br><span class="line"><span class="comment">         * so go ahead and find out the multi bulk length. */</span></span><br><span class="line">        <span class="comment">// 保证第一个字符为&#x27;*&#x27;</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;querybuf[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        <span class="comment">// 将&#x27;*&#x27;之后的数字转换为整数。*3\r\n</span></span><br><span class="line">        ok = string2ll(c-&gt;querybuf+<span class="number">1</span>,newline-(c-&gt;querybuf+<span class="number">1</span>),&amp;ll);</span><br><span class="line">        <span class="keyword">if</span> (!ok || ll &gt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">&quot;Protocol error: invalid multibulk length&quot;</span>);</span><br><span class="line">            setProtocolError(c,pos);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向&quot;*3\r\n&quot;的&quot;\r\n&quot;之后的位置</span></span><br><span class="line">        pos = (newline-c-&gt;querybuf)+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 空白命令，则将之前的删除，保留未阅读的部分</span></span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数数量</span></span><br><span class="line">        c-&gt;multibulklen = ll;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setup argv array on client structure */</span></span><br><span class="line">        <span class="comment">// 分配client参数列表的空间</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argv) zfree(c-&gt;argv);</span><br><span class="line">        c-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;multibulklen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;multibulklen &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 读入multibulklen个参数，并创建对象保存在参数列表中</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;multibulklen) &#123;</span><br><span class="line">        <span class="comment">/* Read bulk length if unknown */</span></span><br><span class="line">        <span class="comment">// 读入参数的长度</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bulklen == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到换行符，确保&quot;\r\n&quot;存在</span></span><br><span class="line">            newline = <span class="built_in">strchr</span>(c-&gt;querybuf+pos,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; PROTO_INLINE_MAX_SIZE) &#123;</span><br><span class="line">                    addReplyError(c,</span><br><span class="line">                        <span class="string">&quot;Protocol error: too big bulk count string&quot;</span>);</span><br><span class="line">                    setProtocolError(c,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> C_ERR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Buffer should also contain \n */</span></span><br><span class="line">            <span class="comment">// 检查格式</span></span><br><span class="line">            <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="type">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $3\r\nSET\r\n...，确保是&#x27;$&#x27;字符，保证格式</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;querybuf[pos] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">                addReplyErrorFormat(c,</span><br><span class="line">                    <span class="string">&quot;Protocol error: expected &#x27;$&#x27;, got &#x27;%c&#x27;&quot;</span>,</span><br><span class="line">                    c-&gt;querybuf[pos]);</span><br><span class="line">                setProtocolError(c,pos);</span><br><span class="line">                <span class="keyword">return</span> C_ERR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数长度保存到ll。</span></span><br><span class="line">            ok = string2ll(c-&gt;querybuf+pos+<span class="number">1</span>,newline-(c-&gt;querybuf+pos+<span class="number">1</span>),&amp;ll);</span><br><span class="line">            <span class="keyword">if</span> (!ok || ll &lt; <span class="number">0</span> || ll &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">                addReplyError(c,<span class="string">&quot;Protocol error: invalid bulk length&quot;</span>);</span><br><span class="line">                setProtocolError(c,pos);</span><br><span class="line">                <span class="keyword">return</span> C_ERR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定位第一个参数的位置，也就是SET的S</span></span><br><span class="line">            pos += newline-(c-&gt;querybuf+pos)+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 参数长度太长，进行优化</span></span><br><span class="line">            <span class="keyword">if</span> (ll &gt;= PROTO_MBULK_BIG_ARG) &#123;</span><br><span class="line">                <span class="type">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* If we are going to read a large object from network</span></span><br><span class="line"><span class="comment">                 * try to make it likely that it will start at c-&gt;querybuf</span></span><br><span class="line"><span class="comment">                 * boundary so that we can optimize object creation</span></span><br><span class="line"><span class="comment">                 * avoiding a large copy of data. */</span></span><br><span class="line">                <span class="comment">// 如果我们要从网络中读取一个大的对象，尝试使它可能从c-&gt; querybuf边界开始，以便我们可以优化对象创建，避免大量的数据副本</span></span><br><span class="line">                <span class="comment">// 保存未读取的部分</span></span><br><span class="line">                sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// 重置偏移量</span></span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 获取querybuf中已使用的长度</span></span><br><span class="line">                qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">                <span class="comment">/* Hint the sds library about the amount of bytes this string is</span></span><br><span class="line"><span class="comment">                 * going to contain. */</span></span><br><span class="line">                <span class="comment">// 扩展querybuf的大小</span></span><br><span class="line">                <span class="keyword">if</span> (qblen &lt; (<span class="type">size_t</span>)ll+<span class="number">2</span>)</span><br><span class="line">                    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,ll+<span class="number">2</span>-qblen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存参数的长度</span></span><br><span class="line">            c-&gt;bulklen = ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read bulk argument */</span></span><br><span class="line">        <span class="comment">// 因为只读了multibulklen字节的数据，读到的数据不够，则直接跳出循环，执行processInputBuffer()函数循环读取</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(c-&gt;querybuf)-pos &lt; (<span class="type">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Not enough data (+2 == trailing \r\n) */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 为参数创建了对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Optimization: if the buffer contains JUST our bulk element</span></span><br><span class="line"><span class="comment">             * instead of creating a new object by *copying* the sds we</span></span><br><span class="line"><span class="comment">             * just use the current sds string. */</span></span><br><span class="line">            <span class="comment">// 如果读入的长度大于32k</span></span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG &amp;&amp;</span><br><span class="line">                (<span class="type">signed</span>) sdslen(c-&gt;querybuf) == c-&gt;bulklen+<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c-&gt;argv[c-&gt;argc++] = createObject(OBJ_STRING,c-&gt;querybuf);</span><br><span class="line">                <span class="comment">// 跳过换行</span></span><br><span class="line">                sdsIncrLen(c-&gt;querybuf,<span class="number">-2</span>); <span class="comment">/* remove CRLF */</span></span><br><span class="line">                <span class="comment">/* Assume that if we saw a fat argument we&#x27;ll see another one</span></span><br><span class="line"><span class="comment">                 * likely... */</span></span><br><span class="line">                <span class="comment">// 设置一个新长度</span></span><br><span class="line">                c-&gt;querybuf = sdsnewlen(<span class="literal">NULL</span>,c-&gt;bulklen+<span class="number">2</span>);</span><br><span class="line">                sdsclear(c-&gt;querybuf);</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 创建对象保存在client的参数列表中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;argv[c-&gt;argc++] =</span><br><span class="line">                    createStringObject(c-&gt;querybuf+pos,c-&gt;bulklen);</span><br><span class="line">                pos += c-&gt;bulklen+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空命令内容的长度</span></span><br><span class="line">            c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 未读取命令参数的数量，读取一个，该值减1</span></span><br><span class="line">            c-&gt;multibulklen--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trim to pos */</span></span><br><span class="line">    <span class="comment">// 删除已经读取的，保留未读取的</span></span><br><span class="line">    <span class="keyword">if</span> (pos) sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We&#x27;re done when c-&gt;multibulk == 0 */</span></span><br><span class="line">    <span class="comment">// 命令的参数全部被读取完</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Still not read to process the command */</span></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们结合一个多条批量回复进行分析。一个多条批量回复以 <code>*&lt;argc&gt;\r\n</code>为前缀，后跟多条不同的批量回复，其中 <code>argc</code>为这些批量回复的数量. 那么<code>SET nmykey nmyvalue</code>命令转换为Redis协议内容如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;*3<span class="subst">\r</span><span class="subst">\n</span>$3<span class="subst">\r</span><span class="subst">\n</span>SET<span class="subst">\r</span><span class="subst">\n</span>$5<span class="subst">\r</span><span class="subst">\n</span>mykey<span class="subst">\r</span><span class="subst">\n</span>$7<span class="subst">\r</span><span class="subst">\n</span>myvalue<span class="subst">\r</span><span class="subst">\n</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>当进入<code>processMultibulkBuffer()</code>函数之后，如果是第一次执行该函数，那么<code>argv</code>中未读取的命令数量为0，也就是说参数列表为空，那么会执行<code>if (c-&gt;multibulklen == 0)</code>的代码，这里的代码会解析<code>*3\r\n</code>，将<code>3</code>保存到<code>multibulklen</code>中，表示后面的参数个数，然后根据参数个数，为<code>argv</code>分配空间.</p>
<p>接着，执行<code>multibulklen</code>次while循环，每次读一个参数，例如<code>$3\r\nSET\r\n</code>，也是先读出参数长度，保存在<code>bulklen</code>中，然后将参数<code>SET</code>保存构建成对象保存到参数列表中. 每次读一个参数，<code>multibulklen</code>就会减1，当等于0时，就表示命令的参数全部读取到参数列表完毕.</p>
<p>于是命令接收的整个过程完成.</p>
<h3 id="3-2-命令回复"><a href="#3-2-命令回复" class="headerlink" title="3.2 命令回复"></a>3.2 命令回复</h3><p>命令回复的函数，也是事件处理程序的回调函数之一. 当服务器的client的回复缓冲区有数据，那么就会调用<code>aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,sendReplyToClient, c)</code>函数，将<code>文件描述符fd</code>和<code>AE_WRITABLE</code>事件关联起来，当客户端可写时，就会触发事件，调用<code>sendReplyToClient()</code>函数，执行写事件. 我们重点看这个函数的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写事件处理程序，只是发送回复给client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendReplyToClient</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    <span class="comment">// 发送完数据会删除fd的可读事件</span></span><br><span class="line">    writeToClient(fd,privdata,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数直接调用了<code>writeToClient()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输出缓冲区的数据写给client，如果client被释放则返回C_ERR，没被释放则返回C_OK</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeToClient</span><span class="params">(<span class="type">int</span> fd, client *c, <span class="type">int</span> handler_installed)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> objlen;</span><br><span class="line">    <span class="type">size_t</span> objmem;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定的client的回复缓冲区中还有数据，则返回真，表示可以写socket</span></span><br><span class="line">    <span class="keyword">while</span>(clientHasPendingReplies(c)) &#123;</span><br><span class="line">        <span class="comment">// 固定缓冲区发送未完成</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将缓冲区的数据写到fd中</span></span><br><span class="line">            nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</span><br><span class="line">            <span class="comment">// 写失败跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 更新发送的数据计数器</span></span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果发送的数据等于buf的偏移量，表示发送完成</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>)c-&gt;sentlen == c-&gt;bufpos) &#123;</span><br><span class="line">                <span class="comment">// 则将其重置</span></span><br><span class="line">                c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 固定缓冲区发送完成，发送回复链表的内容</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回复链表的第一条回复对象，和对象值的长度和所占的内存</span></span><br><span class="line">            o = listNodeValue(listFirst(c-&gt;reply));</span><br><span class="line">            objlen = sdslen(o-&gt;ptr);</span><br><span class="line">            objmem = getStringObjectSdsUsedMemory(o);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过空对象，并删除这个对象</span></span><br><span class="line">            <span class="keyword">if</span> (objlen == <span class="number">0</span>) &#123;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                c-&gt;reply_bytes -= objmem;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前节点的值写到fd中</span></span><br><span class="line">            nwritten = write(fd, ((<span class="type">char</span>*)o-&gt;ptr)+c-&gt;sentlen,objlen-c-&gt;sentlen);</span><br><span class="line">            <span class="comment">// 写失败跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 更新发送的数据计数器</span></span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送完成，则删除该节点，重置发送的数据长度，更新回复链表的总字节数</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">                c-&gt;reply_bytes -= objmem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新写到网络的字节数</span></span><br><span class="line">        server.stat_net_output_bytes += totwritten;</span><br><span class="line">        <span class="comment">// 如果这次写的总量大于NET_MAX_WRITES_PER_EVENT的限制，则会中断本次的写操作，将处理时间让给其他的client，以免一个非常的回复独占服务器，剩余的数据下次继续在写</span></span><br><span class="line">        <span class="comment">// 但是，如果当服务器的内存数已经超过maxmemory，即使超过最大写NET_MAX_WRITES_PER_EVENT的限制，也会继续执行写入操作，是为了尽快写入给客户端</span></span><br><span class="line">        <span class="keyword">if</span> (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span><br><span class="line">            (server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">             zmalloc_used_memory() &lt; server.maxmemory)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理写入失败</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            nwritten = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE,</span><br><span class="line">                <span class="string">&quot;Error writing to client: %s&quot;</span>, strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不是主节点服务器，则更新最近和服务器交互的时间</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定的client的回复缓冲区中已经没有数据，发送完成</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c)) &#123;</span><br><span class="line">        c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 删除当前client的可读事件的监听</span></span><br><span class="line">        <span class="keyword">if</span> (handler_installed) aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Close connection after entire reply has been sent. */</span></span><br><span class="line">        <span class="comment">// 如果指定了写入按成之后立即关闭的标志，则释放client</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) &#123;</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数实际上是对<code>write()</code>函数的封装，将静态回复缓冲区<code>buf</code>或回复链表<code>reply</code>中的数据循环写到文件描述符<code>fd</code>中. 如果写完了，则将当前客户端的<code>AE_WRITABLE</code>事件删除.</p>
<h2 id="4-CLIENT命令的实现"><a href="#4-CLIENT命令的实现" class="headerlink" title="4. CLIENT命令的实现"></a>4. CLIENT命令的实现</h2><p><code>CLIENT</code>相关的命令大致有6条：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CLIENT</span> KILL [ip:port] [ID client-<span class="type">id</span>] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [<span class="built_in">SKIPME</span> yes/no] </span><br><span class="line"><span class="built_in">CLIENT</span> GETNAME</span><br><span class="line"><span class="built_in">CLIENT</span> LIST</span><br><span class="line"><span class="built_in">CLIENT</span> PAUSE timeout </span><br><span class="line"><span class="built_in">CLIENT</span> REPLY ON|OFF|<span class="built_in">SKIP</span> </span><br><span class="line"><span class="built_in">CLIENT</span> SETNAME connection-name </span><br></pre></td></tr></table></figure>

<p>下面是<code>client</code>命令的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client 命令的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clientCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    client *client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  CLIENT LIST 的实现</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;list&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* CLIENT LIST */</span></span><br><span class="line">        <span class="comment">// 获取所有的client信息</span></span><br><span class="line">        sds o = getAllClientsInfoString();</span><br><span class="line">        <span class="comment">// 添加到到输入缓冲区中</span></span><br><span class="line">        addReplyBulkCBuffer(c,o,sdslen(o));</span><br><span class="line">        sdsfree(o);</span><br><span class="line">    <span class="comment">// CLIENT REPLY ON|OFF|SKIP 命令实现</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;reply&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* CLIENT REPLY ON|OFF|SKIP */</span></span><br><span class="line">        <span class="comment">// 如果是 ON</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 取消 off 和 skip 的标志</span></span><br><span class="line">            c-&gt;flags &amp;= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);</span><br><span class="line">            <span class="comment">// 回复 +OK</span></span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">        <span class="comment">// 如果是 OFF</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;off&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 打开 OFF标志</span></span><br><span class="line">            c-&gt;flags |= CLIENT_REPLY_OFF;</span><br><span class="line">        <span class="comment">// 如果是 SKIP</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;skip&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 没有设置 OFF 则设置 SKIP 标志</span></span><br><span class="line">            <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_REPLY_OFF))</span><br><span class="line">                c-&gt;flags |= CLIENT_REPLY_SKIP_NEXT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//  CLIENT KILL [ip:port] [ID client-id] [TYPE normal | master | slave | pubsub] [ADDR ip:port] [SKIPME yes / no]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;kill&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* CLIENT KILL &lt;ip:port&gt;</span></span><br><span class="line"><span class="comment">         * CLIENT KILL &lt;option&gt; [value] ... &lt;option&gt; [value] */</span></span><br><span class="line">        <span class="type">char</span> *addr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> type = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">uint64_t</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> skipme = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> killed = <span class="number">0</span>, close_this_client = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CLIENT KILL addr:port只能通过地址杀死client，旧版本兼容</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">/* Old style syntax: CLIENT KILL &lt;addr&gt; */</span></span><br><span class="line">            addr = c-&gt;argv[<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">            skipme = <span class="number">0</span>; <span class="comment">/* With the old form, you can kill yourself. */</span></span><br><span class="line">        <span class="comment">// 新版本可以根据[ID client-id] [master|normal|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]杀死client</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">2</span>; <span class="comment">/* Next option index. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* New style syntax: parse options. */</span></span><br><span class="line">            <span class="comment">// 解析语法</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; c-&gt;argc) &#123;</span><br><span class="line">                <span class="type">int</span> moreargs = c-&gt;argc &gt; i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// CLIENT KILL [ID client-id]</span></span><br><span class="line">                <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;id&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp;</span><br><span class="line">                    <span class="comment">// 获取client的ID</span></span><br><span class="line">                    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[i+<span class="number">1</span>],&amp;tmp,<span class="literal">NULL</span>)</span><br><span class="line">                        != C_OK) <span class="keyword">return</span>;</span><br><span class="line">                    id = tmp;</span><br><span class="line">                <span class="comment">// CLIENT KILL TYPE type, 这里的 type 可以是 [master|normal|slave|pubsub]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;type&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="comment">// 获取client的类型，[master|normal|slave|pubsub]四种之一</span></span><br><span class="line">                    type = getClientTypeByName(c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr);</span><br><span class="line">                    <span class="keyword">if</span> (type == <span class="number">-1</span>) &#123;</span><br><span class="line">                        addReplyErrorFormat(c,<span class="string">&quot;Unknown client type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                            (<span class="type">char</span>*) c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// CLIENT KILL [ADDR ip:port]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;addr&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="comment">// 获取ip:port</span></span><br><span class="line">                    addr = c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">                <span class="comment">// CLIENT KILL [SKIPME yes/no]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;skipme&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="comment">// 如果是yes，设置设置skipme，调用该命令的客户端将不会被杀死</span></span><br><span class="line">                    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;yes&quot;</span>)) &#123;</span><br><span class="line">                        skipme = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 设置为no会影响到还会杀死调用该命令的客户端。</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;no&quot;</span>)) &#123;</span><br><span class="line">                        skipme = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        addReply(c,shared.syntaxerr);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    addReply(c,shared.syntaxerr);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate clients killing all the matching clients. */</span></span><br><span class="line">        listRewind(server.clients,&amp;li);</span><br><span class="line">        <span class="comment">// 迭代所有的client节点</span></span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            client = listNodeValue(ln);</span><br><span class="line">            <span class="comment">// 比较当前client和这四类信息，如果有一个不符合就跳过本层循环，否则就比较下一个信息</span></span><br><span class="line">            <span class="keyword">if</span> (addr &amp;&amp; <span class="built_in">strcmp</span>(getClientPeerId(client),addr) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (type != <span class="number">-1</span> &amp;&amp; getClientType(client) != type) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (id != <span class="number">0</span> &amp;&amp; client-&gt;id != id) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == client &amp;&amp; skipme) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Kill it. */</span></span><br><span class="line">            <span class="comment">// 杀死当前的client</span></span><br><span class="line">            <span class="keyword">if</span> (c == client) &#123;</span><br><span class="line">                close_this_client = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                freeClient(client);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算杀死client的个数</span></span><br><span class="line">            killed++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Reply according to old/new format. */</span></span><br><span class="line">        <span class="comment">// 回复client信息</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 没找到符合信息的</span></span><br><span class="line">            <span class="keyword">if</span> (killed == <span class="number">0</span>)</span><br><span class="line">                addReplyError(c,<span class="string">&quot;No such client&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                addReply(c,shared.ok);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送杀死的个数</span></span><br><span class="line">            addReplyLongLong(c,killed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this client has to be closed, flag it as CLOSE_AFTER_REPLY</span></span><br><span class="line"><span class="comment">         * only after we queued the reply to its output buffers. */</span></span><br><span class="line">        <span class="keyword">if</span> (close_this_client) c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">    <span class="comment">//  CLIENT SETNAME connection-name</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;setname&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j, len = sdslen(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">        <span class="type">char</span> *p = c-&gt;argv[<span class="number">2</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setting the client name to an empty string actually removes</span></span><br><span class="line"><span class="comment">         * the current name. */</span></span><br><span class="line">        <span class="comment">// 设置名字为空</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先释放掉原来的名字</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;name) decrRefCount(c-&gt;name);</span><br><span class="line">            c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise check if the charset is ok. We need to do this otherwise</span></span><br><span class="line"><span class="comment">         * CLIENT LIST format will break. You should always be able to</span></span><br><span class="line"><span class="comment">         * split by space to get the different fields. */</span></span><br><span class="line">        <span class="comment">// 检查名字格式是否正确</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] &lt; <span class="string">&#x27;!&#x27;</span> || p[j] &gt; <span class="string">&#x27;~&#x27;</span>) &#123; <span class="comment">/* ASCII is assumed. */</span></span><br><span class="line">                addReplyError(c,</span><br><span class="line">                    <span class="string">&quot;Client names cannot contain spaces, &quot;</span></span><br><span class="line">                    <span class="string">&quot;newlines or special characters.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放原来的名字</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;name) decrRefCount(c-&gt;name);</span><br><span class="line">        <span class="comment">// 设置新名字</span></span><br><span class="line">        c-&gt;name = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        incrRefCount(c-&gt;name);</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    <span class="comment">//  CLIENT GETNAME</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;getname&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 回复名字</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;name)</span><br><span class="line">            addReplyBulk(c,c-&gt;name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">    <span class="comment">//  CLIENT PAUSE timeout</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;pause&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> duration;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以毫秒为单位将等待时间保存在duration中</span></span><br><span class="line">        <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;duration,UNIT_MILLISECONDS)</span><br><span class="line">                                        != C_OK) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 暂停client</span></span><br><span class="line">        pauseClients(duration);</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyError(c, <span class="string">&quot;Syntax error, try CLIENT (LIST | KILL | GETNAME | SETNAME | PAUSE | REPLY)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2017.Redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" rel="prev" title="Redis源码与设计剖析 -- 17.Redis事件处理">
      <i class="fa fa-chevron-left"></i> Redis源码与设计剖析 -- 17.Redis事件处理
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">1. Redis网络连接库介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="nav-number">2.</span> <span class="nav-text">2. 客户端的创建与释放</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 客户端的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%87%8A%E6%94%BE"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 客户端的释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%91%BD%E4%BB%A4%E6%8E%A5%E6%94%B6%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%9B%9E%E5%A4%8D"><span class="nav-number">3.</span> <span class="nav-text">3. 命令接收与命令回复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%91%BD%E4%BB%A4%E6%8E%A5%E6%94%B6"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 命令接收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%91%BD%E4%BB%A4%E5%9B%9E%E5%A4%8D"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 命令回复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-CLIENT%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">4. CLIENT命令的实现</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Omlight"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Omlight</p>
  <div class="site-description" itemprop="description">gopher</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/omlight95" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;omlight95" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/qq_49723651?spm=1000.2115.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_49723651?spm&#x3D;1000.2115.3001.5343" rel="noopener" target="_blank"><i class="fa custom csdn fa-fw"></i>CSDN</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Omlight</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'NYxlvPYAXEonmQ80BtgDUD58-gzGzoHsz',
      appKey     : 'su4psizeZXLgtHkhviTz7tct',
      placeholder: "欢迎畅所欲言",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-Hans' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
