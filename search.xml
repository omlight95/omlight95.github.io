<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Future模式 Golang实现</title>
    <url>/2022/09/07/Go/Future%E6%A8%A1%E5%BC%8F%20Golang%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>编程中经常遇到在一个流程中需要调用多个子调用的情况，这些子调用相互之间没有依赖，如果串行地调用，则耗时会很长，此时可以使用并发编程中的future模式。<br>比如我们发送ajax请求的时候，页面进行后续处理，用户无需一直等待请求的结果，可以继续浏览或操作其他内容。</p>
<p><strong>future 模式的基本工作原理</strong>：</p>
<ol>
<li>使用chan作为函数参数</li>
<li>启动goroutine调用函数</li>
<li>通过chan传入参数</li>
<li>做其他可以并行处理的事情</li>
<li>通过chan异步获取结果</li>
</ol>
<p><strong>future模式流程图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa2f6ef20b44e15a1ae9474ac890be5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面是一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个查询结构体</span></span><br><span class="line"><span class="comment">// 这里的sql和result是一个简单的抽象，具体的应用可能是更复杂的数据类型</span></span><br><span class="line"><span class="keyword">type</span> query <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 参数Channel</span></span><br><span class="line">	sql <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">	<span class="comment">// 结果Channel</span></span><br><span class="line">	result <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行Query</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execQuery</span><span class="params">(q query)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 获取输入</span></span><br><span class="line">		sql := &lt;- q.sql</span><br><span class="line">		<span class="comment">// 访问数据库</span></span><br><span class="line">		<span class="comment">// 输出结果通道</span></span><br><span class="line">		q.result &lt;- <span class="string">&quot;result from&quot;</span> + sql</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化Query</span></span><br><span class="line">	q := query&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)&#125;</span><br><span class="line">	<span class="comment">// 执行Query, 注意执行的时候无须准备参数</span></span><br><span class="line">	<span class="keyword">go</span> execQuery(q)</span><br><span class="line">	<span class="comment">// 发送参数</span></span><br><span class="line">	q.sql &lt;- <span class="string">&quot;select *fome table&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 做一些其它的事情, 这里通过Sleep描述</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取结果</span></span><br><span class="line">	fmt.Println(&lt;-q.result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result from select * from table</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Context的使用场景</title>
    <url>/2022/09/08/Go/Golang%20Context%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="1-值传递"><a href="#1-值传递" class="headerlink" title="1.值传递"></a>1.值传递</h2><p>值传递只是context的一个辅助功能，并不是核心功能。一般我们只用context来传递不影响业务主逻辑的可选数据，比如日志信息、调试信息以及元信息等等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readContext</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	traceId, ok := ctx.Value(<span class="string">&quot;key&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;readContext key=&quot;</span>, traceId)i</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;readContext no key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	readContext(ctx)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;beautiful&quot;</span>)</span><br><span class="line">	readContext(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在使用WithValue对ctx包装时，可以设置一个key-value键值对，在goroutine之间传递。</p>
<h2 id="2-超时控制"><a href="#2-超时控制" class="headerlink" title="2.超时控制"></a>2.超时控制</h2><p><strong>http请求设置超时时间</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 处理http请求</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">&quot;Request timed out&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;- time.After(time.Second):</span><br><span class="line">			fmt.Println(<span class="string">&quot;Loading...&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start TestTimeoutContext&quot;</span>)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	httpRequest(ctx)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//start TestTimeoutContext</span></span><br><span class="line"><span class="comment">//Loading...</span></span><br><span class="line"><span class="comment">//Loading...</span></span><br><span class="line"><span class="comment">//Request timed out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>文件io或者网络io等耗时操作，可以查看剩余的时间是否充足，决定是否进行下一步操作</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(ctx context.Context)</span></span>  &#123;</span><br><span class="line">	deadline, ok := ctx.Deadline()</span><br><span class="line">	<span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// deadline.Sub(time.Now()) 截止时间与当前时间的差值</span></span><br><span class="line">	isEnough := deadline.Sub(time.Now()) &gt; time.Second * <span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span> isEnough &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;copy file&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;isEnough is false return&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Second * <span class="number">4</span>))</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	copyFile(ctx)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//isEnough is false return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-取消控制"><a href="#3-取消控制" class="headerlink" title="3.取消控制"></a>3.取消控制</h2><p><strong>goroutine发送取消信号，保证自己这个逻辑中发散出去的goroutine全部成功取消</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">				n++</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个Cancel context</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="comment">// 达到要求之后触发cancel</span></span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang IO操作</title>
    <url>/2022/09/07/Go/Golang%20IO%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="file句柄"><a href="#file句柄" class="headerlink" title="file句柄"></a>file句柄</h2><p><code>os.Open(name string)</code>方法以只读方式打开文件，os 包还提供了 <code>os.OpenFile(name string, flag int, perm FileMode) </code>方法，通过指定额外的 <code>读写方式</code> 和 <code>文件权限</code>参数，使文件操作变得更为灵活。</p>
<p>其中，flag 有以下几种常用的值：</p>
<ul>
<li>os.O_CREATE: create if none exists 不存在则创建</li>
<li>os.O_RDONLY: read-only 只读</li>
<li>os.O_WRONLY: write-only 只写</li>
<li>os.O_RDWR: read-write 可读可写</li>
<li>os.O_TRUNC: truncate when opened 文件长度截为0：即清空文件</li>
<li>os.O_APPEND: append 追加新数据到文件</li>
</ul>
<p>对于文件权限参数，Linux系统中采用四位八进制数组成权限，比如0644 。对于每个新创建的文件或目录，系统都会自动赋予一个默认的权限。<br>可以使用<code>umask</code>命令设置文件或目录的默认权限。系统默认的权限掩码是<code>0022</code>。</p>
<p>通常新建文件的默认权限值为0666，新建目录的默认权限为0777，需要与当前的权限掩码0022相减，可以得到<code>0644</code>和<code>0755</code>。</p>
<p>读文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 打开文件返回一个句柄</span></span><br><span class="line">	file, _ := os.Open(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲区</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="comment">// 存放文件所有内容</span></span><br><span class="line">	<span class="keyword">var</span> bytes []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每次读取一行放入缓冲区</span></span><br><span class="line">		count, err := file.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		bytes = <span class="built_in">append</span>(bytes, buf[:count]...)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写文件</p>
<p>可以通过 <code>Write()</code> 和 <code>WriteString()</code> 方法写入数据，最后通过 <code>Sync()</code> 方法将数据持久化到磁盘：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>, os.O_RDWR | os.O_APPEND | os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	data := []<span class="type">byte</span>(<span class="string">&quot;hello\nyes\nno\n&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字节</span></span><br><span class="line">	count, _ := file.Write(data)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第一次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字符串</span></span><br><span class="line">	count, _ = file.WriteString(<span class="string">&quot;write string\n&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第二次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 确保写入磁盘</span></span><br><span class="line">	file.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="更简单的ioutil"><a href="#更简单的ioutil" class="headerlink" title="更简单的ioutil"></a>更简单的ioutil</h2><p>读文件</p>
<p>一次性读入所有内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	bytes, _ := ioutil.ReadFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐行读入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	file, _ := os.Open(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 接受io.Reader类型参数 返回一个bufio.Scanner实例</span></span><br><span class="line">	scanner := bufio.NewScanner(file)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="comment">// 读取当前行内容</span></span><br><span class="line">		line := scanner.Text()</span><br><span class="line">		fmt.Println(count, <span class="string">&quot;: &quot;</span> ,line)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>写文件</p>
<p>覆盖写入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	data := []<span class="type">byte</span>(<span class="string">&quot;hello\nyes\nno\n&quot;</span>)</span><br><span class="line">	ioutil.WriteFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>, data, <span class="number">0664</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追加：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 以指定的权限打开文件</span></span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>, os.O_RDWR | os.O_APPEND | os.O_CREATE, <span class="number">0664</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	data := []<span class="type">byte</span>(<span class="string">&quot;greet\n&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字节</span></span><br><span class="line">	count, _ := file.Write(data)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第一次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字符串</span></span><br><span class="line">	count, _ = file.WriteString(<span class="string">&quot;echo\n&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第二次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 确保落盘</span></span><br><span class="line">	file.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="io-Writer和io-Reader接口"><a href="#io-Writer和io-Reader接口" class="headerlink" title="io.Writer和io.Reader接口"></a>io.Writer和io.Reader接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实io 包就是围绕着实现了 io.Writer 和 io.Reader 接口类型的值而构建的。比如<code>os.File</code>、<code>io.Copy</code>、<code>io.WriteString</code>、<code>io.PipeWriter/Reader</code>、<code>ioutil</code>等等都实现了这两个接口，所以它们都可以读文件和写文件。当然我们也可以自行实现这两个接口。</p>
<h2 id="io-LimitReader函数"><a href="#io-LimitReader函数" class="headerlink" title="io.LimitReader函数"></a>io.LimitReader函数</h2><p>在学习godis时，在aof.go文件中我看到一个关于io流的函数：<code>io.LimitReader</code>。该函数用于返回指定大小的Reader。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LimitReader returns a Reader that reads from r</span></span><br><span class="line"><span class="comment">// but stops with EOF after n bytes.</span></span><br><span class="line"><span class="comment">// The underlying implementation is a *LimitedReader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="type">int64</span>)</span></span> Reader &#123; <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>下面演示一下基本的使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	file, _ := os.Open(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	res := io.LimitReader(file, <span class="number">20</span>)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	count, err := res.Read(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(data[:count]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，res是一个Reader，且res只获取到了从文件开始往后20字节的内容。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang GC</title>
    <url>/2022/09/07/Go/Golang%20GC/</url>
    <content><![CDATA[<p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的**STW(stop the world)**，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。</p>
<h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>此算法主要有两个主要的步骤：</p>
<ul>
<li>标记(Mark phase)</li>
<li>清除(Sweep phase)</li>
</ul>
<p><strong>第一步</strong>，暂停程序业务逻辑, 找出不可达的对象，然后做上标记。第二步，回收标记好的对象。</p>
<p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>。也就是说，这段时间程序会卡在哪儿。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac1b83fe06af4a14b08370b501d810c8~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/545ce0e836d6421ab817bc882c6a9225~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第三步</strong>,  标记完了之后，然后开始清除未标记的对象. 结果如下:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac72e80cdd647dba6b141ed4ad579d2~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p>
<h2 id="二、标记-清扫-mark-and-sweep-的缺点"><a href="#二、标记-清扫-mark-and-sweep-的缺点" class="headerlink" title="二、标记-清扫(mark and sweep)的缺点"></a>二、标记-清扫(mark and sweep)的缺点</h2><ul>
<li>STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>所以Go V1.3版本之前就是以上来实施的,  流程是:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7718cc193ab043b986b0680dc1ce463b~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a332327e9a43d4b3a0c18b6b3b3a20~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序</strong> 。</p>
<p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用<strong>三色并发标记法</strong>来优化这个问题。</p>
<h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程。</p>
<p><strong>第一步</strong> , 就是只要是新创建的对象,默认的颜色都是标记为“白色”。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac709b570b941d5bd7b81c1cbd45fc1~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这里面需要注意的是, 所谓“程序”, 则是一些对象的根节点集合。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a000a5fbfd74f6593ffd593f4026bf5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>所以上图,可以转换如下的方式来表示:</p>
<p><strong>第二步</strong>, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7af7bdaae0c4930871025c8749d8950~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17bf5f0ddfee4d848759c7bcfce847d0~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第四步</strong>, 重复<strong>第三步</strong>, 直到灰色中无任何对象.</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc6d2618db954e729bc8306c06751d4b~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3010110caf624310bb25df825b274ee5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第五步</strong>: 回收所有的白色标记表的对象. 也就是回收垃圾。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84bcefbb465a46699f360b9f889aeb41~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现并行的呢?</p>
<blockquote>
<p>Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p>
</blockquote>
<h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的。因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景。</p>
<p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cebaae7267b34d24bb096925719a4d4e~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a5a9baa13054016a3815bf60c7dd9e4~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c93db7580edf4d688f3cb1e0ace94773~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb60c2e1b1c040e8971b1d236edd08d9~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3355fc5f7274fc0af1518d858d89376~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的:</p>
<ul>
<li>条件1: 一个白色对象被黑色对象引用 **(白色被挂在黑色下)**。</li>
<li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏 **(灰色同时丢了该白色)**。</li>
</ul>
<p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉！</p>
<p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？</p>
<p>答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了。</p>
<h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式:</p>
<h3 id="1-“强-弱”-三色不变式"><a href="#1-“强-弱”-三色不变式" class="headerlink" title="(1) “强-弱” 三色不变式"></a>(1) “强-弱” 三色不变式</h3><ul>
<li>强三色不变式</li>
</ul>
<p>不存在黑色对象引用到白色对象的指针。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f1e61f0727e4409a3374e77efe09144~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<ul>
<li>弱三色不变式</li>
</ul>
<p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9371425b8d7428a963eed8b7e3c8051~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”。</p>
<h3 id="2-插入屏障"><a href="#2-插入屏障" class="headerlink" title="(2)  插入屏障"></a>(2)  插入屏障</h3><ul>
<li><p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)。</p>
</li>
<li><p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)。</p>
</li>
</ul>
<p>伪码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;   </span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  标记灰色(新下游对象ptr)   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  当前下游对象slot = 新下游对象ptr  				  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(<span class="literal">nil</span>, B)   <span class="comment">//A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span></span><br><span class="line">A.添加下游对象(C, B)     <span class="comment">//A 将下游对象C 更换为B，  B被标记为灰色</span></span><br></pre></td></tr></table></figure>



<p>这段伪码逻辑就是写屏障, 我们知道, 黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>。栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中。</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dc4828bc1af4463ba4ec1373bb1bee5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbafac77b1141828e821cfcf3d26650~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34894cf8c33946329bb2c78a7a69ab6c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/686c50f8dd784d1f844f17bfa21fd5f5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14f841fbb3ac4c12b37195e9acf4cc72~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c673530edb89453da67a81e831547c23~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/073a6e5db8cb475bbe38855c727c57d5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad51f4abc95940369f57d7692158178a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c8834269e634c9ea38658d86edb0701~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dde571066324609862ff19e294e3a95~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h3 id="3-删除屏障"><a href="#3-删除屏障" class="headerlink" title="(3)  删除屏障"></a>(3)  删除屏障</h3><ul>
<li><p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
</li>
<li><p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)。</p>
</li>
</ul>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">if</span> (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123;</span><br><span class="line">  		标记灰色(当前下游对象slot)     <span class="comment">//slot为被删除对象， 标记为灰色</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, <span class="literal">nil</span>)   <span class="comment">//A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)</span></span><br><span class="line">A.添加下游对象(B, C)		 <span class="comment">//A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)</span></span><br></pre></td></tr></table></figure>




<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dec0820aa4c4a7bb231beab84625d2a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a277b8762b9419eb64b00beced71633~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd4a97c8f3ad47d59e3e1841c51efd0f~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4036a8b11d994754811c53a13162f410~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7243344632fa42a791a707f5d8d80627~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd798bd85444f27ac36b9c8f7df571e~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b1c655c756c454c89d167763dd51948~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li><p>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；</p>
</li>
<li><p>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</p>
</li>
</ul>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<h4 id="1-混合写屏障规则"><a href="#1-混合写屏障规则" class="headerlink" title="(1) 混合写屏障规则"></a>(1) 混合写屏障规则</h4><p><code>具体操作</code>: </p>
<p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)， </p>
<p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p>
<p>3、被删除的对象标记为灰色。</p>
<p>4、被添加的对象标记为灰色。</p>
<p><code>满足</code>: 变形的<strong>弱三色不变式</strong>。</p>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">  	<span class="comment">//1 </span></span><br><span class="line">		标记灰色(当前下游对象slot)    <span class="comment">//只要当前下游对象被移走，就标记灰色</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//2 </span></span><br><span class="line">  	标记灰色(新下游对象ptr)</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">//3</span></span><br><span class="line">  	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
<h3 id="2-混合写屏障的具体场景分析"><a href="#2-混合写屏障的具体场景分析" class="headerlink" title="(2) 混合写屏障的具体场景分析"></a>(2) 混合写屏障的具体场景分析</h3><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<blockquote>
<p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p>
</blockquote>
<p><strong>GC开始：扫描栈区，将可达对象全部标记为黑</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e49a176cfe46839c3ea7c5c530bfca~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19055b031c674e48bb1f24cdc8de1f2c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</strong></p>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span></span><br><span class="line">栈对象<span class="number">1</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；  <span class="comment">//将堆对象7 挂在 栈对象1 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = null；    <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff951b3fb30b44b2b9bcfc9889338c2d~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/491aad80d88845ad9fcf8277eb2f5119~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</strong></p>
<p>伪代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> 栈对象<span class="number">9</span>；</span><br><span class="line">对象<span class="number">8</span>-&gt;对象<span class="number">3</span> = 对象<span class="number">3</span>；      <span class="comment">//将栈对象3 挂在 栈对象9 下游</span></span><br><span class="line">对象<span class="number">2</span>-&gt;对象<span class="number">3</span> = null；      <span class="comment">//对象2 删除引用 对象3</span></span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e1d6759f7e54a8abf9bcd24b3bb10d5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/984303836de447ebaafe2c56cf329e7c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb69027ab0b4c0ca34ce9f56f885df2~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</strong></p>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">堆对象<span class="number">10</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；       <span class="comment">//将堆对象7 挂在 堆对象10 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = null；         <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ae43cb30bb244689bb1d882c7fd0252~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b5bcfcff2443218cc40316f4d92aba~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad32a5a07224ecda04a02ffc515fb2e~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</strong></p>
<p>伪代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">堆对象<span class="number">10</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；       <span class="comment">//将堆对象7 挂在 堆对象10 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = null；         <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>




<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce1217825c864b929399831f93794fea~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09bec0e1773848b59bf63ca8bf025fef~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/267919f0eb854318bf9a5d5754295b89~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
<p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
<p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Interface</title>
    <url>/2022/09/07/Go/Golang%20Interface/</url>
    <content><![CDATA[<h2 id="空接口-interface"><a href="#空接口-interface" class="headerlink" title="空接口 interface{}"></a>空接口 interface{}</h2><p>空接口类型可以接收任意类型的数据，它只要记录这个数据在哪儿，是什么类型的就足够了。空接口变量数据结构如下，其中_type指向接口的动态类型元数据，data就指向接口的动态值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>比如下面这个例子，为e赋值以前，其中存储的_type和data都为nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1512d00da2ed4b24a2568071491b9807~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>如果我们把*os.File类型的变量f赋给e。那么变量e的结构如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7da5313d4884fc1b61118245378c9a9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>因为f本身就是个指针，所以e这里的data就等于f，动态类型就是*os.File。值得强调的是类型元数据这里是可以找到类型关联的方法元数据列表的，这一点对于理解“类型断言”至关重要。</p>
<h3 id="interface-参数赋值"><a href="#interface-参数赋值" class="headerlink" title="interface{}参数赋值"></a>interface{}参数赋值</h3><p>interface{}类型的变量中会保存一个地址。假如存在如下的一种情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">a := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = a</span><br></pre></td></tr></table></figure>



<p>那么e接收的参数会是下面这样的吗？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cbd99fba86b04d61a58635988fd3649c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br></p>
<p>答案是否定的，原因是这样并不符合“Go语言中传参值拷贝”的语义。从语义上讲也应该使用<code>a</code>的拷贝值，而不是直接使用<code>a</code>。但问题是空接口类型的参数需要的只是一个数据指针，不能拷贝a的值过来，又不能拷贝a的地址过来，那拷贝谁？</p>
<p>解决这个问题的方式，是在编译阶段增加临时变量作为a的拷贝值(copy of a)，再把<code>copy of a</code>的地址传给函数使用，无论之后对参数指向的数据做什么修改，都不会作用到变量a身上。这样就通过<code>传递复制后的地址实现了传值的语义</code>。</p>
<p><code>copy of a</code>的地址会在编译阶段转换为空接口类型，所以<code>TypeOf</code>接收到的参数就如下图所示。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/738b13d4a801474482b94d47cb43927c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="非空接口"><a href="#非空接口" class="headerlink" title="非空接口"></a>非空接口</h2><p>非空接口就是有方法列表的接口类型，一个变量要想赋值给一个非空接口类型，其类型必须要实现该接口要求的所有方法才行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab   *itab</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>iface.data记录的是接口的动态值，所以接口要求的方法列表以及与data对应的动态类型信息一定存在itab里面。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype</span><br><span class="line">    _type  *_type</span><br><span class="line">    hash   <span class="type">uint32</span></span><br><span class="line">    _      [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="type">uintptr</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>itab.inter是interface的类型元数据，它里面记录了这个接口类型的描述信息，接口要求的方法列表就记录在interfacetype.mhdr这里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ      _type</span><br><span class="line">    pkgpath  name</span><br><span class="line">    mhdr     []imethod</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<ul>
<li>itab._type就是接口的动态类型，也就是被赋给接口类型的那个变量的类型元数据。</li>
<li>itab.hash是从itab._type中拷贝来的，是类型的哈希值，用于快速判断类型是否相等时使用。</li>
<li>itab.fun记录的是动态类型实现的那些接口要求的方法的地址，是从方法元数据中拷贝来的，为的是快速定位到方法。如果itab._type对应的类型没有实现这个接口，则itab.fun[0]&#x3D;0，这在类型断言时会用到。</li>
</ul>
<h2 id="非空接口赋值前后"><a href="#非空接口赋值前后" class="headerlink" title="非空接口赋值前后"></a>非空接口赋值前后</h2><p>如果我们声明一个io.ReadWriter类型的变量rw。被赋值以前，rw的data为nil，tab也为nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br></pre></td></tr></table></figure>


<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf1f4cd39abd413780db6556ef3e27fe~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面我们把一个*os.File类型的变量f，赋值给rw。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">rw = f</span><br></pre></td></tr></table></figure>



<p>此时rw的动态值就是f，动态类型就是<em>os.File。而itab.fun这个数组里记录的是</em>os.File实现的Read、Write方法的地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6127d4e5e2d42769d36448d00387cd4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面我们再声明一个io.Writer类型的变量w，并把f赋值给w。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = f</span><br></pre></td></tr></table></figure>



<p>此时w的动态值和动态类型与rw相同，只是二者的接口类型元数据不同，要求的方法列表也不同罢了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23828e6322e647d293e85d358328676b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="itab缓存"><a href="#itab缓存" class="headerlink" title="itab缓存"></a>itab缓存</h2><p>关于itab我们还要额外关注一点，既然一个非空接口类型和一个动态类型就可以确定一个itab的内容，那这个itab结构体自然是可以被接口类型与动态类型均相同的接口变量复用的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33904780e032484fb2d3cdb955a83ce8~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>实际上Go语言会把用到的itab结构体缓存起来，并且以<code>&lt;接口类型, 动态类型&gt;</code>组合为key，以<code>*itab</code>为value，构造一个哈希表，用于存储与查询itab信息。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51d113c6e0e94122bf7594a3aee42d07~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>这个哈希表与map底层的哈希表不同，其结构设计更为简便。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="type">uintptr</span>             <span class="comment">// length of entries array. Always a power of 2.</span></span><br><span class="line">    count   <span class="type">uintptr</span>             <span class="comment">// current number of filled entries.</span></span><br><span class="line">    entries [itabInitSize]*itab <span class="comment">// really [size] large</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要一个itab时，会首先去itabTable里查找，计算哈希值时会用到接口类型(itab.inter)和动态类型(itab._type)的类型哈希值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabHashFunc</span><span class="params">(inter *interfacetype, typ *_type)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uintptr</span>(inter.typ.hash ^ typ.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能查询到对应的itab指针，就直接拿来使用。若没有就要再创建，然后添加到itabTable中。</p>
<p>了解了空接口和非空接口的数据结构，明确了接口动态值与动态类型在赋值前与赋值后的变化，接下来就可以看看“类型断言”是怎么回事儿了。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Tag语法</title>
    <url>/2022/09/07/Go/Golang%20Tag%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Tag格式"><a href="#Tag格式" class="headerlink" title="Tag格式"></a>Tag格式</h2><p>tag被定义在结构体字段的后面，以字符串的形式出现，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	f1 <span class="type">string</span> <span class="string">&quot;f one&quot;</span></span><br><span class="line">	f2 <span class="type">string</span></span><br><span class="line">	f3 <span class="type">string</span> <span class="string">`f three`</span></span><br><span class="line">	f4, f5 <span class="type">int64</span> <span class="string">`f four and five`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意，不管是双引号还是反引号，都可以用来当tag。如果结构体字段在定义的时候，两个字段共用一个属性，那么这个tag会被附在两个名字上，像上述代码中的f1，f5一样。</p>
<p><strong>键值对</strong></p>
<p><code>Tags</code>可以由键值对来组成，通过空格符来分割键值 —<code>key1:&quot;value1&quot; key2:&quot;value2&quot; key3:&quot;value3&quot;</code>。如果Tags格式没问题的话，我们可以通过<code>Lookup</code>或者<code>Get</code>来获取键值对的值。<br><code>Lookup</code>回传两个值，对应的值和是否找到。<br><code>Get</code>只回传一个值，即对应的那个值，如果没有找到就返回空。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">	Apple <span class="type">string</span> <span class="string">`fruit:&quot;apple&quot;`</span></span><br><span class="line">	Tomato <span class="type">string</span> <span class="string">`vegetable:&quot;tomato&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(Food&#123;&#125;)</span><br><span class="line">	f, _ := t.FieldByName(<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">	fmt.Println(f.Tag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tag.Lookup</span></span><br><span class="line">	v, ok := f.Tag.Lookup(<span class="string">&quot;fruit&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %t\n&quot;</span>, v, ok)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tag.Get</span></span><br><span class="line">	v = f.Tag.Get(<span class="string">&quot;fruit&quot;</span>)</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fruit:<span class="string">&quot;apple&quot;</span></span><br><span class="line">apple, <span class="literal">true</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>






<h2 id="Tag的使用"><a href="#Tag的使用" class="headerlink" title="Tag的使用"></a>Tag的使用</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>在golang中，命名都是推荐用驼峰方式，并且在首字母大小写有特殊的语法含义：包外无法引用。但是由于经常需要和其它的系统进行数据交互，例如转成json格式，存储到mongodb啊等等。这个时候如果用属性名来作为键值可能不一定会符合项目要求。<br>而通过Tag，我们可以在转换成其它格式的时候，使用其中定义的字段作为键值。<br>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserId <span class="type">int</span> <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">	UserName <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	u := &amp;User&#123;UserId: <span class="number">1</span>, UserName: <span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">	j, _ := json.Marshal(u)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(j))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;user_id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;user_name&quot;</span>:<span class="string">&quot;张三&quot;</span>&#125;</span><br></pre></td></tr></table></figure>




<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM是指将关系型数据库中的记录映射为对象，以对象的形式展现。我们可以把对数据库的操作转化为对对象的操作。</p>
<table>
<thead>
<tr>
<th>面向对象的概念</th>
<th>面向关系概念</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>表</td>
</tr>
<tr>
<td>对象</td>
<td>表的行（记录）</td>
</tr>
<tr>
<td>属性</td>
<td>表的列（字段）</td>
</tr>
</tbody></table>
<p>对应到golang中，就是把对关系型数据库的操作转化为对结构体的操作。<br>我们以<code>GORM</code>框架来举例，在GORM中，与数据表进行映射的结构体我们称之为模型（Models）。</p>
<p>回归到Tag，在数据表中定义一个字段时，我们通常会在字段的末尾加上一些额外信息，比如约束、列大小等等。映射到Models中，就需要使用Tag来设置相应的信息。</p>
<p>例如下面这个Models：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Age          sql.NullInt64</span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  Email        <span class="type">string</span>  <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class="line">  Role         <span class="type">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">// 设置字段大小为255</span></span><br><span class="line">  MemberNumber *<span class="type">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span> <span class="comment">// 设置会员号（member number）唯一并且不为空</span></span><br><span class="line">  Num          <span class="type">int</span>     <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">// 设置 num 为自增类型</span></span><br><span class="line">  Address      <span class="type">string</span>  <span class="string">`gorm:&quot;index:addr&quot;`</span> <span class="comment">// 给address字段创建名为addr的索引</span></span><br><span class="line">  IgnoreMe     <span class="type">int</span>     <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略本字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>GORM框架支持很多结构体Tag，具体可以查看这篇博文：</p>
<p><a href="https://blog.csdn.net/qq_49723651/article/details/121586415#Tag">https://blog.csdn.net/qq_49723651&#x2F;article&#x2F;details&#x2F;121586415#Tag</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang channel底层剖析</title>
    <url>/2022/09/07/Go/Golang%20channel%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"> qcount   <span class="type">uint</span>           <span class="comment">// queue 里面有效用户元素，这个字段是在元素出对，入队改变的；</span></span><br><span class="line"> dataqsiz <span class="type">uint</span>           <span class="comment">// 初始化的时候赋值，之后不再改变，指明数组 buffer 的大小；</span></span><br><span class="line"> buf      unsafe.Pointer <span class="comment">// 指明 buffer 数组的地址，初始化赋值，之后不会再改变；</span></span><br><span class="line"> elemsize <span class="type">uint16</span>  <span class="comment">// 指明元素的大小，和 dataqsiz 配合使用就能知道 buffer 内存块的大小了；</span></span><br><span class="line"> closed   <span class="type">uint32</span></span><br><span class="line"> elemtype *_type <span class="comment">// 元素类型，初始化赋值；</span></span><br><span class="line"> sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line"> recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line"> recvq    waitq  <span class="comment">// 等待 recv 响应的对象列表，抽象成 waiters</span></span><br><span class="line"> sendq    waitq  <span class="comment">// 等待 sedn 响应的对象列表，抽象成 waiters</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 互斥资源的保护锁，官方特意说明，在持有本互斥锁的时候，绝对不要修改 Goroutine 的状态，不能很有可能在栈扩缩容的时候，出现死锁</span></span><br><span class="line"> lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="channel的send和recv"><a href="#channel的send和recv" class="headerlink" title="channel的send和recv"></a>channel的send和recv</h2><p>初始状态下，ch的缓冲区为空，读和写的下标都指向下标0的位置，等待队列也都为空。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6e845f7a71245ceb46496bd37a7ecb9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后一个协程g1向ch中发送数据，因为没有协程在等待接收数据，所以元素会被存入缓冲区中，<code>sendx</code>会从0开始向后挪，第五个元素会放到下标为的4的位置，然后sendx会重新回到0。<br>此时缓冲区中已经没有空闲的位置了。所以接下来发送的第6个元素无处可放，g1会进到ch的发送等待队列中。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f24be0aabb9446f8bfdd10a06daf78c9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>发送等待队列是一个sudog类型的链表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	g *g    <span class="comment">// 记录哪个协程在等待</span></span><br><span class="line">	isSelect <span class="type">bool</span></span><br><span class="line">	next *sudog</span><br><span class="line">	prev *sudog</span><br><span class="line">	elem unsafe.Pointer  <span class="comment">// 等待发送的信息在哪</span></span><br><span class="line">	acquiretime <span class="type">int64</span></span><br><span class="line">	ticket <span class="type">uint64</span></span><br><span class="line">	parent *sudog</span><br><span class="line">	waitlink *sudog</span><br><span class="line">	waittail *sudog</span><br><span class="line">	c *hchan   <span class="comment">// 等待哪一个channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>里面会记录哪个协程在等待，等待哪一个channel，等待发送的信息在哪等信息。</p>
<p>接下来协程g2从ch接收一个元素，recvx指向下一个位置，第0个位置就空出来了。所以会唤醒sendq中的g1，将这里的数据发送给ch。然后缓冲区再次满了，sendq队列为空。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98afc280483d4fe2b79580aa02e3a8f9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br></p>
<p>在这一过程中，可以看到<code>sendx</code>和<code>recvx</code>，都会从0到4再到0这样循环变化，所以channel的缓冲区被称为<code>环形缓冲区</code>。</p>
<p><strong>发送数据</strong></p>
<p>所以像诸如 <code>ch &lt;- 10</code> 这样给channel发送数据时，只有在缓冲区还有空闲位置，或者有协程在等着接收数据的时候才不会发生<code>阻塞</code>。<br>碰到channel为nil，或者ch没有缓冲区，而且也没有协程等着接收数据，又或者ch有缓冲区但缓冲区已用尽的情况，都会发生<code>阻塞</code>。</p>
<p>那如果不想阻塞的话，就可以使用select关键字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ch &lt;- <span class="number">10</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用这种写法时，如果检测到ch可以发送数据，就会执行case分支；如果会阻塞，就会执行default分支了。</p>
<p><strong>接收数据</strong></p>
<p>接收数据的写法要更多一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将结果直接丢弃</span></span><br><span class="line">&lt;-ch</span><br><span class="line"><span class="comment">// 将结果赋值给变量v</span></span><br><span class="line">v := ch</span><br><span class="line"><span class="comment">// common ok风格写法</span></span><br><span class="line"><span class="comment">// ok为false时表示ch已经关闭，此时v是channe元素类型的零值</span></span><br><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>



<p>以上几种写法都允许发生阻塞，只有在缓冲区中有数据，或者有协程等着发送数据时，才不会发生阻塞。如果channel为nil，或者channel无缓冲而且没有协程等着发送数据，又或者channel有缓冲但是缓冲区无数据时，都会发生阻塞。</p>
<p>如果无论如何都不想阻塞,t&#x3D;同样可以采用select关键字。这样在检测到channel的recv操作不会阻塞时，就会执行case分支；如果会阻塞，就会执行default分支。</p>
<h3 id="多路select"><a href="#多路select" class="headerlink" title="多路select"></a>多路select</h3><p>多路select指的是存在两个或更多的case分支，每个分支可以是一个channel的send或者recv操作。</p>
<p>例如一个协程通过多路select，等待ch1和ch2。这里default分支是可选的，我们暂且把这个协程记为g1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> a = &lt;-ch1:</span><br><span class="line">		<span class="built_in">println</span>(v)</span><br><span class="line">	<span class="keyword">case</span> ch2 &lt;- b:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>多路select会被编译器转换为对<code>runtime.selectgo</code>函数调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *unint16, pc0 *unintptr, nsends, nrecvs <span class="type">int</span>, block <span class="type">bool</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>



<p>第一个参数cas0指向一个数组，数组里面装的是select中所有的case分支。顺序是send在前recv在后。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/603d712689674a4baf88f1c3af2f4c91~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>第二个参数order0指向一个uint16类型的数组，数组大小等于case分支的两倍，实际上被用作两个数组。第一个数组用来对所有channel的轮询进行乱序。第二个数组用来对所有channel的加锁操作进行排序。因为轮询需要乱序才能保障公正性。而按照固定算法确定加锁顺序才能避免死锁。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69841237a0c242f6bfc143763dd721c1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>第三个参数和race检测有关，我们暂且不关心。</p>
<p>剩下的nsends和nrecvs分别表示所有case中，执行send和recv操作的分支分别有多少个。<br>block表示多路select是否需要阻塞等待，对应到代码只能就是有default分支的不会阻塞，没有的会阻塞。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1dc0bf21794e2a9295ba2ab4860bd6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>再来看第一个返回值，它代表最终哪个case分支被执行了。<br>第二个返回值用于在执行recv操作的case分支时，表明是实际接收到了一个值，还是因channel关闭而得到了零值。<br>多路select需要进行轮询来确定哪个case分支可操作了。但是轮询前要先加锁，所以selectgo函数在执行时，会先按照有序的加锁顺序，对所有的channel加锁，然后按照乱序的轮询顺序，检查所有channel的等待队列和缓冲区。</p>
<p>假如检查到ch1时，发现有数据可读，那就直接拷贝数据，进入对应分支；假如所有channel都不可操作，就把当前协程添加到所有channel的sendq或recvq中。</p>
<p>对应到这个例子，g1会被添加到ch1的recq，以及ch2的sendq中。之后g1会挂起，并解锁所有的channel。</p>
<p>假如接下来的ch1有数据可读了，g1就会被唤醒，完成对应的分支操作后，会再次按照加锁顺序对所有channel加锁，然后从所有sendq或recvq中将自己移除。最后全部解锁后返回。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bc31180e4684dafa76578921e28180b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="channel的常规send和recv操作"><a href="#channel的常规send和recv操作" class="headerlink" title="channel的常规send和recv操作"></a>channel的常规send和recv操作</h2><p><strong>send操作</strong></p>
<p>事实上channel的常规send操作，会被编译器转换为对<code>runtime.chansend1()</code>的调用，而它的内部只是调用了<code>runtime.chansend()</code>。</p>
<p>非阻塞式的send操作会被编译器转换为对<code>runtime.selectnbsend()</code>的调用，它也仅仅是调用了<code>runtime.chansend()</code>。</p>
<p>所以send操作主要是通过这个函数实现的。</p>
<p><strong>recv操作</strong></p>
<p>同样的，常规recv操作会被编译器转换为对<code>runtime.chanrecv1()</code>的调用。而它内部只是调用了<code>runtime.chanrecv()</code>。</p>
<p><code>common ok</code>风格的写法会被编译器转换为对<code>runtime.chanrecv2()</code> 的调用，它的内部也是对调用<code>chanrecv()</code>，只不过比chanrecv1()多了一个返回值。</p>
<p>非阻塞式的recv操作会根据是否为common ok风格，被编译器转换为对<code>runtime.selectnbrecv()</code>或者<code>selectbrecv2()</code>的调用，而它们两个也仅仅是调用了<code>runtime.chanrecv()</code>。</p>
<p>所以recv操作主要是通过<code>chanrecv()</code>函数实现的。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Mutex剖析</title>
    <url>/2022/09/07/Go/Golang%20Mutex%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Mutex内存模型"><a href="#Mutex内存模型" class="headerlink" title="Mutex内存模型"></a>Mutex内存模型</h2><p>在go语言中，Mutex的结构是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为简单所以不需要额外的初始化。此结构的零值就是一个有效的互斥锁，处于Unlock的状态。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9d0d4cc761a47ea8edb064e8ea0ffc3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><code>state</code>储存的是互斥锁的状态，加锁和解锁都是通过atomic包提供的函数原子性操作来操作该字段。</p>
<p><code>sema</code>用作一个信号量，主要用作等待队列。</p>
<h2 id="Mutex的两种模式"><a href="#Mutex的两种模式" class="headerlink" title="Mutex的两种模式"></a>Mutex的两种模式</h2><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>在正常模式下，一个尝试加锁的goroutine会先自旋几次，尝试通过原子操作获得锁，若几次自旋之后仍不能获得锁，则通过信号量排队等待。所有的等待者会按照先入先出（FIFO）的顺序排队。</p>
<p>但是当锁被释放，第一个等待者并不会直接拥有锁，而是需要和后来者竞争。也就是那些处于自旋阶段，尚未排队等待的goroutine。这种情况下后来者更有优势。一方面，它们正在CPU上运行，自然比刚唤醒的goroutine更有优势，另一方面，处于自旋状态的goroutine可以有很多，而被唤醒的goroutine每次只有一个。所以被唤醒的goroutine有很大概率拿不到锁。这种情况下，它会被重新插入到队列的头部，而不是尾部。</p>
<h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>而当一个goroutine本次加锁等待的时间超过了1ms后，它会把当前Mutex从正常模式切换至<code>饥饿模式</code>。</p>
<p>在饥饿模式下，Mutex的所有权从执行Unlock的goroutine直接传递给等待队列头部的goroutine。后来者不会自旋，也不会尝试获得锁。即使Mutex处于Unlock状态，它们会直接从队列的尾部排队等待。当一个等待者获得锁之后，它会在以下两种情况时，将Mutex由饥饿模式切换回正常模式：</p>
<ul>
<li>一种情况是：它的等待时间小于1ms，也就是它刚来不久。</li>
<li>第二种情况是：它是最后一个等待者，等待队列已经空了，后面自然就没有饥饿的goroutine了。</li>
</ul>
<p>综上所述，在正常模式下自旋和排队是同时存在的，执行Lock的goroutine会先一边自旋，尝试过几次后如果还没有拿到锁，就需要去排队等待了。这种在排队之前先让大家来抢的模式，能够有更高的吞吐量，因为频繁的挂起、唤醒goroutine会带来较多的开销。但是又不能无限制的自旋，要把自旋的开销控制在较小的范围内，所以在正常模式下，Mutex有更好的性能。但是可能会出现队列尾端的goroutine迟迟抢不到锁（尾端延迟）的情况。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d5b6e90b5b4c60b6eb16813532b2d5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>而饥饿模式下不再自旋尝试，所有goroutine都要排队，严格的先来后到。对于防止尾端延迟来讲特别重要。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592effd23c4d40d499f427cb22912f4d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="Lock和Unlock"><a href="#Lock和Unlock" class="headerlink" title="Lock和Unlock"></a>Lock和Unlock</h2><p>首先来看一下关于Mutex.state的几个常量定义：</p>
<p>我们再来看一下Mutex的内存模型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a5140360494e3a934a98762b777789~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>state的类型是int32。</p>
<ul>
<li>其中第一位用作锁状态标识符，置为1就表示已加锁，对应的掩码常量为<code>mutexLocked</code>。</li>
<li>第二位用于记录是否已有goroutine被唤醒了，置为1表示已唤醒，对应掩码常量为<code>mutexWoken</code>。</li>
<li>第三位标识Mutex的工作模式，0代表正常模式，1代表饥饿模式，对应掩码常量为<code>mutexStarving</code>。</li>
<li>而常量mutexWaiterShift等于3，表示除了最低三位以外，state的其他位用来记录有多少个等待着在排队。</li>
</ul>
<p><strong>Lock和Unlock方法</strong></p>
<p>再来看看Lock和Unlock方法：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f943605ff5e47319f2c444052510668~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>精简掉了注释和部分race检测相关的代码，两个方法中主要通过atomic函数实现了Fast path，相应的Slow path被单独放在了lockSlow和unlockSlow方法中。根据源码注释的说法，这样是为了便于编译器对于Fast path进行内联优化。</p>
<p>Lock方法的Fast path期望Mutex处于Unlocked状态，没有goroutine在排队，更不会饥饿。理想状况下，一个CAS操作就可以获得锁。但是如果CAS操作没能获得锁，就需要进入Slow path，也就是lockSlow方法。</p>
<p>Unlock方法同理，首先通过原子操作从state中减去mutexLocked，也就是释放锁。然后根据state的新值来判断是否需要执行Slow path。如果新值为0，也就意味着没有其它goroutine在排队，所以不需要执行额外操作；如果新值不为0，那就需要进入slow path，看看是否需要唤醒某个goroutine。</p>
<h2 id="slow-path的主要逻辑"><a href="#slow-path的主要逻辑" class="headerlink" title="slow path的主要逻辑"></a>slow path的主要逻辑</h2><p>当一个goroutine尝试给mutex加锁时，如果其它goroutine已经加了锁还没有释放，而且当前mutex工作在正常模式下，是不是就要开始自旋了呢？</p>
<p>答案是不一定。因为如果当前是单核场景，自旋的goroutine在等待持有锁的goroutine释放锁，而持有锁的goroutine在等待自旋的goroutine让出CPU。这种情况下自旋是没有意义的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447cdca0522a41abb8c259664679d020~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>而且，如果<code>GOMAXPROCS=1</code>，或者当前没有其它P在运行，也和单核场景类似，同样不需要自旋。<br>除此之外，如果当前P的本地runq不为空，相较于自旋而言，切换到本地goroutine更有效率。所以为保障吞吐量，也不会自旋。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28fdbd6c9a18487a800a155c37ef3df4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>最终，只有在多核场景下，且<code>GOMAXPROCS大于1</code>，且至少有一个其它的P正在running，且当前P的本地runq为空的情况下，才可以自旋。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3539a0c00faf4e1488e161c3b76613aa~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>进入自旋的goroutine会先去争抢mutex的唤醒标识位。设置mutexWoken标识位的目的是：在正常模式下，告知持有锁的goroutine，在unlock的时候不用再唤醒其它goroutine了，已经有goroutine在这里等待。以免唤醒太多的等待协程。</p>
<p>mutex中的自旋，底层是通过procyield循环执行30次PAUSE，自旋次数上限为4。而且每自旋一次都要重新判断是否可以继续自旋。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fc64e48f17c4293b9839068b4bad46f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果锁被释放了，或者锁进入饥饿模式，亦或者已经自旋了4次，都会结束自旋。结束自旋或者根本不用的goroutine，就该尝试原子操作修改mutex的状态了。把此时mutex.state保存到old中，把要修改为的新state标记为new。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80247df4ab6f45c7beda90389b81b6de~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果old处于饥饿模式或者加锁状态，goroutine就得去排队，所以上述情况下排队规模要加1。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/071b8b618cc842f9bb6da927a2bbd67b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果是正常模式，就要尝试设置lock位。所以第三行的new位要置为1。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14998427658a48d795a68a0690041c67~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果当前goroutine等待的时间已经超过1ms，而且锁还没有被释放。就要将mutex的状态切换为饥饿模式。注意，这里之所以还要求锁没被释放，是因为如果锁已经释放了，那怎么都得去抢一次，要是直接进入饥饿模式就只能去排队了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe75351df29d4cc989124bc4d8de924d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>把排队规模和几个标识位都设置好以后，在执行原子操作修改state之前，若是当前goroutine持有唤醒标识的话，还要将唤醒标识位重置。<br>因为接下来无论是要去抢锁，还是单纯的要去排队，如果原子操作成功了，要么是成功抢到了锁，要么是成功进到了等待队列里。当前goroutine都不再是被唤醒的goroutine了，所以要释放唤醒标识。<br>而如果原子操作不成功，也就意味着其它goroutine在我们保存mutex.state到old中以后，又修改了state的值。当前goroutine就要回过头去，继续从自旋检查这里开始再次尝试。所以也需要释放自己之前抢到的唤醒标识位，从头再来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f64dadc0401407d88a5a77309e3314a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="加锁的slow-path"><a href="#加锁的slow-path" class="headerlink" title="加锁的slow path"></a>加锁的slow path</h3><p>继续展开这个原子操作成功的分支，如果是抢锁操作成功了，那么加锁的slow path就可以宣告结束了。如果是排队规模设置成功了，还要决定是排在等待队列头部还是尾部。如果当前goroutine已经排过队了，是在unlock时从等待队列中唤醒的，那就要排到等待队列头部。<br>如果是第一次排队，就得排到等待队列尾部，并且从第一次排队开始记录当前goroutine的等待时间。接下来就会让出，进到等待队列里了。队列里的goroutine被唤醒时，要从上次让出的地方开始继续执行。<br>接下来会判断，如果mutex处在正常模式，那就接着从自旋开始抢锁，如果唤醒后处在饥饿模式，那就没有goroutine会和自己抢了。锁已经轮到自己这里，只需要把mutex.state中lock标识位设置为加锁，把等待队列规模减去1，再看看是不是要切换到正常模式，也就是自己的等待时间是不是小于1ms，或者等待队列已经空了，最后设置好mutex.state就一切ok了。</p>
<p>这就是加锁操作的slow path。</p>
<h3 id="解锁的slow-path"><a href="#解锁的slow-path" class="headerlink" title="解锁的slow path"></a>解锁的slow path</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e93ba7aada44102bc4edd6bd29718cc~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>进到unlock的slow path，说明除去lock标识位以外。剩下的位不全为0。<br>如果处在正常模式，若等待队列为空。或者已经有goroutine被唤醒或获得了锁，或者锁进入了饥饿模式，那就不需要唤醒某个goroutine，直接返回即可，否则就要尝试抢占mutexWoken标识位，获取唤醒一个goroutine的权利。抢占成功后，就会通过runtime_Semrelease函数唤醒一个goroutine。<br>如果抢占不成功就进行循环尝试，直到等待队列为空，或者已经有一个goroutine被唤醒或获得了锁，或者锁进入了饥饿模式，则退出循环。<br>而在饥饿模式下，后来的goroutine不会抢占锁，而是直接排队，锁的所有权是直接从执行Unlock的goroutine，传递给等待队列中首个等待者的，所以不用抢占mutexWoken标识位。</p>
<p>第一个等待者唤醒后，会继承当前goroutine的时间片立刻开始运行，也就是继续lockSlow中这里，goroutine被唤醒以后的逻辑。</p>
<p>这就是unlock的slow path。</p>
<p>接下来再看看关于信号量的相关操作。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang defer原理</title>
    <url>/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="defer1-12"><a href="#defer1-12" class="headerlink" title="defer1.12"></a>defer1.12</h2><h3 id="defer延迟和倒序的机制"><a href="#defer延迟和倒序的机制" class="headerlink" title="defer延迟和倒序的机制"></a>defer延迟和倒序的机制</h3><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>在go语言中，我们可以很方便的用defer关闭一个打开的文件、释放一个Redis连接，或者解锁一个Mutex。而且Go语言在设计上保证，即使发生panic，所有的defer调用也能够被执行。不过多个defer函数是按照定义顺序倒序执行的。</p>
<p>我们通过一个例子来解释defer函数的延迟与倒序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> A()</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一段代码，在Go1.12中编译以后的伪指令是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := runtime.deferproc(<span class="number">0</span>, A) <span class="comment">// 经过recover返回时r为1，否则为0</span></span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>其中与defer指令相关的有两个部分。第一部分是<code>deferproc</code>，它负责保存要执行的函数信息,我们称之为defer<code>注册</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span></span><br></pre></td></tr></table></figure>



<p>从函数原型来看，<code>deferproc</code>函数有两个参数，第一个是被注册的defer函数的参数加返回值共占多少字节；第二个参数是一个<code>runtime.funcval</code>结构体的指针，也就是一个<a href="https://blog.csdn.net/qq_49723651/article/details/121362988">Function Value</a>。</p>
<p>与defer指令相关的第二部分就是<code>deferreturn</code>，它被编译器插入到函数返回以前调用，负责执行已经注册的defer函数。所以defer函数之所以能延迟到函数返回前执行，就是因为先注册，后调用。</p>
<h4 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h4><p>再来看看defer函数为什么会倒序执行。<br>defer注册信息会保存到defer链表。每个goroutine在运行时都对应一个<code>runtime.g</code>结构体，其中有一个<code>_defer</code>字段，保存的就是defer链表的头指针。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ef4c84358d8435fa507ddcaf98e7334~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>deferproc新注册的defr信息会添加到链表头。deferreturn执行时也从链表头开始，所以defer才会表现为倒序执行。</p>
<h3 id="defer链表项"><a href="#defer链表项" class="headerlink" title="defer链表项"></a>defer链表项</h3><p>defer链表链起来的是一个一个_defer结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    sp        <span class="type">uintptr</span> <span class="comment">// sp at time of defer</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic <span class="comment">// panic that is running defer</span></span><br><span class="line">    link      *_defer</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>siz  由deferproc第一个参数传入，就是defer函数参数加返回值的总大小。<br>这段空间会直接分配在_defer结构体后面，用于在注册时保存给defer函数传入的参数，并在执行时直接拷贝到defer函数的调用者栈上。</p>
</li>
<li><p>started  标识defer函数是否已经开始执行；</p>
</li>
<li><p>sp  就是注册defer函数的函数栈指针；</p>
</li>
<li><p>pc  是deferproc函数返回后要继续执行的指令地址；</p>
</li>
<li><p>fn  由deferproc的第二个参数传入，也就是被注册的defer函数；</p>
</li>
<li><p>_panic  是触发defer函数执行的panic指针，正常流程执行defer时它就是nil；</p>
</li>
<li><p>link  自然是链到之前注册的那个_defer结构体。</p>
</li>
</ul>
<p>这一篇我们只关注正常流程下defer函数的执行，不考虑panic或runtime.Goexit()的情况。</p>
<h3 id="defer传参机制"><a href="#defer传参机制" class="headerlink" title="defer传参机制"></a>defer传参机制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> A1(a)</span><br><span class="line">    </span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里函数A注册了一个defer函数A1，在A的函数栈帧中，局部变量区域存储a&#x3D;1，b&#x3D;2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf24fc78a7d943fc84d5ed4c50a9414b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>到deferproc函数注册defer函数A1时。<br>第一个参数是A1的参数加返回值共占多少字节。A1没有返回值，64位下一个整型参数占用8字节。<br>第二个参数是函数A1。前面我们介绍过，没有捕获列表的Function Value，在编译阶段会做出优化，就是在只读数据段分配一个共用的funcval结构体。如下图中，函数A1的指令入口地址为addr1。在只读数据段分配的指向A1指令入口的funcval结构体地址为addr2，所以deferproc函数第二个参数就是addr2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/005ed86b5de1411c9faffc2460e3d19d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>额外要注意的是，deferproc函数调用时，编译器会在它自己的两个参数后面，开辟一段空间，用于存放defer函数A1的返回值和参数。这一段空间会在注册defer时，直接拷贝到_defer结构体的后面。A1只有一个参数a&#x3D;1，放在deferproc函数自己的两个参数之后。注意deferproc函数的返回值空间并没有分配在调用者栈上，而是放到了寄存器中，这和recover有关,且先忽略。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0878e777ed334d8aaf2748500b067832~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb05f7debb994592a7c5237bea5d1386~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后这个_defer结构体就被添加到defer链表头，deferproc注册结束。</p>
<p><em>注意：<br>频繁的堆分配势必影响性能，所以Go语言会预分配不同规格的deferpool，执行时从空闲_defer中取一个出来用。没有空闲的或者没有大小合适的，再进行堆分配。用完以后，再放回空闲_defer池。这样可以避免频繁的堆分配与回收。</em></p>
<p>deferproc结束后，接下来会执行到a&#x3D;a+b这一步，所以，局部变量a被置为3。接下来会输出：a&#x3D;3，b&#x3D;2。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数A编译后的伪指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    r := runtime.deferproc(<span class="number">8</span>, A1，<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)<span class="comment">//3,2</span></span><br><span class="line"></span><br><span class="line">    runtime.deferreturn()<span class="comment">//执行defer链表</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后就到deferreturn执行defer链表这里了。从当前goroutine找到链表头上的这个_defer结构体，通过_defer.fn找到defer函数的funcval结构体，进而拿到函数A1的入口地址。接下来就可以调用A1了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca3a88bd004643fba42fcb04317fd79d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>调用A1时，会把_defer后面的参数与返回值整个拷贝到A1的调用者栈上。然后A1开始执行，输出参数值a&#x3D;1。这个例子的关键，是defer函数的参数在注册时拷贝到堆上，执行时再拷贝到栈上。</p>
<h3 id="defer-闭包"><a href="#defer-闭包" class="headerlink" title="defer+闭包"></a>defer+闭包</h3><p>既然deferproc注册的是一个Function Value，下面就来看看有捕获列表时是什么情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        a = a+b</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;(b)</span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个例子中，defer函数不止要传递局部变量<code>b</code>做参数，还捕获了外层函数的局部变量<code>a</code>，形成闭包。匿名函数会由编译器按照<code>A_func1</code>这样的形式命名。如下图所示，假设这个闭包函数的指令入口地址为<code>addr1</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdf9fd010bf84158bff279431144a693~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>上图中，由于捕获变量a除了初始化赋值外还被修改过，所以A的局部变量a改为堆分配，栈上只存它的地址。创建闭包对象时，会堆分配一个<code>funcval</code>结构体，<code>funcval.fn</code>指向闭包函数入口<code>addr1</code>，捕获列表中存储a在堆上的地址。而这个<code>funcval</code>结构体本身的地址addr2，就是<code>deferproc</code>执行时,_defer结构体中的fn的值。别忘了，传给defer函数的参数b&#x3D;2，也要拷贝到_defer结构体后面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f3e8a59963c4eb9a81da2638cbdc9a8~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>上图所示_defer结构体被添加到defer链表头以后，deferproc注册结束。继续执行后面的逻辑。到a&#x3D;a+b这里，a被置为3。下一步输出a&#x3D;3，b&#x3D;2。</p>
<p>接下来，deferreturn执行注册的defer函数时，要把参数b拷贝到栈上的参数空间。还记得闭包函数执行时怎样找到对应的捕获列表吗？通过寄存器存储的funcval地址加上偏移，找到捕获变量a的地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码编译后的伪指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a ：= <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *a = <span class="number">1</span></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line">    r := runtime.deferproc(<span class="number">8</span>, A_func1，<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    *a = *a + b</span><br><span class="line">    fmt.Println(*a, b)<span class="comment">//3,2</span></span><br><span class="line"></span><br><span class="line">    runtime.deferreturn()<span class="comment">//执行defer链表</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A_func1</span><span class="params">(b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a := (<span class="type">int</span> *)([DX]+<span class="number">8</span>)</span><br><span class="line">    *a = *a + b</span><br><span class="line">    fmt.Println(*a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>要注意捕获变量a在堆上分配，闭包函数执行时，捕获变量a&#x3D;3，参数b&#x3D;2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9c79fb99e7a4a028843a52449c01a9d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>所以，接下来在defer函数中，捕获变量a被置为5，最终输出a&#x3D;5，b&#x3D;2。这个例子中，最关键的是分清defer传参与闭包捕获变量的实现机制。</p>
<h3 id="defer-A-B-c"><a href="#defer-A-B-c" class="headerlink" title="defer ( A ( B ( c ) ) )"></a>defer ( A ( B ( c ) ) )</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a++</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> A(B(a))</span><br><span class="line">    a++</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个例子中，main函数注册的defer函数是A，所以，defer链表项中_defer.fn存储的是A的funcval指针。但是deferproc执行时，需要保存A的参数到_defer结构体后面。这就需要在defer注册时拿到B的返回值。</p>
<p>既然B会在defer注册时执行，那么对B(a)求值时a&#x3D;1。函数B的返回值就是2，也就是defer注册时保存的参数值为2，所以defer函数A执行时就会输出3。</p>
<h3 id="defer嵌套"><a href="#defer嵌套" class="headerlink" title="defer嵌套"></a>defer嵌套</h3><p>这一次，我们抛开各种细节，只关注defer链表随着defer函数的注册与执行究竟会如何变化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> B1()</span><br><span class="line">    <span class="keyword">defer</span> B2()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有defer函数都正常执行......</span></span><br></pre></td></tr></table></figure>



<p>这个例子中函数A注册两个defer，我们用函数名标记为A1和A2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7460bf1f1adb49809b354996beb66884~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>到函数A返回前执行deferreturn时，会判断defer链表头上的defer是不是A注册的。方法就是判断_defer结构体记录的sp是否等于A的栈指针.如果是A注册的，就保存defer函数调用的相关信息，然后把这一项从defer链表中移除，然后调用函数A2，A2执行时又注册两个defer，记为B1和B2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d71da34b0534e66aa892c81e27dbe91~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>函数A2返回前同样去执行defer链表，同样判断是否是自己注册的defer函数。所以B2执行，之后B1执行。此时A2仍然不知道自己注册的defer函数已经执行完了，直到下一个_defer.sp不等于A2的栈指针，A2注册的defer执行完，A2就可以结束了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/157c931f81f548d9961d338c06938cdb~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>因为A1是函数A注册的defer函数，所以又回到A的defer执行流程。A1结束后，defer链表为空，函数A结束。<br>这个例子的关键是defer链表注册时添加链表项，执行时移除链表项的用法。</p>
<h3 id="defer1-12性能问题"><a href="#defer1-12性能问题" class="headerlink" title="defer1.12性能问题"></a>defer1.12性能问题</h3><p>defer1.12的性能问题主要缘于两个方面：</p>
<ol>
<li>_defer结构体堆分配，即使有预分配的deferpool，也需要去堆上获取与释放。而且defer函数的参数还要在注册时从栈拷贝到堆，执行时又要从堆拷贝到栈。</li>
<li>defer信息保存到链表，而链表操作比较慢。</li>
</ol>
<h2 id="defer1-13"><a href="#defer1-13" class="headerlink" title="defer1.13"></a>defer1.13</h2><p>Go1.13中defer性能的优化点，主要集中在减少defer结构体堆分配。我们通过一个例子，看看它是怎样做到的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> B(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>像这样一段代码，在Go1.13中编译后的伪指令是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="keyword">struct</span> &#123;</span><br><span class="line">        runtime._defer</span><br><span class="line">        i <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    d.siz = <span class="number">0</span></span><br><span class="line">    d.fn = B</span><br><span class="line">    d.i = <span class="number">10</span></span><br><span class="line">    r := runtime.deferprocStack(&amp;d._defer)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意上面的结构体d，它由两部分组成，一个是<code>runtime._defer</code>结构体，一个是传给defer函数B的参数。它们被定义为函数A的局部变量，执行阶段会分配在函数栈帧的局部变量区域。接下来的<code>runtime.deferprocStack</code>则会把栈上分配的_defer结构体注册到defer链表。通过这样的方式避免在堆上分配_defer结构体。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dce59b615604c8d8074aed3696a711a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>值得注意的是，1.13版本中并不是所有defer都能够在栈上分配。循环中的defer，无论是显示的for循环，还是goto形成的隐式循环，都只能使用1.12版本中的处理方式在堆上分配。即使只执行一次的for循环也是一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示循环</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; n; i++&#123;</span><br><span class="line">    <span class="keyword">defer</span> B(i)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式循环</span></span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">defer</span> B()</span><br><span class="line">    <span class="keyword">if</span> i&lt;n &#123;</span><br><span class="line">        n++</span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>所以Go1.13中，runtime._defer结构体增加了一个字段heap，用于标识是否为堆分配。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    heap      <span class="type">bool</span>       <span class="comment">//标识是否为堆分配</span></span><br><span class="line">    sp        <span class="type">uintptr</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic</span><br><span class="line">    link      *_defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>defer函数的执行在1.13中没有变化，依然通过deferreturn实现，依然需要把_defer结构体后面的参数与返回值空间，拷贝到defer函数的调用者栈上。只不过不是从堆上拷贝到栈上，而是从栈上的局部变量空间拷贝到参数空间。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1892e1eeafb7402080e84dda5c1d2e48~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>1.13版本的defer减少了_defer结构体的堆分配，但是仍然要使用defer链表。官方提供的性能优化在30%左右。</p>
<h2 id="defer1-14"><a href="#defer1-14" class="headerlink" title="defer1.14"></a>defer1.14</h2><p>减少_defer结构体的堆分配，也是1.14版本中defer性能优化要持续践行的策略。但是具体做法与1.13版本不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> A1(i, <span class="number">2</span>*i)</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">defer</span> A2(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a,b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">(m,n <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面这个例子中，函数A注册两个defer函数A1和A2，不过函数A2要到执行阶段根据条件判断是否要执行。先看defer函数A1这部分编译后的伪指令，Go1.14中会把A1需要的参数定义为局部变量，并在函数返回前直接调用A1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">        </span><br><span class="line">    A1（a, b）</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通过这样的方式不仅不用构建_defer结构体，也用不到defer链表，但是到defer函数A2这里就行不通了。因为A2不一定要被执行，这要在执行阶段根据参数i的值来决定。</p>
<p>Go1.14通过增加一个标识变量df来解决这类问题。用df中的每一位对应标识当前函数中的一个defer函数是否要执行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62c04d04b0c435985187e79435000ac~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>例如，函数A1要被执行，所以就通过df |&#x3D; 1把df第一位置为1；在函数返回前再通过df&amp;1判断是否要调用函数A1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    df |= <span class="number">1</span>      </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//code to do something</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以像A2这样有条件执行的defer函数就可以像下面这样处理了。根据条件判断是否要把对应标识位置为1，函数返回前同样要根据标识符来判断是否要调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line">    <span class="comment">//A1的参数</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    df |= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//A2的参数</span></span><br><span class="line">    <span class="keyword">var</span> m,n <span class="type">string</span> = <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line">        df |= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//code to do something</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//判断A2是否要调用</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">2</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">2</span></span><br><span class="line">        A2(m, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断A1是否要调用</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//省略部分与recover相关的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Go1.14把defer函数在当前函数内展开并直接调用，这种方式被称为open coded defer。这种方式不仅不用创建_defer结构体，也脱离了defer链表的束缚。不过这种方式依然不适用于循环中的defer，所以1.12版本defer的处理方式是一直保留的。</p>
<p><strong>注意：</strong></p>
<p>但是，必须要强调的是，我们一直在梳理的都是程序正常执行时defer的处理逻辑。一旦发生panic或者调用了runtime.Goexit函数，在这之后的正常逻辑就都不会执行了，而是直接去执行defer链表。那些使用open coded defer在函数内展开，因而没有被注册到链表的defer函数要通过栈扫描的方式来发现。</p>
<p>Go1.14中runtime._defer结构体又增加了几个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    heap      <span class="type">bool</span></span><br><span class="line">    openDefer <span class="type">bool</span>           <span class="comment">//1</span></span><br><span class="line">    sp        <span class="type">uintptr</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic</span><br><span class="line">    link      *_defer </span><br><span class="line">    fd        unsafe.Pointer <span class="comment">//2</span></span><br><span class="line">    varp      <span class="type">uintptr</span>        <span class="comment">//3</span></span><br><span class="line">    framepc   <span class="type">uintptr</span>  </span><br></pre></td></tr></table></figure>



<p>借助这些信息，panic处理流程可以通过栈扫描的方式找到这些没有被注册到defer链表的defer函数，并按照正确的顺序执行。<br>所以，实际上Go1.14版本中defer的确变快了，但panic变得更慢了……</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang panic和recover原理浅析</title>
    <url>/2022/09/07/Go/Golang%20panic%E5%92%8Crecover%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>我们已经知道，当前执行的goroutine持有一个defer链表的头指针。其实它也有一个panic链表头指针。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df6ba79c1c3a4063b11daff4dd721d51~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>panic链表链起来的是一个一个_panic结构体。和defer链表一样，发生新的panic时，也是在链表头上插入一个_panic结构体。而链表头上的panic就是当前正在执行的那一个。</p>
<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;这里不会被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A2正常结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A1正常结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个例子中，函数A注册两个defer函数A1和A2之后发生panic。panic发生前，defer链表中已经注册了A1和A2，我们同样用函数名作为区分标记。发生panic后，它后面的代码就不会执行了，而是进入panic处理逻辑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92de984d1bca4556ac80fa68db3ce006~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>首先，会在panic链表头处增加一项，我们把它记为<code>panicA</code>，现在它就是当前执行的panic。然后就该执行defer链表了，从defer链表头开始执行，不过与函数正常流程执行defer有些许不同，还记得_defer结构体的内容吗？（Go1.12版本）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span>    <span class="comment">// panic执行defer时会把它标记为true</span></span><br><span class="line">    sp        <span class="type">uintptr</span> </span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic <span class="comment">// 记录触发defer执行的_panic指针</span></span><br><span class="line">    link      *_defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>panic执行到一个defer时，会先把它的<code>_defer.started</code>置为true，标记它已经开始执行；并且会把<code>_defer._panic</code>字段指向当前执行的panic，表示这个defer是由这个panic触发的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9840ae2c84e47c4ab6b5e3b0b320786~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>把A2对应的_defer标记好以后，A2开始执行。这里函数A2能够正常结束，也就是没有发生panic或调用runtime.Goexit函数，所以A2这一项就会被移除，继续执行下个defer。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5326556477f44c1f8362ac46a38315c1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>之所以要等到defer函数正常返回以后再移除对应的defer链表项，主要是为了应对defer函数没有正常结束的情况，就像下面这个例子。</p>
<h2 id="panic之后又panic"><a href="#panic之后又panic" class="headerlink" title="panic之后又panic"></a>panic之后又panic</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A1再次panic&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数A中panic发生后，panic链表增加一项，记为panicA。然后就要执行defer链表了，设置A1对应的_defer.started与_defer._panic字段，然后调用函数A1。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96f7311e15d440498cdf2afa672b8fce~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>A1执行时，再次发生panic,同样要在panic链表头插入一个新的_panic，记为panicA1。现在这个panicA1成为当前执行的panic了。它同样会去执行defer链表，但是发现A1已经执行，并且触发它执行的并不是当前的panicA1，而是之前的panicA。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05a8af4fc35043deb135541d524914cf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>这时会根据A1这里记录的_panic指针，找到对应的_panic，并把它标记为已终止。怎么标记？那就要把_panic结构体展开来看看了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">    argp      unsafe.Pointer</span><br><span class="line">    arg       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    link      *_panic</span><br><span class="line">    recovered <span class="type">bool</span></span><br><span class="line">    aborted   <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>argp 用来存储panic正在执行的defer函数的参数空间地址;</li>
<li>arg 则是panic函数自己的参数;</li>
<li>link自然是链到上一个_panic结构体；</li>
<li>recovered 标识这个panic是否被恢复；</li>
<li>aborted 标识这个panic是否被终止。</li>
</ul>
<p>所以要终止panicA，就是把它的_panic.aborted字段置为true。而且defer链表中A1这一项也要被移除。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db14fc403d44c06bbbca67a31f6bf7e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>此时，defer链表为空，paic处理流程来到了打印panic信息这一步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>:panicA</span><br><span class="line"><span class="built_in">panic</span>:panicA1</span><br></pre></td></tr></table></figure>



<p>注意panic打印异常信息时，会打印此时panic链表中剩余的所有链表项。不过，并不是从链表头开始，而是从链表尾开始，按照链表项的插入顺序逐一输出。所以这个例子才会先输出panicA，然后是panicA1。打印完异常信息后，程序退出。</p>
<p>好了，到目前为止，没有recover发生的panic处理逻辑就算梳理完了，理解这个过程的关键点有两个：</p>
<ol>
<li>panic执行defer函数的方式，先标记，后移除，目的是为了终止之前工作的panic；</li>
<li>panic异常信息：所有还在panic链表上的链表项都会被输出，顺序与panic发生的顺序一致。</li>
</ol>
<h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>接下来我们增加recover看看是什么情况。下面这个例子中，函数A里注册了两个defer函数，并且会发生panic。而defer函数A2中会执行recover。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p := <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Println(p) <span class="comment">//这里会正常执行输出“panicA”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数A中panic发生时，当前goroutine中defer链表已经注册了A1和A2。然后panic链表增加一项，记为panicA。panic触发defer链表执行，先执行函数A2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c599b8a7d0b4eecb6483c14d11c3427~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>函数A2执行时发生recover，其实，recover函数本身的逻辑很简单，它只做一件事，就是把当前执行的panic置为已恢复，也就是把它的_panic.recovered字段置为true，其它的都不管。</p>
<p>所以函数A2中recover发生后会把当前执行的panicA置为已恢复，然后recover函数的任务就完成了。函数A2会继续往下执行，直到A2结束。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/783ff71e604040fead7b3a6ca698464b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>其实在每个defer函数执行完以后，panic处理流程都会检查当前panic是否被恢复了。这里A2结束后，panic处理流程发现panicA已经被恢复，所以就会把它从panic链表中移除。A2这一项也会从defer链表中移除，不过在移除前要保存_defer.sp和_defer.pc两个字段的值。</p>
<p>接下来要做的，就是使用保存的sp和pc字段值跳出panicA处理流程，但是要怎么跳出来？又该恢复到哪里去呢？</p>
<p>我们知道，sp和pc是注册defer函数时保存的，对应到defer函数A2，sp就是函数A的栈指针，而pc就是调用deferproc(或deferprocStack)函数的返回地址。对应到下面这段伪指令中，就是函数A中判断r是否大于零的这部分逻辑。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92a18fb4b78446bb990890497f764c96~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>通过sp，可以恢复到函数A的栈帧；通过pc，可以把指令地址恢复到判断r是否大于零这里。但是r就不能是0了，否则函数A就会重复执行。我们之前提过这个返回值被编译器保存在一个寄存器中，所以只要把它置为1就可以执行goto ret，跳转到deferreturn这里继续执行defer链表了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b37ca442326d4b07b5c83a446d93a2a1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>注意，函数A这里的deferreturn只负责执行函数A中注册的defer函数，是通过栈指针来判断的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f58368ca6364052a1cea5512bb1877b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>我们这个例子中，跳转到A的deferreturn这里后，下一个链表项A1仍然是函数A注册的defer，所以，接下来会执行defer函数A1，A1结束后，defer链表为空，函数A结束。</p>
<p>这就是recover的基本流程，理解的关键有两点：</p>
<ol>
<li>跳出当前panic处理流程以后要恢复到哪里，又是怎样恢复到那里的；<br>2.要注意，在发生recover的函数正常返回以后，才会检测当前panic是否被恢复，然后才会删除被恢复的panic。</li>
</ol>
<h2 id="recover后同一函数又panic"><a href="#recover后同一函数又panic" class="headerlink" title="recover后同一函数又panic"></a>recover后同一函数又panic</h2><p>如果发生recover的函数，在返回前再次panic，情况又会如何？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p := <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Println(p) <span class="comment">//这里会正常执行输出“panicA”</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5dabe644f02a42a6944ff4af9d5c9345~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>当panicA2触发defer链表执行时，发现defer函数A2已经执行，所以把触发它执行的panicA终止掉。A2这一项也会从链表移除。<br>值得注意的是，由于A2没有正常返回，所以即使panicA已经被恢复了，也没有从链表中移除。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9db490bfd1f549f0bd2f8ab942ad4667~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后panicA2继续执行defer函数A1，A1中记录的_defer._panic指向panicA2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e2a5836186d487ea0f8fdc3fb9c9dc6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>函数A1结束后，defer链表为空，接下来就要输出异常信息了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9593a3315a034f6298bb427590ab73c5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>对于链表中已经被恢复的panic，打印它的信息时会加上recovered标记，panic链表每一项都输出后程序退出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>:panicA[recovered]</span><br><span class="line"><span class="built_in">panic</span>:panicA2</span><br></pre></td></tr></table></figure>



<h2 id="recover后恢复到哪里"><a href="#recover后恢复到哪里" class="headerlink" title="recover后恢复到哪里"></a>recover后恢复到哪里</h2><p>这个例子是为了加深对recover的理解，这一次我们结合函数调用关系弄清楚recover发生后，程序究竟会恢复到哪里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;A1正常执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> B1()        </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p := <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Println(p)<span class="comment">//这里正常输出&quot;panicA2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<ul>
<li>函数A发生panic，实际上会调用gopanic函数来处理添加panic链表项与执行defer等工作。我们把这个panic记为panicA。</li>
<li>panicA会执行A的defer函数A2。在A2执行时又注册了defer函数B1，然后再次发生panic，所以函数A2会调用gopanic来处理panicA2。</li>
<li>panicA2会去执行defer链表，所以接下来会调用B1。</li>
<li>B1执行时调用recover函数把panicA2置为已恢复。</li>
<li>B1结束后，panicA2被移除，程序恢复到函数A2这里的deferreturn继续执行。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d56fd18866cc4f7ab5506b0746dcafc0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>因为A2注册的defer函数已经执行完了，所以函数A2返回。最终返回到哪里呢？回到panicA这里继续执行，因为A2的执行就是由panicA触发的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/395a09713e314d16922374879d29bb93~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>回到panicA这里，继续执行defer链表，接下来就轮到函数A1了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c99cd4e2dfca434086502706a0f8311a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>等到A1执行结束，defer链表为空。输出panic链表上仅剩的panicA的异常信息之后程序就退出了。</p>
<h2 id="recover调用限制"><a href="#recover调用限制" class="headerlink" title="recover调用限制"></a>recover调用限制</h2><p>关于recover，还要强调最后一点，就是recover函数只能在defer函数中直接调用，不能通过另外的函数间接调用。这是语言实现层面的要求，不满足要求的recover调用，不会有任何效果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e8daf5d06564eeaaa29213c226c7aee~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="关于open-coded-defer"><a href="#关于open-coded-defer" class="headerlink" title="关于open coded defer"></a>关于open coded defer</h2><p>Go1.14版本以前，panic和recover的基本流程就是这样。但是，由于1.14中使用了open coded defer，在函数内部展开调用的defer函数并没有注册到defer链表，导致panic执行defer链表时不能像之前这般轻松。</p>
<p>1.14版本中panic处理流程要在执行defer链表前先进行栈扫描，把第一个open codeed defer注册到链表中正确的位置。然后开始执行defer链表。而且每次都要判断_defer.openCoded的值，如果为true，就通过_defer记录的信息拿到所属函数中open coded defer的相关信息，然后按照正确的顺序执行。具体过程相当繁琐，但是panic和recover的总体设计思想是一致的。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang method原理浅析</title>
    <url>/2022/09/07/Go/Golang%20method%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法即method，Go语言支持为自定义类型实现方法，method在具体实现上与普通的函数并无不同，只不过会通过运行时栈多传递一个隐含的参数，这个隐含的参数就是所谓的接收者。下面通过代码来进行说明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	a.name = <span class="string">&quot;Hi! &quot;</span> + a.name</span><br><span class="line">	<span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := A&#123;name: <span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// 1）编译器的语法糖，提供面向对象的语法</span></span><br><span class="line">	fmt.Println(a.Name())</span><br><span class="line">	 <span class="comment">// 2）更贴近真实实现的写法，和普通函数调用几乎没什么不同</span></span><br><span class="line">	fmt.Println(A.Name(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码展示了两种不同的写法，都能顺利通过编译并正常运行，实际上这两种写法会生成同样的机器码。<br>第一种：a.Name()，这是我们惯用的写法，很方便；<br>第二种：A.Name(a)，这种写法更底层也更严谨，要求所有的类型必须严格对应，否则是无法通过编译的。<br>其实编译器会帮我们把第一种转换为第二种的形式，所以我们惯用的第一种写法只是“语法糖”，方便而已。</p>
<p>深入理解这两种写法的等价性是非常重要的，下面再用代码进一步验证：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">    a.name = <span class="string">&quot;Hi! &quot;</span> + a.name</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NameOfA</span><span class="params">(a A)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    a.name = <span class="string">&quot;Hi! &quot;</span> + a.name</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := reflect.TypeOf(A.Name)</span><br><span class="line">    t2 := reflect.TypeOf(NameOfA)</span><br><span class="line">    <span class="comment">// 会输出true，通过反射来验证，两者的类型是相同的</span></span><br><span class="line">    fmt.Println(t1 == t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为Go语言反射获取的函数类型只跟参数和返回值有关，既然t1和t2相等，就说明类型A的方法本质上和函数NameOfA相同。也就进一步验证了：方法本质上就是普通的函数，而接收者就是隐含的第一个参数。</p>
<h2 id="值接收者"><a href="#值接收者" class="headerlink" title="值接收者"></a>值接收者</h2><p>接下来，我们看看上面第一个示例中，a.Name()执行时函数调用栈是什么情况。</p>
<p>main函数栈帧中局部变量a只有一个string类型的成员，a.Name()会由编译器转换为A.Name(a)这样的函数调用。局部变量a作为要传入的参数，被直接拷贝到参数空间。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f9d33a122404fb4a9446a4ad28b7278~tplv-k3u1fbpfcp-zoom-1.image" alt="值接收者方法调用栈"></p>
<p>A.Name(a)执行时,修改的是参数空间的a.name，string底层指向的字符串内容发生了变化。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23274923b511411aa5b8df19b3056224~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>函数返回前将返回值写入返回值空间，对应到这个例子，就是拷贝参数a的成员name到返回值空间。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ebd14b243ad4cf3bcaa129ca871796e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>通过值接收者调用方法时，值接收者会作为第一个参数，而Go语言中传参都是值拷贝，所以执行a.Name()修改的并不是局部变量a，而是拷贝过去的参数。要想修改a，还得用指针接收者。</p>
<h2 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h2><p>我们把上个例子改为指针接收者，然后看看通过指针接收者调用方法时，函数调用栈又会是怎样的情况。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pa *A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">    pa.name = <span class="string">&quot;Hi! &quot;</span> + pa.name</span><br><span class="line">    <span class="keyword">return</span> pa.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">    pa := &amp;a</span><br><span class="line">    fmt.Println(pa.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>main函数栈帧有两个局部变量，pa存储的是a的地址。pa.Name()会由编译器转换为（*A).Name(pa)函数调用，所以参数空间拷贝参数pa的值，也就是局部变量a的地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b65bb3491348c7b6b5e16d0e8d13bd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>(*A).Name(pa)执行时，修改的是pa指向的结构体，也就是局部变量a.name的值。这个string类型的成员会指向新的底层字符串，而返回值空间被写入的也是pa指向的结构体的成员name。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07c550f05a20409a9a96dfc0bfc8ceda~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>通过指针类型接收者调用方法时，指针会作为参数传入，传参时拷贝的就是地址，所以这里能够实现对原来变量a的修改。</p>
<h2 id="更甜的语法糖"><a href="#更甜的语法糖" class="headerlink" title="更甜的语法糖"></a>更甜的语法糖</h2><p>再次修改上面的例子，这一次既有值接收者的方法，又有指针接收者的方法。对于a.GetName()和pa.SetName()这两种形式的方法调用我们已经了然。但是下面这pa.GetName()和a.SetName()也能正常执行是几个意思？ </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pa *A)</span></span> SetName() <span class="type">string</span> &#123;</span><br><span class="line">    pa.name = <span class="string">&quot;Hi! &quot;</span> + pa.name</span><br><span class="line">    <span class="keyword">return</span> pa.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">    pa := &amp;a</span><br><span class="line">    </span><br><span class="line">    fmt.Println(pa.GetName())</span><br><span class="line">    fmt.Println(a.SetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>不用展开函数调用栈，只需告诉你这是语法糖，理解起来也就没有问题了。编译期间，会把pa.GetName()这种方法调用转换成(*pa).GetName()，也就等价于执行A.GetName(<em>pa)。而a.SetName()会被转换成(&amp;a).SetName()，也相当于执行（</em>A).SetName(&amp;a)。所以，看似值接收者和指针接收者交叉访问了对方的方法，实际上依然遵循之前介绍的执行过程。</p>
<p><em>如果定义的方法不涉及到任何接口类型时是这样的，详细情况以后详述，目前这样理解无碍。</em></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea57bcd807a14c368a9104ebf8486877~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>既然这种语法糖是在编译期间发挥作用的，像下面这种编译期间不能拿到地址的字面量，就不能享受语法糖，转换成对应的指针接收者调用了。    </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println((A&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;).SetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译期间会发生错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot call pointer method on A literal</span><br><span class="line">cannot take the address of A literal</span><br><span class="line">错误: 进程退出代码 <span class="number">2.</span></span><br></pre></td></tr></table></figure>




<h2 id="Method-Expression-amp-Method-Value"><a href="#Method-Expression-amp-Method-Value" class="headerlink" title="Method Expression &amp; Method Value"></a>Method Expression &amp; Method Value</h2><p>我们已经知道，Go语言中函数作为变量、参数和返回值时，都是以Function Value的形式存在的。也知道闭包只是有捕获列表(catch list)的Funtion Value而已。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf5e160cc88849519ce18f78c882949a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>那么如果把方法赋给一个变量，这个变量又是怎样的存在呢？   </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := A&#123;name:<span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    f1 := A.GetName      <span class="comment">//方法表达式</span></span><br><span class="line">    f1(a)                <span class="comment">//eggo</span></span><br><span class="line"></span><br><span class="line">    f2 := a.GetName      <span class="comment">//方法变量</span></span><br><span class="line">    f2()                 <span class="comment">//eggo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-方法表达式"><a href="#1-方法表达式" class="headerlink" title="1.方法表达式"></a>1.方法表达式</h3><p>如果像f1这样，把一个类型的方法赋给它，这样的变量就被称为<code>方法表达式</code>。对f1的处理相当于下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">......    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetName</span><span class="params">(a A)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := A&#123;name:<span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    f1 := GetName</span><br><span class="line">    f1(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以，f1实际上就是一个普通的Function Value，执行时需要传入一个A类型的变量作为第一个参数。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fca4392d57e4796a755950fe3f80728~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="2-方法变量-作为局部变量"><a href="#2-方法变量-作为局部变量" class="headerlink" title="2.方法变量 (作为局部变量)"></a>2.方法变量 (作为局部变量)</h3><p>然而，像f2这样，通过a.GetName进行赋值，这样的变量被称为<code>方法变量</code>。通过方法变量执行方法时，我们无需再传入方法接收者作为第一个参数，这是因为编译器替我们做了处理。方法变量也是一个Function Value，在这个例子中，编译阶段f2()会被转换为A.GetName(a)。但是这只是方法变量作为<code>局部变量</code>的情况。</p>
<h3 id="3-方法变量-作为返回值"><a href="#3-方法变量-作为返回值" class="headerlink" title="3.方法变量 (作为返回值)"></a>3.方法变量 (作为返回值)</h3><p>如果像下面的GetFunc函数这样，把方法变量作为<code>返回值</code>。这个返回值实际上是一个捕获了局部变量a的Function Value，也就是说f3是一个<code>闭包对象</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...... </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo in GetFunc&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> a.GetName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo in main&quot;</span>&#125;</span><br><span class="line">    f2 := a.GetName</span><br><span class="line">    fmt.Println(f2()) <span class="comment">//这里输出：eggo in main</span></span><br><span class="line"></span><br><span class="line">    f3 := GetFunc()</span><br><span class="line">    fmt.Println(f3()) <span class="comment">//这里输出：eggo in GetFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的GetFunc函数和下面这段代码是等价的，通过它我们能够清晰地看到闭包是如何形成的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span><span class="type">string</span>) &#123;</span><br><span class="line">    a := A&#123;name:<span class="string">&quot;eggo in GetFunc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span><span class="type">string</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.GetName(a)  <span class="comment">//捕获变量a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>f3是一个闭包对象，它执行时用到的是自己捕获的变量，也就是函数GetFunc的局部变量a。而f2这个方法变量，使用的是main函数的局部变量a。这样就很好理解上面这段示例程序的输出结果了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25f2642b7a034d8aa14ab5a161883739~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang reflect底层剖析</title>
    <url>/2022/09/07/Go/Golang%20reflect%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>用到反射的场景不外乎是变量类型不确定，内部结构不明朗的情况，所以反射的作用简单来说就是把类型元数据暴露给用户使用。<br>我们已经介绍过runtime包中<code>_type</code>、<code>uncommontype</code>、<code>eface</code>、<code>iface</code>等类型了，reflect也要和它们打交道，但是它们都属于未导出类型，所以reflect在自己的包中又定义了一套，两边的类型定义是保持一致的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c3da14520694290b8f242f7812dc0b0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>reflect中有两个核心类型，<code>reflect.Type</code>和<code>reflect.Value</code>，它们两个撑起了反射功能的基本框架。</p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p><code>reflect.Type</code>是一个接口类型，它定义了一系列方法用于获取类型各方面的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">    Align() <span class="type">int</span> <span class="comment">//对齐边界</span></span><br><span class="line">    FieldAlign() <span class="type">int</span> <span class="comment">//作为结构体字段的对齐边界</span></span><br><span class="line">    Method(<span class="type">int</span>) Method <span class="comment">//获取方法数组中第i个Method</span></span><br><span class="line">    MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>) <span class="comment">//按照名称查找方法</span></span><br><span class="line">    NumMethod() <span class="type">int</span> <span class="comment">//方法列表中可导出方法的数目</span></span><br><span class="line">    Name() <span class="type">string</span> <span class="comment">//类型名称</span></span><br><span class="line">    PkgPath() <span class="type">string</span> <span class="comment">//包路径</span></span><br><span class="line">    Size() <span class="type">uintptr</span> <span class="comment">//该类型变量占用字节数</span></span><br><span class="line">    String() <span class="type">string</span> <span class="comment">//获取类型的字符串表示</span></span><br><span class="line">    Kind() Kind <span class="comment">//类型对应的reflect.Kind</span></span><br><span class="line">    Implements(u Type) <span class="type">bool</span> <span class="comment">//该类型是否实现了接口u</span></span><br><span class="line">    AssignableTo(u Type) <span class="type">bool</span> <span class="comment">//是否可以赋值给类型u</span></span><br><span class="line">    ConvertibleTo(u Type) <span class="type">bool</span> <span class="comment">//是否可转换为类型u</span></span><br><span class="line">    Comparable() <span class="type">bool</span> <span class="comment">//是否可比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只能应用于某些Kind的方法</span></span><br><span class="line">    <span class="comment">//Int*, Uint*, Float*, Complex*: </span></span><br><span class="line">    Bits() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array,Ptr,Slice,Map: </span></span><br><span class="line">    Elem() Type</span><br><span class="line">    <span class="comment">//Array</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Chan:ChanDir, Elem </span></span><br><span class="line">    ChanDir() ChanDir</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Func: </span></span><br><span class="line">    In(i <span class="type">int</span>) Type</span><br><span class="line">    NumIn() <span class="type">int</span></span><br><span class="line">    Out(i <span class="type">int</span>) Type</span><br><span class="line">    NumOut() <span class="type">int</span></span><br><span class="line">    IsVariadic() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Map: </span></span><br><span class="line">    Key() Type</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Struct: </span></span><br><span class="line">    Field(i <span class="type">int</span>) StructField</span><br><span class="line">    FieldByIndex(index []<span class="type">int</span>) StructField</span><br><span class="line">    FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line">    FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span>) (StructField, <span class="type">bool</span>)  </span><br><span class="line">    NumField() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    common() *rtype</span><br><span class="line">    uncommon() *uncommonType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通常会用<code>reflect.TypeOf</code>这个函数来拿到一个<code>reflect.Type</code>类型的返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>它接收一个空接口类型的参数。<br>接下来，<code>reflect.TypeOf</code>函数会把<code>runtime.eface</code>类型的参数<code>i</code>转换成reflect.emptyInterface类型并赋给局部变量<code>eface</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8706c6d1efc46fab47eb32942cf9022~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>因为<code>*rtype</code>实现了<code>reflect.Type</code>接口，所以只要把<code>eface</code>这里的<code>typ</code>字段取出来，包装成<code>reflect.Type</code>类型的返回值就好了。<br>这就相当于下面这样把<code>eface.typ</code>赋值给一个<code>reflect.Type</code>类型的变量，这两行代码可以帮助我们理解返回值的结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ret reflect.Type</span><br><span class="line">ret = eface.typ</span><br></pre></td></tr></table></figure>



<p>还记得非空接口长什么样子吧？<code>eface.typ</code>是个指针，所以这个返回值的<code>data</code>字段就等于<code>eface.typ</code>，也就是<code>string</code>类型的元数据地址，而<code>itab</code>中的接口类型就是<code>reflect.Type</code>，动态类型就是<code>*rtype</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25b46777918b4178bc34db3a51d52cb2~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>至于<code>*rtype</code>实现的这些接口要求的方法，也不过是去<code>data</code>字段指向的类型元数据那里获取各种信息罢了。<br>例如可以使用<code>Implements</code>方法来判断类型是否实现了某个接口，比方说fmt.Stringer接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d75e386ac77e4e85a5942a87a7408845~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>判断的过程就是通过类型元数据找到方法元数据数组，这里的Method是按照方法名称排过序的，所以只要和接口要求的方法列表两相比较一下，就可以确定该类型是否实现指定接口了。<br>这就是<code>reflect</code>的<code>Type</code>类型和<code>TypeOf</code>方法，重点是要理解反射如何拿到反射变量的类型元数据，剩下的就好说了。</p>
<h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><p>与<code>reflect.Type</code>不同，<code>reflect.Value</code>是一个结构体类型。   </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ *rtype</span><br><span class="line">    ptr unsafe.Pointer</span><br><span class="line">    flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>typ</code>存储反射变量的类型元数据指针；</li>
<li><code>ptr</code>存储数据地址；</li>
<li><code>flag</code>是一个位标识符，存储反射变量值的一些描述信息，例如类型掩码，是否为指针，是否为方法，是否只读等等。</li>
</ul>
<p><code>reflect.Value</code>同样提供了很多方法，这里我们只关注利用反射来更新变量值的过程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">    v := reflect.ValueOf(a)</span><br><span class="line">    v.SetString(<span class="string">&quot;new eggo&quot;</span>)</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先要注意，<code>reflect.ValueOf</code>函数的参数也是空接口类型，所以和前面介绍的<code>TypeOf</code>一样，它接收到的参数中数据指针同样指向<code>a</code>的一个拷贝值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    escapes(i)</span><br><span class="line">    <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此外还要注意，<code>reflect.ValueOf</code>函数目前的实现方式，会通过<code>escapes</code>函数显示地把参数<code>i</code>指向的变量逃逸到堆上。<br>对应到上面这个例子，<code>copy of a</code>就会逃逸到堆上，栈上存储它的地址。所以这个空接口类型的参数<code>i</code>，其动态类型指向string类型元数据，动态值指向堆上的<code>copy of a</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a78332221c484f0d9965b95edc4c48e9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><code>ValueOf</code>函数的返回值是<code>reflect.Value</code>类型，其<code>typ</code>字段取参数的<code>_type</code>字段，指向<code>string</code>类型元数据，<code>ptr</code>字段取参数的<code>data</code>字段，指向<code>copy of a</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/412a5ce2ed14422e9fbb25b243878e07~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>接下来，这个返回值被赋给局部变量<code>v</code>，调用<code>v.SetString</code>时，方法接收者<code>v</code>作为第一个参数，字符串”new eggo”作为第二个参数。 因为此时<code>v.ptr</code>指向的是<code>copy of a</code>，而不是<code>a</code>，所以是不允许修改的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cafce1fce2754de1bb3865e632a852ec~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>因为修改这样一个用户都不知道的临时变量<code>copy of a</code>没有任何意义，毕竟通过反射来修改变量值本意是要作用到原变量身上的，所以上面这个例子在执行阶段会发生panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: reflect: reflect.Value.SetString using unaddressable value</span><br></pre></td></tr></table></figure>



<p>这个异常信息就是提醒我们此时反射修改值的行为并不符合预期。若想顺利修改变量<code>a</code>，就需要反射<code>a</code>的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">    v := reflect.ValueOf(&amp;a)</span><br><span class="line">    v.Elem().SetString(<span class="string">&quot;new eggo&quot;</span>)</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>传参依然是值拷贝，只不过这一次拷贝的是<code>a</code>的地址，所以<code>reflect.ValueOf</code>会显示地把局部变量<code>a</code>逃逸到堆上，栈上只存它的地址&amp;a。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/478f8e7d2de3470496ecf1c4be8d28d7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>局部变量<code>v</code>中，<code>v.typ</code>指向<code>*string</code>类型元数据，<code>v.ptr</code>等于<code>a</code>的地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d9bde514db144be9fe1cde8e8f4226c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>接下来调用<code>v.Elem()</code>方法可以拿到<code>v.ptr</code>指向的那个变量，也就是局部变量<code>a</code>，并把它包装成一个新的<code>reflect.Value</code>对象作为返回值。这个返回值里<code>typ</code>指向<code>string</code>类型元数据，<code>ptr</code>指向局部变量<code>a</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63f55a02caf4c27a1a133f2a4c22311~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>通过<code>v.Elem()</code>的返回值再调用<code>SetString</code>方法时，修改的就是原来的变量<code>a</code>了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0651539506f447df9474ce3b718136ea~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>通过反射修改变量值的问题有点绕，但是只要记住函数传参值拷贝，以及反射修改变量值要作用到原变量身上才有意义这两个原则，再梳理出<code>Value</code>对象内部结构，理解起来就没那么困难了。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang slice传参陷阱</title>
    <url>/2022/09/07/Go/Golang%20slice%E4%BC%A0%E5%8F%82%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<h2 id="先看一道题"><a href="#先看一道题" class="headerlink" title="先看一道题"></a>先看一道题</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	SliceRise(s1)</span><br><span class="line">	SliceRise(s2)</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A: [2,3][2,3,4]</span></span><br><span class="line"><span class="comment">//B: [1,2][1,2,3]</span></span><br><span class="line"><span class="comment">//C: [1,2][2,3,4]</span></span><br><span class="line"><span class="comment">//D: [2,3,1][2,3,4,1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不清楚slice的扩容和Go语言的传参机制，可能很难想出来一个解释的清的答案，答案选C，最后再解释。</p>
<h2 id="slice的传参"><a href="#slice的传参" class="headerlink" title="slice的传参"></a>slice的传参</h2><p>在初学golang的时候，我一直以为slice是引用传递而不是值传递，其实不然。</p>
<p>我们先来看一下官方对于这个问题的解释：</p>
<blockquote>
<p>In a function call, the function value and arguments are evaluated in<br>the usual order. After they are evaluated, the parameters of the call<br>are passed by value to the function and the called function begins<br>execution. The return parameters of the function are passed by value<br>back to the caller when the function returns.</p>
</blockquote>
<p>译文：</p>
<blockquote>
<p>在函数调用中，函数值和参数按通常的顺序计算。求值之后，调用的参数通过值传递给函数，被调用的函数开始执行。当函数返回时，函数的返回参数按值返回给调用者。</p>
</blockquote>
<p>来源于：<br><a href="https://golang.org/ref/spec#Calls">https://golang.org/ref/spec#Calls</a></p>
<p>也就是说golang中其实是没有所谓的引用传递的，只有值传递。那为什么我们在函数中对slice进行修改时，有时候会影响到函数外部的slice呢？</p>
<p>这就要从slice的内存模型说起了，slice的内存模型其实非常简单，就是一个结构体，里面包含了三个字段。第一个字段是一个指向底层数组的指针，第二个是slice的长度，第三个是底层数组的大小。具体的可以看这里：<a href="https://blog.csdn.net/qq_49723651/article/details/121267698?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_49723651&#x2F;article&#x2F;details&#x2F;121267698?spm&#x3D;1001.2014.3001.5501</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在传递参数的时候，其实是传递了一个slice结构体，这个时候当然是值传递。我们来验证一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s1)</span><br><span class="line">	SliceRise(s1)</span><br><span class="line">	<span class="comment">//SliceRise(s2)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1, s2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//0xc000004078</span></span><br><span class="line"><span class="comment">//0xc000004090</span></span><br></pre></td></tr></table></figure>



<p>通过计算可以知道slice结构体的大小为24byte，两个地址之差刚好是24byte。<br>地址不同，所以两个结构体不是同一个结构体。</p>
<p><strong>然而结构体中的指针字段却包含了底层数组的地址，这就使得函数中的slice和函数外的slice都指向了同一个底层数组，这也就是有些时候，改变函数内部的slice也能影响到函数外部的slice的原因。</strong></p>
<h2 id="slice的扩容"><a href="#slice的扩容" class="headerlink" title="slice的扩容"></a>slice的扩容</h2><p>有关扩容的详细规则可以看这篇博客：<a href="https://blog.csdn.net/qq_49723651/article/details/121267698?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_49723651&#x2F;article&#x2F;details&#x2F;121267698?spm&#x3D;1001.2014.3001.5501</a>。</p>
<p>slice在append的时候，如果底层数组的大小(cap)不够了，就会发生扩容。发生扩容的时候，slice结构体的指针会指向一个新的底层数组，然后把原来数组中的元素拷贝到新数组中，最后添加上append的新元素，就完成了扩容。<br>所以在这个时候，函数内部slice的改变是不会影响到函数外部slice的。因为此时，两个结构体中的指针指向的底层数组已经不相同了。</p>
<h2 id="回到开始"><a href="#回到开始" class="headerlink" title="回到开始"></a>回到开始</h2><p>然后我们回到最开始的这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	SliceRise(s1)</span><br><span class="line">	SliceRise(s2)</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A: [2,3][2,3,4]</span></span><br><span class="line"><span class="comment">//B: [1,2][1,2,3]</span></span><br><span class="line"><span class="comment">//C: [1,2][2,3,4]</span></span><br><span class="line"><span class="comment">//D: [2,3,1][2,3,4,1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>选C也就不难解释了：</p>
<ul>
<li>首先s1在初始化的时候，分配了一个底层数组，<code>len=2</code>，<code>cap=2</code> ；</li>
<li>将s1赋值给s2，两者就指向了同一个底层数组；</li>
<li>s2发生扩容，因为cap不够了，这个时候s2指向一个<code>新的底层数组</code>，并且<code>len=3</code>，<code>cap=4</code> ；</li>
<li>然后调用两次<code>SliceRise</code>函数；</li>
<li>s1作为参数进入函数时，发生了扩容，因为<code>cap</code>不够了，所以新分配了一个底层数组，这个时候，main函数中的s1与<code>SliceRise</code>中的s1已经分道扬镳了。所以main函数中的s1不会有任何改变；</li>
<li>s2作为参数进入函数时，同样发生了扩容，但是<code>cap</code>还够，所以不会分配新的底层数组，接下来的所有改变都会影响到s2所指向的底层数组。但是main函数结构体中len字段的值却不会发生变化，所以即使底层数组的第4位append了0，切片s2也访问不到。所以最后在输出s2的时候，只能输出s2的前len位，也就是前3位。</li>
<li>因此最终在main函数中，s1输出[1,2]，而s2输出[2,3,4]。</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang slice原理浅析</title>
    <url>/2022/09/07/Go/Golang%20slice%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="slice内存模型"><a href="#slice内存模型" class="headerlink" title="slice内存模型"></a>slice内存模型</h2><p>我的go源码版本是：<a href="https://golang.org/dl/go1.17.2.src.tar.gz">go1.17.2</a></p>
<p>slice的源码在<code>Go_SDK\go1.17.2\src\runtime\slice.go</code>中。<br>和map.go在同一个目录下。</p>
<p>首先我们来看一下slice的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>slice的结构非常简单，只有三个部分：</p>
<ul>
<li>array: 指向数组的指针。</li>
<li>len：当前长度。</li>
<li>cap：容量。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6044a1c99a7c4dc08edc43007ba4daa0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br></p>
<h2 id="slice的初始化"><a href="#slice的初始化" class="headerlink" title="slice的初始化"></a>slice的初始化</h2><p>举一个例子：</p>
<p><strong>声明一个整型的slice：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints []<span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>变量<code>ints</code>实际上就由以下三个部分组成。<br><code>slice</code>的元素要存在一段连续的内存中，实际上就是一个数组，但是目前只分配了这个切片结构，还没有分配底层数组。所以 <code>data = nil</code> | <code>len = 0</code> | <code>cap = 0</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe914f09f8847e0bc122dd0c68a0323~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><strong>通过make来定义</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这时不仅会分配这三部分结构，还会开辟一段内存作为切片的底层数组，这里make会为ints开辟一段容纳5个整型元素的内存，还会把它们初始化为整型的默认值0 。<br>但是目前这个slice变量只存储了两个元素，所以<code>data指向这个底层数组的首地址 | len = 2 | cap = 5</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c49597a18cb488fbe95476620826bb3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>这个时候我们添加一个元素，然后再做一个赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ints = <span class="built_in">append</span>(ints, <span class="number">1</span>)</span><br><span class="line">ints[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>append的元素会被自动添加到第3个位置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c692251dfb14186b62a79d11a509d45~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>已经存储的元素是可以安全读写的，但是超出这个范围就属于越界访问。会发生<code>panic</code>。</p>
<p>再来举一个例子：</p>
<p>我们创建一个字符串类型的<code>slice</code>，但是不用make，而是用<code>new</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ps := <span class="built_in">new</span>([]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>
<p>new一个slice变量，同样会分配这三部分结构。<br>但他不负责底层数组的分配，所以 <code>data = nil | len = 0 | cap = 0</code> 。new的返回值就是slice结构的起始地址。所以ps就是一个地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*ps)[<span class="number">0</span>] = <span class="string">&quot;egg&quot;</span>  <span class="comment">//不允许</span></span><br></pre></td></tr></table></figure>

<p>此时这个slice变量还没有底层数组。像上述的操作是不允许的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97896bf93aa1403cb6115f4e6117b407~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>但是我们可以使用append的方式为slice添加元素。它就会为slice开辟底层数组。</p>
<h2 id="slice的底层数组"><a href="#slice的底层数组" class="headerlink" title="slice的底层数组"></a>slice的底层数组</h2><p>int型slice的底层就是int型数组，string型slice的底层就是string型数组。</p>
<p>但是slice中的数组指针，并不是必须指向底层数组的开头。</p>
<p>我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; <span class="comment">//数组容量声明了就不可改变</span></span><br></pre></td></tr></table></figure>

<p>我们可以把不同的slice关联到同一个数组。<br>像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span> = arr[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">//左闭右开</span></span><br><span class="line"><span class="keyword">var</span> s2 []<span class="type">int</span> = arr[<span class="number">7</span>:]</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e30a6bcf8f47f8847ab72b992532a7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>slice访问和修改的其实都是底层数组的元素。<br>如果要给<code>s1</code>添加两个元素，直接使用append即可，这个底层数组依然可以使用。<br>但是如果要给<code>s2</code>添加元素，这个底层数组就不能再使用了，因为数组的大小是固定的。<br>因此，得开辟一个新的数组。原来的元素得拷贝过来，还得添加新的元素。元素个数改为4，容量扩到了6。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c238cf41687e4ac089dee0ab66bf1cfa~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="slice的扩容规则"><a href="#slice的扩容规则" class="headerlink" title="slice的扩容规则"></a>slice的扩容规则</h2><p>还记得上面的例子吗？我们只给s2切片添加了1个元素，为什么<code>cap</code>从3扩容到了6呢？那就要看slice的扩容规则了。</p>
<p><strong>STEP1 预估扩容后的容量 newCap</strong></p>
<p>预估规则：</p>
<ul>
<li>如果扩容前容量翻倍，还是小于所需的最小容量，那么预估容量就等于所需的最小容量。</li>
<li>否则就要再细分：<ul>
<li>如果扩容前元素个数小于1024，那就直接翻倍。</li>
<li>如果扩容前元素大于等于1024，那就先扩容至原来的 1&#x2F;4 。</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd06cc9bc6ac4751a6790a3d91437239~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><strong>STEP2 newCap需要多大内存</strong></p>
<p>这一步需要计算需要的内存，这就和元素类型挂钩了。用 <code>预估容量 * 元素类型大小</code> 得到的就是所需内存。</p>
<p>但是不可以直接分配这么多内存。<br>简单来说，再许多编程语言中，申请内存并不是直接与操作系统交涉的，而是与语言自身实现的内存管理模块进行交涉。它会提前向操作系统申请一块内存，分成常用的规格管理起来，我们申请内存时，它会帮我们匹配到足够大且最接近的规格。（按照第一步的扩容规则来）</p>
<p>这就是第三步要做的事情。</p>
<p><strong>STEP3 匹配到合适的内存规格</strong></p>
<p>比如扩容之后的cap &#x3D; 5，在64位操作系统中，就需要 <code>5 * 8 = 40</code> 个字节的内存，来存放底层数组。</p>
<p>按照扩容规则，实际申请时会匹配到48字节。一共能装6个元素。</p>
<p>我们来看一个例子：</p>
<p>创建一个string类型的slice：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="type">string</span>&#123;<span class="string">&quot;my&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;is&quot;</span>&#125;</span><br><span class="line">a := <span class="built_in">append</span>(a, <span class="string">&quot;egg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>step1: newCap &#x3D; 6</p>
<p>step2: 6 * 16 &#x3D; 96 byte  (64位中string类型的大小是16byte)</p>
<p>step3: 匹配到内存规格就是96字节。</p>
<p>所以最终扩容以后，cap就是6。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 内存对齐</title>
    <url>/2022/09/07/Go/Golang%20%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>为保证程序顺利高效的运行，编译器会把各种类型的数据安排到合适的地址，并占用合适的长度，这就是内存对齐。</p>
<p>每种类型的对齐值就是它的对齐边界，内存对齐要求数据存储地址以及占用的字节数都要是它的对齐边界的倍数。所以下述的int32要错开两个字节，从4开始存，却不能紧接着从2开始。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1a924c9da4fa2ab962d6a4e694bb7~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>也可以这样解释：</p>
<p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小成为memory access granularity（粒度）。</p>
<p><strong>如果不进行内存对齐</strong></p>
<p>比如我们想从地址1开始读8字节的数据：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fe4356adac74364a97a0b2fedb0d78f~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>CPU会分两次读：</p>
<ul>
<li>第一次从 <code>0 - 7</code> 但只取后 <code>7</code> 字节。</li>
<li>第二次从 <code>8 - 15</code> 但只取第 <code>1</code> 字节。</li>
</ul>
<p>分两次读，这样势必会对性能造成影响。</p>
<h2 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h2><p>原因主要有两点：</p>
<ul>
<li><p>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
</li>
<li><p>性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
</li>
</ul>
<h2 id="对齐边界"><a href="#对齐边界" class="headerlink" title="对齐边界"></a>对齐边界</h2><p>那该怎么确定每种数据的对齐边界呢？这和平台有关，go语言支持这些平台：</p>
<p>可以看到常见的32位平台，指针宽度和寄存器宽度都是4字节，64位平台上都是8字节。而被go语言称为寄存器宽度的这个值，就可以理解为机器字长，也是平台对应的最大对齐边界。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7caa71ce7394481fa0859b0d00a90b73~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>而数据类型的对齐边界，是取类型大小与平台最大对齐边界中较小的那个。不过要注意，同一个类型在不同平台上，大小可能不同，对齐边界也可能不同。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/107eaa190d58414aa8a8ed46708b7ee8~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>为什么不统一使用平台最大对齐边界呢？或者统一按各类型大小来对齐呢？</p>
<p>我们来试一下，假设目前是64位平台，最大对齐边界为8字节。int8只有1字节，按照1字节对齐的话，它可以放在任何位置，因为总能通过一次读取把它完整拿出来。如果统一对齐到8字节，虽然同样只要读取一次，但每个int8的变量都要浪费7字节，所以对齐到1。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c11caf6e224409906fe1ab65341061~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>int16占2字节，按照2字节对齐，可以从这些地址开始存，而且能保证只用读取一次。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823563ae13c748c6aebdeea433c6e3c1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果按1字节对齐就可能存成这样，那就要读取两次再截取拼接，会影响性能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d66d5c8b42344e8aa0ebadb3d15f5f41~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果按8字节对齐，会与int8一样浪费内存，所以对齐到2。</p>
<p>这是小于最大对齐边界的情况，再来看看大于的情况。</p>
<p>假设要在32位的平台下存储一个int64类型的数据，在0和1位置被占用的情况下，就要从位置8开始存。而如果对齐到4，就可以从位置4开始，内存浪费更少，所以选择对齐到4。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97bd152f5eb486ea29d388e02285f8f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>因此类型对齐边界会这样选择，依然是为了减少浪费提升性能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a95f00887fa2432e9c57dd48c2eabf74~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="GO-计算对齐边界函数"><a href="#GO-计算对齐边界函数" class="headerlink" title="GO 计算对齐边界函数"></a>GO 计算对齐边界函数</h3><p>在go语言中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐边界：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;bool align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">bool</span>(<span class="literal">true</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;int32 align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">int32</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;int8 align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">int8</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;int64 align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">int64</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;byte align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">byte</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;string align: %d\n&quot;</span>, unsafe.Alignof(<span class="string">&quot;EDDYCJY&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;map align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> align: <span class="number">1</span></span><br><span class="line"><span class="type">int32</span> align: <span class="number">4</span></span><br><span class="line"><span class="type">int8</span> align: <span class="number">1</span></span><br><span class="line"><span class="type">int64</span> align: <span class="number">8</span></span><br><span class="line"><span class="type">byte</span> align: <span class="number">1</span></span><br><span class="line"><span class="type">string</span> align: <span class="number">8</span></span><br><span class="line"><span class="keyword">map</span> align: <span class="number">8</span></span><br></pre></td></tr></table></figure>


<br>



<h2 id="确定结构体的对齐边界"><a href="#确定结构体的对齐边界" class="headerlink" title="确定结构体的对齐边界"></a>确定结构体的对齐边界</h2><br>



<p>对结构体而言，首先要确定每个成员的对齐边界，然后取其中最大的，这就是这个结构体的对齐边界。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3989cfb7a55f453cb811c8537a9f7877~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后来存储这个结构体变量：</p>
<p><strong>内存对齐要求一：</strong></p>
<ul>
<li><p><strong>存储这个结构体的起始地址，是对齐边界的倍数。</strong></p>
<pre><code>  假设从0开始存，结构体的每个成员在存储时，都要把这个起始地址当作地址0，然后		再用相对地址来决定自己该放在哪里。
</code></pre>
</li>
</ul>
<p><strong>内存对齐要求2：</strong></p>
<ul>
<li><p><strong>结构体整体占用字节数需要是类型对齐边界的倍数，不够的话要往后扩张一下。</strong></p>
<pre><code>  所以最终上述结构体类型的大小就是24字节。
</code></pre>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">bool</span></span><br><span class="line">	b <span class="type">int32</span></span><br><span class="line">	c <span class="type">int8</span></span><br><span class="line">	d <span class="type">int64</span></span><br><span class="line">	e <span class="type">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Part2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">bool</span></span><br><span class="line">	c <span class="type">int8</span></span><br><span class="line">	e <span class="type">byte</span></span><br><span class="line">	b <span class="type">int32</span> <span class="comment">// 4个字节</span></span><br><span class="line">	d <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别求以上两个结构体占用的字节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;part1 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part1), unsafe.Alignof(part1))</span><br><span class="line">fmt.Printf(<span class="string">&quot;part2 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part2), unsafe.Alignof(part2))</span><br></pre></td></tr></table></figure>

<p>这里我们直接调用函数求得：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">part1 size: <span class="number">32</span>, align: <span class="number">8</span></span><br><span class="line">part2 size: <span class="number">16</span>, align: <span class="number">8</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 优雅的使用Context</title>
    <url>/2022/09/08/Go/Golang%20%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Context/</url>
    <content><![CDATA[<h2 id="优雅的关闭goroutine"><a href="#优雅的关闭goroutine" class="headerlink" title="优雅的关闭goroutine"></a>优雅的关闭goroutine</h2><p>在很多场景下，在执行一个任务时，我们会将这个任务拆分成几个子任务，然后开启几个不同的goroutine去执行。当因为某些原因这个任务需要终止时，我们需要将这些goroutine也全都终止掉。</p>
<p>比如Go http包的Server中，每一个请求都有对应的goroutine去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p>
<p>下面我们举一个简单的例子，然后分别使用不同的方法去关闭例子中的goroutine。</p>
<h3 id="sync-WaitGroup-实现"><a href="#sync-WaitGroup-实现" class="headerlink" title="sync.WaitGroup 实现"></a>sync.WaitGroup 实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(task <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(task, <span class="string">&quot;start...&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 每个groutine运行完毕后就释放WaitGroup的计时器</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		taskName := <span class="string">&quot;task&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		<span class="keyword">go</span> run(taskName)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;所有任务结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task2 start...</span></span><br><span class="line"><span class="comment">// task1 start...</span></span><br><span class="line"><span class="comment">// 所有任务结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面例子中，一个任务结束了必须等待另外一个任务也结束了才算全部结束了，先完成的必须等待其他未完成的，所有的goroutine都要全部完成才OK。</p>
<p>这种方式的优点：使用等待组的并发控制模型，尤其适用于好多个goroutine协同做一件事情的时候，因为每个goroutine做的都是这件事情的一部分，只有全部的goroutine都完成，这件事情才算完成。</p>
<p>这种方式的缺陷：在实际生产中，需要我们主动的通知某一个 goroutine 结束。</p>
<h3 id="channel-select-实现"><a href="#channel-select-实现" class="headerlink" title="channel + select 实现"></a>channel + select 实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- stop:</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 结束了&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 运行中&quot;</span>)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行5秒后停止</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	stop &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 停止检测goroutine是否已经结束</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 结束了</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用channel + select的优点：比较优雅。<br>使用channel + select的缺点：如果有多个goroutine需要关闭怎么办？可以使用全局bool类型变量的方法，但是在为全局变量赋值的时候需要用到锁来保证协程安全，这样势必会对便利性和性能造成影响。更有甚者，如果每个goroutine中又嵌套了goroutine呢？</p>
<h3 id="context-实现"><a href="#context-实现" class="headerlink" title="context 实现"></a>context 实现</h3><p>将以上的代码使用context重写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 开启goroutine，传入ctx</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 结束了&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 运行中&quot;</span>)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行五秒以后停止</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">// 停止检测goroutine是否已经结束</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 结束了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>使用context重写比较简单，当然上述只是启动一个goroutine的情况，如果有多个goroutine呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用context控制多个goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;退出, 停止了&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;运行中&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;任务1&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;任务2&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;任务3&quot;</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 通知任务停止</span></span><br><span class="line">	cancel()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;确定任务全部停止&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务3 运行中</span></span><br><span class="line"><span class="comment">//任务1 运行中</span></span><br><span class="line"><span class="comment">//任务2 运行中</span></span><br><span class="line"><span class="comment">//任务2 运行中</span></span><br><span class="line"><span class="comment">//任务3 运行中</span></span><br><span class="line"><span class="comment">//任务1 运行中</span></span><br><span class="line"><span class="comment">//任务1 运行中</span></span><br><span class="line"><span class="comment">//任务2 运行中</span></span><br><span class="line"><span class="comment">//任务3 运行中</span></span><br><span class="line"><span class="comment">//任务2 退出, 停止了</span></span><br><span class="line"><span class="comment">//任务1 退出, 停止了</span></span><br><span class="line"><span class="comment">//任务3 退出, 停止了</span></span><br><span class="line"><span class="comment">//确定任务全部停止</span></span><br></pre></td></tr></table></figure>



<p>上述Context就像一个控制器一样，按下开关后，所有基于这个 Context 或者衍生的子 Context 都会收到通知，这时就可以进行清理操作了，最终释放 goroutine，这就优雅的解决了 goroutine 启动后不可控的问题。</p>
<h2 id="优雅的关闭多个goroutine嵌套"><a href="#优雅的关闭多个goroutine嵌套" class="headerlink" title="优雅的关闭多个goroutine嵌套"></a>优雅的关闭多个goroutine嵌套</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包含context的新类型</span></span><br><span class="line"><span class="keyword">type</span> otherContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; get msg to cancel&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; is running&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithValue</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; get msg to cancel&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			value := ctx.Value(<span class="string">&quot;key&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; is running value = &quot;</span>, value)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用context.Background()构建一个WithCancel类型的上下文</span></span><br><span class="line">	ctxa, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// work模拟运行并检测前端的退出通知</span></span><br><span class="line">	<span class="keyword">go</span> work(ctxa, <span class="string">&quot;work1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用WithDeadline包装前面的上下文对象ctxa</span></span><br><span class="line">	tm := time.Now().Add(<span class="number">3</span> * time.Second)</span><br><span class="line">	ctxb, _ := context.WithDeadline(ctxa, tm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> work(ctxb, <span class="string">&quot;work2&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用WithValue包装前面的上下文对象ctxb</span></span><br><span class="line">	oc := otherContext&#123;ctxb&#125;</span><br><span class="line">	ctxc := context.WithValue(oc, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;andes, pass from main&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> workWithValue(ctxc, <span class="string">&quot;work3&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 故意 &quot;sleep&quot; 10秒, 让work2、work3超时退出</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示调用work1的cancel方法通知其退出</span></span><br><span class="line">	cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待work1打印退出信息</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> *time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//work3  is running value =  andes, pass from main</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work2  is running</span></span><br><span class="line"><span class="comment">//work2  is running</span></span><br><span class="line"><span class="comment">//work3  is running value =  andes, pass from main</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work3  is running value =  andes, pass from main</span></span><br><span class="line"><span class="comment">//work2  is running</span></span><br><span class="line"><span class="comment">//work3  get msg to cancel</span></span><br><span class="line"><span class="comment">//work2  get msg to cancel</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  get msg to cancel</span></span><br><span class="line"><span class="comment">//main stop</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在使用Context的过程中，程序在底层实际上维护了两条关系链。</p>
<ol>
<li><p>children key构成从根到叶子Context实例的引用关系，在调用With函数时，会调用propagateCancel(parent Context, child canceler) 函数进行维护，程序有一层这样的树状结构：</p>
 <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ctxa</span>.children --&gt;</span> ctxb</span><br><span class="line"><span class="function"><span class="title">ctxb</span>.children --&gt;</span> ctxc</span><br></pre></td></tr></table></figure>
<p> 这棵树提供一种从根节点开始遍历树的方法，context包的取消广播通知就是基于这棵树实现的，取消通知沿着这条链从根节点向下层节点逐层广播。当然也可以在任意一个子树上调用取消通知，一样会扩散到整棵树。</p>
</li>
<li><p>在构造 context 的对象中不断地包裹 context 实例形成一个引用关系链，这个关系链的方向是相反的，是自底向上的。</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ctxc<span class="selector-class">.Context</span> --&gt; oc</span><br><span class="line">ctxc<span class="selector-class">.Context</span><span class="selector-class">.Context</span> --&gt; ctxb</span><br><span class="line">ctxc<span class="selector-class">.Context</span><span class="selector-class">.Context</span><span class="selector-class">.cancelCtx</span> --&gt; ctxa</span><br><span class="line">ctxc<span class="selector-class">.Context</span><span class="selector-class">.Context</span><span class="selector-class">.Context</span><span class="selector-class">.cancelCtx</span><span class="selector-class">.Context</span> -&gt; <span class="built_in">new</span>(emptyCtx) <span class="comment">// context.Background()</span></span><br></pre></td></tr></table></figure>
<p> 这个关系链主要用于切断当前Context实例和上层的Context实例之间的关系。，比如 ctxb调用了退出通知或定时器到期了， ctxb 后续就没有必要在通知广播树上继续存在，它需要找到自己的 parent ，然后执行 delete(parent.children,ctxb）， 把自己从广播树上清理掉。</p>
</li>
</ol>
<h2 id="net-x2F-http包中的context"><a href="#net-x2F-http包中的context" class="headerlink" title="net&#x2F;http包中的context"></a>net&#x2F;http包中的context</h2><p>net&#x2F;http包源码在实现http server时就用到了context, 下面简单分析一下:</p>
<p>1.首先Server在开启服务时会创建一个valueCtx,存储了server的相关信息，之后每建立一条连接就会开启一个协程，并携带此valueCtx。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration     <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.建立连接之后会基于传入的context创建一个valueCtx用于存储本地地址信息，之后在此基础上又创建了一个cancelCtx，然后开始从当前连接中读取网络请求，每当读取到一个请求则会将该cancelCtx传入，用以传递取消信号。一旦连接断开，即可发送取消信号，取消所有进行中的网络请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> serve(ctx context.Context) &#123;</span><br><span class="line">    c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    c.cancelCtx = cancelCtx</span><br><span class="line">    <span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>3.读取到请求之后，会再次基于传入的context创建新的cancelCtx,并设置到当前请求对象req上，同时生成的response对象中cancelCtx保存了当前context取消方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> readRequest(ctx context.Context) (w *response, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    req, err := readRequest(c.bufr, keepHostHeader)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    req.ctx = ctx</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    w = &amp;response&#123;</span><br><span class="line">        conn:          c,</span><br><span class="line">        cancelCtx:     cancelCtx,</span><br><span class="line">        req:           req,</span><br><span class="line">        reqBody:       req.Body,</span><br><span class="line">        handlerHeader: <span class="built_in">make</span>(Header),</span><br><span class="line">        contentLength: <span class="number">-1</span>,</span><br><span class="line">        closeNotifyCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We populate these ahead of time so we&#x27;re not</span></span><br><span class="line">        <span class="comment">// reading from req.Header after their Handler starts</span></span><br><span class="line">        <span class="comment">// and maybe mutates it (Issue 14940)</span></span><br><span class="line">        wants10KeepAlive: req.wantsHttp10KeepAlive(),</span><br><span class="line">        wantsClose:       req.wantsClose(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> w, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这样处理的目的主要有以下几点：</p>
<ul>
<li>一旦请求超时，即可中断当前请求；</li>
<li>在处理构建response过程中如果发生错误，可直接调用response对象的cancelCtx方法结束当前请求；</li>
<li>在处理构建response完成之后，调用response对象的cancelCtx方法结束当前请求。</li>
</ul>
<p>在整个server处理流程中，使用了一条context链贯穿Server、Connection、Request，不仅将上游的信息共享给下游任务，同时实现了上游可发送取消信号取消所有下游任务，而下游任务自行取消不会影响上游任务。</p>
<h2 id="关于Context传递数据"><a href="#关于Context传递数据" class="headerlink" title="关于Context传递数据"></a>关于Context传递数据</h2><p>首先要清楚使用 context 包主要是解决 goroutine 的通知退出，传递数据是其一个额外功能。<br>可以使用它传递一些元信息 ，总之使用 context 传递的信息不能影响正常的业务流程，程序不要期待在 context 中传递某些必需的参数等，没有这些参数，程序也应该能正常工作。</p>
<p><strong>context应该传递什么数据</strong></p>
<p>1.日志信息。<br>2.调试信息。<br>3.不影响业务主逻辑的可选数据。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1.context主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。另外在使用context时有两点值得注意：上游任务仅仅使用context通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说context的取消操作是无侵入的；context是线程安全的，因为context本身是不可变的（immutable），因此可以放心地在多个协程中传递使用。</p>
<p>2.context 包提供的核心的功能是多 goroutine 之间的退出通知机制，传递数据只是个辅助功能，应谨慎使用 context 传递数据。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang map实现原理浅析</title>
    <url>/2022/09/06/Go/Golang%20map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="map的内存模型"><a href="#map的内存模型" class="headerlink" title="map的内存模型"></a>map的内存模型</h2><p>我的go源码版本是：<a href="https://golang.org/dl/go1.17.2.src.tar.gz">go1.17.2</a></p>
<p>map的源码在<code>Go_SDK\go1.17.2\src\runtime\map.go</code>中。</p>
<p>首先我们来看一下map最重要的两个结构：</p>
<p><strong>hmap:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// A header <span class="keyword">for</span> a Go map.</span><br><span class="line"><span class="built_in">type</span> hmap struct &#123;</span><br><span class="line">	// Note: the format of the hmap is also encoded <span class="keyword">in</span> cmd/compile/internal/reflectdata/reflect.go.</span><br><span class="line">	// Make sure this stays <span class="keyword">in</span> <span class="built_in">sync</span> with the compiler<span class="string">&#x27;s definition.</span></span><br><span class="line"><span class="string">	count     int // # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line"><span class="string">	flags     uint8</span></span><br><span class="line"><span class="string">	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line"><span class="string">	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line"><span class="string">	hash0     uint32 // hash seed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line"><span class="string">	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line"><span class="string">	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	extra *mapextra // optional fields</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>


<p><strong>bmap:（bucket桶）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// A bucket <span class="keyword">for</span> a Go map.</span><br><span class="line"><span class="built_in">type</span> bmap struct &#123;</span><br><span class="line">	// tophash generally contains the top byte of the <span class="built_in">hash</span> value</span><br><span class="line">	// <span class="keyword">for</span> each key <span class="keyword">in</span> this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="line">	// tophash[0] is a bucket evacuation state instead.</span><br><span class="line">	tophash [bucketCnt]uint8</span><br><span class="line">	// Followed by bucketCnt keys and <span class="keyword">then</span> bucketCnt elems.</span><br><span class="line">	// NOTE: packing all the keys together and <span class="keyword">then</span> all the elems together makes the</span><br><span class="line">	// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="line">	// us to eliminate padding <span class="built_in">which</span> would be needed <span class="keyword">for</span>, e.g., map[int64]int8.</span><br><span class="line">	// Followed by an overflow pointer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在golang runtime时，编译器会动态为bmap创建一个新结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> bmap struct &#123;</span><br><span class="line">    topbits  [8]uint8</span><br><span class="line">    keys     [8]keytype</span><br><span class="line">    values   [8]valuetype</span><br><span class="line">    pad      uintptr</span><br><span class="line">    overflow uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Golang中map的底层实现是一个哈希表，因此实现map的过程实际上就是实现哈希表的过程。在这个哈希表中，主要出现的结构体有两个，一个叫<code>hmap(a header for a go map)</code>，一个叫<code>bmap(a bucket for a Go map</code>，通常叫其<code>bucket</code>)。这两种结构的样子分别如下所示：</p>
<p><strong>hmap:</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3dae7f42e29445f38102322471ce8f18~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>图中有很多字段，但是便于理解<code>map</code>的架构，你只需要关心的只有一个，就是标红的字段：<code>buckets</code>数组。Golang的map中用于存储的结构是bucket数组。</p>
<p><strong>bucket:</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b41426247e24d92863235a9b189dc34~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>标红的字段依然是“核心”，map中的key和value就存储在这里。“高位哈希值”数组记录的是当前bucket中key相关的“索引”，稍后会详细叙述。还有一个字段是一个指向扩容后的bucket的指针，使得bucket会形成一个链表结构。例如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaa758ba438149bf93f6353214613012~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>由此看出<code>hmap</code>和<code>bucket</code>的关系是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c09461ea0c467aa972b8702761d69a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>而bucket又是一个链表，所以整体的结构应该是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8af26bf1d7d45209276a6b9fac1c9d4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>哈希表的特点是会有一个哈希函数，对传进来的key进行哈希运算，得到唯一的值，一般情况下都是一个数值。Golang的<code>map</code>中也有这么一个哈希函数，也会算出唯一的值，对于这个值的使用：</p>
<p>Golang把求得的值按照用途一分为二：高位和低位。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e8ac896e43647d1a2e931c3a26d07e1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如图所示，蓝色为高位，红色为低位。 然后低位用于寻找当前key属于<code>hmap</code>中的哪个bucket，而高位用于寻找bucket中的哪个key。上文中提到：bucket中有个属性字段是“高位哈希值”数组，这里存的就是蓝色的高位值，用来声明当前bucket中有哪些“key”，便于搜索查找。 需要特别指出的一点是：我们<code>map</code>中的key&#x2F;value值都是存到同一个数组中的。数组中的顺序是这样的:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/959b15e23c0945c9b214b1cfbb582f1f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>并不是key0&#x2F;value0&#x2F;key1&#x2F;value1的形式，这样做的好处是：在key和value的长度不同的时候，<strong>可以消除padding(内存对齐)带来的空间浪费。</strong></p>
<p>现在，我们可以得到Go语言<code>map</code>的整个的结构图了：(hash结果的低位用于选择把KV放在bmap数组中的哪一个bucket中，高位用于key的快速预览，用于快速试错)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a29f6b88fb624e119a37a215a7bcd6f3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a>map的扩容</h2><h3 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h3><p>判断扩充的条件，就是哈希表中的<code>负载因子</code>(即loadFactor)。<br>每个哈希表的都会有一个负载因子，数值超过负载因子就会为哈希表扩容。<br>Golang的<code>map</code>的加载因子的公式是：<strong>map长度 &#x2F; 2^B</strong>(这是代表bmap数组的长度，B是取的低位的位数)<strong>阈值是6.5</strong>。其中B可以理解为已扩容的次数。</p>
<h3 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h3><p>需要扩容时就要分配更多的<code>桶（Bucket）</code>，它们就是新桶。需要把旧桶里储存的键值对都迁移到新桶里。如果哈希表存储的键值对较多，一次性迁移所有桶所花费的时间就比较显著。<br>所以通常会在哈希表扩容时，先分配足够多的新桶，然后用一个字段（<code>oldbuckets</code>）记录旧桶的位置。<br>再增加一个字段（<code>nevacuate</code>），记录旧桶迁移的进度。例如记录下一个要迁移的旧桶编号。<br>在哈希表每次进行读写操作时，如果检测到当前处于扩容阶段，就完成一部分键值对迁移任务，直到所有的旧桶迁移完成，旧桶不再使用，才算真正完成一次哈希表的扩容。<br>像这样把键值对迁移的时间分摊到多次哈希表操作中的方式，就是<strong>渐进式扩容</strong>，可以避免一次性扩容带来的性能瞬时抖动。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f95455cbfbd45adb7b028b8e3215bb9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h3><p>bmap结构体的最后一个字段是一个bmap型指针，指向一个溢出桶。溢出桶的内存布局与常规桶相同，是为了减少扩容次数而引入的。<br>当一个桶存满了，还有可用的溢出桶时，就会在后面链一个溢出桶，继续往这里面存。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1efd19b562443896642191b7d6e7b1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>实际上如果哈希表要分配的桶数目大于<code>2 ^ 4</code>，就认为要使用到溢出桶的几率较大，就会预分配<code>2 ^ (B - 4)</code>个溢出桶备用。<br>这些溢出桶与常规桶在内存中是连续的，只是前<code>2 ^ B</code>个用做常规桶，后面的用作溢出桶。</p>
<p>hmap结构体最后有一个<code>extra</code>字段，指向一个<code>mapextra</code>结构体。里面记录的都是溢出桶相关的信息。<code>nextoverflow</code>指向下一个空闲溢出桶。<br><code>overflow</code>是一个<code>slice</code>，记录目前已经被使用的溢出桶的地址。<code>noverflower</code>记录使用的溢出桶数量。<code>oldoverflower</code>用于在扩容阶段储存旧桶用到的那些溢出桶的地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b59dd8d9e824ef09b215c36f6dd9b5b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h4 id="翻倍扩容"><a href="#翻倍扩容" class="headerlink" title="翻倍扩容"></a>翻倍扩容</h4><p>当负载因子 <code>count / (2 ^ B) &gt; 6.5</code> ,就会发生翻倍扩容（<code>hmap.B++</code>），分配新桶的数量是旧桶的两倍。<br><code>buckets</code>指向新分配的两个桶，<code>oldbuckets</code>指向旧桶。<code>nevacuate</code>为0，表示接下来要迁移编号为0的旧桶。<br>每个旧桶的键值对都会分流到两个新桶中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c83e831d26304a6bb4dd44b0ba4c942c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h4 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h4><p>如果负载因子没有超标，但是使用的溢出桶较多，也会出发扩容，不过这一次是<code>等量扩容</code>。</p>
<p>那么用多少溢出桶算多了呢？</p>
<ul>
<li>如果常规桶的数目不大于 <code>2  ^ 15</code>  ,那么使用溢出桶的数目超过常规桶就算是多了。</li>
<li>如果常规桶的数目大于 <code>2 ^ 15</code> ，那么使用溢出桶的数目一旦超过 <code>2 ^ 15</code> ，就算是多了。</li>
</ul>
<p>所谓等量扩容，就是创建和旧桶数目一样多的新桶。然后把原来的键值对迁移到新桶中，但是既然是等量，那来回迁移的又有什么用呢？<br>什么情况下，桶的负载因子没有超过上限值，却偏偏使用了很多溢出桶呢？自然是有很多键值对被删除的情况。同样数目的键值对，迁移到新桶中，能够排列的更加紧凑，从而减少溢出桶的使用。这就是等量扩容的意义所在。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 协程和IO多路复用</title>
    <url>/2022/09/07/Go/Golang%20%E5%8D%8F%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="IO阻塞问题"><a href="#IO阻塞问题" class="headerlink" title="IO阻塞问题"></a>IO阻塞问题</h2><p>我们知道。通过操作系统记录的进程控制信息，可以找到<code>打开文件描述符表</code>。其中，打开的文件、创建的socket等等，都会记录到这张表里面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ce0518cf1745289992c8fde353f01b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>socket的所有操作都由操作系统来提供，也就是要通过系统调用来完成。每创建一个socket，就会在打开文件描述符表中对应增加一条记录，而返回给应用程序的只有一个socket描述符，用于识别不同的socket。而且每个<code>TCP socket</code>在创建时，操作系统都会为它分配一个<code>读缓冲区</code>和一个<code>写缓冲区</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bc1b59bdab14e099f72b876bb1f6049~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>要获得响应数据，就要从读缓冲区拷贝过来。同样的要通过socket发送数据，也要先把数据拷贝到写缓冲区才行。所以，问题出现了：<br>用户程序想要读数据的时候，读缓冲区里未必有数据，想发送数据的时候，写缓冲区里也未必有空间。那怎么办？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c966e6ba71a34612b48d1b4a454e207d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h2><p>第一种办法是<code>阻塞式IO</code>，即乖乖的让出CPU，进到等待队列里。等socket就绪后，再次获得时间片就可以继续执行了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d619cbad3c41bc94c358872a0c8f15~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>使用阻塞式IO，要处理一个socket就要占用一个线程。等这个socket处理完成才能接手下一个，这在高并发场景下会加剧调度开销。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4beecceab0184192a83943ba35d5502d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h2><p>第二种方法是：<code>非阻塞式IO</code>，也就是不让出CPU。但是需要频繁的检查socket是否就绪了，这是一种<code>忙等待</code>的方式，很难把握轮询的间隔时间，容易造成空耗CPU，加剧响应延时。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4056c9c379d74ef8ad7337f8f2f15f97~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>第三种办法就是<code>IO多路复用</code>，由操作系统提供支持，把需要等待的socket加入到监听集合，这样就可以通过一次系统调用，同时监听多个socket。<br>有socket就绪了，就可以逐个处理了。既不用为等待某个socket而阻塞，也不会陷入<code>忙等待</code>之中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1d550ba4e8416f93080052ab7a2356~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>Linux提供了三种IO多路复用实现方式，分别是<code>select</code>、<code>poll</code> 和 <code>epoll</code>。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>第一种是<code>select</code>。<br>我们可以设置要等待的描述符，也可以设置等待超时时间。如果有准备好的fd，或达到指定超时时间，select函数就会返回。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/533ad9ae072a4666a7d6399b48e59ff6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>从函数签名来看，它支持监听可读、可写、异常三类事件。<br>因为这个fd_set是个unsigned long型的数组。共16个元素，每一位对应一个fd，最多可以监听1024个，这就有点少了。<br>而且<code>每次调用select都要传递所有的监听集合</code>。这就需要频繁的从用户态到内核拷贝数据。除此之外，<code>即便有fd就绪了，也需要遍历整个监听集合，来判断哪个fd是可操作的</code>。这些都会影响性能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf80c969c7af4edfbb3dff9339a5e1ce~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>第二种IO多路复用的实现方式是<code>poll</code>。<br>虽然支持的fd数目，等于最多可以打开的文件描述符个数。但是另外两个问题依然存在。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>而<code>epoll</code>就没有这些问题了，它提供三个接口。</p>
<ul>
<li><code>epoll_create1</code>用于创建<code>一个epoll</code>，并获取一个句柄。</li>
<li><code>epoll_ctl</code>用于添加或删除fd与对应的事件信息。</li>
<li>除了指定fd和要监听的事件类型，还可以传入一个<code>event data</code>，通常会按需定义一个数据结构，用于处理对应的fd。可以看到，每次都只需传入要操作对的一个fd，无需传入所有监听集合，而且只需要注册这一次。通过<code>epoll_wait</code>得到的fd集合都是以及就绪的，逐个处理即可，无需遍历所有监听集合。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7fd52533ca44c5e991ebc2b6b88359e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>通过IO多路复用，线程再也不用为等待某一个socket，而阻塞或空耗CPU。并发处理能力因而大幅提升。</p>
<h2 id="IO多路复用结合协程"><a href="#IO多路复用结合协程" class="headerlink" title="IO多路复用结合协程"></a>IO多路复用结合协程</h2><p>但是IO多路复用也并非没有问题，例如：一个socket可读了，但是这回只读到了半条请求，也就是说需要再次等待这个socket可读。在继续处理下一个socket之前，需要记录下这个socket的处理状态。下一次这个socket可读时，也需要恢复上次保存的现场，才好继续处理。<br>也就是说，在IO多路复用中实现业务逻辑时，我们需要随着事件的等待和就绪，而频繁的保存和恢复现场，这并不符合常规的开发习惯。如果业务逻辑比较简单还好，若是比较复杂的业务场景，就有些悲剧了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f703ad9bcbca47c9acfcc186fa919305~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>既然业务处理过程中，要等待事件时，需要保存现场并切换到下一个就绪的fd。而事件就绪时，又需要恢复现场继续处理。那岂不是很适合使用协程？</p>
<p>在IO多路复用这里，事件循环依然存在，依然要在循环中逐个处理就绪的fd，但处理过程却不是围绕具体业务，而是面向协程调度。<br>如果是用于监听端口的fd就绪了，就建立连接创建一个新的fd，交给一个协程来负责, 协程执行入口就指向业务处理函数入口，业务处理过程中，需要等待时就注册IO事件，然后让出，这样，执行权就会回到切换到该协程的地方继续执行。如果是其它等待IO事件的fd就绪了，只需要恢复关联的协程即可。</p>
<p>协程拥有自己的栈，要保存和恢复现场都很容易实现。这样，IO多路复用这一层的事件循环，就和具体业务逻辑解耦了。</p>
<p>可以把read、write、connect等可能会发生等待的函数包装一下，在其中实现IO事件注册与主动让出。这样在业务逻辑层面，就可以使用这些包装函数，按照常规的顺序编程方式，来实现业务逻辑了。</p>
<p>这些包装函数在需要等待时，就会注册IO事件，然后让出协程，这样我们在实现业务逻辑时，就完全不用担心保存与恢复现场的问题了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8922d77244c240f8867b153f58266c32~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>协程和IO多路复用之间的合作，不仅保留了IO多路复用的高并发性能，还解放了业务逻辑的实现。</p>
<p>协程与IO多路复用结合的项目：</p>
<p><a href="https://github.com/fengyoulin/ef">https://github.com/fengyoulin/ef</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 匿名函数的活用</title>
    <url>/2022/09/07/Go/Golang%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E6%B4%BB%E7%94%A8/</url>
    <content><![CDATA[<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calc 计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="type">int</span>, fTest FuncType)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	result = fTest(a, b)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x, y := <span class="number">2</span>, <span class="number">2</span></span><br><span class="line">	<span class="comment">// Add</span></span><br><span class="line">	<span class="comment">// 回调函数是匿名函数</span></span><br><span class="line">	addResult := Calc(x, y, <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 回调函数是匿名函数</span></span><br><span class="line">	subResult := Calc(x, y, <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;addResult: &quot;</span>, addResult)</span><br><span class="line">	fmt.Println(<span class="string">&quot;subResult: &quot;</span>, subResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">addResult:  <span class="number">4</span></span><br><span class="line">subResult:  <span class="number">0</span></span><br></pre></td></tr></table></figure>




<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>我们使用一个特殊的情况来举例子，顺便巩固一下并发的知识。</p>
<p>请看以下代码，是golang并发中的闭包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>



<p>造成这一输出结果的原因是启动一个goroutine的时间慢于主goroutine中循环的执行时间。<br>这个时候你可能会想到使用循环延时的办法，但是一旦这样做，就失去了并发优势。</p>
<p>所以一般采用以下两个方法：</p>
<ol>
<li><p>将循环变量作为参数传递给匿名函数，原因在于传参的速度几乎是瞬时的，且在启动goroutine前执行。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用同名变量保留当前循环变量的状态</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">     	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		i := i</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其它用法"><a href="#其它用法" class="headerlink" title="其它用法"></a>其它用法</h2><p><strong>定义时调用匿名函数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>将匿名函数复制给变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> sayHi <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>带有return的匿名函数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	greet := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(greet())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>遍历对象数组时做一些回调操作</strong></p>
<p>在学习godis的时候，其中有一个数据引擎接口：<code>EmbedDB</code>。里面有一个遍历当前数据库所有内容的函数：<code>forEach</code>，该函数的形参列表中有一个匿名函数，可以在函数调用的时候，做一些回调操作，我觉得很巧妙。于是就有了下面的例子，该例子没有任何意义，仅仅是展现匿名函数的该种用法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> function <span class="keyword">interface</span> &#123;</span><br><span class="line">	forEach(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 数组结构体实现了接口</span></span><br><span class="line"><span class="keyword">type</span> Array <span class="keyword">struct</span> &#123;</span><br><span class="line">	array []<span class="type">int</span></span><br><span class="line">	length <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Array)</span></span> forEach(callBack <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a.length; i++ &#123;</span><br><span class="line">		callBack(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Array)</span></span> Add(value <span class="type">int</span>) &#123;</span><br><span class="line">	a.array = <span class="built_in">append</span>(a.array, value)</span><br><span class="line">	a.length++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArray</span><span class="params">()</span></span> Array &#123;</span><br><span class="line">	<span class="keyword">return</span> Array&#123;</span><br><span class="line">		<span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := NewArray()</span><br><span class="line">	arr.Add(<span class="number">1</span>)</span><br><span class="line">	arr.Add(<span class="number">2</span>)</span><br><span class="line">	arr.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将每个元素++</span></span><br><span class="line">	arr.forEach(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		arr.array[i]++</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 打印每个元素</span></span><br><span class="line">	arr.forEach(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(arr.array[i])</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 函数调用栈</title>
    <url>/2022/09/07/Go/Golang%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<p>如果在一个函数中调用另一个函数，编译器就会对应生成一条call指令，程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条ret指令，负责在函数结束后跳回到调用处，继续执行。</p>
<h2 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h2><p>函数执行时需要有足够的内存空间，供它存放局部变量、参数等数据，这段空间对应到虚拟地址空间的<strong>栈</strong>。<br><strong>运行时栈，上面是高地址，向下增长</strong>，栈底通常被称为<strong>栈</strong>，栈顶被称为<strong>栈指针</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e94d6ad9124a839a3f426cb8ce4b06~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>分配给函数的栈空间被称为<strong>函数栈帧</strong>。<br>Go语言中函数栈帧布局是这样的，先是调用者栈基地址，然后是函数的局部变量，最后是被调用函数的返回值和参数。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cff3cdf4d02b473ca16061f5c708f18e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><strong>BP of callee</strong>和<strong>SP of callee</strong>标识被调用函数执行时，栈基寄存器和栈指针寄存器指向的位置，但是注意“BP of caller”不一定会存在，有些情况下可能会被优化掉，也有可能是平台不支持。我们只关注局部变量和参数、返回值的相对位置就好。</p>
<p>下面举一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a1, a2, r1, r2 <span class="type">int64</span></span><br><span class="line">    a1, a2 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    r1, r2 = B(a1, a2)</span><br><span class="line">    r1 = C(a1)</span><br><span class="line">    <span class="built_in">println</span>(r1, r2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(p1, p2 <span class="type">int64</span>)</span></span> (<span class="type">int64</span>, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> p2, p1</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span><span class="params">(p1 <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数A的栈帧布局如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16faf75eb4da48f39faccbb0cfb925cf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>注意观察参数的顺序，先入栈第二个参数，再入栈第一个参数，返回值也是一样的，上面是第二个返回值的空间，然后才是第一个返回值的空间。<br>因为这些是被调用函数的返回值和参数，被调用函数是通过栈指针加上偏移值这样相对寻址的方式来定位到自己的参数和返回值的，这样由下至上正好先找到第一个参数，再找到第二个参数。所以参数和返回值采用由右至左的入栈顺序比较合适。<br>通常，我们认为返回值是通过寄存器传递的，但是Go语言支持多返回值，所以在栈上分配返回值空间更合适。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ca3d67c4bd4dd6a3112cb636ff06de~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>对函数B的调用会被编译器编译为call指令。实际上call指令只做两件事情：</p>
<ul>
<li>将下一条指令的地址入栈，被调用函数执行结束后会跳回到这个地址继续执行，这就是函数调用的“返回地址”。</li>
<li>跳转到被调用的函数B指令入口处执行，所以在“返回地址”下面就是函数B的栈帧了。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67a50afccbfb44d79c6814ab2bac27eb~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>所有函数的栈帧布局都遵循统一的约定，函数B结束后它的栈帧被释放，回到函数A中继续执行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5543c1b59d4affa37692d9b723d903~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>到了调用函数C的时候，它只有一个参数和一个返回值，它们会占用函数A栈帧中最下面的一部分空间，所以上面会空出来一块，这是为了在被调用函数中可以用标准的相对地址定位到自己的参数和返回值，而无需顾虑其它。</p>
<p>同样的，call指令会压入返回地址，并跳转到函数C的指令入口处，所以下面就是函数C的栈帧了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c87508517934a96a99de20de7678a15~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>Go语言中，函数栈帧是一次性分配的，也就是在函数开始执行的时候分配足够大的栈帧空间。就像上例中函数A一样，它要调用两个函数，除了调用者栈基地址、局部变量以外，再有四个int64的空间用作被调用函数的参数与返回值就足够了。<br>一次性分配函数栈帧的主要原因是避免栈访问越界，如下图所示，三个goroutine初始分配的栈空间是一样的，如果g2剩余的栈空间不够执行接下来的函数，若函数栈帧是逐步扩张的，那么执行期间就可能发生栈访问越界。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dbb5c85066b4a2184527c4a3acb20f2~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>其实，对于栈消耗较大的函数，go语言的编译器还会在函数头部插入检测代码，如果发现需要进行“栈增长”，就会另外分配一段足够大的栈空间，并把原来栈上的数据拷过来，原来的这段栈空间就被释放了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40b5900b53ce42b28bd6bbfd148fb99b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="函数跳转与返回"><a href="#函数跳转与返回" class="headerlink" title="函数跳转与返回"></a>函数跳转与返回</h2><p>程序执行时 CPU用特定寄存器来存储运行时栈基与栈指针，同时也有指令指针寄存器用于存储下一条要执行的指令地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea9a4eb2076a4604af5e2155a7d2d847~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果接下来要执行”push 3”这条指令，CPU读取后，会将指令指针移向下一条指令，然后栈指针向下移动，数字3入栈。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/325745465f424c0181d538e31f226b36~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>继续执行下一条指令，再次移动栈指针入栈数字4。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a50baad027e40588bf19eca01321378~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>前面我们提过Go语言中函数栈帧不是这样逐步扩张的，而是一次性分配，也就是在分配栈帧时，直接将栈指针移动到所需最大栈空间的位置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad767d182fbf4e428546c5ffd1d54cd1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后通过栈指针加上偏移值这种相对寻址方式使用函数栈帧。例如sp加16字节处存储3，加8字节处存储4，诸如此类。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58549eccc8dd4badbeeee657be772803~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>接下来我们来看看call指令和ret指令，是怎样实现函数跳转与返回的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a,b := <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    B(a,b)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(c,d <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(c,d)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用函数B之前函数A栈帧如下图所示，注意函数A和函数B的指令分布在代码段，而且函数A调用函数B的call指令在地址a1处，函数B入口地址在b1处。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48f7a55d795049fe8c10496bf320291f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后到call指令这里，它的作用有两点：</p>
<ul>
<li>第一，把返回地址a2入栈保存起来；</li>
<li>第二，跳转到指令地址b1处。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f32fbe284f18467c82898f0305c2b6ee~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>call指令结束。函数B开始执行，我们先看它最开始的三条指令：</p>
<ul>
<li>第一条指令，把SP向下移动24字节（从s6挪到s9），为自己分配足够大的栈帧；</li>
<li>第二条指令，要把调用者栈基s1存到SP+16字节的地方(s7那里)；</li>
<li>第三条指令，把s7（SP+16）存入BP寄存器。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a89bff5c734c4db4ab2b1897115831~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>接下来就是执行函数B剩下的指令了，没有局部变量，只有被调用者的参数空间。在最后的ret指令之前，编译器还会插入两条指令：</p>
<ul>
<li>第1条指令：恢复调用者A的栈基地址，它之前被存储在SP+16字节（s7）这里，所以BP恢复到s1；</li>
<li>第2条指令：释放自己的栈帧空间，分配时向下移动多少（从s6到s9）释放时就向上移动多少(从s9到s6)。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be4e351b0bcd495aa13a7b1da003157c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>现在可以从a2这里继续执行了。简单来说，函数通过call指令实现跳转，而每个函数开始时会分配栈帧，结束前又释放自己的栈帧，ret指令又会把栈恢复到call之前的样子，通过这些指令的配合最终实现了函数跳转与返回。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 协程是什么</title>
    <url>/2022/09/07/Go/Golang%20%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>我们都知道，线程是进程中的执行体，拥有一个执行路口，以及从进程虚拟地址空间中分配的栈。包括用户栈和内核栈。<br>操作系统会记录线程控制信息，而线程获得CPU时间片以后才可以执行。CPU的栈指针、指令指针等寄存器，都要切换到对应的线程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1708581ed9fe47a6a711a1b0b37e99db~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>如果线程自己又创建几个<code>执行体</code>，给他们各自指定执行入口，申请一些内存给它们用做执行栈，那么线程就可以按需调度这几个执行体了。为了实现这些执行体的切换，线程也需要记录它们的控制信息。包括<code>ID</code>、<code>栈的位置</code>、<code>执行入口地址</code>、<code>执行现场</code>等等。<br>线程可以选择一个执行体来执行，此时CPU中指令指针就会指向这个执行体的入口，栈基和栈指针寄存器也会指向线程给它分配的执行栈。</p>
<p><strong>切换执行体</strong></p>
<p>要切换执行体时，需要先保存当前执行体的<code>执行现场</code>，然后切换到另一个执行体。通过同样的方式，可以恢复到之前的执行体，这样就可以从上次中断的地方继续执行。<br>这些由线程创建的执行体就是所谓的<code>协程</code>。<br>因为用户程序不能操作内核空间，所以只能给协程分配用户栈，而操作系统对用户栈一无所知。所以<code>协程</code>又被称为<code>用户态线程</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09938523622a4861a14ced396cd066ca~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="协程思想的关键"><a href="#协程思想的关键" class="headerlink" title="协程思想的关键"></a>协程思想的关键</h2><p>在创建协程时，都要指定执行入口，底层都会分配协程执行栈和控制信息，否则又该如何实现用户态调度？<br>而让出执行权时，也都要保存执行现场，不然如何能从中断处恢复执行？<br>所以协程思想的关键在于控制流的<code>主动让出</code>和<code>恢复</code>，每个协程拥有自己的执行栈，可以保存自己的执行现场。所以可以由用户程序，按需创建协程。</p>
<p><strong>协程的主动让出和恢复执行</strong></p>
<p>协程<code>主动让出</code>执行权时，会保存执行现场，然后切换到其它协程。<br>协程<code>恢复执行</code>时，会根据之前保存的执行现场，恢复到中断前的状态，继续执行。<br>这样，就通过协程实现了既轻量又灵活的、由用户态进行调度的<code>多任务模型</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feec9cfcc9844f1daf1811809aa0be94~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>真正让协程大放异彩的是它在<code>IO多路复用</code>中的应用，二者的结合是一种炙手可热的高并发解决方案。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af8befc5b8a945ddba8cba82b2b24bca~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 扇入扇出以及通知退出机制</title>
    <url>/2022/09/07/Go/Golang%20%E6%89%87%E5%85%A5%E6%89%87%E5%87%BA%E4%BB%A5%E5%8F%8A%E9%80%9A%E7%9F%A5%E9%80%80%E5%87%BA%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="扇入和扇出"><a href="#扇入和扇出" class="headerlink" title="扇入和扇出"></a>扇入和扇出</h2><p>编程中经常遇到“扇入和扇出”两个概念，所谓的扇入是指将多路通道聚合到一条通道中处理，Go语言最简单的扇入就是使用select聚合多条通道服务;所谓的扇出是指将一条通道发散到多条通道中处理。在Go语言里面实现就是使用go关键字启动多个goroutine并发处理。</p>
<p>中国有句经典的哲学名句叫“分久必合，合久必分”，软件的设计和开发也遵循同样的哲学思想，扇入就是合，扇出就是分。当生产者的速度很慢时，需要使用扇入技术聚合多个生产者满足消费者，比如很耗时的加密&#x2F;解密服务;当消费者的速度很慢时，需要使用扇出技术，比如Web服务器并发请求处理。扇入和扇出是Go并发编程中常用的技术。</p>
<h2 id="通知退出机制"><a href="#通知退出机制" class="headerlink" title="通知退出机制"></a>通知退出机制</h2><p>读取已经关闭的通道不会引起阻塞，也不会导致panic，而是立即返回该通道存储类型的零值。关闭select监听的某个通道能使select立即感知这种通知，然后进行相应的处理，这就是所谓的退出通知机制(close channel to broadcast)。</p>
<p>其中context标准库就是利用这种机制处理更复杂的通知机制的。</p>
<h2 id="golang实现生成器"><a href="#golang实现生成器" class="headerlink" title="golang实现生成器"></a>golang实现生成器</h2><p>在应用系统编程中，生成器一般用于生成全局事务号、订单号、序列号和随机数等等。</p>
<p>Go 对这种场景的支持非常简单，其中运用了扇入、扇出以及通知退出的思想。</p>
<h3 id="最简单的带缓冲的生成器"><a href="#最简单的带缓冲的生成器" class="headerlink" title="最简单的带缓冲的生成器"></a>最简单的带缓冲的生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 启动一个goroutine用于生成随机数，函数返回一个通道用于获取随机数</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := GenerateIntA()</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5577006791947779410</span></span><br><span class="line"><span class="comment">//8674665223082153551</span></span><br></pre></td></tr></table></figure>



<h3 id="扇入技术实现增强型生成器"><a href="#扇入技术实现增强型生成器" class="headerlink" title="扇入技术实现增强型生成器"></a>扇入技术实现增强型生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 使用select的扇入技术(Fan in)增加生成的随机源</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntA():</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntB():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := GenerateInt()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="退出通知机制实现自动退出的生成器"><a href="#退出通知机制实现自动退出的生成器" class="headerlink" title="退出通知机制实现自动退出的生成器"></a>退出通知机制实现自动退出的生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Lable:</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 通过select监听一个信号chan来确定是否停止生成</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">					<span class="keyword">case</span> &lt;- done:</span><br><span class="line">						<span class="keyword">break</span> Lable</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ch := GenerateIntA(done)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不再需要生成器，通过close chan发送一个通知给生成器</span></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="一个融合了并发、缓冲、退出通知等多重特性的生成器"><a href="#一个融合了并发、缓冲、退出通知等多重特性的生成器" class="headerlink" title="一个融合了并发、缓冲、退出通知等多重特性的生成器"></a>一个融合了并发、缓冲、退出通知等多重特性的生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateIntA done接收通知退出信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Lable:</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">					<span class="keyword">case</span> &lt;- done:</span><br><span class="line">						<span class="keyword">break</span> Lable</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateIntB done接收通知信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">			<span class="keyword">case</span> &lt;- done:</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateInt 通过select 执行扇入操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	send := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Lable:</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntA(send):</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntB(send):</span><br><span class="line">					<span class="keyword">case</span> &lt;- done:</span><br><span class="line">						send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">						send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">						<span class="keyword">break</span> Lable</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个作为退出信号的chan</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动生成器</span></span><br><span class="line">	ch := GenerateInt(done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取生成器资源</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通知生产者停止生产</span></span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;stop produce&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 协程调度器原理及GMP设计思想</title>
    <url>/2022/09/07/Go/Golang%20%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h2 id="一、golang”调度器”的由来"><a href="#一、golang”调度器”的由来" class="headerlink" title="一、golang”调度器”的由来"></a>一、golang”调度器”的由来</h2><h3 id="（1）单进程时代不需要调度器"><a href="#（1）单进程时代不需要调度器" class="headerlink" title="（1）单进程时代不需要调度器"></a>（1）单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代”。</p>
<p>一切的程序只能串行发生。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08e3c609ab684b5f8bfaa68aaf3e98db~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>早期的单进程操作系统，面临2个问题：</p>
<ol>
<li><p>单一的执行流程，计算机只能一个任务一个任务处理。</p>
</li>
<li><p>进程阻塞所带来的CPU时间浪费。</p>
</li>
</ol>
<p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p>
<p>后来操作系统就具有了<strong>最早的并发能力：多进程并发</strong>，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<h3 id="2-多进程-x2F-线程时代有了调度器需求"><a href="#2-多进程-x2F-线程时代有了调度器需求" class="headerlink" title="(2)多进程&#x2F;线程时代有了调度器需求"></a>(2)多进程&#x2F;线程时代有了调度器需求</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0e02d5390c24ddd88e9453b970c8429~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p>
<p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p>
<p><strong>怎么才能提高CPU的利用率呢？</strong> </p>
<p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/191d1e831a2847d6afa2401034644624~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3)协程来提高CPU利用率"></a>(3)协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用<code>4GB[32位操作系统]</code>, 而线程也要大约<code>4MB</code>)。</p>
<p>大量的进程&#x2F;线程出现了新的问题:</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗CPU</li>
</ul>
<p>好了，然后工程师们就发现，其实一个线程分为<code>内核态</code>线程和<code>用户态</code>线程。</p>
<p>一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc955e928704416db3de1b8e193fb34c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52f7fa611b0e4d1982027c0d8588382b~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p>
<p>之后，我们就看到了有3种协程和线程的映射关系：</p>
<p><strong>N:1 关系</strong></p>
<p>N个协程绑定1个线程</p>
<p>优点：</p>
<p>就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上。</p>
<p>缺点：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63da7f70ab484a2b96bdaad382d8895f~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>1:1 关系</strong></p>
<p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点。</p>
<p>缺点：</p>
<ul>
<li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd5b08acef745bbbea9d960327d3346~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>M:N 关系</strong></p>
<p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2ce8e476275421aa829341f9d238790~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>协程跟线程是有区别的，线程由CPU调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出CPU后，才执行下一个协程。</p>
<h3 id="Go语言的协程goroutine"><a href="#Go语言的协程goroutine" class="headerlink" title="Go语言的协程goroutine"></a>Go语言的协程goroutine</h3><p><strong>Go为了提供更容易使用的并发方法，使用了goroutine和channel</strong>。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p>
<p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。</p>
<p>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(runtime调度)</li>
</ul>
<h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5)被废弃的goroutine调度器"></a>(5)被废弃的goroutine调度器</h3><p>好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p>
<p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<blockquote>
<p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c37fd7a106fb4c9d87fd1b4326ab79af~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>下面我们来看看被废弃的golang调度器是如何实现的？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81a250d4067e45319e997f7cd5e72ccc~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>老调度器有几个缺点：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li>
<li>M转移G会造成<strong>延迟和额外的系统负载</strong>。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了<strong>很差的局部性</strong>，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p>
<p>在新调度器中，出现M(thread)和G(goroutine)，又引进了P(Processor)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ff6748e1fd42939988f15c5ea82844~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>Processor，它包含了运行goroutine的资源</strong>，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1)GMP模型"></a>(1)GMP模型</h3><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e19b7368d846649db7b776feb31bfe~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<ol>
<li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li>
<li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。</li>
<li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
</ol>
<p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。</p>
<p><strong>有关P和M的个数问题</strong></p>
<p>1、P的数量：</p>
<ul>
<li>由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS</code>个goroutine在同时运行。</li>
</ul>
<p>2、M的数量:</p>
<ul>
<li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li>runtime&#x2F;debug中的SetMaxThreads函数，设置M的最大数量</li>
<li>一个M阻塞了，会创建新的M。</li>
</ul>
<p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p>
<p><strong>P和M何时会被创建</strong></p>
<p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p>
<p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p>
<h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2)调度器的设计策略"></a>(2)调度器的设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p>
<p>1）work stealing机制</p>
<pre><code>    当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
</code></pre>
<p>2）hand off机制</p>
<pre><code>    当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。
</code></pre>
<p><strong>利用并行</strong>：<code>GOMAXPROCS</code>设置P的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的CPU核进行并行。</p>
<p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p>
<p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p>
<h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func()  调度流程"></a>(3) go func()  调度流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6020e7a9c7414062816345993c6a669c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>从上图我们可以分析出几个结论：</p>
<pre><code>1、我们通过 go func()来创建一个goroutine；

2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；

3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；

4、一个M调度G执行的过程是一个循环机制；

5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；

6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。
</code></pre>
<h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4)调度器的生命周期"></a>(4)调度器的生命周期</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea163f1ab2404d609b60151f3b267d92~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>特殊的M0和G0。</p>
<p><strong>M0</strong></p>
<p><code>M0</code>是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p>
<p><strong>G0</strong></p>
<p><code>G0</code>是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p>
<p>我们来跟踪一段代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p>
<p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是<code>main.main</code>，<code>runtime</code>中也有1个main函数——<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p>
<h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5)可视化GMP编程"></a>(5)可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据:<br><code>go tool trace </code> 和 <code>Debug trace</code>,这里只介绍第二种。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build trace2.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>



<p>通过Debug方式运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 ./trace2 </span><br><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>



<ul>
<li><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</li>
<li><code>0ms</code>：即从程序启动到输出这行日志的时间；</li>
<li><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</li>
<li><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</li>
<li>t<code>hreads: os threads/M</code>的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</li>
<li><code>spinningthreads</code>: 处于自旋状态的os thread数量；</li>
<li><code>idlethread</code>: 处于idle状态的os thread的数量；</li>
<li><code>runqueue=0</code>： Scheduler全局队列中G的数量；</li>
<li><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 实现RPC的几种方式</title>
    <url>/2022/09/07/Go/Golang%20%E5%AE%9E%E7%8E%B0RPC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p><code>远程过程调用（Remote Procedure Call，缩写为 RPC）</code>是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</p>
<p>用通俗易懂的语言描述就是：RPC允许跨机器、跨语言调用计算机程序方法。打个比方，我用go语言写了个获取用户信息的方法getUserInfo，并把go程序部署在阿里云服务器上面，现在我有一个部署在腾讯云上面的php项目，需要调用golang的getUserInfo方法获取用户信息，php跨机器调用go方法的过程就是RPC调用。</p>
<h2 id="golang中使用RPC"><a href="#golang中使用RPC" class="headerlink" title="golang中使用RPC"></a>golang中使用RPC</h2><p>golang官方的<code>net/rpc</code>库使用encoding&#x2F;gob进行编解码，支持tcp或http数据传输方式，不支持跨语言调用。<br>官方还提供了<code>net/rpc/jsonrpc</code>库实现RPC，支持跨语言调用，但是不支持http。</p>
<p><strong>RPC格式的函数</strong></p>
<p>Go RPC的函数只有符合下面的条件才能被远程访问，不然会被忽略，详细的要求如下：</p>
<ul>
<li>函数必须是导出的(首字母大写)</li>
<li>必须有两个导出类型的参数</li>
<li>第一个参数是接收的参数，第二个参数是返回给客- 户端的参数，第二个参数必须是指针类型的</li>
<li>函数还要有一个返回值error</li>
</ul>
<p>比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> MethodName(argType T1, replyType *T2) <span class="type">error</span></span><br></pre></td></tr></table></figure>




<h2 id="net-x2F-rpc库"><a href="#net-x2F-rpc库" class="headerlink" title="net&#x2F;rpc库"></a>net&#x2F;rpc库</h2><p>下面的例子演示一下如何使用golang官方的net&#x2F;rpc库实现RPC方法，使用http作为RPC的载体，通过net&#x2F;http包监听客户端连接请求。</p>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arith 算数运算结构体</span></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 乘积</span></span><br><span class="line">	Pro <span class="type">int</span></span><br><span class="line">	<span class="comment">// 商</span></span><br><span class="line">	Quo <span class="type">int</span></span><br><span class="line">	<span class="comment">// 余数</span></span><br><span class="line">	Rem <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiply 乘法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Multiply(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	res.Pro = req.A * req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Divide 除法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Divide(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> req.B == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;divide by zero&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	res.Quo = req.A / req.B</span><br><span class="line">	res.Rem = req.A % req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注册rpc服务</span></span><br><span class="line">	rpc.Register(<span class="built_in">new</span>(Arith))</span><br><span class="line">	<span class="comment">// 采用http协议作为rpc载体</span></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器创建监听端口</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8095&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;fatal error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start connection&quot;</span>)</span><br><span class="line">	<span class="comment">// 处理请求</span></span><br><span class="line">	http.Serve(listen, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 乘积</span></span><br><span class="line">	Pro <span class="type">int</span></span><br><span class="line">	<span class="comment">// 商</span></span><br><span class="line">	Quo <span class="type">int</span></span><br><span class="line">	<span class="comment">// 余数</span></span><br><span class="line">	Rem <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 请求服务器连接</span></span><br><span class="line">	conn, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8095&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;dailing error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req := ArithRequest&#123;<span class="number">9</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> res ArithResponse</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call函数远程调用服务器的函数</span></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Multiply&quot;</span>, req, &amp;res) <span class="comment">// 乘法运算</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, req.A, req.B, res.Pro)</span><br><span class="line"></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Divide&quot;</span>, req, &amp;res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d / %d, quo is %d, rem is %d\n&quot;</span>, req.A, req.B, res.Quo, res.Rem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="net-x2F-rpc-x2F-jsonrpc"><a href="#net-x2F-rpc-x2F-jsonrpc" class="headerlink" title="net&#x2F;rpc&#x2F;jsonrpc"></a>net&#x2F;rpc&#x2F;jsonrpc</h2><p>下面的例子我们演示一下使用<code>net/rpc/jsonrpc</code>库实现RPC方法，此方式实现的RPC方法支持跨语言调用。</p>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arith 算数运算结构体</span></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	Pro <span class="type">int</span> <span class="comment">// 乘积</span></span><br><span class="line">	Quo <span class="type">int</span> <span class="comment">// 商</span></span><br><span class="line">	Rem <span class="type">int</span> <span class="comment">// 余数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiply 乘法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Multiply(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	res.Pro = req.A * req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Divide 除法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Divide(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> req.B == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;divide by zero&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	res.Quo = req.A / req.B</span><br><span class="line">	res.Rem = req.A % req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpc.Register(<span class="built_in">new</span>(Arith)) <span class="comment">// 注册rpc服务</span></span><br><span class="line"></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8096&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;fatal error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start connection&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := lis.Accept() <span class="comment">// 接收客户端连接请求</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123; <span class="comment">// 并发处理客户端请求</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;new client in coming&quot;</span>)</span><br><span class="line">			jsonrpc.ServeConn(conn)</span><br><span class="line">		&#125;(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	Pro <span class="type">int</span> <span class="comment">// 乘积</span></span><br><span class="line">	Quo <span class="type">int</span> <span class="comment">// 商</span></span><br><span class="line">	Rem <span class="type">int</span> <span class="comment">// 余数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := jsonrpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8096&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;dailing error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req := ArithRequest&#123;<span class="number">9</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> res ArithResponse</span><br><span class="line"></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Multiply&quot;</span>, req, &amp;res) <span class="comment">// 乘法运算</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, req.A, req.B, res.Pro)</span><br><span class="line"></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Divide&quot;</span>, req, &amp;res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d / %d, quo is %d, rem is %d\n&quot;</span>, req.A, req.B, res.Quo, res.Rem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 标准库之反射</title>
    <url>/2022/09/07/Go/Golang%20%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h2><p>Go语言中的变量是分为两部分的:</p>
<ul>
<li>类型信息：预先定义好的元信息。</li>
<li>值信息：程序运行过程中可动态变化的。</li>
</ul>
<h2 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h2><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时,程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p>Go程序在运行期使用reflect包访问程序的反射信息。</p>
<p>我们都知道go语言中的<code>interface&#123;&#125;</code>可以储存任何类型的变量，那我们怎么知道这个空接口保存的数据是什么呢？而反射就是在运行时动态的获取一个变量的类型信息和值信息。</p>
<p><strong>反射和接口的关系：</strong></p>
<p>我们通过interface聚合、兼容了各种不同的插件，最终通过用户输入在main程序通过反射技术把不同的需求调度到各个功能插件本身。</p>
<p>可能有些拗口，下面来举一个例子：</p>
<p>下述代码是golang运行时多态的一个实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 实现了A接口</span></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">	greet <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span></span> <span class="built_in">print</span>()  &#123;</span><br><span class="line">	fmt.Println(b.greet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 实现了A接口</span></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">	greet <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c C)</span></span> <span class="built_in">print</span> ()  &#123;</span><br><span class="line">	fmt.Println(c.greet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create 函数返回一个A接口类型的值</span></span><br><span class="line"><span class="comment">// 首先生成一个随机数num，num的值为0或1</span></span><br><span class="line"><span class="comment">// 如果num=0，返回B对象，如果num=1，返回C对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">()</span></span> (res A) &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	num := rand.Intn(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="number">0</span> == num &#123;</span><br><span class="line">		<span class="keyword">return</span> B&#123;greet: <span class="string">&quot;B: hello!&quot;</span>&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">1</span> == num &#123;</span><br><span class="line">		<span class="keyword">return</span> C&#123;greet: <span class="string">&quot;C: hello!&quot;</span>&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	A := Create()</span><br><span class="line">	A.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行时多态是一种很神奇的现象，main函数中的A对象会根据返回的实际类型调用不同的print函数。这是因为接口变量是动态的值和动态的类型，得需要做<code>类型断言/反射确定当前变量A属于哪种具体的类型之后才能调用接口中定义的方法。</code></p>
<h2 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h2><p>reflect 包封装了反射相关的方法。其中，最核心的是这两个方法：</p>
<ul>
<li>获取类型信息：reflect.TypeOf，是静态的。</li>
<li>获取值信息：reflect.ValueOf，是动态的。</li>
</ul>
<h3 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h3><p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	v  := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%v\n\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">	reflectType(a)</span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	reflectType(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>:<span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>:<span class="type">int64</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="type-name、type-kind"><a href="#type-name、type-kind" class="headerlink" title="type name、type kind"></a>type name、type kind</h4><p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line">	<span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">	reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">	reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">	reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age  <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="type">string</span> &#125;</span><br><span class="line">	<span class="keyword">var</span> d = person&#123;</span><br><span class="line">		name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		age:  <span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> e = book&#123;title: <span class="string">&quot;《张三学法》&quot;</span>&#125;</span><br><span class="line">	reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">	reflectType(e) <span class="comment">// type:book kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>: kind:ptr</span><br><span class="line"><span class="keyword">type</span>:myInt kind:<span class="type">int64</span></span><br><span class="line"><span class="keyword">type</span>:<span class="type">int32</span> kind:<span class="type">int32</span></span><br><span class="line"><span class="keyword">type</span>:person kind:<span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span>:book kind:<span class="keyword">struct</span></span><br></pre></td></tr></table></figure>



<p>简单来说就是<code>变量.Name()</code>可以返回我们使用type定义的自定义类型和类型别名的底层类型。而<code>变量.Kind()</code>可以直接返回变量的底层类型。</p>
<p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。</p>
<p>在<code>reflect</code>包中定义的Kind类型如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                  <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16               <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32               <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64               <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr              <span class="comment">// 指针</span></span><br><span class="line">    Float32              <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64              <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64            <span class="comment">// 64位复数类型</span></span><br><span class="line">    Complex128           <span class="comment">// 128位复数类型</span></span><br><span class="line">    Array                <span class="comment">// 数组</span></span><br><span class="line">    Chan                 <span class="comment">// 通道</span></span><br><span class="line">    Func                 <span class="comment">// 函数</span></span><br><span class="line">    Interface            <span class="comment">// 接口</span></span><br><span class="line">    Map                  <span class="comment">// 映射</span></span><br><span class="line">    Ptr                  <span class="comment">// 指针</span></span><br><span class="line">    Slice                <span class="comment">// 切片</span></span><br><span class="line">    String               <span class="comment">// 字符串</span></span><br><span class="line">    Struct               <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer        <span class="comment">// 底层指针</span></span><br></pre></td></tr></table></figure>



<h3 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h3><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</p>
<p>reflect.Value类型提供的获取原始值的方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Interface() interface {}</td>
<td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>
<tr>
<td>Int() int64</td>
<td>将值以 int 类型返回，所有有符号整型均可以以此方式返回</td>
</tr>
<tr>
<td>Uint() uint64</td>
<td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Float() float64</td>
<td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>
<tr>
<td>Bool() bool</td>
<td>将值以字节数组 []bytes 类型返回</td>
</tr>
<tr>
<td>String() string</td>
<td>将值以字符串类型返回</td>
</tr>
</tbody></table>
<h4 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a>通过反射获取值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	k := v.Kind()</span><br><span class="line">	<span class="keyword">switch</span> k &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Int64:</span><br><span class="line">		<span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float64:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">	reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line">	<span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">	c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> is <span class="type">float32</span>, value is <span class="number">3.140000</span></span><br><span class="line"><span class="keyword">type</span> is <span class="type">int64</span>, value is <span class="number">100</span></span><br><span class="line"><span class="keyword">type</span> c :reflect.Value</span><br></pre></td></tr></table></figure>



<h4 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h4><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">		v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line">	<span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">		v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	<span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">	reflectSetValue2(&amp;a)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>



<h4 id="isNil-、isValid"><a href="#isNil-、isValid" class="headerlink" title="isNil() 、isValid"></a>isNil() 、isValid</h4><p><strong>isNil()</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsNil() <span class="type">bool</span></span><br></pre></td></tr></table></figure>




<p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p>
<p><strong>isValid()</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsValid() <span class="type">bool</span></span><br></pre></td></tr></table></figure>



<p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p>
<p>举个例子：</p>
<p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// *int类型空指针</span></span><br><span class="line">	<span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line">	<span class="comment">// nil值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid())</span><br><span class="line">	<span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">	b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="comment">// 尝试从结构体中查找&quot;abc&quot;字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line">	<span class="comment">// 尝试从结构体中查找&quot;abc&quot;方法</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line">	<span class="comment">// map</span></span><br><span class="line">	c := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;z张三&quot;</span>)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span> IsNil: <span class="literal">true</span></span><br><span class="line"><span class="literal">nil</span> IsValid: <span class="literal">false</span></span><br><span class="line">不存在的结构体成员: <span class="literal">false</span></span><br><span class="line">不存在的结构体方法: <span class="literal">false</span></span><br><span class="line"><span class="keyword">map</span>中不存在的键： <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h3><h4 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h4><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象<code>（reflect.Type）</code>的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p>
<p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field(i int) StructField</td>
<td>根据索引，返回索引对应的结构体字段的信息。</td>
</tr>
<tr>
<td>NumField() int</td>
<td>返回结构体成员字段数量。</td>
</tr>
<tr>
<td>FieldByName(name string) (StructField, bool)</td>
<td>根据给定字符串返回字符串对应的结构体字段的信息。</td>
</tr>
<tr>
<td>FieldByIndex(index []int) StructField</td>
<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td>
</tr>
<tr>
<td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td>
<td>根据传入的匹配函数匹配需要的字段。</td>
</tr>
<tr>
<td>NumMethod() int</td>
<td>返回该类型的方法集中方法的数目</td>
</tr>
<tr>
<td>Method(int) Method</td>
<td>返回该类型方法集中的第i个方法</td>
</tr>
<tr>
<td>MethodByName(string)(Method, bool)</td>
<td>根据方法名返回该类型方法集中的方法</td>
</tr>
</tbody></table>
<h4 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a>StructField类型</h4><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。<br><code>StructField</code>的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    PkgPath <span class="type">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="type">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="type">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="type">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="结构体反射示例"><a href="#结构体反射示例" class="headerlink" title="结构体反射示例"></a>结构体反射示例</h4><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu1 := student&#123;</span><br><span class="line">		Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Score: <span class="number">90</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(stu1)</span><br><span class="line">	fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line">	<span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		field := t.Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line">	<span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">student <span class="keyword">struct</span></span><br><span class="line">name:Name index:[<span class="number">0</span>] <span class="keyword">type</span>:<span class="type">string</span> json tag:name</span><br><span class="line">name:Score index:[<span class="number">1</span>] <span class="keyword">type</span>:<span class="type">int</span> json tag:score</span><br><span class="line">name:Score index:[<span class="number">1</span>] <span class="keyword">type</span>:<span class="type">int</span> json tag:score</span><br></pre></td></tr></table></figure>



<p>接下来编写一个函数printMethod(s interface{})来遍历打印s包含的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.NumMethod())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">		methodType := v.Method(i).Type()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line">		<span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line">		<span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">		v.Method(i).Call(args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h2><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p>
<ol>
<li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li>
<li>大量使用反射的代码通常难以理解。</li>
<li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 标准库之strconv</title>
    <url>/2022/09/07/Go/Golang%20%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bstrconv/</url>
    <content><![CDATA[<p>strconv包实现了基本数据类型与其字符串表示的转换。</p>
<h2 id="string与int转换"><a href="#string与int转换" class="headerlink" title="string与int转换"></a>string与int转换</h2><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><p><code>Atoi()</code>函数用于将字符串类型的整数转换为int类型，函数签名如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<p>如果传入的字符串参数无法转换为int类型，就会返回错误。</p>
<h3 id="Itoa"><a href="#Itoa" class="headerlink" title="Itoa()"></a>Itoa()</h3><p><code>Itoa()</code>函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h2 id="Parse系列函数"><a href="#Parse系列函数" class="headerlink" title="Parse系列函数"></a>Parse系列函数</h2><p>Parse类函数用于转换字符串为给定类型的值。</p>
<h3 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h3><p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h3 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h3><p>返回字符串表示的整数值，接受正负号。</p>
<p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p>
<p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；</p>
<p>返回的err是*NumErr类型的，如果语法有误，err.Error &#x3D; ErrSyntax；如果结果超出类型范围err.Error &#x3D; ErrRange。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h3 id="ParseUint"><a href="#ParseUint" class="headerlink" title="ParseUint"></a>ParseUint</h3><p>ParseUint类似ParseInt但不接受正负号，用于无符号整型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (n <span class="type">uint64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h3 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h3><p>解析一个表示浮点数的字符串并返回其值。<br>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>





<h2 id="Format系列函数"><a href="#Format系列函数" class="headerlink" title="Format系列函数"></a>Format系列函数</h2><p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p>
<h3 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h3><p>根据b的值返回”true”或”false”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h3 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h3><p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h3 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h3><p>是FormatInt的无符号整数版本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="type">uint64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h3 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h3><p>函数将浮点数表示为字符串并返回。</p>
<p>bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p>
<p>fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p>
<p>prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="isPrint"><a href="#isPrint" class="headerlink" title="isPrint()"></a>isPrint()</h3><p>返回一个字符是否是可打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>


<h3 id="CanBackquote"><a href="#CanBackquote" class="headerlink" title="CanBackquote()"></a>CanBackquote()</h3><p>返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanBackquote</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>



<p>除此之外还有Append系列、Quote系列等函数。可以移步至-&gt;</p>
<h3 id="Go语言中文文档"><a href="#Go语言中文文档" class="headerlink" title="Go语言中文文档"></a><a href="https://studygolang.com/pkgdoc">Go语言中文文档</a></h3>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 类型系统</title>
    <url>/2022/09/07/Go/Golang%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>如果我们自定义一个结构体类型T，并给它关联一个方法F1。我们知道变量t的内存布局只包含一个字符串变量，那它和F1之间怎样建立关联？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> F1() &#123;</span><br><span class="line">    fmt.Println(t.name)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t = T&#123;name eggo&#125;</span><br><span class="line">    t.F1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>由于编译阶段，编译器知道每种类型定义了哪些方法，之前我们也介绍过，方法本质上就是函数，只不过在调用时，接收者会作为第一个参数传入。所以通过变量t来调用方法F1时，编译器自然知道要调用哪个函数。</p>
<p><img src="/httpsp3-juejin.byteimg.comtos-cn-i-k3u1fbpfcp29c8ffaa561b44b6ade510f74f711e40~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>但是到了执行阶段，为了支持反射、接口动态派发、类型断言这些语言特性或机制，编译器会给每种类型生成对应的类型描述信息写入可执行文件，这些类型描述信息就是“类型元数据”。</p>
<p>在Go语言里，int、float、string、slice、map、interface等属于内置类型（built-in），而我们自己通过下面这三种方式定义的类型，都属于自定义类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    F1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 给内置类型定义方法是不被允许的，而接口类型是无效的方法接收者，所以我们只能给上面第一、第二种形式的自定义类型定义方法。</p>
<p>数据类型虽然很多，但是不管是内置类型还是自定义类型，它的“类型元数据”都是全局唯一的。这些类型元数据共同构成了Go语言的类型系统。</p>
<p><img src="/httpsp3-juejin.byteimg.comtos-cn-i-k3u1fbpfcp7f61054f418e445aaaa09ddbd0bf44a2~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面就把类型元数据展开，看看里面究竟是什么结构，有什么内容。</p>
<h2 id="内置类型元数据"><a href="#内置类型元数据" class="headerlink" title="内置类型元数据"></a>内置类型元数据</h2><p>像类型名称，大小，对齐边界，是否为自定义类型等信息，是每个类型元数据都要记录的。所以被放到了runtime._type结构体中，作为每个类型元数据的Header。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">uintptr</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span></span><br><span class="line">    hash       <span class="type">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="type">uint8</span></span><br><span class="line">    fieldalign <span class="type">uint8</span></span><br><span class="line">    kind       <span class="type">uint8</span></span><br><span class="line">    alg        typeAlg</span><br><span class="line">    gcdata     <span class="type">byte</span></span><br><span class="line">    str        nameOff</span><br><span class="line">    ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在_type之后存储的是各类型额外需要描述的信息，例如slice的类型元数据在_type结构体后面，记录着一个_type，指向其存储的元素的类型元数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    elem  _type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果是存储string的slice类型，这个指针就指向string类型的元数据。</p>
<p><img src="/httpsp3-juejin.byteimg.comtos-cn-i-k3u1fbpfcp54632a744be8439ab64e2e88aa1ce59e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>再看看指针类型的元数据，它在_type后面也额外存储了一个_type，指向指针类型指向的那个类型的元数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ptrtype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    elem  _type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/httpsp3-juejin.byteimg.comtos-cn-i-k3u1fbpfcpfc4ba34510314ad1bc86392a51bc8f94~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>内置类型的元数据都是这样的结构，可以到runtime包下的type.go查看struct、map等类型的元数据信息。</p>
<h2 id="自定义类型元数据"><a href="#自定义类型元数据" class="headerlink" title="自定义类型元数据"></a>自定义类型元数据</h2><p>然而如果是自定义类型，这后面还会有一个uncommontype结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> uncommontype <span class="keyword">struct</span> &#123;</span><br><span class="line">    pkgpath nameOff</span><br><span class="line">    mcount  <span class="type">uint16</span> </span><br><span class="line">    _       <span class="type">uint16</span>  unused</span><br><span class="line">    moff    <span class="type">uint32</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>pkgpath 记录类型所在的包路径；</li>
<li>mcount 记录了该类型关联到多少个方法；</li>
<li>moff 记录的是这些方法的元数据组成的数组，相对于这个uncommontype结构体偏移了多少字节。方法元数据结构如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> method <span class="keyword">struct</span> &#123;</span><br><span class="line">    name nameOff</span><br><span class="line">    mtyp typeOff</span><br><span class="line">    ifn  textOff</span><br><span class="line">    tfn  textOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>例如，我们基于[]string定义一个新类型myslice，它就是一个自定义类型，可以给它定义两个方法Len和Cap。</p>
<p>myslice的类型元数据中，首先是slicetype类型描述信息，然后在后面加上uncommontype结构体。注意通过uncommontype这里记录的信息，我们就可以找到myslice的方法元数据列表了。</p>
<p><img src="/httpsp3-juejin.byteimg.comtos-cn-i-k3u1fbpfcp31099a5f42b346aba5c60977e41d9e60~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>现在我们可以利用类型元数据来描述下面这两种写法的不同了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType1 = <span class="type">int32</span></span><br><span class="line"><span class="keyword">type</span> MyType2 <span class="type">int32</span></span><br></pre></td></tr></table></figure>


<p>MyType1这种写法，叫做给类型int32取别名，实际上MyType1和int32会关联到同一个类型元数据，属于同一种类型。rune和int32就是这样的关系。</p>
<p><img src="/httpsp3-juejin.byteimg.comtos-cn-i-k3u1fbpfcp6986661f01314e348bd44b6136bcc6bf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>而MyType2这种写法，属于基于已有类型创建新类型，MyType2会自立门户，拥有自己的类型元数据，即使MyType2相对于int32来说没有做任何改变，它们两个对应的类型元数据也已经不同了。</p>
<p><img src="/httpsp3-juejin.byteimg.comtos-cn-i-k3u1fbpfcp24b021ea931c4f188b43a825859b0006~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>既然每种类型都有唯一对应的类型元数据，而类型定义的方法能通过类型元数据找到，那么，很多问题就变得好解释了，例如接下来的“接口”。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 类型断言</title>
    <url>/2022/09/07/Go/Golang%20%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<p>我们已经知道接口可以分为空接口与非空接口两类。相对于接口这种“抽象类型”，像int，slice，string，map，struct等类型被称为“具体类型”。<br>类型断言是Go语言中应用在接口值上的一个神奇特性，而类型断言的目标类型可以是某种具体类型，也可以是某种非空接口类型。这样我们就组合出四种类型断言，接下来就逐一看看它们究竟是如何断言的！</p>
<h2 id="空接口-具体类型"><a href="#空接口-具体类型" class="headerlink" title="空接口.(具体类型)"></a>空接口.(具体类型)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">r,ok := e.(*os.File)</span><br></pre></td></tr></table></figure>

<p>e.(<em>os.File)就是要判断e存储的_type是否指向</em>os.File的类型元数据。反正我们介绍过Go语言里每种类型的类型元数据都是全局唯一的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fe6bd42b75b47079a072cecbc5553dd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f,_ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>如果e像上面这样赋值，e的动态类型就是*os.File，所以e.(*os.File)类型断言成功，ok为true，r为e的动态值。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21b8c3da8da24af9b089764d786527a1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee841f5df8304fbca19f0fcb89d2d705~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30d6f861dad943c397bbdd3219a71dcf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd0f8134678b4d0ba509093d7c5cfea1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>请看以下代码的演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;   <span class="comment">//e为空接口类型</span></span><br><span class="line">	r, ok := e.(*os.File)  <span class="comment">//将e与*os.File类型进行类型断言</span></span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	e = f    <span class="comment">//将*os.File类型的f赋值给e</span></span><br><span class="line">	r, ok = e.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	e = f1  <span class="comment">//将string类型的f1赋值给e</span></span><br><span class="line">	r, ok = e.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>go run</code>以后的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&amp;&#123;<span class="number">0xc000088780</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>





<h2 id="非空接口-具体类型"><a href="#非空接口-具体类型" class="headerlink" title="非空接口.(具体类型)"></a>非空接口.(具体类型)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">r,ok := rw.(*os.File)</span><br></pre></td></tr></table></figure>



<p>rw.(<em>os.File)是要判断rw的动态类型是否为</em>os.File。前面我们介绍过，程序中用到的itab结构体都会缓存起来，可以通过&lt;接口类型, 动态类型&gt;组合起来的key，查找到对应的itab指针。<br>所以这里的类型断言只需要一次比较就能完成，就是看iface.tab是否等于&lt;io.ReadWriter, *os.File&gt;这个组合对应的itab指针就好。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/201b855c4e604b15afc779414d0c2213~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果把一个<em>os.File类型的变量f赋给rw，它的动态值就是f，动态类型就是</em>os.File。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f,_ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">rw = f</span><br></pre></td></tr></table></figure>



<p>rw这里存储的itab指针就指向&lt;io.ReadWriter, *os.File&gt;组合对应的itab，所以类型断言成功，ok为true，r被赋值为rw的动态值。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc0d599f80a24c13a86bb6f52e91d39f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d49fd151a9c242c9915b256cf4a754d1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面我们定义一个eggo类型，并且由*eggo类型实现io.ReadWriter接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果把一个<em>eggo类型的变量赋值给rw，rw的动态类型就是</em>eggo，rw持有的itab指针就不指向&lt;io.ReadWriter, <em>os.File&gt;组合对应的itab结构体，类型断言就会失败，ok为false，而r就会被置为</em>os.File的类型零值nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">rw = &amp;f</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebf4856462cf4e209831625afaa4bd9e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>请看以下代码的演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个eggo类型</span></span><br><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line"></span><br><span class="line">	r, ok := rw.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	rw = f</span><br><span class="line">	r, ok = rw.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">	rw = &amp;f1</span><br><span class="line">	r, ok = rw.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>go run</code>以后的运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>




<h2 id="空接口-非空接口"><a href="#空接口-非空接口" class="headerlink" title="空接口.(非空接口)"></a>空接口.(非空接口)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">rw,ok := e.(io.ReadWriter)</span><br></pre></td></tr></table></figure>



<p>e.(io.ReadWriter)就是要判断e的动态类型是否实现了io.ReadWriter接口。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5115b48d32448a6a02d0b156cb089c4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果e像这样赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f,_ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>e的动态类型就是<em>os.File，我们知道</em>os.File类型元数据的后面可以找到该类型实现的方法列表描述信息。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/469758a3a0a34e7d811504ccd9b730bc~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>其实并不需要每次都检查动态类型的方法列表，还记得itab缓存吗？ 实际上，当类型断言的目标类型为非空接口时，会首先去itabTable里查找对应的itab指针，若没有找到，再去检查动态类型的方法列表。<br>此处注意，就算从itabTable中找到了itab指针，也要进一步确认itab.fun[0]是否等于0。这是因为一旦通过方法列表确定某个具体类型没有实现指定接口，就会把itab这里的fun[0]置为0，然后同样会把这个itab结构体缓存起来，和那些断言成功的itab缓存一样。这样做的目的是避免再遇到同种类型断言时重复检查方法列表。</p>
<p>回到例子中，这里会断言成功，ok为true，rw就是一个io.ReadWriter类型的变量，其动态值与e相同。tab指向&lt;io.ReadWriter, *os.File&gt;对应的itab结构体。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54a068b4d22b4958ad3f2e24e5fc5f59~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>然而如果把一个字符串赋值给e，它的动态类型就是string，&lt;io.ReadWriter, string&gt;这个组合会对应下面这个itab，它也会被缓存起来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c03eee5b43514c7b850a83d8ce403495~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>断言失败，ok为false，rw为io.ReadWriter的类型零值，即tab和data均为nil。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58abfcf1dc3d473b95c9125d6843001a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>示例请看以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	rw, ok := e.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _  := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	e = f</span><br><span class="line">	rw, ok = e.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">	e = f1</span><br><span class="line">	rw, ok = e.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行&#96;&#96;&#96;go run&#96;&#96;以后的运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&amp;&#123;<span class="number">0xc000108780</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>




<h2 id="非空接口-非空接口"><a href="#非空接口-非空接口" class="headerlink" title="非空接口.(非空接口)"></a>非空接口.(非空接口)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">rw,ok := w.(io.ReadWriter)</span><br></pre></td></tr></table></figure>



<p>w.(io.ReadWriter)是要判断w的动态类型是否实现了io.ReadWriter接口。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e5e158fffaf414d960089f1004b45b9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面同样把一个<em>os.File类型的变量f赋值给w，它的动态值就是f，动态类型就是</em>os.File。</p>
<p>f,_ :&#x3D; os.Open(“hello.txt”)<br>w &#x3D; f</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58940ab0e6d2454d9cccb41bb317b204~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>要确定<em>os.File是否实现了io.ReadWriter接口，同样会先去itab缓存里查找&lt;io.ReadWriter,*os.File&gt;对应的itab，若存在，且itab.fun[0]不等于0，则断言成功；若不存在，再去检查</em>os.File的方法列表，创建并缓存itab信息。</p>
<p>这里断言成功，ok为true，rw为io.ReadWriter类型的变量，动态值与w相同，而itab是&lt;io.ReadWriter, *os.File&gt;对应的那一个。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8b7b39cbacc64ca0b1d8137f3aecb483~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面我们自定义一个eggo类型，且<em>eggo类型只实现io.Writer要求的Write方法，并没有实现io.ReadWriter额外要求的Read方法。如果把一个</em>eggo类型的变量赋给w：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">w = &amp;f</span><br></pre></td></tr></table></figure>




<p>此时，w的动态类型为<em>eggo，而</em>eggo的方法列表里缺少一个Read方法，所以类型断言失败，下面这个itab被缓存起来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/25597330157848da9b87c32155093bcf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>断言失败后，ok为false，rw的data和tab均为nil。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51626b80c6644669b7440949462c1b34~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84bf9ebfb557428c9ffa883951ee8df0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>示例请看以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> w io.Writer</span><br><span class="line">	rw, ok := w.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	w = f</span><br><span class="line">	rw, ok = w.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">	w = &amp;f1</span><br><span class="line">	rw, ok = w.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行go run以后的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&amp;&#123;<span class="number">0xc000108780</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>




<p>综上，类型断言的关键是<strong>明确接口的动态类型，以及对应的类型实现了哪些方法</strong>。而明确这些的关键，还是类型元数据，以及空接口与非空接口的数据结构。接下来的<code>Type Switch</code>也不外如是。</p>
<h2 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">str := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = str</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> b := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *os.File:</span><br><span class="line">    &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;*os.File&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        fmt.Println(b)    <span class="comment">//选择这个分支</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的b会被赋值为e的动态值，下面每个case都是把e的动态类型和某个具体类型作比较，相等则选择这个分支，没有匹配的则走到default分支。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aed97e3208c446d69a9f0848fa9439c3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>有时会遇到多个类型放在一个分支的情况，这时b的类型是interface{}。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> b := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *os.File:</span><br><span class="line">    &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;这里b的类型为*os.File&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;这里b的类型为string&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">int32</span>, <span class="type">int64</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;多类型分支里b的类型为interface&#123;&#125;&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 自定义排序</title>
    <url>/2022/09/08/Go/Golang%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>C++中实现自定义排序，可以在sort函数的最后一个参数位上，加上一个<code>自定义的比大小函数</code>或者<code>仿函数</code>来实现：</p>
<p><strong>lambda表达式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v是vector&lt;int&gt;类型</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>仿函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a &gt; b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">SortInt</span>());</span><br></pre></td></tr></table></figure>


<p>Go语言中通过sort包提供的接口和函数，也可以实现自定义排序.</p>
<h2 id="三种基本类型升序排序"><a href="#三种基本类型升序排序" class="headerlink" title="三种基本类型升序排序"></a>三种基本类型升序排序</h2><p>如果要排序的切片是<code>int64, float64, string</code>类型，且是升序排序，可以使用下面三个函数进行排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Ints(x []<span class="type">int</span>)</span><br><span class="line">sort.Float64s(x []<span class="type">float64</span>)</span><br><span class="line">sort.Strings(x []<span class="type">string</span>)</span><br></pre></td></tr></table></figure>


<h2 id="sort-Sort-data-Interface"><a href="#sort-Sort-data-Interface" class="headerlink" title="sort.Sort(data Interface)"></a>sort.Sort(data Interface)</h2><p>这个函数可以对自定义类型的切片进行排序，前提是这种自定义类型得实现<code>Interface</code>接口.</p>
<p><strong>Interface</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line">	Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">	Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>int类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sortInt []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr sortInt)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr sortInt)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[i] &lt; arr[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr sortInt)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> _arr sortInt = arr</span><br><span class="line">	sort.Sort(_arr)</span><br><span class="line">	sort.Sort(sort.Reverse(_arr))  <span class="comment">// 逆序排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>struct类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Students []Student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Students)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Students)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i].score &lt; s[j].score</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Students)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> students Students</span><br><span class="line">	students = []Student&#123;</span><br><span class="line">		Student&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">89</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">98</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;wangwu&quot;</span>, <span class="number">78</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(students)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="sort-Slice-x-interface-less-func-i-j-int-bool"><a href="#sort-Slice-x-interface-less-func-i-j-int-bool" class="headerlink" title="sort.Slice(x interface{}, less func(i, j int) bool)"></a>sort.Slice(x interface{}, less func(i, j int) bool)</h2><p>这个函数可以对切片类型进行排序，还需要提供一个返回值为bool类型的函数对象.</p>
<p><strong>int类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>&#125;</span><br><span class="line">sort.Slice(arr, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[i] &gt; arr[j]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>struct类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">students := []Student&#123;</span><br><span class="line">		Student&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">89</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">98</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;wangwu&quot;</span>, <span class="number">78</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(students, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> students[i].score &gt; students[j].score</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(students)</span><br></pre></td></tr></table></figure>


<p>这样看来使用<code>sort.Slice</code>好像更加方便一些，之后发现更加高级的功能再追加.</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 调度器调度场景</title>
    <url>/2022/09/07/Go/Golang%20%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B0%83%E5%BA%A6%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="场景1-创建G"><a href="#场景1-创建G" class="headerlink" title="场景1 创建G"></a>场景1 创建G</h2><p>P拥有G1，M1获取P后开始运行G1，G1使用<code>go func()</code>创建了G2，为了局部性G2优先加入到P1的本地队列。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfeaa60d987644d980865d74991c6a11~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景2-G执行完毕"><a href="#场景2-G执行完毕" class="headerlink" title="场景2 G执行完毕"></a>场景2 G执行完毕</h2><p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cce4ac9c9ad7461e9fbc06c37ebb65b2~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景3-G2开辟过多的G"><a href="#场景3-G2开辟过多的G" class="headerlink" title="场景3 G2开辟过多的G"></a>场景3 G2开辟过多的G</h2><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。接着触发场景4和5。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/756a5c3a77f142beabfbd6ac55180b79~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景4-G2本地满再创建G7"><a href="#场景4-G2本地满再创建G7" class="headerlink" title="场景4 G2本地满再创建G7"></a>场景4 G2本地满再创建G7</h2><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行<strong>负载均衡</strong>(把P1中本地队列中前一半的G，还有新创建G<strong>转移</strong>到全局队列)</p>
<p><em>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</em></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/236b992afea2467a81891b736375377a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p>
<h2 id="场景5-G2本地未满创建G8"><a href="#场景5-G2本地未满创建G8" class="headerlink" title="场景5 G2本地未满创建G8"></a>场景5 G2本地未满创建G8</h2><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e96d82277fa4d5ca52148fdbfab2a22~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
<h2 id="场景6-唤醒正在休眠的M"><a href="#场景6-唤醒正在休眠的M" class="headerlink" title="场景6 唤醒正在休眠的M"></a>场景6 唤醒正在休眠的M</h2><p>规定：<strong>在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5be54b4f302e455c8d6ca6d44497091a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程<strong>（没有G但为运行状态的线程，不断寻找G）</strong>。</p>
<h2 id="场景7-被唤醒的M从全局取C"><a href="#场景7-被唤醒的M从全局取C" class="headerlink" title="场景7 被唤醒的M从全局取C"></a>场景7 被唤醒的M从全局取C</h2><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：<code>findrunnable()</code>）。M2从全局队列取的G数量符合下面的公式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n = min(<span class="built_in">len</span>(GQ)/GOMAXPROCS + <span class="number">1</span>, <span class="built_in">len</span>(GQ/<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ecd577cde04ca7b7b57d7bd1131da0~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p>
<h2 id="场景8-偷取G情况"><a href="#场景8-偷取G情况" class="headerlink" title="场景8 偷取G情况"></a>场景8 偷取G情况</h2><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b41a8f29987a4ed0a521bc2c15704918~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列</strong>。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
<h2 id="场景9-自旋线程的最大限制"><a href="#场景9-自旋线程的最大限制" class="headerlink" title="场景9 自旋线程的最大限制"></a>场景9 自旋线程的最大限制</h2><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于<strong>自旋状态</strong>，它们不断寻找goroutine。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539b15a133f64241b13805a5287c35ab~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们<strong>希望当有新goroutine创建时，立刻能有M运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>自旋线程 + 执行线程 &lt;= GOMAXPROCS</code>个线程(当前例子中的<code>GOMAXPROCS</code>&#x3D;4，所以一共4个P，2个自旋线程)，多余的没事做线程会让他们休眠。</p>
<h2 id="场景10-G发生调用阻塞"><a href="#场景10-G发生调用阻塞" class="headerlink" title="场景10 G发生调用阻塞"></a>场景10 G发生调用阻塞</h2><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了<strong>阻塞的系统调用</strong>，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22dbdcf494d54982ad06990fb533eff6~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景11-G发生非阻塞系统调用"><a href="#场景11-G发生非阻塞系统调用" class="headerlink" title="场景11 G发生非阻塞系统调用"></a>场景11 G发生非阻塞系统调用</h2><p>G8创建了G9，假如G8进行了<strong>非阻塞系统调用</strong>，就是当G8的阻塞结束的时候。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8c2c7de8dea4abf8c607fd2bf21cd87~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入<strong>系统调用</strong>状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 错误处理</title>
    <url>/2022/09/07/Go/Golang%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>panic相当于throw exception，recover相当于try catch。<br>所以经过recover接收的异常被处理后，不会让程序crash。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;异常信息&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常信息</span></span><br></pre></td></tr></table></figure>




<p>panic 和 recover 的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">revover()<span class="keyword">interface</span>&#123;&#125; </span><br></pre></td></tr></table></figure>



<p><strong>panic的引发</strong></p>
<p>1.程序主动调用panic函数。<br>2.程序产生运行时错误，由运行时检测并抛出。</p>
<p>发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或运行到最外层函数而退出。<br>不仅如此，在defer逻辑里也可以再次调用panic或抛出panic。defer 里面的 panic 能够被后续执行的 defer 捕获。</p>
<p><strong>recover</strong></p>
<p>recover()用来捕获panic,阻止panic 继续向上传递。recover()和defer一起使用，但是recover()只有在defer后面的函数体内被直接调用才能捕获panic终止异常，否则返回nil,异常继续向外传递。</p>
<p>以下场景会捕获失败：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个会捕获失败</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个会捕获失败</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个嵌套两层也会捕获失败</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;defer inner&quot;</span>)</span><br><span class="line">		<span class="built_in">recover</span>()  <span class="comment">// 无效</span></span><br><span class="line">	&#125; ()</span><br><span class="line">&#125; ()</span><br></pre></td></tr></table></figure>

<p>以下场景会捕获成功：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;defer inner&quot;</span>)</span><br><span class="line">	<span class="built_in">recover</span>()</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">except</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">recover</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> except()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>连续多个panic抛出</strong></p>
<p>可以有连续多个panic被抛出，连续多个panic的场景只能出现在defer调用里面，否则不会出现多个panic被抛出的场景。但只有最后一次panic能被捕获。例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 只有最后一次panic调用能够被捕获</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;first defer panic&quot;</span>)</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;second defer panic&quot;</span>)</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;main body panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">first <span class="keyword">defer</span> <span class="built_in">panic</span></span><br></pre></td></tr></table></figure>



<p><strong>新goroutine中抛出的panic</strong></p>
<p>函数并不能捕获内部新启动的 goroutine 所抛出的 panic ，所以比如init函数引发的panic只能在init函数中捕获，在main中无法捕获。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里不能捕获da函数中的panic</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line">	<span class="keyword">go</span> da()</span><br><span class="line">	<span class="keyword">go</span> db()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">da</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;panic da&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">db</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>Go语言内置错误接口类型error。任何类型只要实现Error() string 方法，都可以传递error 接口类型变量。Go语言典型的错误处理方式是将error作为函数最后一个返回值。在调用函数时，通过检测其返回的error值是否为nil来进行错误处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>错误处理的最佳实践</strong>：</p>
<p>1.在多个返回值的函数，error通常作为函数最后一个返回值。<br>2.如果一个函数返回 error 类型变量，则先用 if 语句处理 error !&#x3D; nil 的异常场景，正常逻辑放到if语句块的后面，保持代码平坦。<br>3.defer语句应该放到err判断的后面，不然有可能产生panic。<br>4.在错误处理逐级向上传递的过程中，错误信息应该不断地丰富和完善，而不是简单地抛出下层调用的错误。这在错误日志分析时非常有用和友好。</p>
<h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p><strong>广义上的错误</strong>：发生非期望的行为。<br><strong>狭义的错误</strong>：发生非期望的已知行为，这里的已知是指错误的类型是预料并定义好的。<br><strong>异常</strong>：发生非期待的未知行为。这里的未知是指错误的类型不在预先定义的范围内。又被称为未捕获的错误 (untrapped error) 。，程序编译器和运行时都没有及时将其捕获处理。而是由操作系统进行异常处理。</p>
<p><strong>错误分类关系如图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2be9e93d8d4246a8863cacf95da694~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>Go是一门类型安全的语言，不会出现 <strong>untrapped error</strong> ，所以Go语言不存在所谓的异常，出现的”异常”全是错误。</p>
<p><strong>Go语言的两种错误处理机制</strong></p>
<p>1.通过函数返回错误类型(error)的值来处理错误。<br>2.通过panic打印程序调用栈，终止程序执行来处理错误。</p>
<p><strong>对应的也有两条错误处理规则</strong>：</p>
<p>1.程序发生的错误导致程序不能容错继续执行，此时程序应该主动调用panic或由运行时抛出 panic 。<br>2.程序虽然发生错误，但是程序能够容错继续执行，此时应该使用错误返回值的方式处理错误，或者在可能发生运行时错误的非关键分支.上使用recover捕获panic。</p>
<p>go的整个错误处理过程如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e47ae73897bd475ca7c4ebdcbb6a7e5e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Master-Worker模式 Golang实现</title>
    <url>/2022/09/08/Go/Master-Worker%E6%A8%A1%E5%BC%8F%20Golang%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h1><p>Master-Worker模式是常用的并行计算模式。它的核心思想是系统由两类进程协作工作：Master进行和Worker进行。Master负责接收和分配任务，Worker负责处理子任务。当各个Worker子进程处理完成后，会将结果返回给Master，由Master做归纳和总结。其好处是能将一个大任务分解成若干个子任务，并行执行，从而提高系统的吞吐量。 </p>
<p><strong>master-worker模式流程图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7639ce670f3246b5937efbc17d8712e4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面是一个master-worker模式的例子：</p>
<p>worker.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Job 需要处理的任务，简单定义一下</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	num <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(num <span class="type">int</span>)</span></span> Job &#123;</span><br><span class="line">	<span class="keyword">return</span> Job&#123;num: num&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	id        <span class="type">int</span>                <span class="comment">//workerID</span></span><br><span class="line">	WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job      <span class="comment">//worker池</span></span><br><span class="line">	JobChannel <span class="keyword">chan</span> Job            <span class="comment">//worker从JobChannel中获取Job进行处理</span></span><br><span class="line">	Result    <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span> <span class="comment">//worker将处理结果放入reuslt</span></span><br><span class="line">	quit      <span class="keyword">chan</span> <span class="type">bool</span>          <span class="comment">//停止worker信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job, result <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>, id <span class="type">int</span>)</span></span> Worker &#123;</span><br><span class="line">	<span class="keyword">return</span> Worker&#123;</span><br><span class="line">		id:        id,</span><br><span class="line">		WorkerPool: workerPool,</span><br><span class="line">		JobChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">		Result:    result,</span><br><span class="line">		quit:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span></span> Start() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">//将worker的JobChannel放入master的workerPool中</span></span><br><span class="line">			w.WorkerPool &lt;- w.JobChannel</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">//从JobChannel中获取Job进行处理，JobChannel是同步通道，会阻塞于此</span></span><br><span class="line">			<span class="keyword">case</span> job := &lt;-w.JobChannel:</span><br><span class="line">				<span class="comment">//处理这个job</span></span><br><span class="line">				<span class="comment">//并将处理得到的结果存入master中的结果集</span></span><br><span class="line">				x := job.num * job.num</span><br><span class="line">				fmt.Println(w.id, <span class="string">&quot;:&quot;</span>, x)</span><br><span class="line">				w.Result[x] = w.id</span><br><span class="line">			<span class="comment">//停止信号</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-w.quit:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span></span> Stop() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		w.quit &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>master.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">	WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job <span class="comment">//worker池</span></span><br><span class="line">	Result    <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>  <span class="comment">//存放worker处理后的结果集</span></span><br><span class="line">	jobQueue  <span class="keyword">chan</span> Job      <span class="comment">//待处理的任务chan</span></span><br><span class="line">	workerList []Worker      <span class="comment">//存放worker列表，用于停止worker</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> maxWorker <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMaster maxWorkers:开启线程数</span></span><br><span class="line"><span class="comment">//result :结果集</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMaster</span><span class="params">(maxWorkers <span class="type">int</span>, result <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>)</span></span> *Master &#123;</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> Job, maxWorkers)</span><br><span class="line">	maxWorker = maxWorkers</span><br><span class="line">	<span class="keyword">return</span> &amp;Master&#123;WorkerPool: pool, Result: result, jobQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">2</span>*maxWorkers)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Run() &#123;</span><br><span class="line">	<span class="comment">//启动所有的Worker</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxWorker; i++ &#123;</span><br><span class="line">		work := NewWorker(m.WorkerPool, m.Result, i)</span><br><span class="line">		m.workerList = <span class="built_in">append</span>(m.workerList, work)</span><br><span class="line">		work.Start()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> m.dispatch()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> dispatch() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 从作业队列中获取一个待处理的作业，因为是无缓冲通道，所以会阻塞</span></span><br><span class="line">		<span class="keyword">case</span> job := &lt;-m.jobQueue:</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">				<span class="comment">//从workerPool中取出一个worker的JobChannel</span></span><br><span class="line">				jobChannel := &lt;-m.WorkerPool</span><br><span class="line">				<span class="comment">//向这个JobChannel中发送job，worker中的接收配对操作会被唤醒</span></span><br><span class="line">				jobChannel &lt;- job</span><br><span class="line">			&#125;(job)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddJob 添加任务到任务通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> AddJob(num <span class="type">int</span>) &#123;</span><br><span class="line">	job := NewJob(num)</span><br><span class="line">	<span class="comment">//向任务通道发送任务</span></span><br><span class="line">	m.jobQueue &lt;- job</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop 停止所有任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Stop() &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> m.workerList &#123;</span><br><span class="line">		v.Stop()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>test.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	result := <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	mas := NewMaster(<span class="number">4</span>, result)</span><br><span class="line">	mas.Run()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		mas.AddJob(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	<span class="comment">//mas.Stop()</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;result=&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果每次都是不同的，这里只展示某一次的运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> : <span class="number">81</span></span><br><span class="line"><span class="number">2</span> : <span class="number">4</span></span><br><span class="line"><span class="number">2</span> : <span class="number">9</span></span><br><span class="line"><span class="number">2</span> : <span class="number">16</span></span><br><span class="line"><span class="number">2</span> : <span class="number">64</span></span><br><span class="line"><span class="number">2</span> : <span class="number">36</span></span><br><span class="line"><span class="number">2</span> : <span class="number">49</span></span><br><span class="line"><span class="number">3</span> : <span class="number">1</span></span><br><span class="line"><span class="number">0</span> : <span class="number">0</span></span><br><span class="line"><span class="number">1</span> : <span class="number">25</span></span><br><span class="line">result= <span class="keyword">map</span>[<span class="number">0</span>:<span class="number">0</span> <span class="number">1</span>:<span class="number">3</span> <span class="number">4</span>:<span class="number">2</span> <span class="number">9</span>:<span class="number">2</span> <span class="number">16</span>:<span class="number">2</span> <span class="number">25</span>:<span class="number">1</span> <span class="number">36</span>:<span class="number">2</span> <span class="number">49</span>:<span class="number">2</span> <span class="number">64</span>:<span class="number">2</span> <span class="number">81</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 闭包</title>
    <url>/2022/09/07/Go/Golang%20%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h2><p>先来看一段代码，下面的addr函数的返回值是另一个函数，被返回的这个函数中，又对addr函数中的变量进行了累加，然后返回。<br>在main函数中，使用变量pos接收addr()函数返回的函数对象，然后在for循环中调用5次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addr</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos := addr()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Println(pos(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>以上就是函数闭包。</p>
<h2 id="什么是函数闭包"><a href="#什么是函数闭包" class="headerlink" title="什么是函数闭包"></a>什么是函数闭包</h2><h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>闭包是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。 </p>
<h3 id="闭包的价值"><a href="#闭包的价值" class="headerlink" title="闭包的价值"></a>闭包的价值</h3><p>闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。</p>
<p>Go语言中的闭包同样也会引用到函数外的变量。闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在。</p>
<h2 id="闭包的机制"><a href="#闭包的机制" class="headerlink" title="闭包的机制"></a>闭包的机制</h2><h3 id="function-value"><a href="#function-value" class="headerlink" title="function value"></a>function value</h3><p>go语言中函数是头等对象，可以作为参数传递，可以做函数返回值，也可以绑定到变量。go语言称这样的参数、返回值或变量为<code>function value</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd3d4765197c43caab4d4b84feb92cc9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>函数的指令在编译期间生成。而<code>function value</code>本质上是一个函数指针，但是并不直接指向函数指令入口。而是直接指向一个<code>runtime.funcval</code>结构体。这个结构体里只有一个地址，就是这个函数指令的入口地址。</p>
<p>再来看一个例子：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7995d43a3c04691921a48d0b8b2dacd~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>函数A被赋值给f1和f2两个变量，这种情况，编译器会做出优化。让f1和f2共用一个<code>funcval</code>结构体。如果函数A的指令在addr1所指的位置。<br>编译阶段，会在只读数据段分配一个<code>funcval</code>结构体。fn指向函数指令入口，而它本身的起始地址，会在执行阶段赋给f1和f2。 通过f1来执行函数， 就会通过它储存的地址，找到对应的funcval结构体，拿到函数入口地址，然后跳转执行，参数为1，下一步输出为2。f2的调用完全相同。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/626638b4072d4ef183437baaa4568a7b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>既然只要有函数入口地址就能调用，为什么要通过funcval结构体来包装这个地址，然后使用一个二级指针来调用呢？<br><strong>这里其实就是为了处理闭包的情况。</strong></p>
<p>再来看一种情况：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1feabdbdb5f247e4b78674b6e4b8a525~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>函数create的返回值是一个函数，但这个函数内部使用了外部定义的变量c。即使create执行结束，通过f1和f2依然能够正常调用这个闭包函数。并使用定义在create函数内部的局部变量c。<br>这里符合闭包的定义，通常称这个变量c为捕获变量。<br>闭包函数的指令自然也在编译阶段生成。但因为每个闭包对象都要保存自己的捕获变量，所以要到执行阶段才创建对应的闭包对象。<br>到执行阶段，main函数栈帧有两个局部变量，然后是返回值空间。到create函数栈帧这里，有一个局部变量c&#x3D;2。create函数会在堆上分配一个funcval结构体。<br>fn指向闭包函数入口，除此之外还有一个捕获列表。这里只捕获一个变量c，然后这个结构的起始地址就被作为返回值写入返回值空间。所以f1被赋值为addr2。<br>下面再次调用create函数。它就会再次创建一个funccval结构体。同样捕获变量c，然后这个起始地址addr3作为返回值写入。最终f2被赋值为addr3。<br>通过f1和f2调用闭包函数，就会找到各自对应的funcval结构体。拿到同一个函数入口，但是通过f1调用时要使用addr1指向的捕获列表，而使用f2调用时要使用addr2指向的捕获列表。<strong>这就是称闭包为有状态的函数的原因。</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2d0254e102843708e0c4b168ba1b8e0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>那究竟闭包函数是如何找到对应的捕获列表呢？</p>
<p>go语言中通过一个<code>function value</code>调用函数时，会把对应的<code>funcval</code>结构体地址存入特定寄存器，例如amd64平台使用的是DX寄存器。这样，在闭包函数中，就可以通过寄存器取出funcval结构体的地址，然后加上相应的偏移来找到每一个被捕获的变量。所以go语言中闭包就是有捕获列表的<code>Function Value</code>。而没有捕获列表的<code>Function Value</code>直接忽略这个寄存器的值就好了。</p>
<p>最后来看看捕获列表：</p>
<p>它可不是拷贝变量值这么简单，被闭包捕获的变量要在外层函数与闭包函数中表现一致，好像它们在使用同一个变量。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07d3336cbe7b4816af8f717ae63aa061~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>为此，go语言的编译器针对不同的情况做了不同的处理。</p>
<ul>
<li>被捕获的变量除了初始化赋值外，在任何地方都没有被修改过，所以直接拷贝值到捕获列表中就可以了。</li>
<li>但是如果除了初始化赋值外还被修改过，那就要再做细分了。<ul>
<li>如果被捕获的是局部变量，而且除了初始化赋值外还被修改过， 那么这个局部变量就会被分配到堆上，是变量逃逸的一种场景。</li>
<li>如果修改并被捕获的是参数，涉及到函数原型，就不能像局部变量那样处理了。参数依然通过调用者栈帧传入。但是编译器会把栈上这个参数拷贝到堆上一份。然后外层函数和闭包函数都使用堆上分配的这一个。</li>
<li>如果被捕获的是返回值，处理方式就又有些不同，调用者栈帧上依然会分配返回值空间。不过闭包的外层函数会在堆上也分配一个。但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间。</li>
</ul>
</li>
</ul>
<p>处理方式虽然多样，但是目标只有一个，就是保持捕获变量在外层函数与闭包函数中的一致性。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang1.18 泛型初探</title>
    <url>/2022/09/08/Go/Golang1.18%20%E6%B3%9B%E5%9E%8B%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="泛型出现之前"><a href="#泛型出现之前" class="headerlink" title="泛型出现之前"></a>泛型出现之前</h2><p>在泛型出现之前，go语言的灵活性很大部分是基于<code>interface&#123;&#125;</code>这个空接口来保证的。任何变量都可以继承空接口，但是在使用变量的时候，就需要对变量进行<code>类型断言</code>。而类型断言是基于<code>反射</code>来实现的，反射中的类型错误在真正运行的时候才会引发panic，而且大量使用反射会使得程序的效率变得非常低。</p>
<p>下面我们来看一个类型断言的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumInt</span><span class="params">(param []<span class="keyword">interface</span>&#123;&#125;)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> param &#123;</span><br><span class="line">		sum += v.(<span class="type">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConnStrings</span><span class="params">(param []<span class="keyword">interface</span>&#123;&#125;)</span></span> (str <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> param &#123;</span><br><span class="line">		str += v.(<span class="type">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddSum</span><span class="params">(param ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">switch</span> param[<span class="number">0</span>].(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		<span class="keyword">return</span> SumInt(param)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		<span class="keyword">return</span> ConnStrings(param)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;不支持相加的类型&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(AddSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">	fmt.Println(AddSum(<span class="string">&quot;hello, &quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">	fmt.Println(AddSum([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AddSum</code>函数的参数是空接口类型，保证了传入参数的灵活性，但是参数在传入以后，需要进行<code>解继承</code>才能真正去使用。</p>
<p>但是泛型出现以后，就不需要这么麻烦了，使用以下的方式就可以去解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型约束函数的传入参数只能是int 和 string</span></span><br><span class="line"><span class="comment">// 如果是其它类型将会报错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddSum</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">string</span>]<span class="params">(param ...T)</span></span> (sum T) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> param &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(AddSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">	fmt.Println(AddSum(<span class="string">&quot;hello, &quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>go1.18正式支持泛型，在goland中可以直接下载1.18版本。</p>
<h2 id="泛型特性"><a href="#泛型特性" class="headerlink" title="泛型特性"></a>泛型特性</h2><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Print(v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printSlice[<span class="type">int</span>]([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">	printSlice[<span class="type">string</span>]([]<span class="type">string</span>&#123;<span class="string">&quot;how&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;you&quot;</span>&#125;)</span><br><span class="line">	printSlice[[]<span class="type">int</span>]([][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12345</span></span><br><span class="line"><span class="comment">//howareyou</span></span><br><span class="line"><span class="comment">//[1 2 3][4 5 6][7 8 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>T</code>的后面是<code>any</code>表示传入函数的参数可以是任意类型，该函数的功能是打印传入切片的元素。</p>
<h3 id="泛型slice"><a href="#泛型slice" class="headerlink" title="泛型slice"></a>泛型slice</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> vector[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Print(v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := vector[<span class="type">int</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	printSlice(arr)</span><br><span class="line">	str := vector[<span class="type">string</span>]&#123;<span class="string">&quot;how&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;you&quot;</span>&#125;</span><br><span class="line">	printSlice(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//123</span></span><br><span class="line"><span class="comment">//howareyou</span></span><br></pre></td></tr></table></figure>

<p>上例中我们自定义了一种切片数据类型，该切片可以储存任意一种类型，但是要注意，声明一次只能存同一种数据类型。</p>
<h3 id="泛型map"><a href="#泛型map" class="headerlink" title="泛型map"></a>泛型map</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M[K <span class="type">string</span>, V any] <span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m1 := <span class="built_in">make</span>(M[<span class="type">string</span>, <span class="type">int</span>])</span><br><span class="line">	m1[<span class="string">&quot;key1&quot;</span>] = <span class="number">1</span></span><br><span class="line">	m1[<span class="string">&quot;key2&quot;</span>] = <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m1&#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	m2 := <span class="built_in">make</span>(M[<span class="type">string</span>, <span class="type">string</span>])</span><br><span class="line">	m2[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;key2&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m2&#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key1 1</span></span><br><span class="line"><span class="comment">//key2 2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//key1 hello</span></span><br><span class="line"><span class="comment">//key2 world</span></span><br></pre></td></tr></table></figure>

<p>要注意，map的K是不支持any的，所以在这里我把K约束成了string类型。</p>
<h3 id="泛型channel"><a href="#泛型channel" class="headerlink" title="泛型channel"></a>泛型channel</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C[T any] <span class="keyword">chan</span> T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	chan1 := <span class="built_in">make</span>(C[<span class="type">int</span>], <span class="number">2</span>)</span><br><span class="line">	chan1 &lt;- <span class="number">1</span></span><br><span class="line">	chan1 &lt;- <span class="number">2</span></span><br><span class="line">	fmt.Println(&lt;-chan1)</span><br><span class="line"></span><br><span class="line">	chan2 := <span class="built_in">make</span>(C[<span class="type">string</span>], <span class="number">2</span>)</span><br><span class="line">	chan2 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">	chan2 &lt;- <span class="string">&quot;world&quot;</span></span><br><span class="line">	fmt.Println(&lt;-chan2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="可比较类型"><a href="#可比较类型" class="headerlink" title="可比较类型"></a>可比较类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FindFunc 泛型约束：可比较类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindFunc</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(a []T, v T)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, e := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> e == v &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(FindFunc([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="number">10</span>))</span><br><span class="line">	fmt.Println(FindFunc([]<span class="type">string</span>&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>&#125;, <span class="string">&quot;def&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型还可以约束一种可比较类型<code>comparable</code>，大致功能就是在一个切片中找一个数，具体的算法需要自己实现，在这里我简单的演示了一下。</p>
<h3 id="使用interface中规定的类型来约束函数的参数"><a href="#使用interface中规定的类型来约束函数的参数" class="headerlink" title="使用interface中规定的类型来约束函数的参数"></a>使用interface中规定的类型来约束函数的参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number 使用interface来约束泛型中可以传入的类型</span></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | <span class="type">float64</span> | <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">Number</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	fmt.Println(Add(<span class="number">1.1</span>, <span class="number">2.2</span>))</span><br><span class="line">	fmt.Println(Add(<span class="string">&quot;hello, &quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3.3000000000000003</span></span><br><span class="line"><span class="comment">//hello, world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果函数的约束类型过多怎么办，如果直接写在函数名后面的方括号中，代码将显得非常丑陋，这个时候我们使用interface约束类型。注意，~符号表示约束某种类型的底层类型。</p>
<h3 id="使用interface中规定的方法来约束函数的参数"><a href="#使用interface中规定的方法来约束函数的参数" class="headerlink" title="使用interface中规定的方法来约束函数的参数"></a>使用interface中规定的方法来约束函数的参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Price <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ShowPrice 使用interface来约束传入ShowPriceList函数中的类型必须实现了String方法，不然就报错</span></span><br><span class="line"><span class="keyword">type</span> ShowPrice <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Price)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(<span class="type">int</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowPriceList</span>[<span class="title">T</span> <span class="title">ShowPrice</span>]<span class="params">(s []T)</span></span> (res []<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(ShowPriceList([]Price&#123;<span class="number">1</span>, <span class="number">2</span>&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传入ShowPriceList函数的参数，必须实现String方法。</p>
<h3 id="使用interface中规定的类型和方法来双重约束函数的参数"><a href="#使用interface中规定的类型和方法来双重约束函数的参数" class="headerlink" title="使用interface中规定的类型和方法来双重约束函数的参数"></a>使用interface中规定的类型和方法来双重约束函数的参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriceInt <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i PriceInt)</span></span>String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(<span class="type">int</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriceString <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i PriceString)</span></span>String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShowPrice 约束底层类型必须是int和string 且 必须实现String方法</span></span><br><span class="line"><span class="keyword">type</span> ShowPrice <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowPriceList</span>[<span class="title">T</span> <span class="title">ShowPrice</span>]<span class="params">(s []T)</span></span> (res []<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ShowPriceList([]PriceInt&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">	ShowPriceList([]PriceString&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传入ShowPriceList函数的参数的底层类型必须是int或者string且必须实现String方法。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 逃逸分析</title>
    <url>/2022/09/06/Go/%E6%B5%85%E8%B0%88golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-栈和堆"><a href="#1-栈和堆" class="headerlink" title="1.栈和堆"></a>1.栈和堆</h2><p>在golang中，应用程序的内存载体，可以简单的分为栈和堆。<br>栈的内存是由编译器自动进行分配和释放，栈区往往存储着函数参数、局部变量和调用函数帧，它们随着函数的创建而分配，函数的退出而销毁。<br>与栈不同的是，应用程序在运行时只会存在一个堆。狭隘地说，内存管理只是针对堆内存而言的。程序在运行期间可以主动从堆上申请内存，这些内存通过Go的内存分配器分配，并由垃圾收集器回收。</p>
<p>那么一个问题就来了，<strong>我们怎么知道一个对象是应该放在堆内存还是栈内存之上的呢？</strong></p>
<p>其实golang的官网上已经给出了答案：</p>
<p><a href="https://golang.org/doc/faq#stack_or_heap">https://golang.org/doc/faq#stack_or_heap</a></p>
<p><img src="https://img-blog.csdnimg.cn/358747fa08c946f59de2fc16be230424.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_20,color_FFFFFF,t_70,g_se,x_16"><br>中文版：</p>
<p><img src="https://img-blog.csdnimg.cn/a272814aa9eb4a1e83e9935f7bd92bde.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_20,color_FFFFFF,t_70,g_se,x_16"><br>我们发现了一个名词：<strong>逃逸分析</strong>。</p>
<h2 id="2-逃逸分析"><a href="#2-逃逸分析" class="headerlink" title="2.逃逸分析"></a>2.逃逸分析</h2><p><strong>对于Golang程序，编译器是怎么判断一个变量到底是分配堆内存还是栈内存的呢？编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。</strong></p>
<p>官网中虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的：</p>
<ul>
<li>逃逸分析是在编译器完成的，这是不同于jvm的运行时逃逸分析;</li>
<li>如果变量在函数外部没有引用，则优先放到栈中；</li>
<li>如果变量在函数外部存在引用，则必定放在堆中；</li>
</ul>
<h2 id="3-几种常见的逃逸情况："><a href="#3-几种常见的逃逸情况：" class="headerlink" title="3.几种常见的逃逸情况："></a>3.几种常见的逃逸情况：</h2><p>我们可通过<code>go build -gcflags &#39;-m -l&#39;</code>命令来查看逃逸分析结果，其中-m 打印逃逸分析信息，-l禁止内联优化。</p>
<h3 id="3-1-指针逃逸"><a href="#3-1-指针逃逸" class="headerlink" title="3.1 指针逃逸"></a>3.1 指针逃逸</h3><p>如果一个函数内部创建了一个对象(局部变量)，但是在函数返回时是返回该对象的指针，那么该变量的生命周期就变了，即使当前函数执行结束了，但是变量的指针还在，并不是随着函数结束就被回收的，那么这个局部变量就会被分配在堆上，这就产生了指针逃逸。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(argVal <span class="type">int</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> fooVal1 <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> fooVal2 <span class="type">int</span> = <span class="number">12</span></span><br><span class="line">	<span class="keyword">var</span> fooVal3 <span class="type">int</span> = <span class="number">13</span></span><br><span class="line">	<span class="keyword">var</span> fooVal4 <span class="type">int</span> = <span class="number">14</span></span><br><span class="line">	<span class="keyword">var</span> fooVal5 <span class="type">int</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(&amp;argVal, &amp;fooVal1, &amp;fooVal2, &amp;fooVal3, &amp;fooVal4, &amp;fooVal5)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;fooVal3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mainVal := foo(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(*mainVal, mainVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">6</span>: moved to heap: fooVal3</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0xc000045f58</span> <span class="number">0xc000045f38</span> <span class="number">0xc000045f30</span> <span class="number">0xc00000e040</span> <span class="number">0xc000045f28</span> <span class="number">0xc000045f20</span></span><br><span class="line"><span class="number">13</span> <span class="number">0xc00000e040</span></span><br></pre></td></tr></table></figure>



<p>结果显示，逃逸分析结果显示fooVal3逃逸到了堆中，通过打印出来的变量地址我们可以发现，fooVal3的地址是0xc00000e040，与其他地址是不连续的。</p>
<h3 id="3-2-interface-动态类型逃逸"><a href="#3-2-interface-动态类型逃逸" class="headerlink" title="3.2 interface{} 动态类型逃逸"></a>3.2 interface{} 动态类型逃逸</h3><p>在golang中空接口interface{}可以是任意类型，因此编译器并不能确定其类型，所以也会被分配到堆上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> valA <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	valA = <span class="number">666</span></span><br><span class="line">	fmt.Println(&amp;valA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: moved to heap: valA</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">7</span>: <span class="number">666</span> escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">13</span>: ... argument does not escape</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0xc00004a230</span></span><br></pre></td></tr></table></figure>



<p>通过运行结果我们可以发现，interface{}变量varA逃逸到了堆中。</p>
<p>再来看下面这段程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	varB := <span class="number">666</span></span><br><span class="line">	fmt.Println(varB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: varB escapes to heap</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">666</span></span><br></pre></td></tr></table></figure>

<p>可以看到，分析结果告诉我们变量varB逃逸到了堆上。但是，我们并没有外部引用啊，为什么也会有逃逸呢？为了看到更多细节，可以在语句中再添加一个-m参数：<code>go build -gcflags &#39;-m -m -l&#39;</code>。得到信息如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: varB escapes to heap:</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:   flow: &#123;storage <span class="keyword">for</span> ... argument&#125; = &amp;&#123;storage <span class="keyword">for</span> varB&#125;:</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from varB (spill) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from ... argument (slice-literal-element) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:   flow: &#123;heap&#125; = &#123;storage <span class="keyword">for</span> ... argument&#125;:</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from ... argument (spill) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from fmt.Println(... argument...) (call parameter) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: varB escapes to heap</span><br></pre></td></tr></table></figure>

<p>varB逃逸是因为它被传入了fmt.Println的参数中，这个方法参数自己发生了逃逸。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>因为fmt.Println的函数参数为interface类型，编译期不能确定其参数的具体类型，所以将其分配于堆上。</p>
<h3 id="3-3-栈空间不足"><a href="#3-3-栈空间不足" class="headerlink" title="3.3 栈空间不足"></a>3.3 栈空间不足</h3><p>如果程序中需要分配一个空间比较大的局部变量，栈空间已经不够分配了，那么也会被分配到堆上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		s[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>




<h3 id="3-4-变量大小不确定"><a href="#3-4-变量大小不确定" class="headerlink" title="3.4 变量大小不确定"></a>3.4 变量大小不确定</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		s[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, n) escapes to heap</span><br></pre></td></tr></table></figure>



<h3 id="3-5-闭包"><a href="#3-5-闭包" class="headerlink" title="3.5 闭包"></a>3.5 闭包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>  &#123;</span><br><span class="line">	num := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		num++</span><br><span class="line">		<span class="keyword">return</span> num</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fn := Add()</span><br><span class="line">	fmt.Println(fn())</span><br><span class="line">	fmt.Println(fn())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: moved to heap: num</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">14</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">14</span>:<span class="number">16</span>: fn() escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">16</span>: fn() escapes to heap</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上述代码块中，Add() 返回的是一个闭包，并且该闭包访问了外部变量num，那么num将会被分配到堆上，因为num此时生命周期已经不会随着Add() 函数的结束而被回收，直到 fn 被销毁，num才会被回收。</p>
<h2 id="4-传值还是传指针"><a href="#4-传值还是传指针" class="headerlink" title="4.传值还是传指针"></a>4.传值还是传指针</h2><p>传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。</p>
<p>一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>生产者-消费者模式 Golang实现</title>
    <url>/2022/09/08/Go/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%20Golang%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h1><p>生产者消费者模型具体来讲，就是在一个系统中，存在生产者和消费者两种角色，他们通过内存缓冲区进行通信，生产者生产消费者需要的资料，消费者把资料做成产品。</p>
<p><strong>基本工作原理</strong></p>
<p>生产者线程增加资源数，如果资源数大于最大值则生产者线程挂起等待，当收到消费者线程的通知后继续生产。<br>消费者线程减少资源数，如果资源数为0，则消费者线程挂起，等待生产者通知后继续生产。</p>
<p><strong>举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	PRODUCERS  = <span class="number">5</span></span><br><span class="line">	CONSUMERS = <span class="number">2</span></span><br><span class="line">	PRODUCTS  = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// productCount为资源的数量，需要互斥处理</span></span><br><span class="line"><span class="keyword">var</span> productCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制生产者阻塞等待</span></span><br><span class="line"><span class="keyword">var</span> produceWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 控制消费者阻塞等待</span></span><br><span class="line"><span class="keyword">var</span> consumeWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当资源达到上限或下限时，挂起单个协程，通过这两个变量休眠同类协程</span></span><br><span class="line"><span class="keyword">var</span> stopProduce = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> stopConsume = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Produce 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Produce</span><span class="params">(index <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Producer &quot;</span>, index, <span class="string">&quot; panic&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="comment">// 生产者协程发现stopProduce为true，则睡眠5秒</span></span><br><span class="line">		<span class="keyword">if</span> stopProduce &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Producer &quot;</span>, index, <span class="string">&quot; stop produce, sleep 5 seconds&quot;</span>)</span><br><span class="line">			lock.Unlock()</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Producer &quot;</span>, index, <span class="string">&quot; begin produce&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> productCount &gt;= PRODUCTS &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Products are full&quot;</span>)</span><br><span class="line">			<span class="comment">// 如果产品满了就停止生产</span></span><br><span class="line">			stopProduce = <span class="literal">true</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="comment">//将当前生产者挂起，等待</span></span><br><span class="line">			&lt;-produceWait</span><br><span class="line">			lock.Lock()</span><br><span class="line">			stopProduce = <span class="literal">false</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		productCount++</span><br><span class="line">		fmt.Println(<span class="string">&quot;Products count is &quot;</span>, productCount)</span><br><span class="line">		<span class="comment">// 产品从空的状态到被生产了一个，激活消费者</span></span><br><span class="line">		<span class="keyword">if</span> stopConsume &#123;</span><br><span class="line">			<span class="keyword">var</span> consumerActive <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">			consumeWait &lt;- consumerActive</span><br><span class="line">		&#125;</span><br><span class="line">		lock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consume 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consume</span><span class="params">(index <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Consumer &quot;</span>, index, <span class="string">&quot; panic&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">if</span> stopConsume &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Consumer &quot;</span>, index, <span class="string">&quot; stop consume, sleep 5 seconds&quot;</span>)</span><br><span class="line">			lock.Unlock()</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Consumer &quot;</span>, index, <span class="string">&quot; begin consume&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> productCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Products are empty&quot;</span>)</span><br><span class="line">			stopConsume = <span class="literal">true</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="comment">//产品空了，将当前消费者挂起</span></span><br><span class="line">			&lt;-consumeWait</span><br><span class="line">			lock.Lock()</span><br><span class="line">			stopConsume = <span class="literal">false</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		productCount--</span><br><span class="line">		fmt.Println(<span class="string">&quot;Products count is &quot;</span>, productCount)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 产品从满的状态被消费了一个，激活生产者</span></span><br><span class="line">		<span class="keyword">if</span> stopProduce &#123;</span><br><span class="line">			<span class="keyword">var</span> producerActive <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">			produceWait &lt;- producerActive</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(PRODUCERS + CONSUMERS)</span><br><span class="line">	produceWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	consumeWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; CONSUMERS; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Consume(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; PRODUCERS; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Produce(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在程序中可以发现，在produce函数中，当我们发现系统资源到达临界值时，使用channel将当前的协程阻塞了，然后将bool变量stopProduce置为true，让其它协程进入休眠。为什么要这样做呢？<br>因为程序中的produceWait是非缓冲的，所以一次只能激活一个生产者，这么做在一定程度限制了生产者，所以我们引入bool变量通知其他协程睡眠，避免此问题，consume函数中也是同样的道理。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
</search>
