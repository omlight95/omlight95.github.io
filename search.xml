<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Gin框架的安装和基本使用</title>
    <url>/2022/11/02/Gin/1Gin%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="安装Gin框架"><a href="#安装Gin框架" class="headerlink" title="安装Gin框架"></a>安装Gin框架</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>


<p><strong>示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">		context.JSON(http.StatusOK, &amp;UserInfo&#123;</span><br><span class="line">			Name: <span class="string">&quot;light&quot;</span>,</span><br><span class="line">			Gender: <span class="string">&quot;male&quot;</span>,</span><br><span class="line">			Age: <span class="number">21</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将上面的代码保存并编译执行，然后使用浏览器打开<code>127.0.0.1:8080/hello</code>就能看到一串JSON字符串。</p>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>REST是一种软件架构风格，简单来说，就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。</p>
<ul>
<li>GET用来获取资源</li>
<li>POST用来新建资源</li>
<li>PUT用来更新资源</li>
<li>DELETE用来删除资源。</li>
</ul>
<p>例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，按照RESTful API设计如下：</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>URL</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>&#x2F;book</td>
<td>查询数据信息</td>
</tr>
<tr>
<td>POST</td>
<td>&#x2F;book</td>
<td>创建书籍信息</td>
</tr>
<tr>
<td>PUT</td>
<td>&#x2F;book</td>
<td>更新书籍信息</td>
</tr>
<tr>
<td>DELETE</td>
<td>&#x2F;book</td>
<td>删除书籍信息</td>
</tr>
</tbody></table>
<br>


<p>GIn框架支持RESTful API的开发</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/book&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">&quot;/book&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.PUT(<span class="string">&quot;/book&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;PUT&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.DELETE(<span class="string">&quot;/book&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;DELETE&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Gin渲染"><a href="#Gin渲染" class="headerlink" title="Gin渲染"></a>Gin渲染</h2><p>这里说的渲染主要是以某种数据格式比如json向客户端发送数据，一般写在回调函数中。然后客户端浏览器会将这些数据渲染在HTML页面中。</p>
<h3 id="JSON渲染"><a href="#JSON渲染" class="headerlink" title="JSON渲染"></a>JSON渲染</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// gin.H 是map[string]interface&#123;&#125;的缩写</span></span><br><span class="line">	r.GET(<span class="string">&quot;/someJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方式一：自己拼接JSON</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/moreJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 方法二：使用结构体</span></span><br><span class="line">		<span class="keyword">var</span> msg <span class="keyword">struct</span> &#123;</span><br><span class="line">			Name    <span class="type">string</span> <span class="string">`json:&quot;user&quot;`</span></span><br><span class="line">			Message <span class="type">string</span></span><br><span class="line">			Age     <span class="type">int</span></span><br><span class="line">		&#125;</span><br><span class="line">		msg.Name = <span class="string">&quot;张三&quot;</span></span><br><span class="line">		msg.Message = <span class="string">&quot;Hello world!&quot;</span></span><br><span class="line">		msg.Age = <span class="number">21</span></span><br><span class="line">		c.JSON(http.StatusOK, msg)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="protobuf渲染"><a href="#protobuf渲染" class="headerlink" title="protobuf渲染"></a>protobuf渲染</h3><p>user.proto:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;./;protoFile&quot;</span>;</span><br><span class="line"><span class="keyword">package</span> protoFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> gender = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int32</span> age = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/proto&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		data := &amp;protoFile.User&#123;</span><br><span class="line">			Name:   <span class="string">&quot;dawnlight&quot;</span>,</span><br><span class="line">			Gender: <span class="string">&quot;男&quot;</span>,</span><br><span class="line">			Age:    <span class="number">20</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		c.ProtoBuf(http.StatusOK, data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br></pre></td></tr></table></figure>


<br>


<h2 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h2><h3 id="获取querystring参数"><a href="#获取querystring参数" class="headerlink" title="获取querystring参数"></a>获取querystring参数</h3><p>querystring指的是URL中?后面携带的参数，例如：<code>/user/search?username=张三&amp;address=上海</code>。 获取请求的querystring参数的方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/user/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		username := c.DefaultQuery(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">		<span class="comment">//username := c.Query(&quot;username&quot;)</span></span><br><span class="line">		address := c.Query(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">		<span class="comment">//输出json结果给调用方</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">			<span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="获取form参数"><a href="#获取form参数" class="headerlink" title="获取form参数"></a>获取form参数</h3><p>当前端请求的数据通过form表单提交时，例如向&#x2F;user&#x2F;search发送一个POST请求，获取请求数据的方式如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.POST(<span class="string">&quot;/user/search&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// DefaultPostForm取不到值时会返回指定的默认值</span></span><br><span class="line">		<span class="comment">//username := c.DefaultPostForm(&quot;username&quot;, &quot;张三&quot;)</span></span><br><span class="line">		username := c.PostForm(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">		address := c.PostForm(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">		<span class="comment">//输出json结果给调用方</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">			<span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取json参数"><a href="#获取json参数" class="headerlink" title="获取json参数"></a>获取json参数</h3><p>当前端请求的数据通过JSON提交时，例如向&#x2F;json发送一个POST请求，则获取请求参数的方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/json&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意：下面为了举例子方便，暂时忽略了错误处理</span></span><br><span class="line">	b, _ := c.GetRawData()  <span class="comment">// 从c.Request.Body读取请求数据</span></span><br><span class="line">	<span class="comment">// 定义map或结构体</span></span><br><span class="line">	<span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 反序列化</span></span><br><span class="line">	_ = json.Unmarshal(b, &amp;m)</span><br><span class="line"></span><br><span class="line">	c.JSON(http.StatusOK, m)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>更便利的获取请求参数的方式，参见下面的 参数绑定 小节。</p>
<h3 id="获取path参数"><a href="#获取path参数" class="headerlink" title="获取path参数"></a>获取path参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//Default返回一个默认的路由引擎</span></span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/user/search/:username/:address&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		username := c.Param(<span class="string">&quot;username&quot;</span>)</span><br><span class="line">		address := c.Param(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">		<span class="comment">//输出json结果给调用方</span></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>:  <span class="string">&quot;ok&quot;</span>,</span><br><span class="line">			<span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">			<span class="string">&quot;address&quot;</span>:  address,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的Content-Type识别请求数据类型并利用反射机制自动提取请求中QueryString、form表单、JSON、XML等参数到结构体中。 下面的示例代码演示了.ShouldBind()强大的功能，它能够基于请求自动提取JSON、form表单和QueryString类型的数据，并把值绑定到指定的结构体对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Binding from JSON</span></span><br><span class="line"><span class="keyword">type</span> Login <span class="keyword">struct</span> &#123;</span><br><span class="line">	User     <span class="type">string</span> <span class="string">`form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`</span></span><br><span class="line">	Password <span class="type">string</span> <span class="string">`form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定JSON的示例 (&#123;&quot;user&quot;: &quot;q1mi&quot;, &quot;password&quot;: &quot;123456&quot;&#125;)</span></span><br><span class="line">	router.POST(<span class="string">&quot;/loginJSON&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> login Login</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;login info:%#v\n&quot;</span>, login)</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定form表单示例 (user=q1mi&amp;password=123456)</span></span><br><span class="line">	router.POST(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> login Login</span><br><span class="line">		<span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 绑定QueryString示例 (/loginQuery?user=q1mi&amp;password=123456)</span></span><br><span class="line">	router.GET(<span class="string">&quot;/loginForm&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> login Login</span><br><span class="line">		<span class="comment">// ShouldBind()会根据请求的Content-Type自行选择绑定器</span></span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBind(&amp;login); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;user&quot;</span>:     login.User,</span><br><span class="line">				<span class="string">&quot;password&quot;</span>: login.Password,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Listen and serve on 0.0.0.0:8080</span></span><br><span class="line">	router.Run(<span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ShouldBind会按照下面的顺序解析请求中的数据完成绑定：</p>
<ul>
<li>如果是 GET 请求，只使用 Form 绑定引擎（query）。</li>
<li>如果是 POST 请求，首先检查 content-type 是否为 JSON 或 XML，然后再使用 Form（form-data）。</li>
</ul>
<p>示例：</p>
<p>html表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> &gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>利用反射来提取表单数据，与结构体绑定在一起：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span>&#123;</span><br><span class="line">	Name <span class="type">string</span> <span class="string">`form:&quot;username&quot;`</span></span><br><span class="line">	Pwd <span class="type">string</span> <span class="string">`form:&quot;password&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLFiles(<span class="string">&quot;2formTest\\userInfo.html&quot;</span>)</span><br><span class="line">	r.GET(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;userInfo.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.POST(<span class="string">&quot;/user&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> user UserInfo</span><br><span class="line">		<span class="keyword">if</span> err := c.ShouldBind(&amp;user); err == <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;username&quot;</span> : user.Name,</span><br><span class="line">				<span class="string">&quot;password&quot;</span> : user.Pwd,</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;error&quot;</span>: err.Error()&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<br>

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="单个文件上传"><a href="#单个文件上传" class="headerlink" title="单个文件上传"></a>单个文件上传</h3><p>文件上传前端页面代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>上传文件<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/upload&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--单文件上传--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--多文件上传--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>后端gin框架部分代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLFiles(<span class="string">&quot;3uploadFile/upload.html&quot;</span>)</span><br><span class="line">	r.GET(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;upload.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		file, err := c.FormFile(<span class="string">&quot;f1&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusInternalServerError, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;message&quot;</span> : err.Error(),</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		log.Println(file.Filename)</span><br><span class="line">		dst := fmt.Sprintf(<span class="string">&quot;F:\\GoProject\\Gin\\ginDemo1\\UploadFile\\%s&quot;</span>, file.Filename)</span><br><span class="line">		c.SaveUploadedFile(file, dst)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span> : fmt.Sprintf(<span class="string">&quot;&#x27;%s&#x27; uploaded!&quot;</span>, file.Filename),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="多个文件上传"><a href="#多个文件上传" class="headerlink" title="多个文件上传"></a>多个文件上传</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLFiles(<span class="string">&quot;3uploadFile/upload.html&quot;</span>)</span><br><span class="line">	r.GET(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;upload.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.POST(<span class="string">&quot;/upload&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		form, _ := c.MultipartForm()</span><br><span class="line">		files := form.File[<span class="string">&quot;file&quot;</span>]</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> index, file := <span class="keyword">range</span> files &#123;</span><br><span class="line">			log.Println(file.Filename)</span><br><span class="line">			dst := fmt.Sprintf(<span class="string">&quot;F:\\GoProject\\Gin\\ginDemo1\\UploadFile\\%s_%d&quot;</span>, file.Filename, index)</span><br><span class="line">			c.SaveUploadedFile(file, dst)</span><br><span class="line">		&#125;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span> : fmt.Sprintf(<span class="string">&quot;%d files uploaded!&quot;</span>, <span class="built_in">len</span>(files)),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h3><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/red&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.Redirect(http.StatusMovedPermanently, <span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:9092&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h3><p>路由重定向，使用HandleContext：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.Request.URL.Path = <span class="string">&quot;/test2&quot;</span></span><br><span class="line">		r.HandleContext(c)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.GET(<span class="string">&quot;/test2&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span> : <span class="string">&quot;route redirect successful&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="Gin路由"><a href="#Gin路由" class="headerlink" title="Gin路由"></a>Gin路由</h2><h3 id="普通路由"><a href="#普通路由" class="headerlink" title="普通路由"></a>普通路由</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">r.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure>

<p>此外，还有一个可以匹配所有请求方法的Any方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.Any(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br></pre></td></tr></table></figure>

<p>为没有配置处理函数的路由添加处理程序，默认情况下它返回404代码，下面的代码为没有匹配到路由的请求都返回views&#x2F;404.html页面。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.NoRoute(<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusNotFound, <span class="string">&quot;views/404.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。习惯性一对{}包裹同组的路由，这只是为了看着清晰，你用不用{}包裹功能上没什么区别。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	userGroup := r.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		userGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		userGroup.GET(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		userGroup.POST(<span class="string">&quot;/login&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/cart&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		shopGroup.POST(<span class="string">&quot;/checkout&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由组也是支持嵌套的，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		shopGroup.GET(<span class="string">&quot;/cart&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		shopGroup.POST(<span class="string">&quot;/checkout&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">		<span class="comment">// 嵌套路由组</span></span><br><span class="line">		xx := shopGroup.Group(<span class="string">&quot;xx&quot;</span>)</span><br><span class="line">		xx.GET(<span class="string">&quot;/oo&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p>
<h3 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h3><p>Gin框架中的路由使用的是<a href="https://github.com/julienschmidt/httprouter">httprouter</a>这个库。</p>
<p>其基本原理就是构造一个路由地址的前缀树。</p>
<h2 id="运行多个服务"><a href="#运行多个服务" class="headerlink" title="运行多个服务"></a>运行多个服务</h2><p>我们可以在多个端口启动服务，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;golang.org/x/sync/errgroup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	g errgroup.Group</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router01</span><span class="params">()</span></span> http.Handler &#123;</span><br><span class="line">	e := gin.New()</span><br><span class="line">	e.Use(gin.Recovery())</span><br><span class="line">	e.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(</span><br><span class="line">			http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>:  http.StatusOK,</span><br><span class="line">				<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Welcome server 01&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">router02</span><span class="params">()</span></span> http.Handler &#123;</span><br><span class="line">	e := gin.New()</span><br><span class="line">	e.Use(gin.Recovery())</span><br><span class="line">	e.GET(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(</span><br><span class="line">			http.StatusOK,</span><br><span class="line">			gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>:  http.StatusOK,</span><br><span class="line">				<span class="string">&quot;error&quot;</span>: <span class="string">&quot;Welcome server 02&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server01 := &amp;http.Server&#123;</span><br><span class="line">		Addr:         <span class="string">&quot;:8080&quot;</span>,</span><br><span class="line">		Handler:      router01(),</span><br><span class="line">		ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">		WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server02 := &amp;http.Server&#123;</span><br><span class="line">		Addr:         <span class="string">&quot;:8081&quot;</span>,</span><br><span class="line">		Handler:      router02(),</span><br><span class="line">		ReadTimeout:  <span class="number">5</span> * time.Second,</span><br><span class="line">		WriteTimeout: <span class="number">10</span> * time.Second,</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">// 借助errgroup.Group或者自行开启两个goroutine分别启动两个服务</span></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> server01.ListenAndServe()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	g.Go(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> server02.ListenAndServe()</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := g.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Gin</category>
      </categories>
  </entry>
  <entry>
    <title>Gin中间件</title>
    <url>/2022/11/02/Gin/2Gin%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="中间件简介"><a href="#中间件简介" class="headerlink" title="中间件简介"></a>中间件简介</h2><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、记录日志、耗时统计等。</p>
<p><img src="https://img-blog.csdnimg.cn/98ba1ac7b36d41c5bd67a608f85a424a.png" alt="在这里插入图片描述"><br>简而言之，中间件是用在两个模块之间的功能软件，比如在前后台开发中：</p>
<p><code>路由 ——&gt; 中间件 (起过滤作用) ——&gt; 控制器</code></p>
<p>在Gin中，中间件的效果可以简单的概括为：</p>
<ul>
<li>设置好中间件以后，中间件后面的路由都会使用这个中间件</li>
<li>设置在中间件之前的路由则不会生效</li>
</ul>
<h2 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h2><p>Gin中的中间件必须是一个<code>gin.HandlerFunc</code>类型，在自定义中间件函数时，有两种写法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">(c *gin.Context)</span></span> &#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用中间件</span></span><br><span class="line">r.Use(Test)</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> gin.HandlerFunc &#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用中间件</span></span><br><span class="line">r.Use(Test())</span><br></pre></td></tr></table></figure>

<h2 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h2><p>在gin框架中，我们可以为每个路由添加任意数量的中间件。</p>
<h3 id="为全局路由注册"><a href="#为全局路由注册" class="headerlink" title="为全局路由注册"></a>为全局路由注册</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 新建一个没有任何默认中间件的路由</span></span><br><span class="line">	r := gin.New()</span><br><span class="line">	<span class="comment">// 注册一个全局中间件</span></span><br><span class="line">	r.Use(StatCost())</span><br><span class="line">	</span><br><span class="line">	r.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="type">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">		log.Println(name)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为某个路由单独注册"><a href="#为某个路由单独注册" class="headerlink" title="为某个路由单独注册"></a>为某个路由单独注册</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给/test2路由单独注册中间件（可注册多个）</span></span><br><span class="line">	r.GET(<span class="string">&quot;/test2&quot;</span>, StatCost(), <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		name := c.MustGet(<span class="string">&quot;name&quot;</span>).(<span class="type">string</span>) <span class="comment">// 从上下文取值</span></span><br><span class="line">		log.Println(name)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello world!&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="为路由组注册中间件"><a href="#为路由组注册中间件" class="headerlink" title="为路由组注册中间件"></a>为路由组注册中间件</h3><p>为路由组注册中间件有以下两种写法。</p>
<p>写法1：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>, StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法2：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">shopGroup := r.Group(<span class="string">&quot;/shop&quot;</span>)</span><br><span class="line">shopGroup.Use(StatCost())</span><br><span class="line">&#123;</span><br><span class="line">    shopGroup.GET(<span class="string">&quot;/index&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;...&#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="中间件的嵌套"><a href="#中间件的嵌套" class="headerlink" title="中间件的嵌套"></a>中间件的嵌套</h2><p>中间件可以嵌套使用，这里有三个相关的函数。</p>
<h3 id="Next"><a href="#Next" class="headerlink" title="Next()"></a>Next()</h3><p>表示跳过当前中间件剩余内容， 去执行下一个中间件。 当所有操作执行完之后，以出栈的执行顺序返回，执行剩余代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建中间件</span></span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="title">Test1</span><span class="params">(ctx *gin.Context)</span></span>  &#123;</span><br><span class="line">      	fmt.Println(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">      	ctx.Next()</span><br><span class="line">      	fmt.Println(<span class="string">&quot;4444&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建 另外一种格式的中间件.</span></span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="title">Test2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">      	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">      		fmt.Println(<span class="string">&quot;3333&quot;</span>)</span><br><span class="line">      		context.Next()</span><br><span class="line">      		fmt.Println(<span class="string">&quot;5555&quot;</span>)</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">      	router := gin.Default()</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 使用中间件</span></span><br><span class="line">      	router.Use(Test1)</span><br><span class="line">      	router.Use(Test2())</span><br><span class="line">      </span><br><span class="line">      	router.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">      		fmt.Println(<span class="string">&quot;2222&quot;</span>)</span><br><span class="line">      		context.Writer.WriteString(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">      	&#125;)</span><br><span class="line">      </span><br><span class="line">      	router.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h3><p>终止执行当前中间件剩余内容，执行下一个中间件。 当所有的函数执行结束后，以出栈的顺序执行返回，但，不执行return后的代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建中间件</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">Test1</span><span class="params">(ctx *gin.Context)</span></span>  &#123;</span><br><span class="line">    	fmt.Println(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line">    	</span><br><span class="line">    	ctx.Next()</span><br><span class="line"></span><br><span class="line">    	fmt.Println(<span class="string">&quot;4444&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 另外一种格式的中间件.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">Test2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">    		fmt.Println(<span class="string">&quot;3333&quot;</span>)</span><br><span class="line"></span><br><span class="line">    		<span class="keyword">return</span></span><br><span class="line">    		context.Next()</span><br><span class="line"></span><br><span class="line">    		fmt.Println(<span class="string">&quot;5555&quot;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    	router := gin.Default()</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 使用中间件</span></span><br><span class="line">    	router.Use(Test1)</span><br><span class="line">    	router.Use(Test2())</span><br><span class="line"></span><br><span class="line">    	router.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">    		fmt.Println(<span class="string">&quot;2222&quot;</span>)</span><br><span class="line">    		context.Writer.WriteString(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    	&#125;)</span><br><span class="line"></span><br><span class="line">    	router.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Abort"><a href="#Abort" class="headerlink" title="Abort()"></a>Abort()</h3><p>只执行当前中间件， 操作完成后，以出栈的顺序，依次返回上一级中间件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建中间件</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">Test1</span><span class="params">(ctx *gin.Context)</span></span>  &#123;</span><br><span class="line">    	fmt.Println(<span class="string">&quot;1111&quot;</span>)</span><br><span class="line"></span><br><span class="line">    	ctx.Next()</span><br><span class="line"></span><br><span class="line">    	fmt.Println(<span class="string">&quot;4444&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 另外一种格式的中间件.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">Test2</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">    		fmt.Println(<span class="string">&quot;3333&quot;</span>)</span><br><span class="line"></span><br><span class="line">    		context.Abort()</span><br><span class="line"></span><br><span class="line">    		fmt.Println(<span class="string">&quot;5555&quot;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    	router := gin.Default()</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 使用中间件</span></span><br><span class="line">    	router.Use(Test1)</span><br><span class="line">    	router.Use(Test2())</span><br><span class="line"></span><br><span class="line">    	router.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">    		fmt.Println(<span class="string">&quot;2222&quot;</span>)</span><br><span class="line">    		context.Writer.WriteString(<span class="string">&quot;hello world!&quot;</span>)</span><br><span class="line">    	&#125;)</span><br><span class="line"></span><br><span class="line">    	router.Run(<span class="string">&quot;:9999&quot;</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="中间件注意事项"><a href="#中间件注意事项" class="headerlink" title="中间件注意事项"></a>中间件注意事项</h2><h3 id="gin默认中间件"><a href="#gin默认中间件" class="headerlink" title="gin默认中间件"></a>gin默认中间件</h3><p>gin.Default()默认使用了Logger和Recovery中间件，其中：</p>
<ul>
<li>Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE&#x3D;release。</li>
<li>Recovery中间件会recover任何panic。如果有panic的话，会写入500响应码。</li>
</ul>
<p>如果不想使用上面两个默认的中间件，可以使用gin.New()新建一个没有任何默认中间件的路由。</p>
<h3 id="gin中间件中使用goroutine"><a href="#gin中间件中使用goroutine" class="headerlink" title="gin中间件中使用goroutine"></a>gin中间件中使用goroutine</h3><p>当在中间件或handler中启动新的goroutine时，不能使用原始的上下文（c *gin.Context），必须使用其只读副本（c.Copy()）。</p>
]]></content>
      <categories>
        <category>Gin</category>
      </categories>
  </entry>
  <entry>
    <title>Gin路由拆分与注册</title>
    <url>/2022/11/02/Gin/3Gin%E8%B7%AF%E7%94%B1%E6%8B%86%E5%88%86%E4%B8%8E%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h2 id="基本的路由注册"><a href="#基本的路由注册" class="headerlink" title="基本的路由注册"></a>基本的路由注册</h2><p>下面最基础的gin路由注册方式，适用于路由条目比较少的简单项目或者项目demo。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello light!&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">	<span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由拆分成单独文件或包"><a href="#路由拆分成单独文件或包" class="headerlink" title="路由拆分成单独文件或包"></a>路由拆分成单独文件或包</h2><p>我们在routers.go文件中定义并注册路由信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello light!&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupRouter</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时main.go中调用上面定义好的setupRouter函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := setupRouter()</span><br><span class="line">	<span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的目录结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers.go</span><br></pre></td></tr></table></figure>

<p>把路由部分的代码单独拆分成包的话也是可以的，拆分后的目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    └── routers.go</span><br></pre></td></tr></table></figure>

<p>routers&#x2F;routers.go需要注意此时setupRouter需要改成首字母大写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> routers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello light!&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupRouter 配置路由信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main.<span class="keyword">go</span>文件内容如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;gin_demo/routers&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := routers.SetupRouter()</span><br><span class="line">	<span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由拆分成多个文件"><a href="#路由拆分成多个文件" class="headerlink" title="路由拆分成多个文件"></a>路由拆分成多个文件</h2><p>当我们的业务规模继续膨胀，单独的一个routers文件或包已经满足不了我们的需求了，</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupRouter</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">    r := gin.Default()</span><br><span class="line">    r.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    r.GET(<span class="string">&quot;/xx1&quot;</span>, xxHandler1)</span><br><span class="line">    ...</span><br><span class="line">    r.GET(<span class="string">&quot;/xx30&quot;</span>, xxHandler30)</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们把所有的路由注册都写在一个SetupRouter函数中的话就会太复杂了。</p>
<p>我们可以分开定义多个路由文件，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    ├── blog.go</span><br><span class="line">    └── shop.go</span><br></pre></td></tr></table></figure>

<p>routers&#x2F;shop.go中添加一个LoadShop的函数，将shop相关的路由注册到指定的路由器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadShop</span><span class="params">(e *gin.Engine)</span></span>  &#123;</span><br><span class="line">	e.GET(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">	e.GET(<span class="string">&quot;/goods&quot;</span>, goodsHandler)</span><br><span class="line">	e.GET(<span class="string">&quot;/checkout&quot;</span>, checkoutHandler)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>routers&#x2F;blog.go中添加一个LoadBlog的函数，将blog相关的路由注册到指定的路由器：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadBlog</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">	e.GET(<span class="string">&quot;/post&quot;</span>, postHandler)</span><br><span class="line">	e.GET(<span class="string">&quot;/comment&quot;</span>, commentHandler)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main函数中实现最终的注册逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	routers.LoadBlog(r)</span><br><span class="line">	routers.LoadShop(r)</span><br><span class="line">	<span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="路由拆分到不同的APP"><a href="#路由拆分到不同的APP" class="headerlink" title="路由拆分到不同的APP"></a>路由拆分到不同的APP</h2><p>有时候项目规模实在太大，那么我们就更倾向于把业务拆分的更详细一些，例如把不同的业务代码拆分成不同的APP。</p>
<p>因此我们在项目目录下单独定义一个app目录，用来存放我们不同业务线的代码文件，这样就很容易进行横向扩展。大致目录结构如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gin_demo</span><br><span class="line">├── app</span><br><span class="line">│   ├── blog</span><br><span class="line">│   │   ├── handler.go</span><br><span class="line">│   │   └── router.go</span><br><span class="line">│   └── shop</span><br><span class="line">│       ├── handler.go</span><br><span class="line">│       └── router.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── routers</span><br><span class="line">    └── routers.go</span><br></pre></td></tr></table></figure>

<p>其中app&#x2F;blog&#x2F;router.go用来定义blog相关的路由信息，具体内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routers</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">	e.GET(<span class="string">&quot;/post&quot;</span>, postHandler)</span><br><span class="line">	e.GET(<span class="string">&quot;/comment&quot;</span>, commentHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app&#x2F;shop&#x2F;router.go用来定义shop相关路由信息，具体内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Routers</span><span class="params">(e *gin.Engine)</span></span> &#123;</span><br><span class="line">	e.GET(<span class="string">&quot;/goods&quot;</span>, goodsHandler)</span><br><span class="line">	e.GET(<span class="string">&quot;/checkout&quot;</span>, checkoutHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>routers&#x2F;routers.go中根据需要定义Include函数用来注册子app中定义的路由，Init函数用来进行路由的初始化操作：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Option <span class="function"><span class="keyword">func</span><span class="params">(*gin.Engine)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = []Option&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册app的路由配置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Include</span><span class="params">(opts ...Option)</span></span> &#123;</span><br><span class="line">	options = <span class="built_in">append</span>(options, opts...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> *gin.Engine &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> options &#123;</span><br><span class="line">		opt(r)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.go中按如下方式先注册子app中的路由，然后再进行路由的初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 加载多个APP的路由配置</span></span><br><span class="line">	routers.Include(shop.Routers, blog.Routers)</span><br><span class="line">	<span class="comment">// 初始化路由</span></span><br><span class="line">	r := routers.Init()</span><br><span class="line">	<span class="keyword">if</span> err := r.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;startup service failed, err:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Gin</category>
      </categories>
  </entry>
  <entry>
    <title>Gin框架中使用JWT</title>
    <url>/2022/11/02/Gin/4gin%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8JWT/</url>
    <content><![CDATA[<p>JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。</p>
<h2 id="什么是JWT？"><a href="#什么是JWT？" class="headerlink" title="什么是JWT？"></a>什么是JWT？</h2><p>JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。</p>
<h2 id="为什么需要JWT？"><a href="#为什么需要JWT？" class="headerlink" title="为什么需要JWT？"></a>为什么需要JWT？</h2><p>在之前的一些web项目中，我们通常使用的是Cookie-Session模式实现用户认证。相关流程大致如下：</p>
<ol>
<li>用户在浏览器端填写用户名和密码，并发送给服务端</li>
<li>服务端对用户名和密码校验通过后会生成一份保存当前用户相关信息的session数据和一个与之对应的标识（通常称为session_id）</li>
<li>服务端返回响应时将上一步的session_id写入用户浏览器的Cookie</li>
<li>后续用户来自该浏览器的每次请求都会自动携带包含session_id的Cookie</li>
<li>服务端通过请求中的session_id就能找到之前保存的该用户那份session数据，从而获取该用户的相关信息。</li>
</ol>
<p>这种方案依赖于客户端（浏览器）保存Cookie，并且需要在服务端存储用户的session数据。</p>
<p>在移动互联网时代，我们的用户可能使用浏览器也可能使用APP来访问我们的服务，我们的web应用可能是前后端分开部署在不同的端口，有时候我们还需要支持第三方登录，这下Cookie-Session的模式就有些力不从心了。</p>
<p>JWT就是一种基于Token的轻量级认证模式，服务端认证通过后，会生成一个JSON对象，经过签名后得到一个Token（令牌）再发回给用户，用户后续请求只需要带上这个Token，服务端解密之后就能获取该用户的相关信息了。</p>
<h2 id="生成JWT和解析JWT"><a href="#生成JWT和解析JWT" class="headerlink" title="生成JWT和解析JWT"></a>生成JWT和解析JWT</h2><p>我们在这里直接使用<a href="https://github.com/dgrijalva/jwt-go">jwt-go</a>这个库来实现我们生成JWT和解析JWT的功能。</p>
<p>安装jwt-go：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/dgrijalva/jwt-<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p><strong>定义需求</strong></p>
<p>我们需要定制自己的需求来决定JWT中保存哪些数据，比如我们规定在JWT中要存储username信息，那么我们就定义一个MyClaims结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClaims 自定义声明结构体并内嵌jwt.StandardClaims</span></span><br><span class="line"><span class="comment">// jwt包自带的jwt.StandardClaims只包含了官方字段</span></span><br><span class="line"><span class="comment">// 我们这里需要额外记录一个username字段，所以要自定义结构体</span></span><br><span class="line"><span class="comment">// 如果想要保存更多信息，都可以添加到这个结构体中</span></span><br><span class="line"><span class="keyword">type</span> MyClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">	jwt.StandardClaims</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们定义JWT的过期时间，这里以2小时为例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TokenExpireDuration = time.Hour * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>接下来还需要定义Secret：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MySecret = []<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>生成JWT</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GenToken 生成JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenToken</span><span class="params">(username <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建一个我们自己的声明</span></span><br><span class="line">	c := MyClaims&#123;</span><br><span class="line">		username, <span class="comment">// 自定义字段</span></span><br><span class="line">		jwt.StandardClaims&#123;</span><br><span class="line">			ExpiresAt: time.Now().Add(TokenExpireDuration).Unix(), <span class="comment">// 过期时间</span></span><br><span class="line">			Issuer:    <span class="string">&quot;my-project&quot;</span>,                               <span class="comment">// 签发人</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用指定的签名方法创建签名对象</span></span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodHS256, c)</span><br><span class="line">	<span class="comment">// 使用指定的secret签名并获得完整的编码后的字符串token</span></span><br><span class="line">	<span class="keyword">return</span> token.SignedString(MySecret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析JWT</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ParseToken 解析JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="type">string</span>)</span></span> (*MyClaims, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 解析token</span></span><br><span class="line">	token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (i <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> MySecret, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123; <span class="comment">// 校验token</span></span><br><span class="line">		<span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在gin框架中使用JWT"><a href="#在gin框架中使用JWT" class="headerlink" title="在gin框架中使用JWT"></a>在gin框架中使用JWT</h2><p>首先我们注册一条路由&#x2F;auth，对外提供获取Token的渠道：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r.POST(<span class="string">&quot;/auth&quot;</span>, authHandler)</span><br><span class="line"></span><br><span class="line">我们的authHandler定义如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 用户发送用户名和密码过来</span></span><br><span class="line">	<span class="keyword">var</span> user UserInfo</span><br><span class="line">	err := c.ShouldBind(&amp;user)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;code&quot;</span>: <span class="number">2001</span>,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;无效的参数&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验用户名和密码是否正确</span></span><br><span class="line">	<span class="keyword">if</span> user.Username == <span class="string">&quot;q1mi&quot;</span> &amp;&amp; user.Password == <span class="string">&quot;q1mi123&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 生成Token</span></span><br><span class="line">		tokenString, _ := GenToken(user.Username)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;code&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;success&quot;</span>,</span><br><span class="line">			<span class="string">&quot;data&quot;</span>: gin.H&#123;<span class="string">&quot;token&quot;</span>: tokenString&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span>: <span class="number">2002</span>,</span><br><span class="line">		<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;鉴权失败&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用户通过上面的接口获取Token之后，后续就会携带着Token再来请求我们的其他接口，这个时候就需要对这些请求的Token进行校验操作了，很显然我们应该实现一个检验Token的中间件，具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JWTAuthMiddleware 基于JWT的认证中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWTAuthMiddleware</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI</span></span><br><span class="line">		<span class="comment">// 这里假设Token放在Header的Authorization中，并使用Bearer开头</span></span><br><span class="line">		<span class="comment">// 这里的具体实现方式要依据你的实际业务情况决定</span></span><br><span class="line">		authHeader := c.PostForm(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> authHeader == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>: <span class="number">2003</span>,</span><br><span class="line">				<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;请求头中auth为空&quot;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 按空格分割</span></span><br><span class="line">		parts := strings.SplitN(authHeader, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> !(<span class="built_in">len</span>(parts) == <span class="number">2</span> &amp;&amp; parts[<span class="number">0</span>] == <span class="string">&quot;Bearer&quot;</span>) &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>: <span class="number">2004</span>,</span><br><span class="line">				<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;请求头中auth格式有误&quot;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// parts[1]是获取到的tokenString，我们使用之前定义好的解析JWT的函数来解析它</span></span><br><span class="line">		mc, err := ParseToken(parts[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>: <span class="number">2005</span>,</span><br><span class="line">				<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;无效的Token&quot;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将当前请求的username信息保存到请求的上下文c上</span></span><br><span class="line">		c.Set(<span class="string">&quot;username&quot;</span>, mc.Username)</span><br><span class="line">		c.Next() <span class="comment">// 后续的处理函数可以用过c.Get(&quot;username&quot;)来获取当前请求的用户信息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注册一个/home路由，发个请求验证一下吧。</span><br><span class="line"></span><br><span class="line">r.GET(<span class="string">&quot;/home&quot;</span>, JWTAuthMiddleware(), homeHandler)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	username := c.MustGet(<span class="string">&quot;username&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">		<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;success&quot;</span>,</span><br><span class="line">		<span class="string">&quot;data&quot;</span>: gin.H&#123;<span class="string">&quot;username&quot;</span>: username&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不想自己实现上述功能，你也可以使用Github上别人封装好的包，比如<a href="https://github.com/appleboy/gin-jwt">https://github.com/appleboy/gin-jwt</a>。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下面是我自己做的一个小示例：</p>
<p>token.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username <span class="type">string</span> <span class="string">`json:&quot;username&quot;`</span></span><br><span class="line">	jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TokenExpireDuration = time.Hour * <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mySecret = []<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenToken 生成JWT</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenToken</span><span class="params">(username <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	c := MyClaims&#123;</span><br><span class="line">		<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		jwt.StandardClaims&#123;</span><br><span class="line">			ExpiresAt: time.Now().Add(TokenExpireDuration).Unix(),</span><br><span class="line">			Issuer: <span class="string">&quot;myProject&quot;</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodHS256, c)</span><br><span class="line">	<span class="comment">/*fmt.Println(&quot;secret: &quot;, mySecret)</span></span><br><span class="line"><span class="comment">	fmt.Println(&quot;token: &quot;, token)*/</span></span><br><span class="line">	tmp, err := token.SignedString(mySecret)</span><br><span class="line">	<span class="comment">/*fmt.Println(&quot;生成的token令牌：&quot;, tmp)*/</span></span><br><span class="line">	<span class="keyword">return</span> tmp, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenSring <span class="type">string</span>)</span></span> (*MyClaims, <span class="type">error</span>) &#123;</span><br><span class="line">	token, err := jwt.ParseWithClaims(tokenSring, &amp;MyClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> mySecret, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> Claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123;</span><br><span class="line">		<span class="keyword">return</span> Claims, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>main.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Username <span class="type">string</span> <span class="string">`form:&quot;username&quot;`</span></span><br><span class="line">	Password <span class="type">string</span> <span class="string">`form:&quot;password&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 用户发送用户名和密码过来</span></span><br><span class="line">	<span class="keyword">var</span> user UserInfo</span><br><span class="line">	err := c.ShouldBind(&amp;user)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;code&quot;</span>: <span class="number">2001</span>,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;无效的参数&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 校验用户名和密码是否正确</span></span><br><span class="line">	<span class="keyword">if</span> user.Username == <span class="string">&quot;张三&quot;</span> &amp;&amp; user.Password == <span class="string">&quot;123456&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 生成Token</span></span><br><span class="line">		tokenString, _ := GenToken(user.Username)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;code&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">			<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;success&quot;</span>,</span><br><span class="line">			<span class="string">&quot;data&quot;</span>: gin.H&#123;<span class="string">&quot;token&quot;</span>: tokenString&#125;,</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span>: <span class="number">2002</span>,</span><br><span class="line">		<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;鉴权失败&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JWTAuthMiddleware 基于JWT的认证中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWTAuthMiddleware</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 客户端携带Token有三种方式 1.放在请求头 2.放在请求体 3.放在URI</span></span><br><span class="line">		<span class="comment">// 这里假设Token放在Header的Authorization中，并使用Bearer开头</span></span><br><span class="line">		<span class="comment">// 这里的具体实现方式要依据你的实际业务情况决定</span></span><br><span class="line">		authHeader := c.PostForm(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> authHeader == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>: <span class="number">2003</span>,</span><br><span class="line">				<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;请求头中auth为空&quot;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 按空格分割</span></span><br><span class="line">		parts := strings.SplitN(authHeader, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">		<span class="keyword">if</span> !(<span class="built_in">len</span>(parts) == <span class="number">2</span> &amp;&amp; parts[<span class="number">0</span>] == <span class="string">&quot;Bearer&quot;</span>) &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>: <span class="number">2004</span>,</span><br><span class="line">				<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;请求头中auth格式有误&quot;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// parts[1]是获取到的tokenString，我们使用之前定义好的解析JWT的函数来解析它</span></span><br><span class="line">		mc, err := ParseToken(parts[<span class="number">1</span>])</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">				<span class="string">&quot;code&quot;</span>: <span class="number">2005</span>,</span><br><span class="line">				<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;无效的Token&quot;</span>,</span><br><span class="line">			&#125;)</span><br><span class="line">			c.Abort()</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将当前请求的username信息保存到请求的上下文c上</span></span><br><span class="line">		c.Set(<span class="string">&quot;username&quot;</span>, mc.Username)</span><br><span class="line">		c.Next() <span class="comment">// 后续的处理函数可以用过c.Get(&quot;username&quot;)来获取当前请求的用户信息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">homeHandler</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	username := c.MustGet(<span class="string">&quot;username&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;code&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">		<span class="string">&quot;msg&quot;</span>:  <span class="string">&quot;success&quot;</span>,</span><br><span class="line">		<span class="string">&quot;data&quot;</span>: gin.H&#123;<span class="string">&quot;username&quot;</span>: username&#125;,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.LoadHTMLFiles(<span class="string">&quot;./login.html&quot;</span>, <span class="string">&quot;./login2.html&quot;</span>)</span><br><span class="line">	r.GET(<span class="string">&quot;/auth&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;login.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.POST(<span class="string">&quot;/auth&quot;</span>, authHandler)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/home&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.HTML(http.StatusOK, <span class="string">&quot;login2.html&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.POST(<span class="string">&quot;/home&quot;</span>, JWTAuthMiddleware(), homeHandler)</span><br><span class="line">	r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>login.html</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form method=<span class="string">&quot;post&quot;</span> action=<span class="string">&quot;/auth&quot;</span>&gt;</span><br><span class="line">            &lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">            &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">            &lt;label&gt;密码：&lt;/label&gt;</span><br><span class="line">            &lt;input <span class="keyword">type</span>=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span> &gt; &lt;br&gt;</span><br><span class="line"></span><br><span class="line">            &lt;input <span class="keyword">type</span>=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>login2.html</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;IE=edge&quot;</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">&quot;viewport&quot;</span> content=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;携带token的token认证&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">&quot;/home&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">        &lt;label&gt;token：&lt;/label&gt;</span><br><span class="line">        &lt;input <span class="keyword">type</span>=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;Authorization&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">        &lt;input <span class="keyword">type</span>=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交token&quot;</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>执行步骤</strong></p>
<ol>
<li><p>使用命令<code>go run main.go token.go</code>启动示例。</p>
</li>
<li><p>在浏览器中输入<code>http://localhost:9090/auth</code>访问登录页面，填写用户名和密码，服务器会根据用户信息生成一个token发送给客户端浏览器。</p>
<p> <img src="https://img-blog.csdnimg.cn/a0fbcf6daee84d4d9384d129ab6ec241.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/78910abcc6ed4273abf451344d205d8a.png" alt="在这里插入图片描述"><br> 3.在浏览器中输入<code>http://localhost:9090/home</code>，输入token，实现携带token访问服务器，认证成功。</p>
<p> <img src="https://img-blog.csdnimg.cn/21086c8e02214f2b88c65abcf89e26de.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/15f5c110b461433bbe80dd4a132c90a9.png" alt="在这里插入图片描述"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Gin</category>
      </categories>
  </entry>
  <entry>
    <title>使用Air热重载Go程序</title>
    <url>/2022/11/02/Gin/5%E4%BD%BF%E7%94%A8Air%E7%83%AD%E9%87%8D%E8%BD%BDGo%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>我们在启动一个web程序以后，如果中间需要不断对代码进行修改，每次修改以后都需要重新启动程序，非常麻烦。</p>
<h2 id="Air介绍"><a href="#Air介绍" class="headerlink" title="Air介绍"></a>Air介绍</h2><p>Github上有一个工具：<a href="https://github.com/cosmtrek/air">Air</a>，可以基于gin框架开发时实现热重载。</p>
<p>它还支持以下特性：</p>
<ol>
<li>彩色日志输出</li>
<li>自定义构建或二进制命令</li>
<li>支持忽略子目录</li>
<li>启动后支持监听新目录</li>
<li>更好的构建过程</li>
</ol>
<h2 id="安装Air"><a href="#安装Air" class="headerlink" title="安装Air"></a>安装Air</h2><p>直接使用以下命令在github中拉取即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/cosmtrek/air</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用Air"><a href="#使用Air" class="headerlink" title="使用Air"></a>使用Air</h2><p><strong>1.在当前目录下创建一个新的配置文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> .air.conf</span><br></pre></td></tr></table></figure>

<p><strong>2.复制下面的内容到上面的配置文件中</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># [Air](https://github.com/cosmtrek/air) TOML 格式的配置文件</span><br><span class="line"></span><br><span class="line"># 工作目录</span><br><span class="line"># 使用 . 或绝对路径，请注意 `tmp_dir` 目录必须在 `root` 目录下</span><br><span class="line">root = &quot;.&quot;</span><br><span class="line">tmp_dir = &quot;tmp&quot;</span><br><span class="line"></span><br><span class="line">[build]</span><br><span class="line"># 只需要写你平常编译使用的shell命令。你也可以使用 `make`</span><br><span class="line"># Windows平台示例: cmd = &quot;go build -o tmp\main.exe .&quot;</span><br><span class="line">cmd = &quot;go build -o ./tmp/main .&quot;</span><br><span class="line"># 由`cmd`命令得到的二进制文件名</span><br><span class="line"># Windows平台示例：bin = &quot;tmp\main.exe&quot;</span><br><span class="line">bin = &quot;tmp/main&quot;</span><br><span class="line"># 自定义执行程序的命令，可以添加额外的编译标识例如添加 GIN_MODE=release</span><br><span class="line"># Windows平台示例：full_bin = &quot;tmp\main.exe&quot;</span><br><span class="line">full_bin = &quot;APP_ENV=dev APP_USER=air ./tmp/main&quot;</span><br><span class="line"># 监听以下文件扩展名的文件.</span><br><span class="line">include_ext = [&quot;go&quot;, &quot;tpl&quot;, &quot;tmpl&quot;, &quot;html&quot;]</span><br><span class="line"># 忽略这些文件扩展名或目录</span><br><span class="line">exclude_dir = [&quot;assets&quot;, &quot;tmp&quot;, &quot;vendor&quot;, &quot;frontend/node_modules&quot;]</span><br><span class="line"># 监听以下指定目录的文件</span><br><span class="line">include_dir = []</span><br><span class="line"># 排除以下文件</span><br><span class="line">exclude_file = []</span><br><span class="line"># 如果文件更改过于频繁，则没有必要在每次更改时都触发构建。可以设置触发构建的延迟时间</span><br><span class="line">delay = 1000 # ms</span><br><span class="line"># 发生构建错误时，停止运行旧的二进制文件。</span><br><span class="line">stop_on_error = true</span><br><span class="line"># air的日志文件名，该日志文件放置在你的`tmp_dir`中</span><br><span class="line">log = &quot;air_errors.log&quot;</span><br><span class="line"></span><br><span class="line">[log]</span><br><span class="line"># 显示日志时间</span><br><span class="line">time = true</span><br><span class="line"></span><br><span class="line">[color]</span><br><span class="line"># 自定义每个部分显示的颜色。如果找不到颜色，使用原始的应用程序日志。</span><br><span class="line">main = &quot;magenta&quot;</span><br><span class="line">watcher = &quot;cyan&quot;</span><br><span class="line">build = &quot;yellow&quot;</span><br><span class="line">runner = &quot;green&quot;</span><br><span class="line"></span><br><span class="line">[misc]</span><br><span class="line"># 退出时删除tmp目录</span><br><span class="line">clean_on_exit = true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3.进入需要监听的目录下，使用下面的命令即可</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">air</span><br></pre></td></tr></table></figure>
<p>然后我们在调试代码的使用就不需要重启程序了。</p>
]]></content>
      <categories>
        <category>Gin</category>
      </categories>
  </entry>
  <entry>
    <title>Gin操作Cookie和Session</title>
    <url>/2022/11/02/Gin/6Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie是什么"><a href="#Cookie是什么" class="headerlink" title="Cookie是什么"></a>Cookie是什么</h3><p>在 Internet 中，Cookie 实际上是指小量信息，是由 Web 服务器创建的，将信息存储在用户计算机上（客户端）的数据文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理。</p>
<h3 id="Cookie的机制"><a href="#Cookie的机制" class="headerlink" title="Cookie的机制"></a>Cookie的机制</h3><p>Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key&#x2F;value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p>
<p>总结一下Cookie的特点：</p>
<ol>
<li>浏览器发送请求的时候，自动把携带该站点之前存储的Cookie信息。</li>
<li>服务端可以设置Cookie数据。</li>
<li>Cookie是针对单个域名的，不同域名之间的Cookie是独立的。</li>
<li>Cookie数据可以配置过期时间，过期的Cookie数据会被系统清除。</li>
</ol>
<h2 id="go操作Cookie"><a href="#go操作Cookie" class="headerlink" title="go操作Cookie"></a>go操作Cookie</h2><p>标准库<code>net/http</code>中定义了Cookie，它代表一个出现在HTTP响应头中Set-Cookie的值里或者HTTP请求头中Cookie的值的<code>HTTP cookie</code>。</p>
<h3 id="Cookie结构体"><a href="#Cookie结构体" class="headerlink" title="Cookie结构体"></a>Cookie结构体</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cookie <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name       <span class="type">string</span>  <span class="comment">//名称，相当于key</span></span><br><span class="line">    Value      <span class="type">string</span>  <span class="comment">//内容</span></span><br><span class="line">    Path       <span class="type">string</span>  <span class="comment">//路径，通常传&quot;&quot;</span></span><br><span class="line">    Domain     <span class="type">string</span>  <span class="comment">//域名，ip地址</span></span><br><span class="line">    Expires    time.Time</span><br><span class="line">    RawExpires <span class="type">string</span></span><br><span class="line">    <span class="comment">// MaxAge=0表示未设置Max-Age属性</span></span><br><span class="line">    <span class="comment">// MaxAge&lt;0表示立刻删除该cookie，等价于&quot;Max-Age: 0&quot;</span></span><br><span class="line">    <span class="comment">// MaxAge&gt;0表示存在Max-Age属性，单位是秒</span></span><br><span class="line">    MaxAge   <span class="type">int</span></span><br><span class="line">    <span class="comment">//设置是否安全保护。true：不能在 地址栏前，点击查看。 可以使用 F12 查看。</span></span><br><span class="line">	<span class="comment">//               false：能在 地址栏前，点击查看。</span></span><br><span class="line">    Secure   <span class="type">bool</span>  </span><br><span class="line">    HttpOnly <span class="type">bool</span>  <span class="comment">//是否只针对http协议。</span></span><br><span class="line">    Raw      <span class="type">string</span></span><br><span class="line">    Unparsed []<span class="type">string</span> <span class="comment">// 未解析的“属性-值”对的原始文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="设置Cookie"><a href="#设置Cookie" class="headerlink" title="设置Cookie"></a>设置Cookie</h3><p><code>net/http</code>中提供了如下<code>SetCookie</code>函数，它在w的头域中添加Set-Cookie头，该HTTP头的值为cookie。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetCookie</span><span class="params">(w ResponseWriter, cookie *Cookie)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><p><code>Request</code>对象拥有两个获取Cookie的方法和一个添加Cookie的方法：</p>
<p>获取Cookie的两种方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析并返回该请求的Cookie头设置的所有cookie</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> Cookies() []*Cookie</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> Cookie(name <span class="type">string</span>) (*Cookie, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>添加Cookie的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AddCookie向请求中添加一个cookie。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Request)</span></span> AddCookie(c *Cookie)</span><br></pre></td></tr></table></figure>


<h2 id="gin操作Cookie"><a href="#gin操作Cookie" class="headerlink" title="gin操作Cookie"></a>gin操作Cookie</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := gin.Default()</span><br><span class="line">    router.GET(<span class="string">&quot;/cookie&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        cookie, err := c.Cookie(<span class="string">&quot;gin_cookie&quot;</span>) <span class="comment">// 获取Cookie</span></span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            cookie = <span class="string">&quot;NotSet&quot;</span></span><br><span class="line">            <span class="comment">// 设置Cookie</span></span><br><span class="line">            c.SetCookie(<span class="string">&quot;gin_cookie&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="number">3600</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;localhost&quot;</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Cookie value: %s \n&quot;</span>, cookie)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    router.Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session的由来"><a href="#Session的由来" class="headerlink" title="Session的由来"></a>Session的由来</h3><p>Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是<code>Session</code>。</p>
<p>问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。</p>
<p>用户登陆成功之后，我们在服务端为每个用户创建一个特定的session和一个唯一的标识，它们一一对应。其中：</p>
<ul>
<li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li>
<li>唯一标识通常称为Session ID会写入用户的Cookie中。</li>
</ul>
<p>这样该用户后续再次访问时，请求会自动携带Cookie数据（其中包含了<code>Session ID</code>），服务器通过该<code>Session ID</code>就能找到与之对应的Session数据，也就知道来的人是“谁”。</p>
<p>总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在服务端为每个用户保存一个Session数据，该Session数据中能够保存具体的用户数据信息。</p>
<p>另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。</p>
<h3 id="Cookie和Session生成过程"><a href="#Cookie和Session生成过程" class="headerlink" title="Cookie和Session生成过程"></a>Cookie和Session生成过程</h3><p><img src="https://img-blog.csdnimg.cn/e78ed821008e42b087a3819041ddc391.png" alt="在这里插入图片描述"></p>
<h2 id="gin操作Session"><a href="#gin操作Session" class="headerlink" title="gin操作Session"></a>gin操作Session</h2><p>gin框架默认不支持Session功能，需要添加插件才能对Session进行操作。</p>
<h3 id="拉取gin-contrib-x2F-sessions插件"><a href="#拉取gin-contrib-x2F-sessions插件" class="headerlink" title="拉取gin-contrib&#x2F;sessions插件"></a>拉取gin-contrib&#x2F;sessions插件</h3><p>访问以下网站可以找到这个插件：</p>
<p><a href="https://github.com/gin-contrib/sessions">https://github.com/gin-contrib/sessions</a></p>
<p>安装Session插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/gin-contrib/sessions</span><br></pre></td></tr></table></figure>


<h3 id="Session容器"><a href="#Session容器" class="headerlink" title="Session容器"></a>Session容器</h3><p><strong>容器的初始化</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(size <span class="type">int</span>, network, address, password <span class="type">string</span>, keyPairs ...[]<span class="type">byte</span>)</span></span> (Store, <span class="type">error</span>)</span><br><span class="line"><span class="comment">// size:容器大小</span></span><br><span class="line"><span class="comment">// network：协议</span></span><br><span class="line"><span class="comment">// address：ip:port</span></span><br><span class="line"><span class="comment">// password：使用redis做容器使用的密码</span></span><br><span class="line"><span class="comment">// []byte(“secret”)： 加密密钥</span></span><br></pre></td></tr></table></figure>

<p><strong>使用容器</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> Use(middleware ...HandlerFunc) IRoutes &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用容器</span></span><br><span class="line">router.Use(sessions.Sessions(<span class="string">&quot;mysession&quot;</span>, store))</span><br></pre></td></tr></table></figure>

<h3 id="设置Session"><a href="#设置Session" class="headerlink" title="设置Session"></a>设置Session</h3><p>以下案例设置了一个Session并且储存到Redis数据库中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;github.com/gin-contrib/sessions/redis&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-contrib/sessions&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化容器.</span></span><br><span class="line">	store, _ := redis.NewStore(<span class="number">10</span>, <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:6379&quot;</span>, <span class="string">&quot;&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用容器</span></span><br><span class="line">	router.Use(sessions.Sessions(<span class="string">&quot;mysession&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">	router.GET(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 调用session, 设置session数据</span></span><br><span class="line">		s := sessions.Default(context)</span><br><span class="line">		<span class="comment">// 设置session</span></span><br><span class="line">		s.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;light&quot;</span>)</span><br><span class="line">		<span class="comment">// 修改session时, 需要Save函数配合.否则不生效</span></span><br><span class="line">		s.Save()</span><br><span class="line"></span><br><span class="line">		context.Writer.WriteString(<span class="string">&quot;测试 Session ...&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="获取Session"><a href="#获取Session" class="headerlink" title="获取Session"></a>获取Session</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := sessions.Default(c)</span><br><span class="line">v := s.Get(<span class="string">&quot;username&quot;</span>)</span><br></pre></td></tr></table></figure>


<p>下面来看一个完整的小案例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-contrib/sessions&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-contrib/sessions/redis&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化容器.</span></span><br><span class="line">	store, _ := redis.NewStore(<span class="number">10</span>, <span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;116.62.177.68:63791&quot;</span>, <span class="string">&quot;501124524&quot;</span>, []<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用容器</span></span><br><span class="line">	router.Use(sessions.Sessions(<span class="string">&quot;mysession&quot;</span>, store))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置Session</span></span><br><span class="line">	router.GET(<span class="string">&quot;/setSession&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 调用session, 设置session数据</span></span><br><span class="line">		s := sessions.Default(c)</span><br><span class="line">		<span class="comment">// 设置session</span></span><br><span class="line">		s.Set(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;light&quot;</span>)</span><br><span class="line">		<span class="comment">// 修改session时, 需要Save函数配合.否则不生效</span></span><br><span class="line">		s.Save()</span><br><span class="line"></span><br><span class="line">		c.Writer.WriteString(<span class="string">&quot;测试 Session ...&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取Session</span></span><br><span class="line">	router.GET(<span class="string">&quot;/getSession&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		s := sessions.Default(c)</span><br><span class="line">		v := s.Get(<span class="string">&quot;username&quot;</span>)</span><br><span class="line"></span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;username&quot;</span> : v.(<span class="type">string</span>),</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	router.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用Session实现的登录过滤器"><a href="#使用Session实现的登录过滤器" class="headerlink" title="使用Session实现的登录过滤器"></a>使用Session实现的登录过滤器</h3><p>如果能获取到Session，就继续执行下面的路由，如果获取不到，就停止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoginFilter</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx *gin.Context)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 初始化 Session 对象</span></span><br><span class="line">		s := sessions.Default(ctx)</span><br><span class="line">		userName := s.Get(<span class="string">&quot;userName&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> userName == <span class="literal">nil</span> &#123;</span><br><span class="line">			ctx.Abort()			<span class="comment">// 从这里返回, 不必继续执行了</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ctx.Next()			<span class="comment">// 继续向下</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加路由分组</span></span><br><span class="line">r1 := router.Group(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">		<span class="comment">// 设置一个过滤器中间件来过滤掉用户未登录的情况</span></span><br><span class="line">		<span class="comment">// 同样的道理，后面路由的具体实现中，也不需要再校验用户是否登录</span></span><br><span class="line">		r1.Use(LoginFilter())  </span><br><span class="line">		</span><br><span class="line">    r1.DELETE(<span class="string">&quot;/delete&quot;</span>, controller.DeleteUser)</span><br><span class="line">    r1.GET(<span class="string">&quot;/get&quot;</span>, controller.GetUserInfo)</span><br><span class="line">    r1.PUT(<span class="string">&quot;/update&quot;</span>, controller.UpdateUserInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Gin</category>
      </categories>
  </entry>
  <entry>
    <title>JWT实现跨域请求</title>
    <url>/2022/11/02/Gin/7JWT%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="cookie的弊端"><a href="#cookie的弊端" class="headerlink" title="cookie的弊端"></a>cookie的弊端</h2><p>最近在做一个web项目，我想实现一个功能：客户端浏览器每次访问首页的时候，就从请求中获取cookie，如果cookie中含有用户信息，就自动为用户登录，否则就不登陆。<br>但是我的前端是基于vue实现的，起在8080端口，服务端起在9090端口，众所周知cookie是不可以跨域的，满足<code>不同协议，不同域名，不同端口</code>即为跨域，虽然前后端都部署在localhost，但是不同端口造成了跨域。</p>
<p>虽然我们可以采取<code>cors策略</code>等办法实现跨域，但是相对来说增添了麻烦。</p>
<h2 id="使用JWT实现跨域"><a href="#使用JWT实现跨域" class="headerlink" title="使用JWT实现跨域"></a>使用JWT实现跨域</h2><p>我采取了网上的很多办法，依然不能让cookie实现跨域，于是就想到了使用<code>JWT+localStorage</code>的办法。其实JWT是可以放在cookie里面的，但是在本文的场景中cookie不能跨域。</p>
<p>大致思路是这样的：</p>
<ol>
<li>用户登录成功以后，服务端把用户的手机号码生成一个Token令牌，然后返回给客户端浏览器。</li>
<li>客户端浏览器在收到服务端的response以后，把Token令牌储存到localStorage中，但是localStorage默认是没有过期时间的，也就是永久保存，所以我们还需要做一层封装，维护一个过期时间。</li>
<li>下一次用户访问首页的时候，如果储存的token没有过期，就把token令牌储存在request中。</li>
<li>服务端获取到request中的token令牌，如果正确，就自动为用户登录</li>
</ol>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>在这里我做了一个简单的小demo来演示大致的流程，用了gin、vue以及一个go的jwt库：<a href="https://blog.csdn.net/qq_49723651/article/details/123699275?spm=1001.2014.3001.5501">Gin中使用JWT</a>。</p>
<p><strong>客户端</strong></p>
<p>首先在前端创建一个<code>storage.js</code>文件来对localStorage做一次封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;form&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; v-model=&quot;phoneNumber&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; @click=&quot;submit&quot;&gt;</span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;br&gt;</span><br><span class="line"></span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;第二次提交&quot; @click=&quot;submit2&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import storage from &#x27;../../assets/storage&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            phoneNumber: null,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        submit() &#123;</span><br><span class="line">            var forms = new FormData();</span><br><span class="line">            forms.append(&quot;phoneNumber&quot;, this.phoneNumber);</span><br><span class="line">            this.$axios.post(&quot;http://127.0.0.1:9092/token&quot;, forms).then((res) =&gt; &#123;</span><br><span class="line">                storage.set(&quot;access_token&quot;, res.data.token)</span><br><span class="line">                console.log(&quot;后端发送来的token储存到本地：&quot;);</span><br><span class="line">                console.log(res.data.token);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        submit2() &#123;</span><br><span class="line">            var forms = new FormData();</span><br><span class="line">            forms.append(&quot;Authorization&quot;, &#x27;Bearer &#x27; + storage.get(&quot;access_token&quot;))</span><br><span class="line">            console.log(&quot;从浏览器缓存取出token发送：&quot; + forms.get(&quot;Authorization&quot;));</span><br><span class="line">            this.$axios.post(&quot;http://127.0.0.1:9092/token2&quot;, forms).then((res) =&gt; &#123;</span><br><span class="line">                console.log(&quot;打印后端的数据：&quot;);</span><br><span class="line">                console.log(res.data.message);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/9aeea77af7d34df6b5f36fc6102f28c1.png" alt="在这里插入图片描述"><br><strong>服务端</strong></p>
<p>首先创建一个jwt的model在<code>token.go</code>文件中，我们在里面定义了jwt结构体、生成token令牌的方法以及解析token令牌的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/dgrijalva/jwt-go&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClaims 自定义结构体</span></span><br><span class="line"><span class="keyword">type</span> MyClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">	PhoneNumber <span class="type">string</span> <span class="string">`json:&quot;phoneNumber&quot;`</span></span><br><span class="line">	jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TokenExpireDuration = time.Hour * <span class="number">720</span></span><br><span class="line"><span class="comment">// 自定义密钥</span></span><br><span class="line"><span class="keyword">var</span> mySecret = []<span class="type">byte</span>(<span class="string">&quot;123456&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenToken 生成jwt</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenToken</span><span class="params">(phoneNumber <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>)  &#123;</span><br><span class="line">	c := MyClaims&#123;</span><br><span class="line">		phoneNumber,</span><br><span class="line">		jwt.StandardClaims &#123;</span><br><span class="line">			ExpiresAt: time.Now().Add(TokenExpireDuration).Unix(),  <span class="comment">// 过期时间</span></span><br><span class="line">			Issuer: <span class="string">&quot;goShop&quot;</span>,   <span class="comment">// 签发人</span></span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用HS256加密方式</span></span><br><span class="line">	token := jwt.NewWithClaims(jwt.SigningMethodHS256, c)</span><br><span class="line">	tmp, err := token.SignedString(mySecret)</span><br><span class="line">	<span class="keyword">return</span> tmp, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseToken 解析token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(tokenString <span class="type">string</span>)</span></span> (*MyClaims, <span class="type">error</span>)  &#123;</span><br><span class="line">	token, err := jwt.ParseWithClaims(tokenString, &amp;MyClaims&#123;&#125;, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> mySecret, <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> Claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123;</span><br><span class="line">		<span class="keyword">return</span> Claims, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;invalid token&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们在入口函数中定义接受客户端两次请求的路由：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> tests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;go-shop/middleware&quot;</span></span><br><span class="line">	<span class="string">&quot;go-shop/models&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authHandler</span><span class="params">(c *gin.Context)</span></span>  &#123;</span><br><span class="line">	phoneNumber := c.PostForm(<span class="string">&quot;phoneNumber&quot;</span>)</span><br><span class="line">	<span class="comment">// 生成token</span></span><br><span class="line">	tokenString, _ := models.GenToken(phoneNumber)</span><br><span class="line">	fmt.Println(<span class="string">&quot;生成token：&quot;</span>, tokenString)</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;msg&quot;</span> : <span class="string">&quot;success&quot;</span>,</span><br><span class="line">		<span class="string">&quot;token&quot;</span> : tokenString,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authHandler2</span><span class="params">(c *gin.Context)</span></span>  &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;token认证成功！&quot;</span>)</span><br><span class="line">	c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">		<span class="string">&quot;message&quot;</span> : <span class="string">&quot;success&quot;</span>,</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestJWT</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.Use(middleware.Cors())</span><br><span class="line">	r.POST(<span class="string">&quot;/token&quot;</span>, authHandler)</span><br><span class="line">	r.POST(<span class="string">&quot;/token2&quot;</span>, middleware.JWTAuthMiddleware(),authHandler2)</span><br><span class="line">	r.Run(<span class="string">&quot;:9092&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在表单中输入我的手机号码，然后点击提交，服务端会生成一段token令牌发送回来：<br><img src="https://img-blog.csdnimg.cn/48647f018c104589afc2c79b5eaf8517.png" alt="在这里插入图片描述">然后点击第二次提交按钮，客户端会把令牌从localStorage中提取出来，加在request中发送给服务端，服务端验证成功以后，发送反馈消息：</p>
<p><img src="https://img-blog.csdnimg.cn/c3450938481c4c79a3668a9925d8b2cc.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Gin</category>
      </categories>
  </entry>
  <entry>
    <title>一、Docker的安装与卸载</title>
    <url>/2022/11/01/Docker/%E4%B8%80%E3%80%81CentOS7%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BDDocker/</url>
    <content><![CDATA[<h2 id="CentOS安装Docker"><a href="#CentOS安装Docker" class="headerlink" title="CentOS安装Docker"></a>CentOS安装Docker</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 切换镜像源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果出现 wget: 无法解析主机地址 “mirrors.aliyun.com”</span></span><br><span class="line"><span class="comment"># 需要修改centos中的DNS配置，可以临时修改也可以永久修改：</span></span><br><span class="line"><span class="comment"># (1) 临时修改（重启后会恢复原样）：</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vi /etc/resolv.conf</span></span><br><span class="line"><span class="comment"># 将内容修改为下面这样：</span></span><br><span class="line">nameserver <span class="number">114.114</span>.<span class="number">114.114</span></span><br><span class="line">nameserver <span class="number">119.29</span>.<span class="number">29.29</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (2) 永久修改</span></span><br><span class="line"><span class="comment"># 编辑ens33网卡的配置，将DNS配置修改为：</span></span><br><span class="line">DNS1=<span class="number">114.114</span>.<span class="number">114.114</span></span><br><span class="line">DNS2=<span class="number">119.29</span>.<span class="number">29.29</span></span><br><span class="line"><span class="comment"># 重启网络服务</span></span><br><span class="line">service network restart</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 查看当前镜像源中支持的docker版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum list docker-ce --showduplicates</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 安装特定版本的docker-ce</span></span><br><span class="line"><span class="comment"># 必须指定--setopt=obsoletes=0，否则yum会自动安装更高版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 添加一个配置文件</span></span><br><span class="line"><span class="comment"># Docker在默认情况下使用的Cgroup Driver为cgroupfs，而kubernetes推荐使用systemd来代替cgroupfs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /etc/docker</span></span><br><span class="line"><span class="comment"># 配置镜像加速</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF &gt;  /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="Ubuntu安装Docker"><a href="#Ubuntu安装Docker" class="headerlink" title="Ubuntu安装Docker"></a>Ubuntu安装Docker</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于我的Ubuntu系统安装在亚马逊的服务器上，所以不用切换镜像源、配置加速，整个过程会很简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">sudo apt<span class="literal">-get</span> install <span class="literal">-y</span> docker.io</span><br><span class="line"><span class="comment"># 启动docekr</span></span><br><span class="line">systemctl <span class="built_in">start</span> docker</span><br><span class="line"><span class="comment"># 设置为开机启动</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 启动docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line"><span class="comment"># 设置开机启动docker服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 检查docker状态和版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># docker version</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="卸载-docker"><a href="#卸载-docker" class="headerlink" title="卸载 docker"></a>卸载 docker</h2><h3 id="删除安装包"><a href="#删除安装包" class="headerlink" title="删除安装包"></a>删除安装包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span><br></pre></td></tr></table></figure>

<h3 id="删除镜像、容器、配置文件等内容"><a href="#删除镜像、容器、配置文件等内容" class="headerlink" title="删除镜像、容器、配置文件等内容"></a>删除镜像、容器、配置文件等内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf /etc/docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>三、Docker容器使用及命令</title>
    <url>/2022/11/01/Docker/%E4%B8%89%E3%80%81Docker%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker容器使用及命令"><a href="#Docker容器使用及命令" class="headerlink" title="Docker容器使用及命令"></a>Docker容器使用及命令</h1><p>容器就是镜像的一个实例，相当于面向对象中的类和对象，镜像相当于类，而容器则相当于对象。</p>
<h2 id="Docker-客户端"><a href="#Docker-客户端" class="headerlink" title="Docker 客户端"></a>Docker 客户端</h2><p>docker 客户端非常简单 ,我们可以直接输入 docker 命令来查看到 Docker 客户端的所有命令选项。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker</span><br></pre></td></tr></table></figure>

<p>可以通过命令 <code>docker command --help</code> 更深入的了解指定的 Docker 命令使用方法。</p>
<p>例如我们要查看 <code>docker stats</code> 指令的具体使用方法：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker stats <span class="literal">--help</span></span><br></pre></td></tr></table></figure>

<h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><p>查看所有的容器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span></span><br></pre></td></tr></table></figure>

<p>查看正在运行的容器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">ps</span></span><br></pre></td></tr></table></figure>


<h2 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h2><p>以下命令使用 redis 镜像启动一个容器，参数为以命令行模式进入该容器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=myRedis redis /bin/bash</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-i: 交互式操作</li>
<li>-t: 终端</li>
<li>name：指定容器的名字</li>
<li>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 shell，因此用的是 &#x2F;bin&#x2F;bash</li>
</ul>
<p>要退出终端，直接输入 exit</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<p><strong>后台启动</strong></p>
<p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 -d 指定容器的运行模式。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-id</span> <span class="literal">--name</span> myRedis redis /bin/bash</span><br></pre></td></tr></table></figure>

<p>注：加了 <code>-d</code> 参数默认不会进入容器，想要进入容器需要使用指令 <code>docker exec</code>（下面会介绍到）。</p>
<p><strong>启动一个已经停止的容器</strong></p>
<p>首先用<code>docker ps -a</code>查看有哪些容器：</p>
<p><img src="https://img-blog.csdnimg.cn/9786ee2e638947ec95a4ec296c572549.png" alt="在这里插入图片描述"><br>启动已经停止的myRedis容器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">start</span> <span class="number">438</span>a9db4aed5</span><br></pre></td></tr></table></figure>

<p><strong>用完即删</strong></p>
<p>一般用于测试，退出容器之后会自动删除。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--rm</span> redis /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>以继承的方式启动容器：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span> yourRedis <span class="literal">--volumes-from</span> myRedis redis /bin/bash</span><br></pre></td></tr></table></figure>
<p>yourRedis继承了myRedis后启动，启动以后，myRedis和yourRedis的数据卷是共享的。即实现了容器之间的数据共享。</p>
<h2 id="进入和退出容器"><a href="#进入和退出容器" class="headerlink" title="进入和退出容器"></a>进入和退出容器</h2><p>在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器后开启一个新的终端，可以在里面操作(常用)，用exit退出后不会关闭容器</span></span><br><span class="line">docker exec [容器<span class="type">id</span>]</span><br><span class="line"><span class="comment"># 进入容器正在执行的终端，不会启动新的进程（不推荐使用），用exit退出后会关闭容器</span></span><br><span class="line">docker attach [容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure>

<h2 id="停止和重启容器"><a href="#停止和重启容器" class="headerlink" title="停止和重启容器"></a>停止和重启容器</h2><p>停止容器的命令如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker stop [容器 <span class="type">id</span>]</span><br></pre></td></tr></table></figure>

<p><strong>停止所有容器</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker stop <span class="variable">$</span>(docker <span class="built_in">ps</span> <span class="literal">-aq</span>)</span><br></pre></td></tr></table></figure>

<p><strong>重启容器</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker restart [容器 <span class="type">id</span>]</span><br></pre></td></tr></table></figure>

<h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><p>删除指定容器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> [容器 <span class="type">id</span>]</span><br></pre></td></tr></table></figure>

<p>清理所有处于终止状态的容器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<p>直接删除所有容器：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> <span class="variable">$</span>(docker <span class="built_in">ps</span> <span class="literal">-aq</span>)</span><br></pre></td></tr></table></figure>


<h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><p><strong>导出容器</strong></p>
<p>导出容器快照到本地文件（默认导出到当前目录下）：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker export [容器<span class="type">id</span>] &gt; myRedis.tar</span><br></pre></td></tr></table></figure>


<p><strong>导入容器快照</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入成功之后可以使用docker images命令查看</span></span><br><span class="line"><span class="built_in">cat</span> myRedis.tar | docker import - myredis/redis:latest</span><br></pre></td></tr></table></figure>

<p>此外，也可以通过指定 URL 或者某个目录来导入，例如：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br></pre></td></tr></table></figure>


<h2 id="查看容器信息"><a href="#查看容器信息" class="headerlink" title="查看容器信息"></a>查看容器信息</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker inspect [容器名称/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>二、Docker镜像使用和命令</title>
    <url>/2022/11/01/Docker/%E4%BA%8C%E3%80%81Docker%E9%95%9C%E5%83%8F%E4%BD%BF%E7%94%A8%E5%92%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Docker镜像使用和命令"><a href="#Docker镜像使用和命令" class="headerlink" title="Docker镜像使用和命令"></a>Docker镜像使用和命令</h1><p>镜像就是一个轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>所有的应用，直接打包docker镜像,就可以直接跑起来。</p>
<p>获取镜像的方式：</p>
<ul>
<li>从远程仓库下载</li>
<li>从别人那里拷贝</li>
<li>自己制作一个镜像<code>DockerFile</code></li>
</ul>
<h2 id="列出本机镜像"><a href="#列出本机镜像" class="headerlink" title="列出本机镜像"></a>列出本机镜像</h2><p>我们可以使用 <code>docker images</code> 来列出本地主机上的镜像。</p>
<p><img src="https://img-blog.csdnimg.cn/c92664361a55430d99af289bb220f5c0.png" alt="在这里插入图片描述"><br>各个选项说明:</p>
<ul>
<li>REPOSITORY：表示镜像的仓库源</li>
<li>TAG：镜像的标签</li>
<li>IMAGE ID：镜像ID</li>
<li>CREATED：镜像创建时间</li>
<li>SIZE：镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p>所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-t</span> <span class="literal">-i</span> ubuntu:<span class="number">15.10</span> /bin/bash</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>-i: 交互式操作。</li>
<li>-t: 终端。</li>
<li>ubuntu:15.10: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</li>
<li>&#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash。</li>
</ul>
<p>如果要使用版本为 14.04 的 ubuntu 系统镜像来运行容器时，命令如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-t</span> <span class="literal">-i</span> ubuntu:<span class="number">14.04</span> /bin/bash </span><br></pre></td></tr></table></figure>

<p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
<h2 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h2><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>我们也可以使用 <code>docker search</code> 命令来搜索镜像。比如我们需要一个 redis 的镜像来作为我们的 web 服务。我们可以通过 <code>docker search</code> 命令搜索 httpd 来寻找适合我们的镜像。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f72e6021d3544d9b8715e158bb37aa41.png" alt="在这里插入图片描述"></p>
<p><strong>NAME:</strong> 镜像仓库源的名称</p>
<p><strong>DESCRIPTION:</strong> 镜像的描述</p>
<p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p>
<p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
<p><strong>AUTOMATED:</strong> 自动构建。</p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>我们决定使用上图中的最新redis镜像，使用命令 <code>docker pull</code> 来下载镜像，如果要下载指定版本的镜像，可以在镜像的后面加上<code>:版本号</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载最新版本</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="comment"># 下载指定版本</span></span><br><span class="line">docker pull redis:<span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/57339a60e2fa4f0b974d3441aa081426.png" alt="在这里插入图片描述"></p>
<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><p>镜像删除使用 <code>docker rmi</code> 命令，比如我们删除<code>redis</code>镜像：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用名称删除</span></span><br><span class="line">docker rmi redis:<span class="number">5.0</span></span><br><span class="line"><span class="comment"># 用Image ID删除</span></span><br><span class="line">docker rmi <span class="number">7614</span>ae9453d1</span><br></pre></td></tr></table></figure>
<h2 id="删除所有镜像"><a href="#删除所有镜像" class="headerlink" title="删除所有镜像"></a>删除所有镜像</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除所有redis镜像</span></span><br><span class="line">docker rmi <span class="variable">$</span>(docker images <span class="literal">-q</span>)</span><br></pre></td></tr></table></figure>

<h2 id="镜像的原理"><a href="#镜像的原理" class="headerlink" title="镜像的原理"></a>镜像的原理</h2><p>首先来看Linux的文件系统：</p>
<p>Linux文件系统由bootfs 和rootfs 两部分组成</p>
<ul>
<li>bootfs：包含bootloader（引导加载程序）和kernel（内核）</li>
<li>rootfs：root文件系统，包含的就是典型的Linux 系统中的&#x2F;dev、&#x2F;proc、&#x2F;bin等标准目录和文件</li>
<li>不同的Linux 发行版，bootfs 基本一样，而rootfs 不同，如ubuntu，CentOS等</li>
</ul>
<p><strong>Docker 镜像原理：</strong></p>
<ul>
<li>Docker 镜像是由特殊的文件系统叠加而成</li>
<li>最低端是bootfs，并使用宿主机的bootfs</li>
<li>第二层是root 文件系统rootfs ，称为base iamge</li>
<li>然后再往上可以叠加其他的镜像文件</li>
<li>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统</li>
<li>一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像称为基础镜像</li>
<li>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</li>
</ul>
<p><strong>镜像制作：</strong></p>
<p>容器转为镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 容器id 镜像名称:版本号</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o 压缩文件名称 镜像名称:版本号</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load -i 压缩文件名称</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>五、Docker应用部署</title>
    <url>/2022/11/01/Docker/%E4%BA%94%E3%80%81Docker%E5%BA%94%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Docker应用部署"><a href="#Docker应用部署" class="headerlink" title="Docker应用部署"></a>Docker应用部署</h1><h2 id="部署MySQL"><a href="#部署MySQL" class="headerlink" title="部署MySQL"></a>部署MySQL</h2><p><strong>需求</strong></p>
<p>在Docker容器中部署MySQL，并通过外部MySQL客户端操作MySQL Server。</p>
<p><strong>开始部署</strong></p>
<ol>
<li><p>搜索mysql镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取mysql镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.6</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器，设置端口映射、目录映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/root目录下创建mysql目录用于存储mysql数据信息</span></span><br><span class="line">mkdir ~/mysql</span><br><span class="line">cd ~/mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id \</span><br><span class="line">-p 3307:3306 \</span><br><span class="line">--name=c_mysql \</span><br><span class="line">-v $PWD/conf:/etc/mysql/conf.d \</span><br><span class="line">-v $PWD/logs:/logs \</span><br><span class="line">-v $PWD/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">mysql:5.6</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明<ul>
<li><code>-p 3307:3306</code>：将容器的3306端口映射到宿主机的3307端口</li>
<li><code>--v $PWD/conf:/etc/mysql/conf.d</code>：将主机当前目录下的<code>conf/my.cnf</code>挂载到容器<code>/etc/mysql/my.cnf</code>配置目录</li>
<li><code>-v $PWD/logs:/logs</code>：将主机当前目录下的<code>logs</code>目录挂载到容器的<code>/logs</code>目录日志</li>
<li><code>-v $PWD/data:/var/lib/mysql</code>：将主机当前目录下的<code>data</code>目录挂载到容器的<code>/var/lib/mysql</code>数据目录</li>
<li><code>-e MYSQL_ROOT_PASSWORD=123456</code>：初始化root 用户密码</li>
</ul>
</li>
</ul>
</li>
<li><p>使用windowes下的SQLyog连接数据库，并创建数据库成功：</p>
<p> <img src="https://img-blog.csdnimg.cn/e3eaac1498a84e2fa65d9e6f09eedc74.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/3a4600f03b79471d891b09a1999d93f4.png" alt="在这里插入图片描述"></p>
<h2 id="部署Nginx"><a href="#部署Nginx" class="headerlink" title="部署Nginx"></a>部署Nginx</h2><ol>
<li><p>搜索Nginx 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取nginx镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器，设置端口映射、目录映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在/root目录下创建nginx目录用于存储nginx数据信息</span></span><br><span class="line">mkdir ~/nginx</span><br><span class="line">cd ~/nginx</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在~/nginx/html/下创建index.html文件，写入以下内容：</span></span><br><span class="line">&lt;h1&gt;Welcome to Nginx!&lt;/h1&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后在~/nginx/下创建conf目录：</span></span><br><span class="line">mkdir conf</span><br><span class="line">cd conf</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">在~/nginx/conf/下创建nginx.conf文件，粘贴下面代码块的内容</span></span><br><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    #tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">	</span><br><span class="line">	include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id --name=c_nginx \</span><br><span class="line">-p 800:80 \</span><br><span class="line">-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v $PWD/logs:/var/log/nginx \</span><br><span class="line">-v $PWD/html:/usr/share/nginx/html \</span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：<ul>
<li><code>-p 800:80</code>：将容器的80端口映射到宿主机的800端口</li>
<li><code>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</code>：将主机当前目录下的<code>/conf/nginx.conf</code>挂载到容器的<code>:/etc/nginx/nginx.conf</code>配置目录</li>
<li><code>-v $PWD/html:/usr/share/nginx/html</code>：将主机当前目录挂载到容器的<code>/val/log/nginx</code>日志目录</li>
</ul>
</li>
</ul>
</li>
<li><p>使用windows下的浏览器访问虚拟机的800端口：</p>
<p> <img src="https://img-blog.csdnimg.cn/5239e21c016f4ee38558901ac5e32456.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<h2 id="部署Redis"><a href="#部署Redis" class="headerlink" title="部署Redis"></a>部署Redis</h2><ol>
<li><p>搜索Redis 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取Redis 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis:5.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建容器，设置端口映射、目录映射</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -id --name=c_redis -p 6379:6379 redis:5.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用windows下的Redis客户端连接虚拟机中的服务：</p>
<p> <img src="https://img-blog.csdnimg.cn/9f679b2cef3c4e38b9c35a494cf3fbac.png" alt="在这里插入图片描述"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>六、Docker Dockerfile</title>
    <url>/2022/11/01/Docker/%E5%85%AD%E3%80%81Docker%20Dockerfile/</url>
    <content><![CDATA[<h2 id="什么是-Dockerfile？"><a href="#什么是-Dockerfile？" class="headerlink" title="什么是 Dockerfile？"></a>什么是 Dockerfile？</h2><ul>
<li>Dockerfile 是一个文本文件</li>
<li>包含了一条条的指令</li>
<li>每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像</li>
<li>对于开发人员，可以为开发团队提供一个完全一致的开发环境</li>
<li>对于测试人员，可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了</li>
<li>对于运维人员，在部署时，可以实现应用的无缝移植</li>
</ul>
<h2 id="使用-Dockerfile-定制镜像"><a href="#使用-Dockerfile-定制镜像" class="headerlink" title="使用 Dockerfile 定制镜像"></a>使用 Dockerfile 定制镜像</h2><p>1.下面定制一个 nginx 镜像（构建好的镜像内会有一个 <code>/usr/share/nginx/html/index.html</code>文件）</p>
<p>在一个空目录下，新建一个名为<code>Dockerfile</code>文件，并在文件内添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;这是一个本地构建的nginx镜像&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>


<p>2.FROM 和 RUN 指令的作用</p>
<p>FROM：定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。</p>
<p>RUN：用于执行后面跟着的命令行命令。有以下俩种格式：</p>
<ul>
<li>shell 格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN &lt;命令行命令&gt;</span><br><span class="line">//  &lt;命令行命令&gt; 等同于，在终端操作的 shell 命令。</span><br></pre></td></tr></table></figure>

<ul>
<li>exec 格式：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</span><br><span class="line"></span><br><span class="line">// 例如：</span><br><span class="line">// RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</span><br></pre></td></tr></table></figure>

<p>注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">RUN yum install wget</span><br><span class="line">RUN wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span><br><span class="line">RUN tar -xvf redis.tar.gz</span><br><span class="line">以上执行会创建 3 层镜像。可简化为以下格式：</span><br><span class="line">FROM centos</span><br><span class="line">RUN yum install wget \</span><br><span class="line">    &amp;&amp; wget -O redis.tar.gz &quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot; \</span><br><span class="line">    &amp;&amp; tar -xvf redis.tar.gz </span><br></pre></td></tr></table></figure>

<p>如上，以 <code>&amp;&amp;</code> 符号连接命令，这样执行后，只会创建 1 层镜像。</p>
<h3 id="Dockefile构建过程"><a href="#Dockefile构建过程" class="headerlink" title="Dockefile构建过程"></a>Dockefile构建过程</h3><p><img src="https://img-blog.csdnimg.cn/6969cb9a464d4fb78b79f52570ed762f.png" alt="在这里插入图片描述"></p>
<h3 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h3><p>在 Dockerfile 文件的存放目录下，执行构建动作。</p>
<p>Dockerfile文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;这是一个本地构建的nginx镜像&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>以下示例，通过目录下的 Dockerfile 构建一个 nginx:v3（镜像名称:镜像标签）。</p>
<p>注：最后的 . 代表本次执行的上下文路径，稍后介绍。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/8b5e23189cf043b3912cc93bb9652589.png" alt="在这里插入图片描述"></p>
<p>以上显示，说明已经构建成功。</p>
<h3 id="上下文路径"><a href="#上下文路径" class="headerlink" title="上下文路径"></a>上下文路径</h3><p>上一节中，有提到指令最后一个 . 是上下文路径，那么什么是上下文路径呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v3 .</span><br></pre></td></tr></table></figure>

<p>上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。</p>
<p>如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。</p>
<p>注意：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。</p>
<h3 id="Dockerfile关键字"><a href="#Dockerfile关键字" class="headerlink" title="Dockerfile关键字"></a>Dockerfile关键字</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>作用</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>指定父镜像</td>
<td align="left">指定dockerfile基于哪个images构建</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>作者信息</td>
<td align="left">用来标明这个dockerfile 谁写的</td>
</tr>
<tr>
<td>LABEL</td>
<td>标签</td>
<td align="left">用来指明dockerfile 的标签，可以使用Label代替Maintainer 最终都是在docker image基本信息中嗯可以查看</td>
</tr>
<tr>
<td>RUN</td>
<td>执行命令</td>
<td align="left">执行一段命令 默认是<code>/bin/sh</code> 格式：<code>RUN command</code> 或者 <code>RUN [&quot;command&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></td>
</tr>
<tr>
<td>CMD</td>
<td>容器启动命令</td>
<td align="left">提供启动容器时候的默认命令和ENTRYPOINT配合使用。格式：<code>CMD command param1 param2</code>或者<code>CMD [&quot;command&quot;,&quot;param1&quot;,&quot;param2&quot;]</code></td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>入口</td>
<td align="left">一般在制作一些执行就关闭的容器中会使用</td>
</tr>
<tr>
<td>COPY</td>
<td>复制文件</td>
<td align="left">build 的时候复制文件到image中</td>
</tr>
<tr>
<td>ADD</td>
<td>添加文件</td>
<td align="left">build 的时候添加文件到iamge 中，不仅仅局限于当前build 上下文 可以来源于远程服务</td>
</tr>
<tr>
<td>ENV</td>
<td>环境变量</td>
<td align="left">指定build 时候的环境变量 可以在启动容器的时候 通过<code>-e</code>覆盖  格式：<code>ENV name = value</code></td>
</tr>
<tr>
<td>ARG</td>
<td>构建参数</td>
<td align="left">构建参数 只在构建的时候使用参时 如果有ENV 那么ENV 的相同名字的值始终覆盖ARG 的值</td>
</tr>
<tr>
<td>VOLUME</td>
<td>定义外部可以挂载的数据卷</td>
<td align="left">指定build 的image 那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用<code>-v</code>绑定 格式：<code>VOLUME [&quot;目录&quot;]</code></td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口</td>
<td align="left">定义容器运行的时候监听的端口 启动容器的使用<code>-p</code>来绑定暴露端口 格式：<code>EXPOSE 8080</code>或者<code>EXPOSE 8080/udp</code></td>
</tr>
<tr>
<td>WORKDIR</td>
<td>工作目录</td>
<td align="left">指定容器内部的工作目录 如果没有创建则自动创建 如果指定&#x2F;使用是绝对地址 如果不是&#x2F;开头那么实在上一条workdir 的路径的相对路径</td>
</tr>
<tr>
<td>USER</td>
<td>指定执行用户</td>
<td align="left">指定build 或者启动的时候 用户 在RUN CMD ENTRYPOINT执行的时候的用户</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查</td>
<td align="left">指定监测当前容器的健康测试的命令 基本上没有 因为很多时候 应用本身由健康监测机制</td>
</tr>
<tr>
<td>ONBUILD</td>
<td>触发器</td>
<td align="left">当存在ONBUILD 关键字的镜像作为基础镜像的时候 当执行FROM 完成之后 会执行ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td>
</tr>
<tr>
<td>STOPSIGNAL</td>
<td>发送信息量到宿主机</td>
<td align="left">该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出</td>
</tr>
<tr>
<td>SHELL</td>
<td>指定执行脚本的shell</td>
<td align="left">指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td>
</tr>
</tbody></table>
<h2 id="利用Dockerfile构建自己的CentOS"><a href="#利用Dockerfile构建自己的CentOS" class="headerlink" title="利用Dockerfile构建自己的CentOS"></a>利用Dockerfile构建自己的CentOS</h2><p>1.创建Dockerfile文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim centos_dockfile</span><br></pre></td></tr></table></figure>

<p>2.撰写Dockerfile文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM centos</span><br><span class="line">MAINTAINGER omlight&lt;501124524@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /home/admin/dockers/mycentos</span><br><span class="line">WORKER $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"> </span><br><span class="line">EXPOSE 80</span><br><span class="line"> </span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;-----end-----&quot;</span><br><span class="line">CMD bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f centos_dockfile -t mycentos:0.1 .</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2b6a5e972ecf4463b77333573dbf1dbe.png" alt="在这里插入图片描述"><br>4.测试运行</p>
<p>跑一个容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it mycentos:0.1</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/77adb701c8c44936821341a6fa29e21e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2b72bfe5a50240eb8985d545794614f7.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2c1f2a6b80ab4496a1dfdbcf26147438.png" alt="在这里插入图片描述"><br>查看当前镜像的构建历史：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker history</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6e25d03a828042eb8732960facf4099e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>四、Docker容器数据卷</title>
    <url>/2022/11/01/Docker/%E5%9B%9B%E3%80%81Docker%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="数据卷介绍"><a href="#数据卷介绍" class="headerlink" title="数据卷介绍"></a>数据卷介绍</h2><p>数据卷（Data Volumes）是宿主机中的一个目录或文件，数据卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。当容器目录和数据卷目录绑定后，对方的修改会立即同步，一个数据卷可以被多个容器同时挂载，一个容器也可以被挂载多个数据卷。</p>
<p><img src="https://img-blog.csdnimg.cn/a501e3a5a0624e0396ae3a70a884da0b.png" alt="在这里插入图片描述"><br><strong>数据卷的作用</strong></p>
<ul>
<li>容器数据持久化</li>
<li>外部机器和容器间接通信</li>
<li>容器之间数据交换</li>
</ul>
<h2 id="配置数据卷"><a href="#配置数据卷" class="headerlink" title="配置数据卷"></a>配置数据卷</h2><p>创建启动容器时，使用<code>-v</code>参数 设置数据卷</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run ... <span class="literal">-v</span> 宿主机目录(文件):容器内目录(文件) ...</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li>目录必须是绝对路径</li>
<li>如果目录不存在，会自动创建</li>
<li>可以挂载多个数据卷</li>
</ol>
<p>比如我要创建一个myRedis镜像的容器，并创建数据卷：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=myredis <span class="literal">-v</span> /root/<span class="keyword">data</span>:/root/data_container myredis:latest /bin/bash</span><br></pre></td></tr></table></figure>

<p>创建完毕后，在主机的<code>/root目录</code>下出现了<code>data</code>目录，而在容器的<code>/root</code>目录下出现了<code>data_container</code>目录。</p>
<p>然后在主机上创建一个<code>a.txt</code>：</p>
<p><img src="https://img-blog.csdnimg.cn/6fe33f5d46d24a6c86fc8945dac82f39.png" alt="在这里插入图片描述"><br>发现容器的<code>data_container</code>目录下也多了一个<code>a.txt</code>文件：</p>
<p><img src="https://img-blog.csdnimg.cn/5ce01077dcf1475ebe975f663296b9bc.png" alt="在这里插入图片描述">将容器关闭并删除之后，文件依然在。</p>
<p>然后使用<code>docker run -it --name=myredis -v /root/data:/root/data_container myredis:latest /bin/bash</code>重新起一个容器，发现容器中的<code>a.txt</code>文件又回来了：</p>
<p><img src="https://img-blog.csdnimg.cn/5b397e2a7a1145bfb0c4eee914fae06d.png" alt="在这里插入图片描述"></p>
<p><strong>一个容器挂载多个目录</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=myredis \</span><br><span class="line"><span class="literal">-v</span> ~/data2:/root/data2 \</span><br><span class="line"><span class="literal">-v</span> ~/data3:/root/data3 \</span><br><span class="line">myredis:latest \</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>查看容器的<code>/root/data</code>目录，发现多了两个目录：</p>
<p><img src="https://img-blog.csdnimg.cn/df67f141f5bc44a5a0365532c413c907.png" alt="在这里插入图片描述"><br>主机的<code>/root/data</code>目录下也多了两个目录：</p>
<p><img src="https://img-blog.csdnimg.cn/0dc0fa2ea35343ea9d135b39e649e7b2.png" alt="在这里插入图片描述"></p>
<p><strong>两个容器通过挂载同一个目录共享数据</strong></p>
<p>容器1：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=myredis1 \</span><br><span class="line"><span class="literal">-v</span> ~/<span class="keyword">data</span>:/root/<span class="keyword">data</span> \</span><br><span class="line">myredis:latest \</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>容器2：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=myredis2 \</span><br><span class="line"><span class="literal">-v</span> ~/<span class="keyword">data</span>:/root/<span class="keyword">data</span> \</span><br><span class="line">myredis:latest \</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure>

<p>可以看到，两个容器和主机的<code>/root</code>目录下都多了一个<code>data</code>目录：</p>
<p><img src="https://img-blog.csdnimg.cn/ed62b8dd6afa4a8b9c92d0028f314f5b.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/3e0d0a61fc154499823c4a53e12410c0.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/c0cee53f53fa4a31b8b95cc39372f5ab.png" alt="在这里插入图片描述"><br>接着，我们在容器1的<code>data</code>目录下创建一个<code>a.txt</code>，并向文件中写入一个’’hello’’字符串：</p>
<p><img src="https://img-blog.csdnimg.cn/95d6ded36f2f4fc89d72d41e869306d7.png" alt="在这里插入图片描述">然后在容器2中可以发现刚刚在容器1中创建的内容：</p>
<p><img src="https://img-blog.csdnimg.cn/66e16e006d644ecb840355d57e3283aa.png" alt="在这里插入图片描述"></p>
<h2 id="配置数据卷容器"><a href="#配置数据卷容器" class="headerlink" title="配置数据卷容器"></a>配置数据卷容器</h2><p>多容器如何进行数据交互，在上面我们使用的是<code>多个容器挂载同一个数据卷</code>的方式，其实还有一种方式，就是创建<code>数据卷容器</code>。</p>
<p>比如现在有三个容器：c1、c2和c3，现在我们将c3挂载一个数据卷，然后将c1和c2分别挂载到c3上面，这个时候就相当于c1与c2同时挂载到了数据卷上，可以进行数据共享（即使c3出问题宕机了，c1和c2依然能正常完成数据共享），此时c3就被称为数据卷容器。</p>
<p><img src="https://img-blog.csdnimg.cn/62a8e67b476148bcb9365218b056e391.png" alt="在这里插入图片描述"></p>
<p>首先启动c3数据卷容器，使用<code>-v</code>参数设置数据卷：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=c3 <span class="literal">-v</span> ~/<span class="keyword">data</span>:/root/volume myredis:latest /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后创建启动c1、c2容器，使用<code>--volumes-from</code>参数设置数据卷：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=c1 <span class="literal">--volumes-from</span> c3  myredis:latest /bin/bash</span><br><span class="line"></span><br><span class="line">docker run <span class="literal">-it</span> <span class="literal">--name</span>=c2 <span class="literal">--volumes-from</span> c3  myredis:latest /bin/bash</span><br></pre></td></tr></table></figure>

<p>创建完毕后，我们首先在c1容器的<code>/root/volume</code>目录下创建一个<code>b.txt</code>，并在里面写入”docker”字符串：</p>
<p><img src="https://img-blog.csdnimg.cn/f0b61b5673e547df997c0adc5bdf4d79.png" alt="在这里插入图片描述">然后在c2中可以发现刚刚在c1中创建的内容：</p>
<p><img src="https://img-blog.csdnimg.cn/656beafc94fd4b2fa2419ec7be6faa37.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Git基本操作</title>
    <url>/2022/11/02/Git/Git%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Git基本概念"><a href="#Git基本概念" class="headerlink" title="Git基本概念"></a>Git基本概念</h2><p><strong>四个工作区</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e0af5a92fa1b4af7a66a4f1bd4d9c85a.png" alt="在这里插入图片描述"></p>
<p><strong>Workspace</strong>： 工作区，就是你平时存放项目代码的地方<br><strong>Index &#x2F; Stage</strong>： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表<br><strong>Repository</strong>： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本<br><strong>Remote</strong>： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</p>
<p><strong>四种状态</strong></p>
<p><img src="https://img-blog.csdnimg.cn/b4862faba1f048ac9f1116f932352239.png" alt="在这里插入图片描述"></p>
<p><strong>Untracked</strong>: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged.</p>
<p><strong>Unmodify</strong>: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified.如果使用git rm移出版本库, 则成为Untracked文件</p>
<p><strong>Modified</strong>: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过,返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改</p>
<p><strong>Staged</strong>: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</p>
<h2 id="本地操作"><a href="#本地操作" class="headerlink" title="本地操作"></a>本地操作</h2><h3 id="配置用户签名"><a href="#配置用户签名" class="headerlink" title="配置用户签名"></a>配置用户签名</h3><p><strong>方式一 (单个仓库有效)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name 用户名</span><br><span class="line">git config user.email 邮箱</span><br></pre></td></tr></table></figure>

<p>配置信息会保存在当前仓库目录下的<code>.git/config</code>文件中。</p>
<p><strong>方式二 (全局有效)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name 用户名</span><br><span class="line">git config --global user.email 邮箱</span><br></pre></td></tr></table></figure>

<p>该种方式配置信息会保存在系统盘的系统用户目录下的<code>.gitconfig</code>文件中，保存格式同上面一样。</p>
<h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a>初始化仓库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<h3 id="查看Git状态"><a href="#查看Git状态" class="headerlink" title="查看Git状态"></a>查看Git状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<h3 id="Git添加代码到暂存区"><a href="#Git添加代码到暂存区" class="headerlink" title="Git添加代码到暂存区"></a>Git添加代码到暂存区</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个或多个文件到暂存区</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [<span class="built_in">dir</span>]</span><br><span class="line"><span class="comment"># 添加当前目录下的所有文件到暂存区</span></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>

<h3 id="Git提交代码"><a href="#Git提交代码" class="headerlink" title="Git提交代码"></a>Git提交代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交代码并加上备注信息</span></span><br><span class="line">git commit -m <span class="string">&quot;[message]&quot;</span></span><br><span class="line"><span class="comment"># 提交指定文件</span></span><br><span class="line">git commit [file1] [file2] ... -m <span class="string">&quot;[message]&quot;</span></span><br><span class="line"><span class="comment"># 直接提交 </span></span><br><span class="line"><span class="comment"># -a参数设置修改文件以后不需要执行 git add 命令，直接提交</span></span><br><span class="line">git commit -am <span class="string">&quot;[message]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Git修改并提交代码"><a href="#Git修改并提交代码" class="headerlink" title="Git修改并提交代码"></a>Git修改并提交代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改代码文件，查看状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 再次添加到暂存区</span></span><br><span class="line">git add filename</span><br><span class="line"><span class="comment"># 再次查看状态</span></span><br><span class="line">git status</span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit</span><br><span class="line"><span class="comment"># 查看版本信息</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure>

<h3 id="Git版本切换"><a href="#Git版本切换" class="headerlink" title="Git版本切换"></a>Git版本切换</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本信息</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="comment"># 更加详细的显示</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 切换版本</span></span><br><span class="line">git reset --hard [版本号]</span><br></pre></td></tr></table></figure>

<h3 id="Git分支常用命令"><a href="#Git分支常用命令" class="headerlink" title="Git分支常用命令"></a>Git分支常用命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git branch -v</span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch [新分支名]</span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [分支名]</span><br><span class="line"><span class="comment"># 修改分支</span></span><br><span class="line">git branch -m [旧名字] [新名字]</span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout [分支名]</span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git merge [分支名]</span><br></pre></td></tr></table></figure>

<p><strong>如何解决合并分支冲突</strong></p>
<p>合并分支时，两个分支在同一个代码的同一个位置都有修改，Git无法判断，如何去留?</p>
<p>这个时候需要手动修改文件，修改完成后再次提交就合并成功了。</p>
<h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><h3 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制远程仓库的地址然后创建一个别名</span></span><br><span class="line">git remote add myProject [远程仓库地址]</span><br><span class="line"><span class="comment"># 查看远程仓库地址和别名</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<h3 id="推送本地库到github"><a href="#推送本地库到github" class="headerlink" title="推送本地库到github"></a>推送本地库到github</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推送分支到远程仓库</span></span><br><span class="line">git remote [别名] [分支名]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的命令可能或报错：error: Unknown subcommand</span></span><br><span class="line"><span class="comment"># 用以下命令即可</span></span><br><span class="line">git push [别名] [分支名]</span><br></pre></td></tr></table></figure>


<p>第一次推送需要windows凭据，会自动弹出一个窗口，在浏览器中输入账户和密码即可。</p>
<p>如果出现10053错误，那么使用<code>git config --global http.sslVerify false</code>来解除https的ssl的凭证。</p>
<p>在提交的时候，有时候会出现这样的错误：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">hint: Updates were rejected because <span class="keyword">the</span> remote <span class="keyword">contains</span> work that you <span class="built_in">do</span></span><br><span class="line">hint: <span class="keyword">not</span> have locally. This is usually caused <span class="keyword">by</span> another repository pushing</span><br><span class="line">hint: <span class="built_in">to</span> <span class="keyword">the</span> same ref. You may want <span class="built_in">to</span> <span class="keyword">first</span> integrate <span class="keyword">the</span> remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) <span class="keyword">before</span> pushing again.</span><br><span class="line">hint: See <span class="keyword">the</span> <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>
<p>这是因为在写代码之前，没有先更新本地项目造成的，所以我们得想办法先更新一下本地项目，但是我们又写了新的代码，有两种解决方案：</p>
<ol>
<li><p>允许不相关历史提交，并强制合并</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>
</li>
<li><p>强制提交</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="拉取远程库到本地"><a href="#拉取远程库到本地" class="headerlink" title="拉取远程库到本地"></a>拉取远程库到本地</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull [别名] [分支名]</span><br></pre></td></tr></table></figure>

<p>解决pull的时候速度慢：<code>git config --global http.postBuffer 524288000</code></p>
<h3 id="克隆远程库"><a href="#克隆远程库" class="headerlink" title="克隆远程库"></a>克隆远程库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> [url地址]</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<ul>
<li>fork: 复制一份别人的仓库到自己的远程仓库中，后期可以使用pull request请求别人合并自己新增加的功能。</li>
<li>clone: 将别人的项目clone到自己的本地电脑中。</li>
<li>pull: 从远程获取最新版本并merge到本地。</li>
</ul>
<h3 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h3><p>邀请团队成员：</p>
<p>github项目-&gt;Settings-&gt;Collaborators-&gt;Manage access-&gt;Add people</p>
<h3 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h3><p>先fork一份到自己的github中，修改完毕以后，先提交，然后Create pull request给其它团队的管理者审核，对方同意以后，就可以合并。</p>
<h3 id="github免密登录"><a href="#github免密登录" class="headerlink" title="github免密登录"></a>github免密登录</h3><ol>
<li><p>在windows 用户目录下面找到.ssh 文件夹</p>
</li>
<li><p>在当前目录下面打开git命令行，输入以下命令生成密钥：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C [github邮箱]</span><br></pre></td></tr></table></figure></li>
<li><p>复制id_rsa.pub中的内容</p>
</li>
<li><p>在github账号中配置，将复制的公钥粘贴到以下地址中：</p>
<p> Settings-&gt;SSH and GPG keys</p>
</li>
</ol>
<p>然后pull的时候就可以使用ssh，不需要输入用户名和密码。</p>
<h1 id="JetBrains-的IDE集成Git和GitHub"><a href="#JetBrains-的IDE集成Git和GitHub" class="headerlink" title="JetBrains 的IDE集成Git和GitHub"></a>JetBrains 的IDE集成Git和GitHub</h1><h2 id="集成Git"><a href="#集成Git" class="headerlink" title="集成Git"></a>集成Git</h2><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><p><strong>集成Git</strong></p>
<p>VCS-&gt;启用版本控制集成-&gt;确定</p>
<p><strong>取消版本控制</strong></p>
<p>设置-&gt;版本控制-&gt;选中项目点减号</p>
<p><strong>添加忽略文件</strong></p>
<p>在根目录创建一个.gitignore文件，然后将要忽略的文件添加进去。</p>
<h3 id="集成Git切换版本"><a href="#集成Git切换版本" class="headerlink" title="集成Git切换版本"></a>集成Git切换版本</h3><p><strong>1.添加到暂存区</strong></p>
<p>右键根目录-&gt;Git-&gt;添加</p>
<p><strong>2.提交</strong></p>
<p>右键根目录-&gt;Git-&gt;提交-&gt;写上备注信息-&gt;点击提交</p>
<p><strong>3.查看版本</strong></p>
<p>当提交多次以后，可以查看提交过的历史版本：</p>
<p>点击左下角的Git-&gt;Log</p>
<p><img src="https://img-blog.csdnimg.cn/62c724bada574d569d0e0a608cc43f72.png" alt="在这里插入图片描述"><br><strong>4.切换版本</strong></p>
<p>右键要切换的版本，然后点击<code>签出修订...</code>，即可切换版本。</p>
<p><img src="https://img-blog.csdnimg.cn/574f7ea5b2204ebcb8d2e6a572e03a8d.png" alt="在这里插入图片描述"><br>可以看到指针此时指向了v2。</p>
<p>如果要回到最新版本，右键最新版本，然后签出到master。</p>
<h3 id="集成Git创建、切换分支、合并分支"><a href="#集成Git创建、切换分支、合并分支" class="headerlink" title="集成Git创建、切换分支、合并分支"></a>集成Git创建、切换分支、合并分支</h3><p><strong>创建分支</strong></p>
<p>菜单-&gt;Git-&gt;新建分支…</p>
<p><strong>切换分支</strong></p>
<p>左下角-&gt;选择分支-&gt;签出</p>
<p><strong>合并分支</strong></p>
<p>首先切换到要合并的分支（一般是master）-&gt; Git -&gt; 合并 -&gt; 选择分支 …</p>
<p><img src="https://img-blog.csdnimg.cn/8c6f3c23883b4f4ab42ba3537c9961d9.png" alt="在这里插入图片描述"></p>
<p><strong>解决分支冲突</strong></p>
<p><img src="https://img-blog.csdnimg.cn/70c65716ee0746209bd7dd6be10a0e35.png" alt="在这里插入图片描述"><br>根据需要手动选择即可，第三个选项是自己手动修改。</p>
<h2 id="集成GitHub"><a href="#集成GitHub" class="headerlink" title="集成GitHub"></a>集成GitHub</h2><h3 id="在ide中配置GitHub"><a href="#在ide中配置GitHub" class="headerlink" title="在ide中配置GitHub"></a>在ide中配置GitHub</h3><p>文件-&gt;设置-&gt;版本控制-&gt;GitHub-&gt;点击+添加即可</p>
<h3 id="推送项目到GitHub"><a href="#推送项目到GitHub" class="headerlink" title="推送项目到GitHub"></a>推送项目到GitHub</h3><p><strong>共享项目到GitHub</strong></p>
<p>Git -&gt; GitHub -&gt; 在GitHub上共享项目 -&gt; 在描述中写上项目别名 -&gt; 点击确定</p>
<p><img src="https://img-blog.csdnimg.cn/09932f72418d4c07b042b5b991dea1a9.png" alt="在这里插入图片描述"></p>
<p><strong>push</strong></p>
<ol>
<li>修改代码并提交代码</li>
<li>Git -&gt; 推送</li>
</ol>
<h3 id="从GitHub-拉取项目"><a href="#从GitHub-拉取项目" class="headerlink" title="从GitHub 拉取项目"></a>从GitHub 拉取项目</h3><p>pull的目的就是获取项目的最新版本，并merge到本地。</p>
<p>Git -&gt; 更新项目</p>
<h3 id="从GitHub克隆项目"><a href="#从GitHub克隆项目" class="headerlink" title="从GitHub克隆项目"></a>从GitHub克隆项目</h3><p>VCS -&gt; 启用版本控制 -&gt; Git -&gt; 克隆</p>
<h1 id="码云Gitee"><a href="#码云Gitee" class="headerlink" title="码云Gitee"></a>码云Gitee</h1><h2 id="Gitee简介"><a href="#Gitee简介" class="headerlink" title="Gitee简介"></a>Gitee简介</h2><p>Gitee与Github功能类似，但是相比于github而言，gitee有两个优势：一是速度快，二是支持免费的私密项目。</p>
<p><strong>官网</strong></p>
<p><a href="https://gitee.com/">https://gitee.com/</a></p>
<h2 id="JetBrains的IDE集成码云Gitee"><a href="#JetBrains的IDE集成码云Gitee" class="headerlink" title="JetBrains的IDE集成码云Gitee"></a>JetBrains的IDE集成码云Gitee</h2><p>1.添加插件gitee<br>2.登录码云<br>3.push<br>4.pull</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Future模式 Golang实现</title>
    <url>/2022/09/07/Go/Future%E6%A8%A1%E5%BC%8F%20Golang%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>编程中经常遇到在一个流程中需要调用多个子调用的情况，这些子调用相互之间没有依赖，如果串行地调用，则耗时会很长，此时可以使用并发编程中的future模式。<br>比如我们发送ajax请求的时候，页面进行后续处理，用户无需一直等待请求的结果，可以继续浏览或操作其他内容。</p>
<p><strong>future 模式的基本工作原理</strong>：</p>
<ol>
<li>使用chan作为函数参数</li>
<li>启动goroutine调用函数</li>
<li>通过chan传入参数</li>
<li>做其他可以并行处理的事情</li>
<li>通过chan异步获取结果</li>
</ol>
<p><strong>future模式流程图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fa2f6ef20b44e15a1ae9474ac890be5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面是一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个查询结构体</span></span><br><span class="line"><span class="comment">// 这里的sql和result是一个简单的抽象，具体的应用可能是更复杂的数据类型</span></span><br><span class="line"><span class="keyword">type</span> query <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 参数Channel</span></span><br><span class="line">	sql <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">	<span class="comment">// 结果Channel</span></span><br><span class="line">	result <span class="keyword">chan</span> <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行Query</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">execQuery</span><span class="params">(q query)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 启动协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 获取输入</span></span><br><span class="line">		sql := &lt;- q.sql</span><br><span class="line">		<span class="comment">// 访问数据库</span></span><br><span class="line">		<span class="comment">// 输出结果通道</span></span><br><span class="line">		q.result &lt;- <span class="string">&quot;result from&quot;</span> + sql</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化Query</span></span><br><span class="line">	q := query&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)&#125;</span><br><span class="line">	<span class="comment">// 执行Query, 注意执行的时候无须准备参数</span></span><br><span class="line">	<span class="keyword">go</span> execQuery(q)</span><br><span class="line">	<span class="comment">// 发送参数</span></span><br><span class="line">	q.sql &lt;- <span class="string">&quot;select *fome table&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 做一些其它的事情, 这里通过Sleep描述</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取结果</span></span><br><span class="line">	fmt.Println(&lt;-q.result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result from select * from table</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Context的使用场景</title>
    <url>/2022/09/08/Go/Golang%20Context%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="1-值传递"><a href="#1-值传递" class="headerlink" title="1.值传递"></a>1.值传递</h2><p>值传递只是context的一个辅助功能，并不是核心功能。一般我们只用context来传递不影响业务主逻辑的可选数据，比如日志信息、调试信息以及元信息等等。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readContext</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	traceId, ok := ctx.Value(<span class="string">&quot;key&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;readContext key=&quot;</span>, traceId)i</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;readContext no key&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line">	readContext(ctx)</span><br><span class="line">	ctx = context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;beautiful&quot;</span>)</span><br><span class="line">	readContext(ctx)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在使用WithValue对ctx包装时，可以设置一个key-value键值对，在goroutine之间传递。</p>
<h2 id="2-超时控制"><a href="#2-超时控制" class="headerlink" title="2.超时控制"></a>2.超时控制</h2><p><strong>http请求设置超时时间</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequest</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 处理http请求</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">&quot;Request timed out&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">case</span> &lt;- time.After(time.Second):</span><br><span class="line">			fmt.Println(<span class="string">&quot;Loading...&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;start TestTimeoutContext&quot;</span>)</span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	httpRequest(ctx)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//start TestTimeoutContext</span></span><br><span class="line"><span class="comment">//Loading...</span></span><br><span class="line"><span class="comment">//Loading...</span></span><br><span class="line"><span class="comment">//Request timed out</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>文件io或者网络io等耗时操作，可以查看剩余的时间是否充足，决定是否进行下一步操作</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFile</span><span class="params">(ctx context.Context)</span></span>  &#123;</span><br><span class="line">	deadline, ok := ctx.Deadline()</span><br><span class="line">	<span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// deadline.Sub(time.Now()) 截止时间与当前时间的差值</span></span><br><span class="line">	isEnough := deadline.Sub(time.Now()) &gt; time.Second * <span class="number">5</span></span><br><span class="line">	<span class="keyword">if</span> isEnough &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;copy file&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;isEnough is false return&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithDeadline(context.Background(), time.Now().Add(time.Second * <span class="number">4</span>))</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	copyFile(ctx)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//isEnough is false return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="3-取消控制"><a href="#3-取消控制" class="headerlink" title="3.取消控制"></a>3.取消控制</h2><p><strong>goroutine发送取消信号，保证自己这个逻辑中发散出去的goroutine全部成功取消</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(ctx context.Context)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- n:</span><br><span class="line">				n++</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个Cancel context</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="keyword">for</span> n := <span class="keyword">range</span> gen(ctx) &#123;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">5</span> &#123;</span><br><span class="line">			<span class="comment">// 达到要求之后触发cancel</span></span><br><span class="line">			cancel()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang IO操作</title>
    <url>/2022/09/07/Go/Golang%20IO%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="file句柄"><a href="#file句柄" class="headerlink" title="file句柄"></a>file句柄</h2><p><code>os.Open(name string)</code>方法以只读方式打开文件，os 包还提供了 <code>os.OpenFile(name string, flag int, perm FileMode) </code>方法，通过指定额外的 <code>读写方式</code> 和 <code>文件权限</code>参数，使文件操作变得更为灵活。</p>
<p>其中，flag 有以下几种常用的值：</p>
<ul>
<li>os.O_CREATE: create if none exists 不存在则创建</li>
<li>os.O_RDONLY: read-only 只读</li>
<li>os.O_WRONLY: write-only 只写</li>
<li>os.O_RDWR: read-write 可读可写</li>
<li>os.O_TRUNC: truncate when opened 文件长度截为0：即清空文件</li>
<li>os.O_APPEND: append 追加新数据到文件</li>
</ul>
<p>对于文件权限参数，Linux系统中采用四位八进制数组成权限，比如0644 。对于每个新创建的文件或目录，系统都会自动赋予一个默认的权限。<br>可以使用<code>umask</code>命令设置文件或目录的默认权限。系统默认的权限掩码是<code>0022</code>。</p>
<p>通常新建文件的默认权限值为0666，新建目录的默认权限为0777，需要与当前的权限掩码0022相减，可以得到<code>0644</code>和<code>0755</code>。</p>
<p>读文件</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 打开文件返回一个句柄</span></span><br><span class="line">	file, _ := os.Open(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓冲区</span></span><br><span class="line">	buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="comment">// 存放文件所有内容</span></span><br><span class="line">	<span class="keyword">var</span> bytes []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每次读取一行放入缓冲区</span></span><br><span class="line">		count, err := file.Read(buf)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		bytes = <span class="built_in">append</span>(bytes, buf[:count]...)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>写文件</p>
<p>可以通过 <code>Write()</code> 和 <code>WriteString()</code> 方法写入数据，最后通过 <code>Sync()</code> 方法将数据持久化到磁盘：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>, os.O_RDWR | os.O_APPEND | os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">	data := []<span class="type">byte</span>(<span class="string">&quot;hello\nyes\nno\n&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字节</span></span><br><span class="line">	count, _ := file.Write(data)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第一次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字符串</span></span><br><span class="line">	count, _ = file.WriteString(<span class="string">&quot;write string\n&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第二次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 确保写入磁盘</span></span><br><span class="line">	file.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="更简单的ioutil"><a href="#更简单的ioutil" class="headerlink" title="更简单的ioutil"></a>更简单的ioutil</h2><p>读文件</p>
<p>一次性读入所有内容：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	bytes, _ := ioutil.ReadFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(bytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逐行读入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	file, _ := os.Open(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 接受io.Reader类型参数 返回一个bufio.Scanner实例</span></span><br><span class="line">	scanner := bufio.NewScanner(file)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> count <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">		count++</span><br><span class="line">		<span class="comment">// 读取当前行内容</span></span><br><span class="line">		line := scanner.Text()</span><br><span class="line">		fmt.Println(count, <span class="string">&quot;: &quot;</span> ,line)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>写文件</p>
<p>覆盖写入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	data := []<span class="type">byte</span>(<span class="string">&quot;hello\nyes\nno\n&quot;</span>)</span><br><span class="line">	ioutil.WriteFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>, data, <span class="number">0664</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追加：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 以指定的权限打开文件</span></span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>, os.O_RDWR | os.O_APPEND | os.O_CREATE, <span class="number">0664</span>)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	data := []<span class="type">byte</span>(<span class="string">&quot;greet\n&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字节</span></span><br><span class="line">	count, _ := file.Write(data)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第一次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 写入字符串</span></span><br><span class="line">	count, _ = file.WriteString(<span class="string">&quot;echo\n&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;第二次写入&quot;</span>, count, <span class="string">&quot;字节&quot;</span>)</span><br><span class="line">	<span class="comment">// 确保落盘</span></span><br><span class="line">	file.Sync()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="io-Writer和io-Reader接口"><a href="#io-Writer和io-Reader接口" class="headerlink" title="io.Writer和io.Reader接口"></a>io.Writer和io.Reader接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">   Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实io 包就是围绕着实现了 io.Writer 和 io.Reader 接口类型的值而构建的。比如<code>os.File</code>、<code>io.Copy</code>、<code>io.WriteString</code>、<code>io.PipeWriter/Reader</code>、<code>ioutil</code>等等都实现了这两个接口，所以它们都可以读文件和写文件。当然我们也可以自行实现这两个接口。</p>
<h2 id="io-LimitReader函数"><a href="#io-LimitReader函数" class="headerlink" title="io.LimitReader函数"></a>io.LimitReader函数</h2><p>在学习godis时，在aof.go文件中我看到一个关于io流的函数：<code>io.LimitReader</code>。该函数用于返回指定大小的Reader。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LimitReader returns a Reader that reads from r</span></span><br><span class="line"><span class="comment">// but stops with EOF after n bytes.</span></span><br><span class="line"><span class="comment">// The underlying implementation is a *LimitedReader.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LimitReader</span><span class="params">(r Reader, n <span class="type">int64</span>)</span></span> Reader &#123; <span class="keyword">return</span> &amp;LimitedReader&#123;r, n&#125; &#125;</span><br></pre></td></tr></table></figure>

<p>下面演示一下基本的使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	file, _ := os.Open(<span class="string">&quot;D:\\Desktop\\readme.txt&quot;</span>)</span><br><span class="line">	res := io.LimitReader(file, <span class="number">20</span>)</span><br><span class="line">	data := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	count, err := res.Read(data)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="type">string</span>(data[:count]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，res是一个Reader，且res只获取到了从文件开始往后20字节的内容。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Interface</title>
    <url>/2022/09/07/Go/Golang%20Interface/</url>
    <content><![CDATA[<h2 id="空接口-interface"><a href="#空接口-interface" class="headerlink" title="空接口 interface{}"></a>空接口 interface{}</h2><p>空接口类型可以接收任意类型的数据，它只要记录这个数据在哪儿，是什么类型的就足够了。空接口变量数据结构如下，其中_type指向接口的动态类型元数据，data就指向接口的动态值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>比如下面这个例子，为e赋值以前，其中存储的_type和data都为nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/c2f0af3751cd4a9f91c90510731618fd.png" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>如果我们把*os.File类型的变量f赋给e。那么变量e的结构如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/14df482e593547b89430bd44fda5c4f1.png" alt="在这里插入图片描述"></p>
<p>因为f本身就是个指针，所以e这里的data就等于f，动态类型就是*os.File。值得强调的是类型元数据这里是可以找到类型关联的方法元数据列表的，这一点对于理解“类型断言”至关重要。</p>
<h3 id="interface-参数赋值"><a href="#interface-参数赋值" class="headerlink" title="interface{}参数赋值"></a>interface{}参数赋值</h3><p>interface{}类型的变量中会保存一个地址。假如存在如下的一种情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">a := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = a</span><br></pre></td></tr></table></figure>



<p>那么e接收的参数会是下面这样的吗？</p>
<p><img src="https://img-blog.csdnimg.cn/84ff820775174577b9a2ccfa0eef8f94.png" alt="在这里插入图片描述"></p>
<p>答案是否定的，原因是这样并不符合“Go语言中传参值拷贝”的语义。从语义上讲也应该使用<code>a</code>的拷贝值，而不是直接使用<code>a</code>。但问题是空接口类型的参数需要的只是一个数据指针，不能拷贝a的值过来，又不能拷贝a的地址过来，那拷贝谁？</p>
<p>解决这个问题的方式，是在编译阶段增加临时变量作为a的拷贝值(copy of a)，再把<code>copy of a</code>的地址传给函数使用，无论之后对参数指向的数据做什么修改，都不会作用到变量a身上。这样就通过<code>传递复制后的地址实现了传值的语义</code>。</p>
<p><code>copy of a</code>的地址会在编译阶段转换为空接口类型，所以<code>TypeOf</code>接收到的参数就如下图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/d61b71d7b3384655af7d0e8708236f76.png" alt="在这里插入图片描述"></p>
<h2 id="非空接口"><a href="#非空接口" class="headerlink" title="非空接口"></a>非空接口</h2><p>非空接口就是有方法列表的接口类型，一个变量要想赋值给一个非空接口类型，其类型必须要实现该接口要求的所有方法才行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab   *itab</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>iface.data记录的是接口的动态值，所以接口要求的方法列表以及与data对应的动态类型信息一定存在itab里面。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter  *interfacetype</span><br><span class="line">    _type  *_type</span><br><span class="line">    hash   <span class="type">uint32</span></span><br><span class="line">    _      [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">    fun    [<span class="number">1</span>]<span class="type">uintptr</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>itab.inter是interface的类型元数据，它里面记录了这个接口类型的描述信息，接口要求的方法列表就记录在interfacetype.mhdr这里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ      _type</span><br><span class="line">    pkgpath  name</span><br><span class="line">    mhdr     []imethod</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>



<ul>
<li>itab._type就是接口的动态类型，也就是被赋给接口类型的那个变量的类型元数据。</li>
<li>itab.hash是从itab._type中拷贝来的，是类型的哈希值，用于快速判断类型是否相等时使用。</li>
<li>itab.fun记录的是动态类型实现的那些接口要求的方法的地址，是从方法元数据中拷贝来的，为的是快速定位到方法。如果itab._type对应的类型没有实现这个接口，则itab.fun[0]&#x3D;0，这在类型断言时会用到。</li>
</ul>
<h2 id="非空接口赋值前后"><a href="#非空接口赋值前后" class="headerlink" title="非空接口赋值前后"></a>非空接口赋值前后</h2><p>如果我们声明一个io.ReadWriter类型的变量rw。被赋值以前，rw的data为nil，tab也为nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/9289d00e7f8d4834b6185656f473a138.png" alt="在这里插入图片描述"></p>
<p>下面我们把一个*os.File类型的变量f，赋值给rw。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">rw = f</span><br></pre></td></tr></table></figure>



<p>此时rw的动态值就是f，动态类型就是<em>os.File。而itab.fun这个数组里记录的是</em>os.File实现的Read、Write方法的地址。</p>
<p><img src="https://img-blog.csdnimg.cn/483e1bf916a14742b3bba37d491388eb.png" alt="在这里插入图片描述"></p>
<p>下面我们再声明一个io.Writer类型的变量w，并把f赋值给w。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer = f</span><br></pre></td></tr></table></figure>



<p>此时w的动态值和动态类型与rw相同，只是二者的接口类型元数据不同，要求的方法列表也不同罢了。</p>
<p><img src="https://img-blog.csdnimg.cn/07bbb185a9dc41a3b40bdb8e0d05ec12.png" alt="在这里插入图片描述"></p>
<h2 id="itab缓存"><a href="#itab缓存" class="headerlink" title="itab缓存"></a>itab缓存</h2><p>关于itab我们还要额外关注一点，既然一个非空接口类型和一个动态类型就可以确定一个itab的内容，那这个itab结构体自然是可以被接口类型与动态类型均相同的接口变量复用的。<br><img src="https://img-blog.csdnimg.cn/5c5a86b04d064ad592d57a8e7235202e.png" alt="在这里插入图片描述"></p>
<p>实际上Go语言会把用到的itab结构体缓存起来，并且以<code>&lt;接口类型, 动态类型&gt;</code>组合为key，以<code>*itab</code>为value，构造一个哈希表，用于存储与查询itab信息。</p>
<p><img src="https://img-blog.csdnimg.cn/33741fe5bbda444fac710fad554d689e.png" alt="在这里插入图片描述"></p>
<p>这个哈希表与map底层的哈希表不同，其结构设计更为简便。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="type">uintptr</span>             <span class="comment">// length of entries array. Always a power of 2.</span></span><br><span class="line">    count   <span class="type">uintptr</span>             <span class="comment">// current number of filled entries.</span></span><br><span class="line">    entries [itabInitSize]*itab <span class="comment">// really [size] large</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要一个itab时，会首先去itabTable里查找，计算哈希值时会用到接口类型(itab.inter)和动态类型(itab._type)的类型哈希值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabHashFunc</span><span class="params">(inter *interfacetype, typ *_type)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uintptr</span>(inter.typ.hash ^ typ.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能查询到对应的itab指针，就直接拿来使用。若没有就要再创建，然后添加到itabTable中。</p>
<p>了解了空接口和非空接口的数据结构，明确了接口动态值与动态类型在赋值前与赋值后的变化，接下来就可以看看“类型断言”是怎么回事儿了。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Mutex剖析</title>
    <url>/2022/09/07/Go/Golang%20Mutex%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Mutex内存模型"><a href="#Mutex内存模型" class="headerlink" title="Mutex内存模型"></a>Mutex内存模型</h2><p>在go语言中，Mutex的结构是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为简单所以不需要额外的初始化。此结构的零值就是一个有效的互斥锁，处于Unlock的状态。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9d0d4cc761a47ea8edb064e8ea0ffc3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><code>state</code>储存的是互斥锁的状态，加锁和解锁都是通过atomic包提供的函数原子性操作来操作该字段。</p>
<p><code>sema</code>用作一个信号量，主要用作等待队列。</p>
<h2 id="Mutex的两种模式"><a href="#Mutex的两种模式" class="headerlink" title="Mutex的两种模式"></a>Mutex的两种模式</h2><h3 id="正常模式"><a href="#正常模式" class="headerlink" title="正常模式"></a>正常模式</h3><p>在正常模式下，一个尝试加锁的goroutine会先自旋几次，尝试通过原子操作获得锁，若几次自旋之后仍不能获得锁，则通过信号量排队等待。所有的等待者会按照先入先出（FIFO）的顺序排队。</p>
<p>但是当锁被释放，第一个等待者并不会直接拥有锁，而是需要和后来者竞争。也就是那些处于自旋阶段，尚未排队等待的goroutine。这种情况下后来者更有优势。一方面，它们正在CPU上运行，自然比刚唤醒的goroutine更有优势（正在CPU上运行的协程不需要进行上下文切换，而刚唤醒的协程需要进行上下文切换），另一方面，处于自旋状态的goroutine可以有很多，而被唤醒的goroutine每次只有一个。所以被唤醒的goroutine有很大概率拿不到锁。这种情况下，它会被重新插入到队列的头部，而不是尾部。</p>
<h3 id="饥饿模式"><a href="#饥饿模式" class="headerlink" title="饥饿模式"></a>饥饿模式</h3><p>而当一个goroutine本次加锁等待的时间超过了1ms后，它会把当前Mutex从正常模式切换至<code>饥饿模式</code>。</p>
<p>在饥饿模式下，Mutex的所有权从执行Unlock的goroutine直接传递给等待队列头部的goroutine。后来者不会自旋，也不会尝试获得锁。即使Mutex处于Unlock状态，它们会直接从队列的尾部排队等待。当一个等待者获得锁之后，它会在以下两种情况时，将Mutex由饥饿模式切换回正常模式：</p>
<ul>
<li>一种情况是：它的等待时间小于1ms，也就是它刚来不久。</li>
<li>第二种情况是：它是最后一个等待者，等待队列已经空了，后面自然就没有饥饿的goroutine了。</li>
</ul>
<p>综上所述，在正常模式下自旋和排队是同时存在的，执行Lock的goroutine会先一边自旋，尝试过几次后如果还没有拿到锁，就需要去排队等待了。这种在排队之前先让大家来抢的模式，能够有更高的吞吐量，因为频繁的挂起、唤醒goroutine会带来较多的开销。但是又不能无限制的自旋，要把自旋的开销控制在较小的范围内，所以在正常模式下，Mutex有更好的性能。但是可能会出现队列尾端的goroutine迟迟抢不到锁（尾端延迟）的情况。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d5b6e90b5b4c60b6eb16813532b2d5~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>而饥饿模式下不再自旋尝试，所有goroutine都要排队，严格的先来后到。对于防止尾端延迟来讲特别重要。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592effd23c4d40d499f427cb22912f4d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="Lock和Unlock"><a href="#Lock和Unlock" class="headerlink" title="Lock和Unlock"></a>Lock和Unlock</h2><p>首先来看一下关于Mutex.state的几个常量定义：</p>
<p>我们再来看一下Mutex的内存模型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span></span><br><span class="line">	sema <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a5140360494e3a934a98762b777789~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>state的类型是int32。</p>
<ul>
<li>其中第一位用作锁状态标识符，置为1就表示已加锁，对应的掩码常量为<code>mutexLocked</code>。</li>
<li>第二位用于记录是否已有goroutine被唤醒了，置为1表示已唤醒，对应掩码常量为<code>mutexWoken</code>。</li>
<li>第三位标识Mutex的工作模式，0代表正常模式，1代表饥饿模式，对应掩码常量为<code>mutexStarving</code>。</li>
<li>而常量mutexWaiterShift等于3，表示除了最低三位以外，state的其他位用来记录有多少个等待着在排队。</li>
</ul>
<p><strong>Lock和Unlock方法</strong></p>
<p>再来看看Lock和Unlock方法：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f943605ff5e47319f2c444052510668~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>精简掉了注释和部分race检测相关的代码，两个方法中主要通过atomic函数实现了Fast path，相应的Slow path被单独放在了lockSlow和unlockSlow方法中。根据源码注释的说法，这样是为了便于编译器对于Fast path进行内联优化。</p>
<p>Lock方法的Fast path期望Mutex处于Unlocked状态，没有goroutine在排队，更不会饥饿。理想状况下，一个CAS操作就可以获得锁。但是如果CAS操作没能获得锁，就需要进入Slow path，也就是lockSlow方法。</p>
<p>Unlock方法同理，首先通过原子操作从state中减去mutexLocked，也就是释放锁。然后根据state的新值来判断是否需要执行Slow path。如果新值为0，也就意味着没有其它goroutine在排队，所以不需要执行额外操作；如果新值不为0，那就需要进入slow path，看看是否需要唤醒某个goroutine。</p>
<h2 id="slow-path的主要逻辑"><a href="#slow-path的主要逻辑" class="headerlink" title="slow path的主要逻辑"></a>slow path的主要逻辑</h2><p>当一个goroutine尝试给mutex加锁时，如果其它goroutine已经加了锁还没有释放，而且当前mutex工作在正常模式下，是不是就要开始自旋了呢？</p>
<p>答案是不一定。因为如果当前是单核场景，自旋的goroutine在等待持有锁的goroutine释放锁，而持有锁的goroutine在等待自旋的goroutine让出CPU。这种情况下自旋是没有意义的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/447cdca0522a41abb8c259664679d020~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>而且，如果<code>GOMAXPROCS=1</code>，或者当前没有其它P在运行，也和单核场景类似，同样不需要自旋。<br>除此之外，如果当前P的本地runq不为空，相较于自旋而言，切换到本地goroutine更有效率。所以为保障吞吐量，也不会自旋。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28fdbd6c9a18487a800a155c37ef3df4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>最终，只有在多核场景下，且<code>GOMAXPROCS大于1</code>，且至少有一个其它的P正在running，且当前P的本地runq为空的情况下，才可以自旋。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3539a0c00faf4e1488e161c3b76613aa~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>进入自旋的goroutine会先去争抢mutex的唤醒标识位。设置mutexWoken标识位的目的是：在正常模式下，告知持有锁的goroutine，在unlock的时候不用再唤醒其它goroutine了，已经有goroutine在这里等待。以免唤醒太多的等待协程。</p>
<p>mutex中的自旋，底层是通过procyield循环执行30次PAUSE，自旋次数上限为4。而且每自旋一次都要重新判断是否可以继续自旋。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6fc64e48f17c4293b9839068b4bad46f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果锁被释放了，或者锁进入饥饿模式，亦或者已经自旋了4次，都会结束自旋。结束自旋或者根本不用的goroutine，就该尝试原子操作修改mutex的状态了。把此时mutex.state保存到old中，把要修改为的新state标记为new。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80247df4ab6f45c7beda90389b81b6de~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果old处于饥饿模式或者加锁状态，goroutine就得去排队，所以上述情况下排队规模要加1。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/071b8b618cc842f9bb6da927a2bbd67b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果是正常模式，就要尝试设置lock位。所以第三行的new位要置为1。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14998427658a48d795a68a0690041c67~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果当前goroutine等待的时间已经超过1ms，而且锁还没有被释放。就要将mutex的状态切换为饥饿模式。注意，这里之所以还要求锁没被释放，是因为如果锁已经释放了，那怎么都得去抢一次，要是直接进入饥饿模式就只能去排队了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe75351df29d4cc989124bc4d8de924d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>把排队规模和几个标识位都设置好以后，在执行原子操作修改state之前，若是当前goroutine持有唤醒标识的话，还要将唤醒标识位重置。<br>因为接下来无论是要去抢锁，还是单纯的要去排队，如果原子操作成功了，要么是成功抢到了锁，要么是成功进到了等待队列里。当前goroutine都不再是被唤醒的goroutine了，所以要释放唤醒标识。<br>而如果原子操作不成功，也就意味着其它goroutine在我们保存mutex.state到old中以后，又修改了state的值。当前goroutine就要回过头去，继续从自旋检查这里开始再次尝试。所以也需要释放自己之前抢到的唤醒标识位，从头再来。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f64dadc0401407d88a5a77309e3314a~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="加锁的slow-path"><a href="#加锁的slow-path" class="headerlink" title="加锁的slow path"></a>加锁的slow path</h3><p>继续展开这个原子操作成功的分支，如果是抢锁操作成功了，那么加锁的slow path就可以宣告结束了。如果是排队规模设置成功了，还要决定是排在等待队列头部还是尾部。如果当前goroutine已经排过队了，是在unlock时从等待队列中唤醒的，那就要排到等待队列头部。<br>如果是第一次排队，就得排到等待队列尾部，并且从第一次排队开始记录当前goroutine的等待时间。接下来就会让出，进到等待队列里了。队列里的goroutine被唤醒时，要从上次让出的地方开始继续执行。<br>接下来会判断，如果mutex处在正常模式，那就接着从自旋开始抢锁，如果唤醒后处在饥饿模式，那就没有goroutine会和自己抢了。锁已经轮到自己这里，只需要把mutex.state中lock标识位设置为加锁，把等待队列规模减去1，再看看是不是要切换到正常模式，也就是自己的等待时间是不是小于1ms，或者等待队列已经空了，最后设置好mutex.state就一切ok了。</p>
<p>这就是加锁操作的slow path。</p>
<h3 id="解锁的slow-path"><a href="#解锁的slow-path" class="headerlink" title="解锁的slow path"></a>解锁的slow path</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e93ba7aada44102bc4edd6bd29718cc~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>进到unlock的slow path，说明除去lock标识位以外。剩下的位不全为0。<br>如果处在正常模式，若等待队列为空。或者已经有goroutine被唤醒或获得了锁，或者锁进入了饥饿模式，那就不需要唤醒某个goroutine，直接返回即可，否则就要尝试抢占mutexWoken标识位，获取唤醒一个goroutine的权利。抢占成功后，就会通过runtime_Semrelease函数唤醒一个goroutine。<br>如果抢占不成功就进行循环尝试，直到等待队列为空，或者已经有一个goroutine被唤醒或获得了锁，或者锁进入了饥饿模式，则退出循环。<br>而在饥饿模式下，后来的goroutine不会抢占锁，而是直接排队，锁的所有权是直接从执行Unlock的goroutine，传递给等待队列中首个等待者的，所以不用抢占mutexWoken标识位。</p>
<p>第一个等待者唤醒后，会继承当前goroutine的时间片立刻开始运行，也就是继续lockSlow中这里，goroutine被唤醒以后的逻辑。</p>
<p>这就是unlock的slow path。</p>
<p>接下来再看看关于信号量的相关操作。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang GC</title>
    <url>/2022/09/07/Go/Golang%20GC/</url>
    <content><![CDATA[<p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的**STW(stop the world)**，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。</p>
<h2 id="一、Go-V1-3之前的标记-清除-mark-and-sweep-算法"><a href="#一、Go-V1-3之前的标记-清除-mark-and-sweep-算法" class="headerlink" title="一、Go V1.3之前的标记-清除(mark and sweep)算法"></a>一、Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>此算法主要有两个主要的步骤：</p>
<ul>
<li>标记(Mark phase)</li>
<li>清除(Sweep phase)</li>
</ul>
<p><strong>第一步</strong>，暂停程序业务逻辑, 找出不可达的对象，然后做上标记。第二步，回收标记好的对象。</p>
<p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>。也就是说，这段时间程序会卡在哪儿。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac1b83fe06af4a14b08370b501d810c8~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/545ce0e836d6421ab817bc882c6a9225~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第三步</strong>,  标记完了之后，然后开始清除未标记的对象. 结果如下:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eac72e80cdd647dba6b141ed4ad579d2~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p>
<h2 id="二、标记-清扫-mark-and-sweep-的缺点"><a href="#二、标记-清扫-mark-and-sweep-的缺点" class="headerlink" title="二、标记-清扫(mark and sweep)的缺点"></a>二、标记-清扫(mark and sweep)的缺点</h2><ul>
<li>STW，stop the world；让程序暂停，程序出现卡顿 **(重要问题)**。</li>
<li>标记需要扫描整个heap</li>
<li>清除数据会产生heap碎片</li>
</ul>
<p>所以Go V1.3版本之前就是以上来实施的,  流程是:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7718cc193ab043b986b0680dc1ce463b~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93a332327e9a43d4b3a0c18b6b3b3a20~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序</strong> 。</p>
<p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用<strong>三色并发标记法</strong>来优化这个问题。</p>
<h2 id="三、Go-V1-5的三色并发标记法"><a href="#三、Go-V1-5的三色并发标记法" class="headerlink" title="三、Go V1.5的三色并发标记法"></a>三、Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程。</p>
<p><strong>第一步</strong> , 就是只要是新创建的对象,默认的颜色都是标记为“白色”。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ac709b570b941d5bd7b81c1cbd45fc1~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这里面需要注意的是, 所谓“程序”, 则是一些对象的根节点集合。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a000a5fbfd74f6593ffd593f4026bf5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>所以上图,可以转换如下的方式来表示:</p>
<p><strong>第二步</strong>, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7af7bdaae0c4930871025c8749d8950~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17bf5f0ddfee4d848759c7bcfce847d0~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第四步</strong>, 重复<strong>第三步</strong>, 直到灰色中无任何对象.</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc6d2618db954e729bc8306c06751d4b~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3010110caf624310bb25df825b274ee5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>第五步</strong>: 回收所有的白色标记表的对象. 也就是回收垃圾。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84bcefbb465a46699f360b9f889aeb41~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现并行的呢?</p>
<blockquote>
<p>Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p>
</blockquote>
<h2 id="四、没有STW的三色标记法"><a href="#四、没有STW的三色标记法" class="headerlink" title="四、没有STW的三色标记法"></a>四、没有STW的三色标记法</h2><p>我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的。因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景。</p>
<p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cebaae7267b34d24bb096925719a4d4e~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a5a9baa13054016a3815bf60c7dd9e4~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c93db7580edf4d688f3cb1e0ace94773~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb60c2e1b1c040e8971b1d236edd08d9~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3355fc5f7274fc0af1518d858d89376~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的:</p>
<ul>
<li>条件1: 一个白色对象被黑色对象引用 **(白色被挂在黑色下)**。</li>
<li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏 **(灰色同时丢了该白色)**。</li>
</ul>
<p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p>
<p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉！</p>
<p>为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？</p>
<p>答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了。</p>
<h2 id="五、屏障机制"><a href="#五、屏障机制" class="headerlink" title="五、屏障机制"></a>五、屏障机制</h2><p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式:</p>
<h3 id="1-“强-弱”-三色不变式"><a href="#1-“强-弱”-三色不变式" class="headerlink" title="(1) “强-弱” 三色不变式"></a>(1) “强-弱” 三色不变式</h3><ul>
<li>强三色不变式</li>
</ul>
<p>不存在黑色对象引用到白色对象的指针。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f1e61f0727e4409a3374e77efe09144~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<ul>
<li>弱三色不变式</li>
</ul>
<p>所有被黑色对象引用的白色对象都处于灰色保护状态。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9371425b8d7428a963eed8b7e3c8051~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”。</p>
<h3 id="2-插入屏障"><a href="#2-插入屏障" class="headerlink" title="(2)  插入屏障"></a>(2)  插入屏障</h3><ul>
<li><p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)。</p>
</li>
<li><p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)。</p>
</li>
</ul>
<p>伪码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;   </span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  标记灰色(新下游对象ptr)   </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  当前下游对象slot = 新下游对象ptr  				  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(<span class="literal">nil</span>, B)   <span class="comment">//A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span></span><br><span class="line">A.添加下游对象(C, B)     <span class="comment">//A 将下游对象C 更换为B，  B被标记为灰色</span></span><br></pre></td></tr></table></figure>



<p>这段伪码逻辑就是写屏障, 我们知道, 黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>。栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中。</p>
<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dc4828bc1af4463ba4ec1373bb1bee5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afbafac77b1141828e821cfcf3d26650~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34894cf8c33946329bb2c78a7a69ab6c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/686c50f8dd784d1f844f17bfa21fd5f5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/14f841fbb3ac4c12b37195e9acf4cc72~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c673530edb89453da67a81e831547c23~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/073a6e5db8cb475bbe38855c727c57d5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad51f4abc95940369f57d7692158178a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3c8834269e634c9ea38658d86edb0701~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dde571066324609862ff19e294e3a95~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h3 id="3-删除屏障"><a href="#3-删除屏障" class="headerlink" title="(3)  删除屏障"></a>(3)  删除屏障</h3><ul>
<li><p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
</li>
<li><p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)。</p>
</li>
</ul>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot， 新下游对象ptr) &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  <span class="keyword">if</span> (当前下游对象slot是灰色 || 当前下游对象slot是白色) &#123;</span><br><span class="line">  		标记灰色(当前下游对象slot)     <span class="comment">//slot为被删除对象， 标记为灰色</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//2</span></span><br><span class="line">  当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>场景：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">A.添加下游对象(B, <span class="literal">nil</span>)   <span class="comment">//A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)</span></span><br><span class="line">A.添加下游对象(B, C)		 <span class="comment">//A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)</span></span><br></pre></td></tr></table></figure>




<p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程:</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dec0820aa4c4a7bb231beab84625d2a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a277b8762b9419eb64b00beced71633~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cd4a97c8f3ad47d59e3e1841c51efd0f~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4036a8b11d994754811c53a13162f410~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7243344632fa42a791a707f5d8d80627~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0bd798bd85444f27ac36b9c8f7df571e~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b1c655c756c454c89d167763dd51948~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h2 id="六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制"><a href="#六、Go-V1-8的混合写屏障-hybrid-write-barrier-机制" class="headerlink" title="六、Go V1.8的混合写屏障(hybrid write barrier)机制"></a>六、Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li><p>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；</p>
</li>
<li><p>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</p>
</li>
</ul>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<h4 id="1-混合写屏障规则"><a href="#1-混合写屏障规则" class="headerlink" title="(1) 混合写屏障规则"></a>(1) 混合写屏障规则</h4><p><code>具体操作</code>: </p>
<p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)， </p>
<p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p>
<p>3、被删除的对象标记为灰色。</p>
<p>4、被添加的对象标记为灰色。</p>
<p><code>满足</code>: 变形的<strong>弱三色不变式</strong>。</p>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">添加下游对象(当前下游对象slot, 新下游对象ptr) &#123;</span><br><span class="line">  	<span class="comment">//1 </span></span><br><span class="line">		标记灰色(当前下游对象slot)    <span class="comment">//只要当前下游对象被移走，就标记灰色</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">//2 </span></span><br><span class="line">  	标记灰色(新下游对象ptr)</span><br><span class="line">  		</span><br><span class="line">  	<span class="comment">//3</span></span><br><span class="line">  	当前下游对象slot = 新下游对象ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p>
<h3 id="2-混合写屏障的具体场景分析"><a href="#2-混合写屏障的具体场景分析" class="headerlink" title="(2) 混合写屏障的具体场景分析"></a>(2) 混合写屏障的具体场景分析</h3><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p>
<blockquote>
<p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p>
</blockquote>
<p><strong>GC开始：扫描栈区，将可达对象全部标记为黑</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/41e49a176cfe46839c3ea7c5c530bfca~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19055b031c674e48bb1f24cdc8de1f2c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</strong></p>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span></span><br><span class="line">栈对象<span class="number">1</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；  <span class="comment">//将堆对象7 挂在 栈对象1 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = null；    <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff951b3fb30b44b2b9bcfc9889338c2d~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/491aad80d88845ad9fcf8277eb2f5119~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</strong></p>
<p>伪代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">new</span> 栈对象<span class="number">9</span>；</span><br><span class="line">对象<span class="number">8</span>-&gt;对象<span class="number">3</span> = 对象<span class="number">3</span>；      <span class="comment">//将栈对象3 挂在 栈对象9 下游</span></span><br><span class="line">对象<span class="number">2</span>-&gt;对象<span class="number">3</span> = null；      <span class="comment">//对象2 删除引用 对象3</span></span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e1d6759f7e54a8abf9bcd24b3bb10d5~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/984303836de447ebaafe2c56cf329e7c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ecb69027ab0b4c0ca34ce9f56f885df2~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</strong></p>
<p>伪代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">堆对象<span class="number">10</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；       <span class="comment">//将堆对象7 挂在 堆对象10 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = null；         <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>



<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ae43cb30bb244689bb1d882c7fd0252~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f0b5bcfcff2443218cc40316f4d92aba~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad32a5a07224ecda04a02ffc515fb2e~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</strong></p>
<p>伪代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">堆对象<span class="number">10</span>-&gt;对象<span class="number">7</span> = 堆对象<span class="number">7</span>；       <span class="comment">//将堆对象7 挂在 堆对象10 下游</span></span><br><span class="line">堆对象<span class="number">4</span>-&gt;对象<span class="number">7</span> = null；         <span class="comment">//对象4 删除引用 对象7</span></span><br></pre></td></tr></table></figure>




<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce1217825c864b929399831f93794fea~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09bec0e1773848b59bf63ca8bf025fef~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/267919f0eb854318bf9a5d5754295b89~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p>
<p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
<p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p>
<p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang Tag语法</title>
    <url>/2022/09/07/Go/Golang%20Tag%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="Tag格式"><a href="#Tag格式" class="headerlink" title="Tag格式"></a>Tag格式</h2><p>tag被定义在结构体字段的后面，以字符串的形式出现，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">	f1 <span class="type">string</span> <span class="string">&quot;f one&quot;</span></span><br><span class="line">	f2 <span class="type">string</span></span><br><span class="line">	f3 <span class="type">string</span> <span class="string">`f three`</span></span><br><span class="line">	f4, f5 <span class="type">int64</span> <span class="string">`f four and five`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意，不管是双引号还是反引号，都可以用来当tag。如果结构体字段在定义的时候，两个字段共用一个属性，那么这个tag会被附在两个名字上，像上述代码中的f1，f5一样。</p>
<p><strong>键值对</strong></p>
<p><code>Tags</code>可以由键值对来组成，通过空格符来分割键值 —<code>key1:&quot;value1&quot; key2:&quot;value2&quot; key3:&quot;value3&quot;</code>。如果Tags格式没问题的话，我们可以通过<code>Lookup</code>或者<code>Get</code>来获取键值对的值。<br><code>Lookup</code>回传两个值，对应的值和是否找到。<br><code>Get</code>只回传一个值，即对应的那个值，如果没有找到就返回空。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Food <span class="keyword">struct</span> &#123;</span><br><span class="line">	Apple <span class="type">string</span> <span class="string">`fruit:&quot;apple&quot;`</span></span><br><span class="line">	Tomato <span class="type">string</span> <span class="string">`vegetable:&quot;tomato&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(Food&#123;&#125;)</span><br><span class="line">	f, _ := t.FieldByName(<span class="string">&quot;Apple&quot;</span>)</span><br><span class="line">	fmt.Println(f.Tag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tag.Lookup</span></span><br><span class="line">	v, ok := f.Tag.Lookup(<span class="string">&quot;fruit&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s, %t\n&quot;</span>, v, ok)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Tag.Get</span></span><br><span class="line">	v = f.Tag.Get(<span class="string">&quot;fruit&quot;</span>)</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fruit:<span class="string">&quot;apple&quot;</span></span><br><span class="line">apple, <span class="literal">true</span></span><br><span class="line">apple</span><br></pre></td></tr></table></figure>






<h2 id="Tag的使用"><a href="#Tag的使用" class="headerlink" title="Tag的使用"></a>Tag的使用</h2><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>在golang中，命名都是推荐用驼峰方式，并且在首字母大小写有特殊的语法含义：包外无法引用。但是由于经常需要和其它的系统进行数据交互，例如转成json格式，存储到mongodb啊等等。这个时候如果用属性名来作为键值可能不一定会符合项目要求。<br>而通过Tag，我们可以在转换成其它格式的时候，使用其中定义的字段作为键值。<br>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	UserId <span class="type">int</span> <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">	UserName <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	u := &amp;User&#123;UserId: <span class="number">1</span>, UserName: <span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">	j, _ := json.Marshal(u)</span><br><span class="line">	fmt.Println(<span class="type">string</span>(j))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;user_id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;user_name&quot;</span>:<span class="string">&quot;张三&quot;</span>&#125;</span><br></pre></td></tr></table></figure>




<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM是指将关系型数据库中的记录映射为对象，以对象的形式展现。我们可以把对数据库的操作转化为对对象的操作。</p>
<table>
<thead>
<tr>
<th>面向对象的概念</th>
<th>面向关系概念</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>表</td>
</tr>
<tr>
<td>对象</td>
<td>表的行（记录）</td>
</tr>
<tr>
<td>属性</td>
<td>表的列（字段）</td>
</tr>
</tbody></table>
<p>对应到golang中，就是把对关系型数据库的操作转化为对结构体的操作。<br>我们以<code>GORM</code>框架来举例，在GORM中，与数据表进行映射的结构体我们称之为模型（Models）。</p>
<p>回归到Tag，在数据表中定义一个字段时，我们通常会在字段的末尾加上一些额外信息，比如约束、列大小等等。映射到Models中，就需要使用Tag来设置相应的信息。</p>
<p>例如下面这个Models：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Age          sql.NullInt64</span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  Email        <span class="type">string</span>  <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class="line">  Role         <span class="type">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">// 设置字段大小为255</span></span><br><span class="line">  MemberNumber *<span class="type">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span> <span class="comment">// 设置会员号（member number）唯一并且不为空</span></span><br><span class="line">  Num          <span class="type">int</span>     <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">// 设置 num 为自增类型</span></span><br><span class="line">  Address      <span class="type">string</span>  <span class="string">`gorm:&quot;index:addr&quot;`</span> <span class="comment">// 给address字段创建名为addr的索引</span></span><br><span class="line">  IgnoreMe     <span class="type">int</span>     <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略本字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>GORM框架支持很多结构体Tag，具体可以查看这篇博文：</p>
<p><a href="https://blog.csdn.net/qq_49723651/article/details/121586415#Tag">https://blog.csdn.net/qq_49723651&#x2F;article&#x2F;details&#x2F;121586415#Tag</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang channel底层剖析</title>
    <url>/2022/09/07/Go/Golang%20channel%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line"> qcount   <span class="type">uint</span>           <span class="comment">// queue 里面有效用户元素，这个字段是在元素出队，入队改变的；</span></span><br><span class="line"> dataqsiz <span class="type">uint</span>           <span class="comment">// 初始化的时候赋值，之后不再改变，指明数组 buffer 的大小；</span></span><br><span class="line"> buf      unsafe.Pointer <span class="comment">// 指明 buffer 数组的地址，初始化赋值，之后不会再改变；</span></span><br><span class="line"> elemsize <span class="type">uint16</span>  <span class="comment">// 指明元素的大小，和 dataqsiz 配合使用就能知道 buffer 内存块的大小了；</span></span><br><span class="line"> closed   <span class="type">uint32</span></span><br><span class="line"> elemtype *_type <span class="comment">// 元素类型，初始化赋值；</span></span><br><span class="line"> sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line"> recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line"> recvq    waitq  <span class="comment">// 等待 recv 响应的对象列表，抽象成 waiters</span></span><br><span class="line"> sendq    waitq  <span class="comment">// 等待 sedn 响应的对象列表，抽象成 waiters</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 互斥资源的保护锁，官方特意说明，在持有本互斥锁的时候，绝对不要修改 Goroutine 的状态，不能很有可能在栈扩缩容的时候，出现死锁</span></span><br><span class="line"> lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="channel的send和recv"><a href="#channel的send和recv" class="headerlink" title="channel的send和recv"></a>channel的send和recv</h2><p>初始状态下，ch的缓冲区为空，读和写的下标都指向下标0的位置，等待队列也都为空。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6e845f7a71245ceb46496bd37a7ecb9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后一个协程g1向ch中发送数据，因为没有协程在等待接收数据，所以元素会被存入缓冲区中，<code>sendx</code>会从0开始向后挪，第五个元素会放到下标为的4的位置，然后sendx会重新回到0。<br>此时缓冲区中已经没有空闲的位置了。所以接下来发送的第6个元素无处可放，g1会进到ch的发送等待队列中。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f24be0aabb9446f8bfdd10a06daf78c9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>发送等待队列是一个sudog类型的链表。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	g *g    <span class="comment">// 记录哪个协程在等待</span></span><br><span class="line">	isSelect <span class="type">bool</span></span><br><span class="line">	next *sudog</span><br><span class="line">	prev *sudog</span><br><span class="line">	elem unsafe.Pointer  <span class="comment">// 等待发送的信息在哪</span></span><br><span class="line">	acquiretime <span class="type">int64</span></span><br><span class="line">	ticket <span class="type">uint64</span></span><br><span class="line">	parent *sudog</span><br><span class="line">	waitlink *sudog</span><br><span class="line">	waittail *sudog</span><br><span class="line">	c *hchan   <span class="comment">// 等待哪一个channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>里面会记录哪个协程在等待，等待哪一个channel，等待发送的信息在哪等信息。</p>
<p>接下来协程g2从ch接收一个元素，recvx指向下一个位置，第0个位置就空出来了。所以会唤醒sendq中的g1，将这里的数据发送给ch。然后缓冲区再次满了，sendq队列为空。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98afc280483d4fe2b79580aa02e3a8f9~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br></p>
<p>在这一过程中，可以看到<code>sendx</code>和<code>recvx</code>，都会从0到4再到0这样循环变化，所以channel的缓冲区被称为<code>环形缓冲区</code>。</p>
<p><strong>发送数据</strong></p>
<p>所以像诸如 <code>ch &lt;- 10</code> 这样给channel发送数据时，只有在缓冲区还有空闲位置，或者有协程在等着接收数据的时候才不会发生<code>阻塞</code>。<br>碰到channel为nil，或者ch没有缓冲区，而且也没有协程等着接收数据，又或者ch有缓冲区但缓冲区已用尽的情况，都会发生<code>阻塞</code>。</p>
<p>那如果不想阻塞的话，就可以使用select关键字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> ch &lt;- <span class="number">10</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用这种写法时，如果检测到ch可以发送数据，就会执行case分支；如果会阻塞，就会执行default分支了。</p>
<p><strong>接收数据</strong></p>
<p>接收数据的写法要更多一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将结果直接丢弃</span></span><br><span class="line">&lt;-ch</span><br><span class="line"><span class="comment">// 将结果赋值给变量v</span></span><br><span class="line">v := ch</span><br><span class="line"><span class="comment">// common ok风格写法</span></span><br><span class="line"><span class="comment">// ok为false时表示ch已经关闭，此时v是channe元素类型的零值</span></span><br><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>



<p>以上几种写法都允许发生阻塞，只有在缓冲区中有数据，或者有协程等着发送数据时，才不会发生阻塞。如果channel为nil，或者channel无缓冲而且没有协程等着发送数据，又或者channel有缓冲但是缓冲区无数据时，都会发生阻塞。</p>
<p>如果无论如何都不想阻塞,同样可以采用select关键字。这样在检测到channel的recv操作不会阻塞时，就会执行case分支；如果会阻塞，就会执行default分支。</p>
<h3 id="多路select"><a href="#多路select" class="headerlink" title="多路select"></a>多路select</h3><p>多路select指的是存在两个或更多的case分支，每个分支可以是一个channel的send或者recv操作。</p>
<p>例如一个协程通过多路select，等待ch1和ch2。这里default分支是可选的，我们暂且把这个协程记为g1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> a = &lt;-ch1:</span><br><span class="line">		<span class="built_in">println</span>(v)</span><br><span class="line">	<span class="keyword">case</span> ch2 &lt;- b:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>多路select会被编译器转换为对<code>runtime.selectgo</code>函数调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *unint16, pc0 *unintptr, nsends, nrecvs <span class="type">int</span>, block <span class="type">bool</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>)</span><br></pre></td></tr></table></figure>



<p>第一个参数cas0指向一个数组，数组里面装的是select中所有的case分支。顺序是send在前recv在后。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/603d712689674a4baf88f1c3af2f4c91~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>第二个参数order0指向一个uint16类型的数组，数组大小等于case分支的两倍，实际上被用作两个数组。第一个数组用来对所有channel的轮询进行乱序。第二个数组用来对所有channel的加锁操作进行排序。因为轮询需要乱序才能保障公正性。而按照固定算法确定加锁顺序才能避免死锁。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69841237a0c242f6bfc143763dd721c1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br>第三个参数和race检测有关，我们暂且不关心。</p>
<p>剩下的nsends和nrecvs分别表示所有case中，执行send和recv操作的分支分别有多少个。<br>block表示多路select是否需要阻塞等待，对应到代码只能就是有default分支的不会阻塞，没有的会阻塞。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c1dc0bf21794e2a9295ba2ab4860bd6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>再来看第一个返回值，它代表最终哪个case分支被执行了。<br>第二个返回值用于在执行recv操作的case分支时，表明是实际接收到了一个值，还是因channel关闭而得到了零值。<br>多路select需要进行轮询来确定哪个case分支可操作了。但是轮询前要先加锁，所以selectgo函数在执行时，会先按照有序的加锁顺序，对所有的channel加锁，然后按照乱序的轮询顺序，检查所有channel的等待队列和缓冲区。</p>
<p>假如检查到ch1时，发现有数据可读，那就直接拷贝数据，进入对应分支；假如所有channel都不可操作，就把当前协程添加到所有channel的sendq或recvq中。</p>
<p>对应到这个例子，g1会被添加到ch1的recq，以及ch2的sendq中。之后g1会挂起，并解锁所有的channel。</p>
<p>假如接下来的ch1有数据可读了，g1就会被唤醒，完成对应的分支操作后，会再次按照加锁顺序对所有channel加锁，然后从所有sendq或recvq中将自己移除。最后全部解锁后返回。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bc31180e4684dafa76578921e28180b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="channel的常规send和recv操作"><a href="#channel的常规send和recv操作" class="headerlink" title="channel的常规send和recv操作"></a>channel的常规send和recv操作</h2><p><strong>send操作</strong></p>
<p>事实上channel的常规send操作，会被编译器转换为对<code>runtime.chansend1()</code>的调用，而它的内部只是调用了<code>runtime.chansend()</code>。</p>
<p>非阻塞式的send操作会被编译器转换为对<code>runtime.selectnbsend()</code>的调用，它也仅仅是调用了<code>runtime.chansend()</code>。</p>
<p>所以send操作主要是通过这个函数实现的。</p>
<p><strong>recv操作</strong></p>
<p>同样的，常规recv操作会被编译器转换为对<code>runtime.chanrecv1()</code>的调用。而它内部只是调用了<code>runtime.chanrecv()</code>。</p>
<p><code>common ok</code>风格的写法会被编译器转换为对<code>runtime.chanrecv2()</code> 的调用，它的内部也是对调用<code>chanrecv()</code>，只不过比chanrecv1()多了一个返回值。</p>
<p>非阻塞式的recv操作会根据是否为common ok风格，被编译器转换为对<code>runtime.selectnbrecv()</code>或者<code>selectbrecv2()</code>的调用，而它们两个也仅仅是调用了<code>runtime.chanrecv()</code>。</p>
<p>所以recv操作主要是通过<code>chanrecv()</code>函数实现的。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang defer原理</title>
    <url>/2022/09/07/Go/Golang%20defer%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="defer1-12"><a href="#defer1-12" class="headerlink" title="defer1.12"></a>defer1.12</h2><h3 id="defer延迟和倒序的机制"><a href="#defer延迟和倒序的机制" class="headerlink" title="defer延迟和倒序的机制"></a>defer延迟和倒序的机制</h3><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>在go语言中，我们可以很方便的用defer关闭一个打开的文件、释放一个Redis连接，或者解锁一个Mutex。而且Go语言在设计上保证，即使发生panic，所有的defer调用也能够被执行。不过多个defer函数是按照定义顺序倒序执行的。</p>
<p>我们通过一个例子来解释defer函数的延迟与倒序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> A()</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一段代码，在Go1.12中编译以后的伪指令是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := runtime.deferproc(<span class="number">0</span>, A) <span class="comment">// 经过recover返回时r为1，否则为0</span></span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>其中与defer指令相关的有两个部分。第一部分是<code>deferproc</code>，它负责保存要执行的函数信息,我们称之为defer<code>注册</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferproc</span><span class="params">(siz <span class="type">int32</span>, fn *funcval)</span></span></span><br></pre></td></tr></table></figure>


<p>从函数原型来看，<code>deferproc</code>函数有两个参数，第一个是被注册的defer函数的参数加返回值共占多少字节；第二个参数是一个<code>runtime.funcval</code>结构体的指针，也就是一个<a href="https://blog.csdn.net/qq_49723651/article/details/121362988">Function Value</a>。</p>
<p>与defer指令相关的第二部分就是<code>deferreturn</code>，它被编译器插入到函数返回以前调用，负责执行已经注册的defer函数。所以defer函数之所以能延迟到函数返回前执行，就是因为先注册，后调用。</p>
<h4 id="倒序"><a href="#倒序" class="headerlink" title="倒序"></a>倒序</h4><p>再来看看defer函数为什么会倒序执行。<br>defer注册信息会保存到defer链表。每个goroutine在运行时都对应一个<code>runtime.g</code>结构体，其中有一个<code>_defer</code>字段，保存的就是defer链表的头指针。<br><img src="https://img-blog.csdnimg.cn/4633c7d0f13146e98629e4aa28a41897.png" alt="在这里插入图片描述"></p>
<p>deferproc新注册的defr信息会添加到链表头。defer return执行时也从链表头开始，所以defer才会表现为倒序执行。</p>
<h3 id="defer链表项"><a href="#defer链表项" class="headerlink" title="defer链表项"></a>defer链表项</h3><p>defer链表链起来的是一个一个_defer结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    sp        <span class="type">uintptr</span> <span class="comment">// sp at time of defer</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic <span class="comment">// panic that is running defer</span></span><br><span class="line">    link      *_defer</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>siz  由deferproc第一个参数传入，就是defer函数参数加返回值的总大小。<br>这段空间会直接分配在_defer结构体后面，用于在注册时保存给defer函数传入的参数，并在执行时直接拷贝到defer函数的调用者栈上。</p>
</li>
<li><p>started  标识defer函数是否已经开始执行；</p>
</li>
<li><p>sp  就是注册defer函数的函数栈指针；</p>
</li>
<li><p>pc  是deferproc函数返回后要继续执行的指令地址；</p>
</li>
<li><p>fn  由deferproc的第二个参数传入，也就是被注册的defer函数；</p>
</li>
<li><p>_panic  是触发defer函数执行的panic指针，正常流程执行defer时它就是nil；</p>
</li>
<li><p>link  自然是链到之前注册的那个_defer结构体。</p>
</li>
</ul>
<p>这一篇我们只关注正常流程下defer函数的执行，不考虑panic或runtime.Goexit()的情况。</p>
<h3 id="defer传参机制"><a href="#defer传参机制" class="headerlink" title="defer传参机制"></a>defer传参机制</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> A1(a)</span><br><span class="line">    </span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这里函数A注册了一个defer函数A1，在A的函数栈帧中，局部变量区域存储a&#x3D;1，b&#x3D;2。</p>
<p><img src="https://img-blog.csdnimg.cn/aede08b2153d4207acfda6f0cfcabefc.png" alt="在这里插入图片描述"></p>
<p>到deferproc函数注册defer函数A1时。<br>第一个参数是A1的参数加返回值共占多少字节。A1没有返回值，64位下一个整型参数占用8字节。<br>第二个参数是函数A1。前面我们介绍过，没有捕获列表的Function Value，在编译阶段会做出优化，就是在只读数据段分配一个共用的funcval结构体。如下图中，函数A1的指令入口地址为addr1。在只读数据段分配的指向A1指令入口的funcval结构体地址为addr2，所以deferproc函数第二个参数就是addr2。</p>
<p><img src="https://img-blog.csdnimg.cn/3acc4c115ed148e288623124b9271fc4.png" alt="在这里插入图片描述"></p>
<p>额外要注意的是，deferproc函数调用时，编译器会在它自己的两个参数后面，开辟一段空间，用于存放defer函数A1的返回值和参数。这一段空间会在注册defer时，直接拷贝到_defer结构体的后面。A1只有一个参数a&#x3D;1，放在deferproc函数自己的两个参数之后。注意deferproc函数的返回值空间并没有分配在调用者栈上，而是放到了寄存器中，这和recover有关,且先忽略。</p>
<p><img src="https://img-blog.csdnimg.cn/5fd309d14f104c8cab7a9958769887fc.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/6398a8b53ce3467383089c008ac673f8.png" alt="在这里插入图片描述"></p>
<p>然后这个_defer结构体就被添加到defer链表头，deferproc注册结束。</p>
<p><em>注意：<br>频繁的堆分配势必影响性能，所以Go语言会预分配不同规格的deferpool，执行时从空闲_defer中取一个出来用。没有空闲的或者没有大小合适的，再进行堆分配。用完以后，再放回空闲_defer池。这样可以避免频繁的堆分配与回收。</em></p>
<p>deferproc结束后，接下来会执行到a&#x3D;a+b这一步，所以，局部变量a被置为3。接下来会输出：a&#x3D;3，b&#x3D;2。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数A编译后的伪指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    r := runtime.deferproc(<span class="number">8</span>, A1，<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)<span class="comment">//3,2</span></span><br><span class="line"></span><br><span class="line">    runtime.deferreturn()<span class="comment">//执行defer链表</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后就到deferreturn执行defer链表这里了。从当前goroutine找到链表头上的这个_defer结构体，通过_defer.fn找到defer函数的funcval结构体，进而拿到函数A1的入口地址。接下来就可以调用A1了。</p>
<p><img src="https://img-blog.csdnimg.cn/524f3dcc39704a839926a4937b14a11a.png" alt="在这里插入图片描述"></p>
<p>调用A1时，会把_defer后面的参数与返回值整个拷贝到A1的调用者栈上。然后A1开始执行，输出参数值a&#x3D;1。这个例子的关键，是defer函数的参数在注册时拷贝到堆上，执行时再拷贝到栈上。</p>
<h3 id="defer-闭包"><a href="#defer-闭包" class="headerlink" title="defer+闭包"></a>defer+闭包</h3><p>既然deferproc注册的是一个Function Value，下面就来看看有捕获列表时是什么情况。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        a = a+b</span><br><span class="line">        fmt.Println(a, b)</span><br><span class="line">    &#125;(b)</span><br><span class="line">    a = a + b</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个例子中，defer函数不止要传递局部变量<code>b</code>做参数，还捕获了外层函数的局部变量<code>a</code>，形成闭包。匿名函数会由编译器按照<code>A_func1</code>这样的形式命名。如下图所示，假设这个闭包函数的指令入口地址为<code>addr1</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/7fa8fc9013ea4cf69f30e78cf3d6cde3.png" alt="在这里插入图片描述"></p>
<p>上图中，由于捕获变量a除了初始化赋值外还被修改过，所以A的局部变量a改为堆分配，栈上只存它的地址。创建闭包对象时，会堆分配一个<code>funcval</code>结构体，<code>funcval.fn</code>指向闭包函数入口<code>addr1</code>，捕获列表中存储a在堆上的地址。而这个<code>funcval</code>结构体本身的地址addr2，就是<code>deferproc</code>执行时,_defer结构体中的fn的值。别忘了，传给defer函数的参数b&#x3D;2，也要拷贝到_defer结构体后面。</p>
<p><img src="https://img-blog.csdnimg.cn/a03cdb95ef2f4d0496dfb127f87293e1.png" alt="在这里插入图片描述"></p>
<p>上图所示_defer结构体被添加到defer链表头以后，deferproc注册结束。继续执行后面的逻辑。到a&#x3D;a+b这里，a被置为3。下一步输出a&#x3D;3，b&#x3D;2。</p>
<p>接下来，deferreturn执行注册的defer函数时，要把参数b拷贝到栈上的参数空间。还记得闭包函数执行时怎样找到对应的捕获列表吗？通过寄存器存储的funcval地址加上偏移，找到捕获变量a的地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例代码编译后的伪指令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a ：= <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">    *a = <span class="number">1</span></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line">    r := runtime.deferproc(<span class="number">8</span>, A_func1，<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    *a = *a + b</span><br><span class="line">    fmt.Println(*a, b)<span class="comment">//3,2</span></span><br><span class="line"></span><br><span class="line">    runtime.deferreturn()<span class="comment">//执行defer链表</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A_func1</span><span class="params">(b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    a := (<span class="type">int</span> *)([DX]+<span class="number">8</span>)</span><br><span class="line">    *a = *a + b</span><br><span class="line">    fmt.Println(*a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>要注意捕获变量a在堆上分配，闭包函数执行时，捕获变量a&#x3D;3，参数b&#x3D;2。</p>
<p><img src="https://img-blog.csdnimg.cn/2a0b0654034e4c8f90d7e3093fc6159f.png" alt="在这里插入图片描述"></p>
<p>所以，接下来在defer函数中，捕获变量a被置为5，最终输出a&#x3D;5，b&#x3D;2。这个例子中，最关键的是分清defer传参与闭包捕获变量的实现机制。</p>
<h3 id="defer-A-B-c"><a href="#defer-A-B-c" class="headerlink" title="defer ( A ( B ( c ) ) )"></a>defer ( A ( B ( c ) ) )</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a++</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    a++</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="keyword">defer</span> A(B(a))</span><br><span class="line">    a++</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个例子中，main函数注册的defer函数是A，所以，defer链表项中_defer.fn存储的是A的funcval指针。但是deferproc执行时，需要保存A的参数到_defer结构体后面。这就需要在defer注册时拿到B的返回值。</p>
<p>既然B会在defer注册时执行，那么对B(a)求值时a&#x3D;1。函数B的返回值就是2，也就是defer注册时保存的参数值为2，所以defer函数A执行时就会输出3。</p>
<h3 id="defer嵌套"><a href="#defer嵌套" class="headerlink" title="defer嵌套"></a>defer嵌套</h3><p>这一次，我们抛开各种细节，只关注defer链表随着defer函数的注册与执行究竟会如何变化。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">defer</span> B1()</span><br><span class="line">    <span class="keyword">defer</span> B2()</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有defer函数都正常执行......</span></span><br></pre></td></tr></table></figure>

<p>这个例子中函数A注册两个defer，我们用函数名标记为A1和A2。</p>
<p><img src="https://img-blog.csdnimg.cn/2aa40dc14734494daf50d6003df58cc5.png" alt="在这里插入图片描述"></p>
<p>到函数A返回前执行deferreturn时，会判断defer链表头上的defer是不是A注册的。方法就是判断_defer结构体记录的sp是否等于A的栈指针.如果是A注册的，就保存defer函数调用的相关信息，然后把这一项从defer链表中移除，然后调用函数A2，A2执行时又注册两个defer，记为B1和B2。</p>
<p><img src="https://img-blog.csdnimg.cn/35f5899cabd84fe48dbd24c40902ce08.png" alt="在这里插入图片描述"></p>
<p>函数A2返回前同样去执行defer链表，同样判断是否是自己注册的defer函数。所以B2执行，之后B1执行。此时A2仍然不知道自己注册的defer函数已经执行完了，直到下一个_defer.sp不等于A2的栈指针，A2注册的defer执行完，A2就可以结束了。</p>
<p><img src="https://img-blog.csdnimg.cn/9485c414068445c8890f7de2623b8842.png" alt="在这里插入图片描述"></p>
<p>因为A1是函数A注册的defer函数，所以又回到A的defer执行流程。A1结束后，defer链表为空，函数A结束。<br>这个例子的关键是defer链表注册时添加链表项，执行时移除链表项的用法。</p>
<h3 id="defer1-12性能问题"><a href="#defer1-12性能问题" class="headerlink" title="defer1.12性能问题"></a>defer1.12性能问题</h3><p>defer1.12的性能问题主要缘于两个方面：</p>
<ol>
<li>_defer结构体堆分配，即使有预分配的deferpool，也需要去堆上获取与释放。而且defer函数的参数还要在注册时从栈拷贝到堆，执行时又要从堆拷贝到栈。</li>
<li>defer信息保存到链表，而链表操作比较慢。</li>
</ol>
<h2 id="defer1-13"><a href="#defer1-13" class="headerlink" title="defer1.13"></a>defer1.13</h2><p>Go1.13中defer性能的优化点，主要集中在减少defer结构体堆分配。我们通过一个例子，看看它是怎样做到的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> B(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>像这样一段代码，在Go1.13中编译后的伪指令是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> d <span class="keyword">struct</span> &#123;</span><br><span class="line">        runtime._defer</span><br><span class="line">        i <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    d.siz = <span class="number">0</span></span><br><span class="line">    d.fn = B</span><br><span class="line">    d.i = <span class="number">10</span></span><br><span class="line">    r := runtime.deferprocStack(&amp;d._defer)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">ret:</span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>注意上面的结构体d，它由两部分组成，一个是<code>runtime._defer</code>结构体，一个是传给defer函数B的参数。它们被定义为函数A的局部变量，执行阶段会分配在函数栈帧的局部变量区域。接下来的<code>runtime.deferprocStack</code>则会把栈上分配的_defer结构体注册到defer链表。通过这样的方式避免在堆上分配_defer结构体。</p>
<p><img src="https://img-blog.csdnimg.cn/b946fc19c85742a099fd3b67b1521f03.png" alt="在这里插入图片描述"></p>
<p>值得注意的是，1.13版本中并不是所有defer都能够在栈上分配。循环中的defer，无论是显示的for循环，还是goto形成的隐式循环，都只能使用1.12版本中的处理方式在堆上分配。即使只执行一次的for循环也是一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示循环</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt; n; i++&#123;</span><br><span class="line">    <span class="keyword">defer</span> B(i)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//隐式循环</span></span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">defer</span> B()</span><br><span class="line">    <span class="keyword">if</span> i&lt;n &#123;</span><br><span class="line">        n++</span><br><span class="line">        <span class="keyword">goto</span> again</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p>所以Go1.13中，runtime._defer结构体增加了一个字段heap，用于标识是否为堆分配。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    heap      <span class="type">bool</span>       <span class="comment">//标识是否为堆分配</span></span><br><span class="line">    sp        <span class="type">uintptr</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic</span><br><span class="line">    link      *_defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>defer函数的执行在1.13中没有变化，依然通过deferreturn实现，依然需要把_defer结构体后面的参数与返回值空间，拷贝到defer函数的调用者栈上。只不过不是从堆上拷贝到栈上，而是从栈上的局部变量空间拷贝到参数空间。</p>
<p><img src="https://img-blog.csdnimg.cn/c90468fd3fbc41a3a3f2ea67b0936ebe.png" alt="在这里插入图片描述"></p>
<p>1.13版本的defer减少了_defer结构体的堆分配，但是仍然要使用defer链表。官方提供的性能优化在30%左右。</p>
<h2 id="defer1-14"><a href="#defer1-14" class="headerlink" title="defer1.14"></a>defer1.14</h2><p>减少_defer结构体的堆分配，也是1.14版本中defer性能优化要持续践行的策略。但是具体做法与1.13版本不同。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> A1(i, <span class="number">2</span>*i)</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">defer</span> A2(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// code to do something</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a,b <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">(m,n <span class="type">string</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面这个例子中，函数A注册两个defer函数A1和A2，不过函数A2要到执行阶段根据条件判断是否要执行。先看defer函数A1这部分编译后的伪指令，Go1.14中会把A1需要的参数定义为局部变量，并在函数返回前直接调用A1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">        </span><br><span class="line">    A1（a, b）</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过这样的方式不仅不用构建_defer结构体，也用不到defer链表，但是到defer函数A2这里就行不通了。因为A2不一定要被执行，这要在执行阶段根据参数i的值来决定。</p>
<p>Go1.14通过增加一个标识变量df来解决这类问题。用df中的每一位对应标识当前函数中的一个defer函数是否要执行。</p>
<p><img src="https://img-blog.csdnimg.cn/b031a359cf12415b9521b5e71a6ff0fd.png" alt="在这里插入图片描述"></p>
<p>例如，函数A1要被执行，所以就通过df |&#x3D; 1把df第一位置为1；在函数返回前再通过df&amp;1判断是否要调用函数A1。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    df |= <span class="number">1</span>      </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//code to do something</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>所以像A2这样有条件执行的defer函数就可以像下面这样处理了。根据条件判断是否要把对应标识位置为1，函数返回前同样要根据标识符来判断是否要调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line">    <span class="comment">//A1的参数</span></span><br><span class="line">    <span class="keyword">var</span> a, b <span class="type">int</span> = i, <span class="number">2</span>*i</span><br><span class="line">    df |= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//A2的参数</span></span><br><span class="line">    <span class="keyword">var</span> m,n <span class="type">string</span> = <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;eggo&quot;</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line">        df |= <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//code to do something</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//判断A2是否要调用</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">2</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">2</span></span><br><span class="line">        A2(m, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断A1是否要调用</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">        df = df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a, b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">//省略部分与recover相关的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Go1.14把defer函数在当前函数内展开并直接调用，这种方式被称为open coded defer。这种方式不仅不用创建_defer结构体，也脱离了defer链表的束缚。不过这种方式依然不适用于循环中的defer，所以1.12版本defer的处理方式是一直保留的。</p>
<p><strong>注意：</strong></p>
<p>但是，必须要强调的是，我们一直在梳理的都是程序正常执行时defer的处理逻辑。一旦发生panic或者调用了runtime.Goexit函数，在这之后的正常逻辑就都不会执行了，而是直接去执行defer链表。那些使用open coded defer在函数内展开，因而没有被注册到链表的defer函数要通过栈扫描的方式来发现。</p>
<p>Go1.14中runtime._defer结构体又增加了几个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span></span><br><span class="line">    heap      <span class="type">bool</span></span><br><span class="line">    openDefer <span class="type">bool</span>           <span class="comment">//1</span></span><br><span class="line">    sp        <span class="type">uintptr</span></span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic</span><br><span class="line">    link      *_defer </span><br><span class="line">    fd        unsafe.Pointer <span class="comment">//2</span></span><br><span class="line">    varp      <span class="type">uintptr</span>        <span class="comment">//3</span></span><br><span class="line">    framepc   <span class="type">uintptr</span>  </span><br></pre></td></tr></table></figure>


<p>借助这些信息，panic处理流程可以通过栈扫描的方式找到这些没有被注册到defer链表的defer函数，并按照正确的顺序执行。<br>所以，实际上Go1.14版本中defer的确变快了，但panic变得更慢了……</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang method原理浅析</title>
    <url>/2022/09/07/Go/Golang%20method%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法即method，Go语言支持为自定义类型实现方法，method在具体实现上与普通的函数并无不同，只不过会通过运行时栈多传递一个隐含的参数，这个隐含的参数就是所谓的接收者。下面通过代码来进行说明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	a.name = <span class="string">&quot;Hi! &quot;</span> + a.name</span><br><span class="line">	<span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	a := A&#123;name: <span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// 1）编译器的语法糖，提供面向对象的语法</span></span><br><span class="line">	fmt.Println(a.Name())</span><br><span class="line">	 <span class="comment">// 2）更贴近真实实现的写法，和普通函数调用几乎没什么不同</span></span><br><span class="line">	fmt.Println(A.Name(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以上代码展示了两种不同的写法，都能顺利通过编译并正常运行，实际上这两种写法会生成同样的机器码。<br>第一种：a.Name()，这是我们惯用的写法，很方便；<br>第二种：A.Name(a)，这种写法更底层也更严谨，要求所有的类型必须严格对应，否则是无法通过编译的。<br>其实编译器会帮我们把第一种转换为第二种的形式，所以我们惯用的第一种写法只是“语法糖”，方便而已。</p>
<p>深入理解这两种写法的等价性是非常重要的，下面再用代码进一步验证：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">    a.name = <span class="string">&quot;Hi! &quot;</span> + a.name</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NameOfA</span><span class="params">(a A)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    a.name = <span class="string">&quot;Hi! &quot;</span> + a.name</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t1 := reflect.TypeOf(A.Name)</span><br><span class="line">    t2 := reflect.TypeOf(NameOfA)</span><br><span class="line">    <span class="comment">// 会输出true，通过反射来验证，两者的类型是相同的</span></span><br><span class="line">    fmt.Println(t1 == t2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为Go语言反射获取的函数类型只跟参数和返回值有关，既然t1和t2相等，就说明类型A的方法本质上和函数NameOfA相同。也就进一步验证了：方法本质上就是普通的函数，而接收者就是隐含的第一个参数。</p>
<h2 id="值接收者"><a href="#值接收者" class="headerlink" title="值接收者"></a>值接收者</h2><p>接下来，我们看看上面第一个示例中，a.Name()执行时函数调用栈是什么情况。</p>
<p>main函数栈帧中局部变量a只有一个string类型的成员，a.Name()会由编译器转换为A.Name(a)这样的函数调用。局部变量a作为要传入的参数，被直接拷贝到参数空间。</p>
<p><img src="https://img-blog.csdnimg.cn/61cad817a21e4e80a3340cd5054885c4.png" alt="在这里插入图片描述"></p>
<p>A.Name(a)执行时,修改的是参数空间的a.name，string底层指向的字符串内容发生了变化。</p>
<p><img src="https://img-blog.csdnimg.cn/e70d780bf70a409c8bc70fe66182552f.png" alt="在这里插入图片描述"></p>
<p>函数返回前将返回值写入返回值空间，对应到这个例子，就是拷贝参数a的成员name到返回值空间。</p>
<p><img src="https://img-blog.csdnimg.cn/d2cde70df4554bdb8b6907593c6620c9.png" alt="在这里插入图片描述"></p>
<p>通过值接收者调用方法时，值接收者会作为第一个参数，而Go语言中传参都是值拷贝，所以执行a.Name()修改的并不是局部变量a，而是拷贝过去的参数。要想修改a，还得用指针接收者。</p>
<h2 id="指针接收者"><a href="#指针接收者" class="headerlink" title="指针接收者"></a>指针接收者</h2><p>我们把上个例子改为指针接收者，然后看看通过指针接收者调用方法时，函数调用栈又会是怎样的情况。 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pa *A)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">    pa.name = <span class="string">&quot;Hi! &quot;</span> + pa.name</span><br><span class="line">    <span class="keyword">return</span> pa.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">    pa := &amp;a</span><br><span class="line">    fmt.Println(pa.Name())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>main函数栈帧有两个局部变量，pa存储的是a的地址。pa.Name()会由编译器转换为（*A).Name(pa)函数调用，所以参数空间拷贝参数pa的值，也就是局部变量a的地址。</p>
<p><img src="https://img-blog.csdnimg.cn/4a1e75835b7b4d9e9f3c93f1ceaa0f9f.png" alt="在这里插入图片描述"></p>
<p>(*A).Name(pa)执行时，修改的是pa指向的结构体，也就是局部变量a.name的值。这个string类型的成员会指向新的底层字符串，而返回值空间被写入的也是pa指向的结构体的成员name。</p>
<p><img src="https://img-blog.csdnimg.cn/96850a3d04774280935386972c230d6a.png" alt="在这里插入图片描述"></p>
<p>通过指针类型接收者调用方法时，指针会作为参数传入，传参时拷贝的就是地址，所以这里能够实现对原来变量a的修改。</p>
<h2 id="更甜的语法糖"><a href="#更甜的语法糖" class="headerlink" title="更甜的语法糖"></a>更甜的语法糖</h2><p>再次修改上面的例子，这一次既有值接收者的方法，又有指针接收者的方法。对于a.GetName()和pa.SetName()这两种形式的方法调用我们已经了然。但是下面这pa.GetName()和a.SetName()也能正常执行是几个意思？ </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pa *A)</span></span> SetName() <span class="type">string</span> &#123;</span><br><span class="line">    pa.name = <span class="string">&quot;Hi! &quot;</span> + pa.name</span><br><span class="line">    <span class="keyword">return</span> pa.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">    pa := &amp;a</span><br><span class="line">    </span><br><span class="line">    fmt.Println(pa.GetName())</span><br><span class="line">    fmt.Println(a.SetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>不用展开函数调用栈，只需告诉你这是语法糖，理解起来也就没有问题了。编译期间，会把pa.GetName()这种方法调用转换成(*pa).GetName()，也就等价于执行A.GetName(<em>pa)。而a.SetName()会被转换成(&amp;a).SetName()，也相当于执行（</em>A).SetName(&amp;a)。所以，看似值接收者和指针接收者交叉访问了对方的方法，实际上依然遵循之前介绍的执行过程。</p>
<p><em>如果定义的方法不涉及到任何接口类型时是这样的，详细情况以后详述，目前这样理解无碍。</em></p>
<p><img src="https://img-blog.csdnimg.cn/35e77b30c4ed49afab4c7203c153d835.png" alt="在这里插入图片描述"></p>
<p>既然这种语法糖是在编译期间发挥作用的，像下面这种编译期间不能拿到地址的字面量，就不能享受语法糖，转换成对应的指针接收者调用了。    </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println((A&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;).SetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>编译期间会发生错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cannot call pointer method on A literal</span><br><span class="line">cannot take the address of A literal</span><br><span class="line">错误: 进程退出代码 <span class="number">2.</span></span><br></pre></td></tr></table></figure>




<h2 id="Method-Expression-amp-Method-Value"><a href="#Method-Expression-amp-Method-Value" class="headerlink" title="Method Expression &amp; Method Value"></a>Method Expression &amp; Method Value</h2><p>我们已经知道，Go语言中函数作为变量、参数和返回值时，都是以Function Value的形式存在的。也知道闭包只是有捕获列表(catch list)的Funtion Value而已。</p>
<p>那么如果把方法赋给一个变量，这个变量又是怎样的存在呢？   </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := A&#123;name:<span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    f1 := A.GetName      <span class="comment">//方法表达式</span></span><br><span class="line">    f1(a)                <span class="comment">//eggo</span></span><br><span class="line"></span><br><span class="line">    f2 := a.GetName      <span class="comment">//方法变量</span></span><br><span class="line">    f2()                 <span class="comment">//eggo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-方法表达式"><a href="#1-方法表达式" class="headerlink" title="1.方法表达式"></a>1.方法表达式</h3><p>如果像f1这样，把一个类型的方法赋给它，这样的变量就被称为<code>方法表达式</code>。对f1的处理相当于下面这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">......    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetName</span><span class="params">(a A)</span></span> <span class="type">string</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a := A&#123;name:<span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    f1 := GetName</span><br><span class="line">    f1(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以，f1实际上就是一个普通的Function Value，执行时需要传入一个A类型的变量作为第一个参数。</p>
<h3 id="2-方法变量-作为局部变量"><a href="#2-方法变量-作为局部变量" class="headerlink" title="2.方法变量 (作为局部变量)"></a>2.方法变量 (作为局部变量)</h3><p>然而，像f2这样，通过a.GetName进行赋值，这样的变量被称为<code>方法变量</code>。通过方法变量执行方法时，我们无需再传入方法接收者作为第一个参数，这是因为编译器替我们做了处理。方法变量也是一个Function Value，在这个例子中，编译阶段f2()会被转换为A.GetName(a)。但是这只是方法变量作为<code>局部变量</code>的情况。</p>
<h3 id="3-方法变量-作为返回值"><a href="#3-方法变量-作为返回值" class="headerlink" title="3.方法变量 (作为返回值)"></a>3.方法变量 (作为返回值)</h3><p>如果像下面的GetFunc函数这样，把方法变量作为<code>返回值</code>。这个返回值实际上是一个捕获了局部变量a的Function Value，也就是说f3是一个<code>闭包对象</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...... </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo in GetFunc&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> a.GetName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := A&#123;name: <span class="string">&quot;eggo in main&quot;</span>&#125;</span><br><span class="line">    f2 := a.GetName</span><br><span class="line">    fmt.Println(f2()) <span class="comment">//这里输出：eggo in main</span></span><br><span class="line"></span><br><span class="line">    f3 := GetFunc()</span><br><span class="line">    fmt.Println(f3()) <span class="comment">//这里输出：eggo in GetFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>上面的GetFunc函数和下面这段代码是等价的，通过它我们能够清晰地看到闭包是如何形成的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> (<span class="function"><span class="keyword">func</span><span class="params">()</span></span><span class="type">string</span>) &#123;</span><br><span class="line">    a := A&#123;name:<span class="string">&quot;eggo in GetFunc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span><span class="type">string</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.GetName(a)  <span class="comment">//捕获变量a</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>f3是一个闭包对象，它执行时用到的是自己捕获的变量，也就是函数GetFunc的局部变量a。而f2这个方法变量，使用的是main函数的局部变量a。这样就很好理解上面这段示例程序的输出结果了。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang panic和recover原理浅析</title>
    <url>/2022/09/07/Go/Golang%20panic%E5%92%8Crecover%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>我们已经知道，当前执行的goroutine持有一个defer链表的头指针。其实它也有一个panic链表头指针。</p>
<p><img src="https://img-blog.csdnimg.cn/06e9a411121e4ab0a0751b20d63472c1.png" alt="在这里插入图片描述"></p>
<p>panic链表链起来的是一个一个_panic结构体。和defer链表一样，发生新的panic时，也是在链表头上插入一个_panic结构体。而链表头上的panic就是当前正在执行的那一个。</p>
<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;这里不会被执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A2正常结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A1正常结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这个例子中，函数A注册两个defer函数A1和A2之后发生panic。panic发生前，defer链表中已经注册了A1和A2，我们同样用函数名作为区分标记。发生panic后，它后面的代码就不会执行了，而是进入panic处理逻辑。</p>
<p><img src="https://img-blog.csdnimg.cn/24fc80b527f943659ca48a363c6e0853.png" alt="在这里插入图片描述"></p>
<p>首先，会在panic链表头处增加一项，我们把它记为<code>panicA</code>，现在它就是当前执行的panic。然后就该执行defer链表了，从defer链表头开始执行，不过与函数正常流程执行defer有些许不同，还记得_defer结构体的内容吗？（Go1.12版本）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">    siz       <span class="type">int32</span></span><br><span class="line">    started   <span class="type">bool</span>    <span class="comment">// panic执行defer时会把它标记为true</span></span><br><span class="line">    sp        <span class="type">uintptr</span> </span><br><span class="line">    pc        <span class="type">uintptr</span></span><br><span class="line">    fn        *funcval</span><br><span class="line">    _panic    *_panic <span class="comment">// 记录触发defer执行的_panic指针</span></span><br><span class="line">    link      *_defer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>panic执行到一个defer时，会先把它的<code>_defer.started</code>置为true，标记它已经开始执行；并且会把<code>_defer._panic</code>字段指向当前执行的panic，表示这个defer是由这个panic触发的。</p>
<p><img src="https://img-blog.csdnimg.cn/bcb123d0601e485bb2371bce64b2f0a2.png" alt="在这里插入图片描述"></p>
<p>把A2对应的_defer标记好以后，A2开始执行。这里函数A2能够正常结束，也就是没有发生panic或调用runtime.Goexit函数，所以A2这一项就会被移除，继续执行下个defer。</p>
<p><img src="https://img-blog.csdnimg.cn/8bf3bcd9500a461faa883ee6b8a8dbd6.png" alt="在这里插入图片描述"></p>
<p>之所以要等到defer函数正常返回以后再移除对应的defer链表项，主要是为了应对defer函数没有正常结束的情况，就像下面这个例子。</p>
<h2 id="panic之后又panic"><a href="#panic之后又panic" class="headerlink" title="panic之后又panic"></a>panic之后又panic</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;A1再次panic&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>函数A中panic发生后，panic链表增加一项，记为panicA。然后就要执行defer链表了，设置A1对应的_defer.started与_defer._panic字段，然后调用函数A1。</p>
<p><img src="https://img-blog.csdnimg.cn/ef9d388fccc6495bbba7022614c44529.png" alt="在这里插入图片描述"></p>
<p>A1执行时，再次发生panic,同样要在panic链表头插入一个新的_panic，记为panicA1。现在这个panicA1成为当前执行的panic了。它同样会去执行defer链表，但是发现A1已经执行，并且触发它执行的并不是当前的panicA1，而是之前的panicA。</p>
<p><img src="https://img-blog.csdnimg.cn/178ebe4cf18c4eed829af6f481766a30.png" alt="在这里插入图片描述"></p>
<p>这时会根据A1这里记录的_panic指针，找到对应的_panic，并把它标记为已终止。怎么标记？那就要把_panic结构体展开来看看了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">    argp      unsafe.Pointer</span><br><span class="line">    arg       <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    link      *_panic</span><br><span class="line">    recovered <span class="type">bool</span></span><br><span class="line">    aborted   <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>argp 用来存储panic正在执行的defer函数的参数空间地址;</li>
<li>arg 则是panic函数自己的参数;</li>
<li>link自然是链到上一个_panic结构体；</li>
<li>recovered 标识这个panic是否被恢复；</li>
<li>aborted 标识这个panic是否被终止。</li>
</ul>
<p>所以要终止panicA，就是把它的_panic.aborted字段置为true。而且defer链表中A1这一项也要被移除。</p>
<p><img src="https://img-blog.csdnimg.cn/cf824d6349684bb9a0ab2caa3f6be5a7.png" alt="在这里插入图片描述"></p>
<p>此时，defer链表为空，paic处理流程来到了打印panic信息这一步。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>:panicA</span><br><span class="line"><span class="built_in">panic</span>:panicA1</span><br></pre></td></tr></table></figure>

<p>注意panic打印异常信息时，会打印此时panic链表中剩余的所有链表项。不过，并不是从链表头开始，而是从链表尾开始，按照链表项的插入顺序逐一输出。所以这个例子才会先输出panicA，然后是panicA1。打印完异常信息后，程序退出。</p>
<p>好了，到目前为止，没有recover发生的panic处理逻辑就算梳理完了，理解这个过程的关键点有两个：</p>
<ol>
<li>panic执行defer函数的方式，先标记，后移除，目的是为了终止之前工作的panic；</li>
<li>panic异常信息：所有还在panic链表上的链表项都会被输出，顺序与panic发生的顺序一致。</li>
</ol>
<h2 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h2><p>接下来我们增加recover看看是什么情况。下面这个例子中，函数A里注册了两个defer函数，并且会发生panic。而defer函数A2中会执行recover。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p := <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Println(p) <span class="comment">//这里会正常执行输出“panicA”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>函数A中panic发生时，当前goroutine中defer链表已经注册了A1和A2。然后panic链表增加一项，记为panicA。panic触发defer链表执行，先执行函数A2。</p>
<p><img src="https://img-blog.csdnimg.cn/70447d221e8948ac9bdcd515d7832754.png" alt="在这里插入图片描述"></p>
<p>函数A2执行时发生recover，其实，recover函数本身的逻辑很简单，它只做一件事，就是把当前执行的panic置为已恢复，也就是把它的_panic.recovered字段置为true，其它的都不管。</p>
<p>所以函数A2中recover发生后会把当前执行的panicA置为已恢复，然后recover函数的任务就完成了。函数A2会继续往下执行，直到A2结束。</p>
<p><img src="https://img-blog.csdnimg.cn/3088df6cd8834b52a297a2843b16e6a2.png" alt="在这里插入图片描述"></p>
<p>其实在每个defer函数执行完以后，panic处理流程都会检查当前panic是否被恢复了。这里A2结束后，panic处理流程发现panicA已经被恢复，所以就会把它从panic链表中移除。A2这一项也会从defer链表中移除，不过在移除前要保存_defer.sp和_defer.pc两个字段的值。</p>
<p>接下来要做的，就是使用保存的sp和pc字段值跳出panicA处理流程，但是要怎么跳出来？又该恢复到哪里去呢？</p>
<p>我们知道，sp和pc是注册defer函数时保存的，对应到defer函数A2，sp就是函数A的栈指针，而pc就是调用deferproc(或deferprocStack)函数的返回地址。对应到下面这段伪指令中，就是函数A中判断r是否大于零的这部分逻辑。</p>
<p><img src="https://img-blog.csdnimg.cn/818f7ecc07354c03a6f9deb1cc00830e.png" alt="在这里插入图片描述"></p>
<p>通过sp，可以恢复到函数A的栈帧；通过pc，可以把指令地址恢复到判断r是否大于零这里。但是r就不能是0了，否则函数A就会重复执行。我们之前提过这个返回值被编译器保存在一个寄存器中，所以只要把它置为1就可以执行goto ret，跳转到deferreturn这里继续执行defer链表了。</p>
<p><img src="https://img-blog.csdnimg.cn/6a0dad73bc4246edab3022e8a68c9875.png" alt="在这里插入图片描述"></p>
<p>注意，函数A这里的deferreturn只负责执行函数A中注册的defer函数，是通过栈指针来判断的。</p>
<p><img src="https://img-blog.csdnimg.cn/d6bc4d11f5d54f8793aed979e835dd72.png" alt="在这里插入图片描述"></p>
<p>我们这个例子中，跳转到A的deferreturn这里后，下一个链表项A1仍然是函数A注册的defer，所以，接下来会执行defer函数A1，A1结束后，defer链表为空，函数A结束。</p>
<p>这就是recover的基本流程，理解的关键有两点：</p>
<ol>
<li>跳出当前panic处理流程以后要恢复到哪里，又是怎样恢复到那里的；<br>2.要注意，在发生recover的函数正常返回以后，才会检测当前panic是否被恢复，然后才会删除被恢复的panic。</li>
</ol>
<h2 id="recover后同一函数又panic"><a href="#recover后同一函数又panic" class="headerlink" title="recover后同一函数又panic"></a>recover后同一函数又panic</h2><p>如果发生recover的函数，在返回前再次panic，情况又会如何？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p := <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Println(p) <span class="comment">//这里会正常执行输出“panicA”</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA2&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/b4af212c15d94f119bd1bb48a4fc2bb3.png" alt="在这里插入图片描述"></p>
<p>当panicA2触发defer链表执行时，发现defer函数A2已经执行，所以把触发它执行的panicA终止掉。A2这一项也会从链表移除。<br>值得注意的是，由于A2没有正常返回，所以即使panicA已经被恢复了，也没有从链表中移除。</p>
<p><img src="https://img-blog.csdnimg.cn/47c8fa96a73c467f8a995f677391cd86.png" alt="在这里插入图片描述"></p>
<p>然后panicA2继续执行defer函数A1，A1中记录的_defer._panic指向panicA2。</p>
<p><img src="https://img-blog.csdnimg.cn/9126d8e2c54d4f508435ff6334c4888b.png" alt="在这里插入图片描述"></p>
<p>函数A1结束后，defer链表为空，接下来就要输出异常信息了。</p>
<p><img src="https://img-blog.csdnimg.cn/8c1a02c4dae04231a32a4f8865797f97.png" alt="在这里插入图片描述"></p>
<p>对于链表中已经被恢复的panic，打印它的信息时会加上recovered标记，panic链表每一项都输出后程序退出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>:panicA[recovered]</span><br><span class="line"><span class="built_in">panic</span>:panicA2</span><br></pre></td></tr></table></figure>


<h2 id="recover后恢复到哪里"><a href="#recover后恢复到哪里" class="headerlink" title="recover后恢复到哪里"></a>recover后恢复到哪里</h2><p>这个例子是为了加深对recover的理解，这一次我们结合函数调用关系弄清楚recover发生后，程序究竟会恢复到哪里。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> A1()</span><br><span class="line">    <span class="keyword">defer</span> A2()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span>&#123; </span><br><span class="line">    fmt.Println(<span class="string">&quot;A1正常执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> B1()        </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;panicA2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p := <span class="built_in">recover</span>()</span><br><span class="line">    fmt.Println(p)<span class="comment">//这里正常输出&quot;panicA2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>函数A发生panic，实际上会调用gopanic函数来处理添加panic链表项与执行defer等工作。我们把这个panic记为panicA。</li>
<li>panicA会执行A的defer函数A2。在A2执行时又注册了defer函数B1，然后再次发生panic，所以函数A2会调用gopanic来处理panicA2。</li>
<li>panicA2会去执行defer链表，所以接下来会调用B1。</li>
<li>B1执行时调用recover函数把panicA2置为已恢复。</li>
<li>B1结束后，panicA2被移除，程序恢复到函数A2这里的deferreturn继续执行。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/041ca603580948749560d2d4f16c7c7f.png" alt="在这里插入图片描述"></p>
<p>因为A2注册的defer函数已经执行完了，所以函数A2返回。最终返回到哪里呢？回到panicA这里继续执行，因为A2的执行就是由panicA触发的。</p>
<p><img src="https://img-blog.csdnimg.cn/01c13618179f4da4a300f4e41e39ecaa.png" alt="在这里插入图片描述"></p>
<p>回到panicA这里，继续执行defer链表，接下来就轮到函数A1了。</p>
<p><img src="https://img-blog.csdnimg.cn/dd5a306f6cfd457f9331ff745931acab.png" alt="在这里插入图片描述"></p>
<p>等到A1执行结束，defer链表为空。输出panic链表上仅剩的panicA的异常信息之后程序就退出了。</p>
<h2 id="recover调用限制"><a href="#recover调用限制" class="headerlink" title="recover调用限制"></a>recover调用限制</h2><p>关于recover，还要强调最后一点，就是recover函数只能在defer函数中直接调用，不能通过另外的函数间接调用。这是语言实现层面的要求，不满足要求的recover调用，不会有任何效果。</p>
<p><img src="https://img-blog.csdnimg.cn/cad8f3334d13458a8ae2f79e0c768914.png" alt="在这里插入图片描述"></p>
<h2 id="关于open-coded-defer"><a href="#关于open-coded-defer" class="headerlink" title="关于open coded defer"></a>关于open coded defer</h2><p>Go1.14版本以前，panic和recover的基本流程就是这样。但是，由于1.14中使用了open coded defer，在函数内部展开调用的defer函数并没有注册到defer链表，导致panic执行defer链表时不能像之前这般轻松。</p>
<p>1.14版本中panic处理流程要在执行defer链表前先进行栈扫描，把第一个open codeed defer注册到链表中正确的位置。然后开始执行defer链表。而且每次都要判断_defer.openCoded的值，如果为true，就通过_defer记录的信息拿到所属函数中open coded defer的相关信息，然后按照正确的顺序执行。具体过程相当繁琐，但是panic和recover的总体设计思想是一致的。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang map实现原理浅析</title>
    <url>/2022/09/06/Go/Golang%20map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>总体来说golang的<code>map</code>是<code>hashmap</code>，是使用数组+链表的形式实现的，使用拉链法消除<a href="https://www.cnblogs.com/yeya/p/9845910.html">hash冲突</a>。</p>
<h2 id="map的内存模型"><a href="#map的内存模型" class="headerlink" title="map的内存模型"></a>map的内存模型</h2><p>我的go源码版本是：<a href="https://golang.org/dl/go1.17.2.src.tar.gz">go1.17.2</a></p>
<p>map的源码在<code>Go_SDK\go1.17.2\src\runtime\map.go</code>中。</p>
<p>首先我们来看一下map最重要的两个结构：</p>
<p><strong>hmap:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// A header <span class="keyword">for</span> a Go map.</span><br><span class="line"><span class="built_in">type</span> hmap struct &#123;</span><br><span class="line">	// Note: the format of the hmap is also encoded <span class="keyword">in</span> cmd/compile/internal/reflectdata/reflect.go.</span><br><span class="line">	// Make sure this stays <span class="keyword">in</span> <span class="built_in">sync</span> with the compiler<span class="string">&#x27;s definition.</span></span><br><span class="line"><span class="string">	count     int // # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line"><span class="string">	flags     uint8</span></span><br><span class="line"><span class="string">	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line"><span class="string">	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line"><span class="string">	hash0     uint32 // hash seed</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line"><span class="string">	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line"><span class="string">	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	extra *mapextra // optional fields</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>


<p><strong>bmap:（bucket桶）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// A bucket <span class="keyword">for</span> a Go map.</span><br><span class="line"><span class="built_in">type</span> bmap struct &#123;</span><br><span class="line">	// tophash generally contains the top byte of the <span class="built_in">hash</span> value</span><br><span class="line">	// <span class="keyword">for</span> each key <span class="keyword">in</span> this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="line">	// tophash[0] is a bucket evacuation state instead.</span><br><span class="line">	tophash [bucketCnt]uint8</span><br><span class="line">	// Followed by bucketCnt keys and <span class="keyword">then</span> bucketCnt elems.</span><br><span class="line">	// NOTE: packing all the keys together and <span class="keyword">then</span> all the elems together makes the</span><br><span class="line">	// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="line">	// us to eliminate padding <span class="built_in">which</span> would be needed <span class="keyword">for</span>, e.g., map[int64]int8.</span><br><span class="line">	// Followed by an overflow pointer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上在golang runtime时，编译器会动态为bmap创建一个新结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> bmap struct &#123;</span><br><span class="line">    topbits  [8]uint8</span><br><span class="line">    keys     [8]keytype</span><br><span class="line">    values   [8]valuetype</span><br><span class="line">    pad      uintptr</span><br><span class="line">    overflow uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>Golang中map的底层实现是一个哈希表，因此实现map的过程实际上就是实现哈希表的过程。在这个哈希表中，主要出现的结构体有两个，一个叫<code>hmap(a header for a go map)</code>，一个叫<code>bmap(a bucket for a Go map</code>，通常叫其<code>bucket</code>)。这两种结构的样子分别如下所示：</p>
<p><strong>hmap:</strong></p>
<p><img src="https://img-blog.csdnimg.cn/0240ebf82c564b2e85bac2b4d390a830.png" alt="在这里插入图片描述"></p>
<ul>
<li>count：键值对数目。</li>
<li>flags：状态标志。</li>
<li>B：当前桶个数的二次幂。</li>
<li>noverflow：溢出桶的个数。</li>
<li>hash0：哈希种子。</li>
<li>buckets：哈希桶的地址。</li>
<li>old buckets：旧桶的地址，用于扩容。</li>
<li>nevacuate：即将迁移的旧桶编号，可以作为搬迁进度，小于nevacuate的已经搬迁。</li>
<li>overflow：溢出桶的信息。</li>
</ul>
<p><strong>bucket:</strong></p>
<p>其中键值对被保存在溢出桶中，溢出桶的结构是这样的：</p>
<p>“高位哈希值”数组存储的是通过哈希函数计算后的key再经取模后的高八位，而储存键值对的数组一共可以储存8个键值对，其中key都存在数组的前面，而value都存在后面。最后一个字段是一个指向溢出桶的指针。</p>
<p><img src="https://img-blog.csdnimg.cn/d281e0e293714a579ae2fed715370226.png" alt="在这里插入图片描述"></p>
<p>由此看出<code>hmap</code>和<code>bucket</code>的关系是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/93d9e7d9297248ccbddf52e079bd211a.png" alt="在这里插入图片描述"></p>
<p><strong>对key求哈希</strong></p>
<p>哈希表的特点是会有一个哈希函数，对传进来的key进行哈希运算，得到唯一的值，一般情况下都是一个数值。Golang的<code>map</code>中也有这么一个哈希函数，也会算出唯一的值，对于这个值的使用：</p>
<p>Golang把求得的值按照用途一分为二：高位和低位。</p>
<p><img src="https://img-blog.csdnimg.cn/f820981a63de401092012e0110bd4208.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_7,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>如图所示，蓝色为高位，红色为低位。 然后低位用于寻找当前key属于<code>hmap</code>中的哪个bucket，而高位用于寻找bucket中的哪个key。上文中提到：bucket中有个属性字段是“高位哈希值”数组，这里存的就是蓝色的高位值，用来声明当前bucket中有哪些“key”，便于搜索查找。 需要特别指出的一点是：我们<code>map</code>中的key&#x2F;value值都是存到同一个数组中的。数组中的顺序是这样的:<br><img src="https://img-blog.csdnimg.cn/e710e566d84446b8ac21dfda54bd3996.png" alt="在这里插入图片描述"><br>并不是key0&#x2F;value0&#x2F;key1&#x2F;value1的形式，这样做的好处是：在key和value的长度不同的时候，<strong>可以消除padding(内存对齐)带来的空间浪费。</strong></p>
<h2 id="map的扩容"><a href="#map的扩容" class="headerlink" title="map的扩容"></a>map的扩容</h2><h3 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h3><p>需要扩容时就要分配更多的<code>桶（Bucket）</code>，它们就是新桶。需要把旧桶里储存的键值对都迁移到新桶里。如果哈希表存储的键值对较多，一次性迁移所有桶所花费的时间就比较显著。<br>所以通常会在哈希表扩容时，先分配足够多的新桶，然后用一个字段（<code>oldbuckets</code>）记录旧桶的位置。<br>再增加一个字段（<code>nevacuate</code>），记录旧桶迁移的进度。例如记录下一个要迁移的旧桶编号。<br>在哈希表每次进行读写操作时，如果检测到当前处于扩容阶段，就完成一部分键值对迁移任务，直到所有的旧桶迁移完成，旧桶不再使用，才算真正完成一次哈希表的扩容。<br>像这样把键值对迁移的时间分摊到多次哈希表操作中的方式，就是<strong>渐进式扩容</strong>，可以避免一次性扩容带来的性能瞬时抖动。</p>
<p><img src="https://img-blog.csdnimg.cn/1f0a0b8afe454871a241514174d793aa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h3><p>bmap结构体的最后一个字段是一个bmap型指针，指向一个溢出桶。溢出桶的内存布局与常规桶相同，是为了减少扩容次数而引入的。<br>当一个桶存满了，还有可用的溢出桶时，就会在后面链一个溢出桶，继续往这里面存。</p>
<p><img src="https://img-blog.csdnimg.cn/93ef492076de4a24a597cacbb31d3a08.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>实际上如果哈希表要分配的桶数目大于<code>2 ^ 4</code>，就认为要使用到溢出桶的几率较大，就会预分配<code>2 ^ (B - 4)</code>个溢出桶备用。<br>这些溢出桶与常规桶在内存中是连续的，只是前<code>2 ^ B</code>个用做常规桶，后面的用作溢出桶。</p>
<p>hmap结构体最后有一个<code>extra</code>字段，指向一个<code>mapextra</code>结构体。里面记录的都是溢出桶相关的信息。<code>nextoverflow</code>指向下一个空闲溢出桶。<br><code>overflow</code>是一个<code>slice</code>，记录目前已经被使用的溢出桶的地址。<code>noverflower</code>记录使用的溢出桶数量。<code>oldoverflower</code>用于在扩容阶段储存旧桶用到的那些溢出桶的地址。</p>
<p><img src="https://img-blog.csdnimg.cn/6f0e2121f7a84e7a8f025ae9aaf80803.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="翻倍扩容"><a href="#翻倍扩容" class="headerlink" title="翻倍扩容"></a>翻倍扩容</h4><p><strong>负载因子</strong></p>
<p>判断翻倍扩容的条件，就是哈希表中的<code>负载因子</code>(键值对个数 &#x2F; 桶个数)。<br>负载因子的计算公式是：<strong>map长度 &#x2F; 2^B</strong>，阈值是<strong>6.5</strong>。其中B是bucket个数的二次幂，存在hmap表头结构中。</p>
<p>当负载因子 <code>count / (2 ^ B) &gt; 6.5</code> ,就会发生翻倍扩容（<code>hmap.B++</code>），分配新桶的数量是旧桶的两倍。<br><code>buckets</code>指向新分配的两个桶，<code>oldbuckets</code>指向旧桶。<code>nevacuate</code>为0，表示接下来要迁移编号为0的旧桶。<br>每个旧桶的键值对都会分流到两个新桶中。</p>
<p><img src="https://img-blog.csdnimg.cn/7857f4371ca74cf89fa9ff3d0d2c21b0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h4 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h4><p>如果负载因子没有超标，但是使用的溢出桶较多，也会出发扩容，不过这一次是<code>等量扩容</code>。</p>
<p>那么用多少溢出桶算多了呢？</p>
<ul>
<li>如果常规桶的数目不大于 <code>2  ^ 15</code>  ,那么使用溢出桶的数目超过常规桶就算是多了。</li>
<li>如果常规桶的数目大于 <code>2 ^ 15</code> ，那么使用溢出桶的数目一旦超过 <code>2 ^ 15</code> ，就算是多了。</li>
</ul>
<p>所谓等量扩容，就是创建和旧桶数目一样多的新桶。然后把原来的键值对迁移到新桶中，但是既然是等量，那来回迁移的又有什么用呢？<br>什么情况下，桶的负载因子没有超过上限值，却偏偏使用了很多溢出桶呢？自然是有很多键值对被删除的情况。同样数目的键值对，迁移到新桶中，能够排列的更加紧凑，从而减少溢出桶的使用。这就是等量扩容的意义所在。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang reflect底层剖析</title>
    <url>/2022/09/07/Go/Golang%20reflect%E5%BA%95%E5%B1%82%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>用到反射的场景不外乎是变量类型不确定，内部结构不明朗的情况，所以反射的作用简单来说就是把类型元数据暴露给用户使用。<br>我们已经介绍过runtime包中<code>_type</code>、<code>uncommontype</code>、<code>eface</code>、<code>iface</code>等类型了，reflect也要和它们打交道，但是它们都属于未导出类型，所以reflect在自己的包中又定义了一套，两边的类型定义是保持一致的。</p>
<p><img src="https://img-blog.csdnimg.cn/934e7a0589e545d3b5acf3103520c385.png" alt="在这里插入图片描述"></p>
<p>reflect中有两个核心类型，<code>reflect.Type</code>和<code>reflect.Value</code>，它们两个撑起了反射功能的基本框架。</p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p><code>reflect.Type</code>是一个接口类型，它定义了一系列方法用于获取类型各方面的信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">    Align() <span class="type">int</span> <span class="comment">//对齐边界</span></span><br><span class="line">    FieldAlign() <span class="type">int</span> <span class="comment">//作为结构体字段的对齐边界</span></span><br><span class="line">    Method(<span class="type">int</span>) Method <span class="comment">//获取方法数组中第i个Method</span></span><br><span class="line">    MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>) <span class="comment">//按照名称查找方法</span></span><br><span class="line">    NumMethod() <span class="type">int</span> <span class="comment">//方法列表中可导出方法的数目</span></span><br><span class="line">    Name() <span class="type">string</span> <span class="comment">//类型名称</span></span><br><span class="line">    PkgPath() <span class="type">string</span> <span class="comment">//包路径</span></span><br><span class="line">    Size() <span class="type">uintptr</span> <span class="comment">//该类型变量占用字节数</span></span><br><span class="line">    String() <span class="type">string</span> <span class="comment">//获取类型的字符串表示</span></span><br><span class="line">    Kind() Kind <span class="comment">//类型对应的reflect.Kind</span></span><br><span class="line">    Implements(u Type) <span class="type">bool</span> <span class="comment">//该类型是否实现了接口u</span></span><br><span class="line">    AssignableTo(u Type) <span class="type">bool</span> <span class="comment">//是否可以赋值给类型u</span></span><br><span class="line">    ConvertibleTo(u Type) <span class="type">bool</span> <span class="comment">//是否可转换为类型u</span></span><br><span class="line">    Comparable() <span class="type">bool</span> <span class="comment">//是否可比较</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只能应用于某些Kind的方法</span></span><br><span class="line">    <span class="comment">//Int*, Uint*, Float*, Complex*: </span></span><br><span class="line">    Bits() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Array,Ptr,Slice,Map: </span></span><br><span class="line">    Elem() Type</span><br><span class="line">    <span class="comment">//Array</span></span><br><span class="line">    Len() <span class="type">int</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//Chan:ChanDir, Elem </span></span><br><span class="line">    ChanDir() ChanDir</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Func: </span></span><br><span class="line">    In(i <span class="type">int</span>) Type</span><br><span class="line">    NumIn() <span class="type">int</span></span><br><span class="line">    Out(i <span class="type">int</span>) Type</span><br><span class="line">    NumOut() <span class="type">int</span></span><br><span class="line">    IsVariadic() <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Map: </span></span><br><span class="line">    Key() Type</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Struct: </span></span><br><span class="line">    Field(i <span class="type">int</span>) StructField</span><br><span class="line">    FieldByIndex(index []<span class="type">int</span>) StructField</span><br><span class="line">    FieldByName(name <span class="type">string</span>) (StructField, <span class="type">bool</span>)</span><br><span class="line">    FieldByNameFunc(match <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> <span class="type">bool</span>) (StructField, <span class="type">bool</span>)  </span><br><span class="line">    NumField() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    common() *rtype</span><br><span class="line">    uncommon() *uncommonType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>通常会用<code>reflect.TypeOf</code>这个函数来拿到一个<code>reflect.Type</code>类型的返回值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">    eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line">    <span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>它接收一个空接口类型的参数。<br>接下来，<code>reflect.TypeOf</code>函数会把<code>runtime.eface</code>类型的参数<code>i</code>转换成reflect.emptyInterface类型并赋给局部变量<code>eface</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/2d8113189c3040ab89dcf7df9e048698.png" alt="在这里插入图片描述"></p>
<p>因为<code>*rtype</code>实现了<code>reflect.Type</code>接口，所以只要把<code>eface</code>这里的<code>typ</code>字段取出来，包装成<code>reflect.Type</code>类型的返回值就好了。<br>这就相当于下面这样把<code>eface.typ</code>赋值给一个<code>reflect.Type</code>类型的变量，这两行代码可以帮助我们理解返回值的结构。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ret reflect.Type</span><br><span class="line">ret = eface.typ</span><br></pre></td></tr></table></figure>



<p>还记得非空接口长什么样子吧？<code>eface.typ</code>是个指针，所以这个返回值的<code>data</code>字段就等于<code>eface.typ</code>，也就是<code>string</code>类型的元数据地址，而<code>itab</code>中的接口类型就是<code>reflect.Type</code>，动态类型就是<code>*rtype</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/d843536c4c5a4f3c886b1be7e717a90a.png" alt="在这里插入图片描述"></p>
<p>至于<code>*rtype</code>实现的这些接口要求的方法，也不过是去<code>data</code>字段指向的类型元数据那里获取各种信息罢了。<br>例如可以使用<code>Implements</code>方法来判断类型是否实现了某个接口，比方说fmt.Stringer接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/0d234088dda6445e94be7a84a4201bd3.png" alt="在这里插入图片描述"></p>
<p>判断的过程就是通过类型元数据找到方法元数据数组，这里的Method是按照方法名称排过序的，所以只要和接口要求的方法列表两相比较一下，就可以确定该类型是否实现指定接口了。<br>这就是<code>reflect</code>的<code>Type</code>类型和<code>TypeOf</code>方法，重点是要理解反射如何拿到反射变量的类型元数据，剩下的就好说了。</p>
<h2 id="Value"><a href="#Value" class="headerlink" title="Value"></a>Value</h2><p>与<code>reflect.Type</code>不同，<code>reflect.Value</code>是一个结构体类型。   </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ *rtype</span><br><span class="line">    ptr unsafe.Pointer</span><br><span class="line">    flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><code>typ</code>存储反射变量的类型元数据指针；</li>
<li><code>ptr</code>存储数据地址；</li>
<li><code>flag</code>是一个位标识符，存储反射变量值的一些描述信息，例如类型掩码，是否为指针，是否为方法，是否只读等等。</li>
</ul>
<p><code>reflect.Value</code>同样提供了很多方法，这里我们只关注利用反射来更新变量值的过程。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">    v := reflect.ValueOf(a)</span><br><span class="line">    v.SetString(<span class="string">&quot;new eggo&quot;</span>)</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先要注意，<code>reflect.ValueOf</code>函数的参数也是空接口类型，所以和前面介绍的<code>TypeOf</code>一样，它接收到的参数中数据指针同样指向<code>a</code>的一个拷贝值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line">    <span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    escapes(i)</span><br><span class="line">    <span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>此外还要注意，<code>reflect.ValueOf</code>函数目前的实现方式，会通过<code>escapes</code>函数显示地把参数<code>i</code>指向的变量逃逸到堆上。<br>对应到上面这个例子，<code>copy of a</code>就会逃逸到堆上，栈上存储它的地址。所以这个空接口类型的参数<code>i</code>，其动态类型指向string类型元数据，动态值指向堆上的<code>copy of a</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/046de697b508497a84a6a7064bcc8114.png" alt="在这里插入图片描述"></p>
<p><code>ValueOf</code>函数的返回值是<code>reflect.Value</code>类型，其<code>typ</code>字段取参数的<code>_type</code>字段，指向<code>string</code>类型元数据，<code>ptr</code>字段取参数的<code>data</code>字段，指向<code>copy of a</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/77b4c360da5d44d3a8b346f469cf8d6e.png" alt="在这里插入图片描述"></p>
<p>接下来，这个返回值被赋给局部变量<code>v</code>，调用<code>v.SetString</code>时，方法接收者<code>v</code>作为第一个参数，字符串”new eggo”作为第二个参数。 因为此时<code>v.ptr</code>指向的是<code>copy of a</code>，而不是<code>a</code>，所以是不允许修改的。</p>
<p><img src="https://img-blog.csdnimg.cn/7eff206c59b74247bee2a180d8cdc365.png" alt="在这里插入图片描述"></p>
<p>因为修改这样一个用户都不知道的临时变量<code>copy of a</code>没有任何意义，毕竟通过反射来修改变量值本意是要作用到原变量身上的，所以上面这个例子在执行阶段会发生panic：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>: reflect: reflect.Value.SetString using unaddressable value</span><br></pre></td></tr></table></figure>



<p>这个异常信息就是提醒我们此时反射修改值的行为并不符合预期。若想顺利修改变量<code>a</code>，就需要反射<code>a</code>的指针。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">    v := reflect.ValueOf(&amp;a)</span><br><span class="line">    v.Elem().SetString(<span class="string">&quot;new eggo&quot;</span>)</span><br><span class="line">    <span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>传参依然是值拷贝，只不过这一次拷贝的是<code>a</code>的地址，所以<code>reflect.ValueOf</code>会显示地把局部变量<code>a</code>逃逸到堆上，栈上只存它的地址&amp;a。</p>
<p><img src="https://img-blog.csdnimg.cn/3b28ff59fee947a3b3f8bd2e6c6c652b.png" alt="在这里插入图片描述"></p>
<p>局部变量<code>v</code>中，<code>v.typ</code>指向<code>*string</code>类型元数据，<code>v.ptr</code>等于<code>a</code>的地址。</p>
<p><img src="https://img-blog.csdnimg.cn/6b42695dc514444886bb4581e58ffc31.png" alt="在这里插入图片描述"></p>
<p>接下来调用<code>v.Elem()</code>方法可以拿到<code>v.ptr</code>指向的那个变量，也就是局部变量<code>a</code>，并把它包装成一个新的<code>reflect.Value</code>对象作为返回值。这个返回值里<code>typ</code>指向<code>string</code>类型元数据，<code>ptr</code>指向局部变量<code>a</code>。</p>
<p><img src="https://img-blog.csdnimg.cn/21fce825212042c5944c77f972be449a.png" alt="在这里插入图片描述"></p>
<p>通过<code>v.Elem()</code>的返回值再调用<code>SetString</code>方法时，修改的就是原来的变量<code>a</code>了。</p>
<p><img src="https://img-blog.csdnimg.cn/e621fd8820384ac3967caf1ace483202.png" alt="在这里插入图片描述"></p>
<p>通过反射修改变量值的问题有点绕，但是只要记住函数传参值拷贝，以及反射修改变量值要作用到原变量身上才有意义这两个原则，再梳理出<code>Value</code>对象内部结构，理解起来就没那么困难了。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang slice原理浅析</title>
    <url>/2022/09/07/Go/Golang%20slice%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="slice内存模型"><a href="#slice内存模型" class="headerlink" title="slice内存模型"></a>slice内存模型</h2><p>我的go源码版本是：<a href="https://golang.org/dl/go1.17.2.src.tar.gz">go1.17.2</a></p>
<p>slice的源码在<code>Go_SDK\go1.17.2\src\runtime\slice.go</code>中。<br>和map.go在同一个目录下。</p>
<p>首先我们来看一下slice的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>slice的结构非常简单，只有三个部分：</p>
<ul>
<li>array: 指向数组的指针。</li>
<li>len：当前长度。</li>
<li>cap：容量。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6044a1c99a7c4dc08edc43007ba4daa0~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"><br></p>
<h2 id="slice的初始化"><a href="#slice的初始化" class="headerlink" title="slice的初始化"></a>slice的初始化</h2><p>举一个例子：</p>
<p><strong>声明一个整型的slice：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints []<span class="type">int</span></span><br></pre></td></tr></table></figure>



<p>变量<code>ints</code>实际上就由以下三个部分组成。<br><code>slice</code>的元素要存在一段连续的内存中，实际上就是一个数组，但是目前只分配了这个切片结构，还没有分配底层数组。所以 <code>data = nil</code> | <code>len = 0</code> | <code>cap = 0</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fe914f09f8847e0bc122dd0c68a0323~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><strong>通过make来定义</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ints []<span class="type">int</span> = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>这时不仅会分配这三部分结构，还会开辟一段内存作为切片的底层数组，这里make会为ints开辟一段容纳5个整型元素的内存，还会把它们初始化为整型的默认值0 。<br>但是目前这个slice变量只存储了两个元素，所以<code>data指向这个底层数组的首地址 | len = 2 | cap = 5</code> 。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c49597a18cb488fbe95476620826bb3~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>这个时候我们添加一个元素，然后再做一个赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ints = <span class="built_in">append</span>(ints, <span class="number">1</span>)</span><br><span class="line">ints[<span class="number">0</span>] = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>append的元素会被自动添加到第3个位置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c692251dfb14186b62a79d11a509d45~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>已经存储的元素是可以安全读写的，但是超出这个范围就属于越界访问。会发生<code>panic</code>。</p>
<p>再来举一个例子：</p>
<p>我们创建一个字符串类型的<code>slice</code>，但是不用make，而是用<code>new</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ps := <span class="built_in">new</span>([]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>
<p>new一个slice变量，同样会分配这三部分结构。<br>但他不负责底层数组的分配，所以 <code>data = nil | len = 0 | cap = 0</code> 。new的返回值就是slice结构的起始地址。所以ps就是一个地址。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(*ps)[<span class="number">0</span>] = <span class="string">&quot;egg&quot;</span>  <span class="comment">//不允许</span></span><br></pre></td></tr></table></figure>

<p>此时这个slice变量还没有底层数组。像上述的操作是不允许的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97896bf93aa1403cb6115f4e6117b407~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>但是我们可以使用append的方式为slice添加元素。它就会为slice开辟底层数组。</p>
<h2 id="slice的底层数组"><a href="#slice的底层数组" class="headerlink" title="slice的底层数组"></a>slice的底层数组</h2><p>int型slice的底层就是int型数组，string型slice的底层就是string型数组。</p>
<p>但是slice中的数组指针，并不是必须指向底层数组的开头。</p>
<p>我们来看一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := [<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125; <span class="comment">//数组容量声明了就不可改变</span></span><br></pre></td></tr></table></figure>

<p>我们可以把不同的slice关联到同一个数组。<br>像这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 []<span class="type">int</span> = arr[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">//左闭右开</span></span><br><span class="line"><span class="keyword">var</span> s2 []<span class="type">int</span> = arr[<span class="number">7</span>:]</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e30a6bcf8f47f8847ab72b992532a7~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>slice访问和修改的其实都是底层数组的元素。<br>如果要给<code>s1</code>添加两个元素，直接使用append即可，这个底层数组依然可以使用。<br>但是如果要给<code>s2</code>添加元素，这个底层数组就不能再使用了，因为数组的大小是固定的。<br>因此，得开辟一个新的数组。原来的元素得拷贝过来，还得添加新的元素。元素个数改为4，容量扩到了6。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c238cf41687e4ac089dee0ab66bf1cfa~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="slice的扩容规则"><a href="#slice的扩容规则" class="headerlink" title="slice的扩容规则"></a>slice的扩容规则</h2><p>还记得上面的例子吗？我们只给s2切片添加了1个元素，为什么<code>cap</code>从3扩容到了6呢？那就要看slice的扩容规则了。</p>
<p><strong>STEP1 预估扩容后的容量 newCap</strong></p>
<p>预估规则：</p>
<ul>
<li>如果扩容前容量翻倍，还是小于所需的最小容量，那么预估容量就等于所需的最小容量。</li>
<li>否则就要再细分：<ul>
<li>如果扩容前元素个数小于1024，那就直接翻倍。</li>
<li>如果扩容前元素大于等于1024，那就先扩容至原来的 1&#x2F;4 。</li>
</ul>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd06cc9bc6ac4751a6790a3d91437239~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><strong>STEP2 newCap需要多大内存</strong></p>
<p>这一步需要计算需要的内存，这就和元素类型挂钩了。用 <code>预估容量 * 元素类型大小</code> 得到的就是所需内存。</p>
<p>但是不可以直接分配这么多内存。<br>简单来说，再许多编程语言中，申请内存并不是直接与操作系统交涉的，而是与语言自身实现的内存管理模块进行交涉。它会提前向操作系统申请一块内存，分成常用的规格管理起来，我们申请内存时，它会帮我们匹配到足够大且最接近的规格。（按照第一步的扩容规则来）</p>
<p>这就是第三步要做的事情。</p>
<p><strong>STEP3 匹配到合适的内存规格</strong></p>
<p>比如扩容之后的cap &#x3D; 5，在64位操作系统中，就需要 <code>5 * 8 = 40</code> 个字节的内存，来存放底层数组。</p>
<p>按照扩容规则，实际申请时会匹配到48字节。一共能装6个元素。</p>
<p>我们来看一个例子：</p>
<p>创建一个string类型的slice：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := []<span class="type">string</span>&#123;<span class="string">&quot;my&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;is&quot;</span>&#125;</span><br><span class="line">a := <span class="built_in">append</span>(a, <span class="string">&quot;egg&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>step1: newCap &#x3D; 6</p>
<p>step2: 6 * 16 &#x3D; 96 byte  (64位中string类型的大小是16byte)</p>
<p>step3: 匹配到内存规格就是96字节。</p>
<p>所以最终扩容以后，cap就是6。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang sync.Map原理分析</title>
    <url>/2022/11/02/Go/Golang%20sync.Map%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="GO语言内置的map"><a href="#GO语言内置的map" class="headerlink" title="GO语言内置的map"></a>GO语言内置的map</h2><p>go语言内置一个map数据结构，使用起来非常方便，但是它仅支持并发的读，不支持并发的写，比如下面的代码：</p>
<p>在main函数中开启两个协程同时对m进行并发读和并发写，程序运行之后会报错：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			_ = m[<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			m[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/4c595886cc4d43839ac06953564fbd28.png" alt="在这里插入图片描述"></p>
<p><strong>改进</strong></p>
<p>既然不可以并发的写，我们可以给map加一个读写锁，这样就不会有并发写冲突的问题了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	<span class="keyword">var</span> lock sync.RWMutex</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			lock.RLock()</span><br><span class="line">			_ = m[<span class="number">1</span>]</span><br><span class="line">			lock.RUnlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			lock.Lock()</span><br><span class="line">			m[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方式的实现非常简洁，但也存在一些问题，比如在map的数据非常大的情况下，一把锁会导致大并发的客户端共争一把锁。</p>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>sync.Map是官方在sync包中提供的一种并发map，使用起来非常简单，和普通map相比，只有遍历的方式有区别：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m sync.Map</span><br><span class="line">	<span class="comment">// 1. 写入</span></span><br><span class="line">	m.Store(<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>)</span><br><span class="line">	m.Store(<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 读取</span></span><br><span class="line">	price, _ := m.Load(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line">	fmt.Println(price.(<span class="type">int</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 遍历</span></span><br><span class="line">	m.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		fruit := key.(<span class="type">string</span>)</span><br><span class="line">		price := value.(<span class="type">int</span>)</span><br><span class="line">		fmt.Println(fruit, price)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 删除</span></span><br><span class="line">	m.Delete(<span class="string">&quot;apple&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 读取或写入</span></span><br><span class="line">	m.LoadOrStore(<span class="string">&quot;peach&quot;</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>sync.Map是通过 read 和 dirty 两个字段将读写分离，读的数据存在只读字段 read 上，将最新写入的数据则存在 dirty 字段上。<br>读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty。<br>读取 read 并不需要加锁，而读或写 dirty 都需要加锁，另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上，对于删除数据则直接通过标记来延迟删除。</p>
<p>在map + 锁的基础上，它有着几个优化点：</p>
<ol>
<li>空间换时间。 通过冗余的两个数据结构(read、dirty)，实现加锁对性能的影响。</li>
<li>使用只读数据(read)，避免读写冲突。</li>
<li>动态调整，miss次数多了之后，将dirty数据提升为read。</li>
<li>double-checking。</li>
<li>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</li>
<li>优先从read读取、更新、删除，因为对read的读取不需要锁。</li>
</ol>
<h2 id="sync-Map原理分析"><a href="#sync-Map原理分析" class="headerlink" title="sync.Map原理分析"></a>sync.Map原理分析</h2><h3 id="sync-Map的结构"><a href="#sync-Map的结构" class="headerlink" title="sync.Map的结构"></a>sync.Map的结构</h3><p>sync.Map的实现在<code>src/sync/map.go</code>中，首先来看Map结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 当涉及到脏数据(dirty)操作时候，需要使用这个锁</span></span><br><span class="line">    mu Mutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// read是一个只读数据结构，包含一个map结构，</span></span><br><span class="line">    <span class="comment">// 读不需要加锁，只需要通过 atomic 加载最新的指正即可</span></span><br><span class="line">    read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dirty 包含部分map的键值对，如果操作需要mutex获取锁</span></span><br><span class="line">    <span class="comment">// 最后dirty中的元素会被全部提升到read里的map去</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// misses是一个计数器，用于记录read中没有的数据而在dirty中有的数据的数量。</span></span><br><span class="line">    <span class="comment">// 也就是说如果read不包含这个数据，会从dirty中读取，并misses+1</span></span><br><span class="line">    <span class="comment">// 当misses的数量等于dirty的长度，就会将dirty中的数据迁移到read中</span></span><br><span class="line">    misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上述结构体中的read字段实际上是一个包含map的结构体，该结构体中的map是一个read map，对该map的访问不需要加锁，但是增加的元素不会被添加到这个map中，元素会被先增加到dirty中，后续才会被迁移到read只读map中。<br>readOnly结构体中还有一个amended字段，该字段是一个标志位，用来表示read map中的数据是否完整。假设当前要查找一个key，会先去read map中找，如果没有找到，会判断amended是否为true，如果为true，说明read map的数据不完整，需要去dirty map中找。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readOnly is an immutable struct stored atomically in the Map.read field.</span></span><br><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// m包含所有只读数据，不会进行任何的数据增加和删除操作 </span></span><br><span class="line">    <span class="comment">// 但是可以修改entry的指针因为这个不会导致map的元素移动</span></span><br><span class="line">    m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标志位，如果为true则表明当前read只读map的数据不完整，dirty map中包含部分数据</span></span><br><span class="line">    amended <span class="type">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>entry</strong></p>
<p><code>readOnly.m</code>和<code>Map.dirty</code>存储的值类型是*entry,它包含一个指针p, 指向用户存储的value值，结构如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中p对应着三种值：</p>
<ul>
<li><code>p == nil</code>: 键值已经被删除，且 <code>m.dirty == nil</code>，这个时候dirty在等待read的同步数据。</li>
<li><code>p == expunged</code>: 键值已经被删除，但 <code>m.dirty!=nil</code> 且 m.dirty 不存在该键值（dirty已经得到了read的数据同步，原来为nil的值已经被标记为了expunged没有被同步过来）。</li>
<li>除以上情况，则键值对存在，存在于 m.read.m 中，如果 m.dirty!&#x3D;nil 则也存在于 m.dirty</li>
</ul>
<p>下面是sync.Map的结构示意图：<br><img src="https://img-blog.csdnimg.cn/9252a5486abe46a2bf7acb5069565deb.png" alt="在这里插入图片描述"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找元素会调用Load函数，该函数的执行流程：</p>
<ol>
<li>首先去read map中找值，不用加锁，找到了直接返回结果。</li>
<li>如果没有找到就判断<code>read.amended</code>字段是否为true，true说明dirty中有新数据，应该去dirty中查找，开始加锁。</li>
<li>加完锁以后又去read map中查找，因为在加锁的过程中，m.dirty可能被提升为m.read。</li>
<li>如果二次检查没有找到key，就去<code>m.dirty</code>中寻找，然后将misses计数加一。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/map.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Load returns the value stored in the map for a key, or nil if no</span></span><br><span class="line"><span class="comment">// value is present.</span></span><br><span class="line"><span class="comment">// The ok result indicates whether value was found in the map.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 首先从只读ready的map中查找，这时不需要加锁</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有找到，并且read.amended为true，说明dirty中有新数据，从dirty中查找，开始加锁了</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock() <span class="comment">// 加锁</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 又在 readonly 中检查一遍，因为在加锁的时候 dirty 的数据可能已经迁移到了read中</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// read 还没有找到，并且dirty中有数据</span></span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key] <span class="comment">//从 dirty 中查找数据</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不管m.dirty中存不存在，都将misses + 1</span></span><br><span class="line">            <span class="comment">// missLocked() 中满足条件后就会把m.dirty中数据迁移到m.read中</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>misses计数</strong></p>
<p>misses计数是有上限的，如果misses次数达到<code>m.dirty</code>的长度，就开始迁移数据，程序会直接将m.dirty提升为m.read，然后将m.dirty置为nil，等到下次插入新数据的时候，程序才会把read map中的值全部复制给dirty map。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/map.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;<span class="comment">//misses次数小于 dirty的长度，就不迁移数据，直接返回</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;) <span class="comment">//开始迁移数据</span></span><br><span class="line">    m.dirty = <span class="literal">nil</span>   <span class="comment">//迁移完dirty就赋值为nil</span></span><br><span class="line">    m.misses = <span class="number">0</span>  <span class="comment">//迁移完 misses归0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新增和更新"><a href="#新增和更新" class="headerlink" title="新增和更新"></a>新增和更新</h3><p>新增或者更新元素会调用Store函数，该函数的前面几个步骤与Load函数是一样的：</p>
<ol>
<li>首先去read map中找值，不用加锁，找到了直接调用<code>tryStore()</code>函数更新值即可。</li>
<li>如果没有找到就开始对dirty map加锁，加完锁之后再次去read map中找值，如果存在就判断该key对应的entry有没有被标记为<code>unexpunge</code>，如果没有被标记，就直接调用<code>storeLocked()</code>函数更新值即可。</li>
<li>如果在read map中进行二次检查还是没有找到key，就去dirty map中找，找到了直接调用<code>storeLocked()</code>函数更新值。</li>
<li>如果dirty map中也没有这个key，说明是新加入的key，首先要将<code>read.amended</code>标记为true，然后将read map中未删除的值复制到dirty中，最后向dirty map中加入这个值。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/map.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Store sets the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">   <span class="comment">// 直接在read中查找值，找到了，就尝试 tryStore() 更新值</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// m.read 中不存在</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123; <span class="comment">// 未被标记成删除，前面讲到entry数据结构时，里面的p值有3种。1.nil 2.expunged，这个值含义有点复杂，可以看看前面entry数据结构 3.正常值</span></span><br><span class="line">            </span><br><span class="line">            m.dirty[key] = e <span class="comment">// 加入到dirty里</span></span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value) <span class="comment">// 更新值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123; <span class="comment">// 存在于 dirty 中，直接更新</span></span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 新的值</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123; <span class="comment">// m.dirty 中没有新数据，增加到 m.dirty 中</span></span><br><span class="line">            <span class="comment">// We&#x27;re adding the first new key to the dirty map.</span></span><br><span class="line">            <span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">            m.dirtyLocked() <span class="comment">// 从 m.read中复制未删除的数据</span></span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;) </span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value) <span class="comment">//将这个entry加入到m.dirty中</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Store函数中我们用到了两个用于更新值的函数：<code>tryStore</code>以及<code>storeLocked</code>，<code>tryStore</code>函数是先判断p有没有被标记为expunged（软删除），如果被标记了就直接返回false，如果没有被标记，就将p指向的值进行更新然后返回true。<br><code>storeLocked</code>函数是直接将p指向的值进行更新。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tryStore stores a value if the entry has not been expunged.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If the entry is expunged, tryStore returns false and leaves the entry</span></span><br><span class="line"><span class="comment">// unchanged.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// storeLocked unconditionally stores a value to the entry.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The entry must be known not to be expunged.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将read map中的值复制到dirty map中：</strong></p>
<p><code>m.dirtyLocked()</code>函数用于将read map中的值复制到dirty map中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">	<span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	read, _ := m.read.Load().(readOnly)</span><br><span class="line">	m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">	<span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">		<span class="comment">// 判断值是否被删除，被标记为expunged的值不会被复制到read map中</span></span><br><span class="line">		<span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">			m.dirty[k] = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// expunged实际上是一个指向空接口的unsafe指针</span></span><br><span class="line"><span class="keyword">var</span> expunged = unsafe.Pointer(<span class="built_in">new</span>(<span class="keyword">interface</span>&#123;&#125;))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">	p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">	<span class="comment">// 如果p为nil，就会被标记为expunged</span></span><br><span class="line">	<span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>下面是对sync.Map进行读写操作的示意图，正常读写且read map中有数据，程序只会访问read map，而不会去加锁：</p>
<p><img src="https://img-blog.csdnimg.cn/99820ec894c34c3db0ac52ce4204cceb.png" alt="在这里插入图片描述"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除会调用<code>Delete</code>函数，该函数的步骤如下：</p>
<ol>
<li>首先去read map中找key，找到了就调用<code>e.delete()</code>函数删除。</li>
<li>如果在read map中没有找到值就开始对dirty map加锁，加锁完毕之后再次去read map中查找，找到了就调用<code>e.delete()</code>函数删除。</li>
<li>如果二次检查都没有找到key（说明这个key是被追加之后，还没有提升到read map中就要被删除），就去dirty map中删除这个key。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/sync/map.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete deletes the value for a key.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 从 m.read 中开始查找</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">// m.read中没有找到，并且可能存在于m.dirty中，加锁查找</span></span><br><span class="line">        m.mu.Lock() <span class="comment">// 加锁</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly) <span class="comment">// 再在m.read中查找一次</span></span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123; <span class="comment">//m.read中又没找到，amended标志位true，说明在m.dirty中</span></span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key) <span class="comment">// 删除</span></span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123; <span class="comment">// 在 m.read 中就直接删除</span></span><br><span class="line">        e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (hadValue <span class="type">bool</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">		<span class="comment">// 已标记为删除</span></span><br><span class="line">		<span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 原子操作，e.p标记为nil，GO的GC会将对象自动删除</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>key究竟什么时候会被删除</strong></p>
<p>我们可以发现，如果read map中存在待删除的key时，程序并不会去直接删除这个key，而是将这个key对应的p指针指向nil。<br>在下一次<code>read -&gt; dirty</code>的同步时，指向nil的p指针会被标记为expunged，程序不会将被标记为expunged的 key 同步过去。<br>等到再一次<code>dirty -&gt; read</code>同步的时候，read会被dirty直接覆盖，这个时候被标记为expunged的key才真正被删除了，这就是sync.Map的延迟删除。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang slice传参陷阱</title>
    <url>/2022/09/07/Go/Golang%20slice%E4%BC%A0%E5%8F%82%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<h2 id="先看一道题"><a href="#先看一道题" class="headerlink" title="先看一道题"></a>先看一道题</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	SliceRise(s1)</span><br><span class="line">	SliceRise(s2)</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A: [2,3][2,3,4]</span></span><br><span class="line"><span class="comment">//B: [1,2][1,2,3]</span></span><br><span class="line"><span class="comment">//C: [1,2][2,3,4]</span></span><br><span class="line"><span class="comment">//D: [2,3,1][2,3,4,1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果不清楚slice的扩容和Go语言的传参机制，可能很难想出来一个解释的清的答案，答案选C，最后再解释。</p>
<h2 id="slice的传参"><a href="#slice的传参" class="headerlink" title="slice的传参"></a>slice的传参</h2><p>在初学golang的时候，我一直以为slice是引用传递而不是值传递，其实不然。</p>
<p>我们先来看一下官方对于这个问题的解释：</p>
<blockquote>
<p>In a function call, the function value and arguments are evaluated in<br>the usual order. After they are evaluated, the parameters of the call<br>are passed by value to the function and the called function begins<br>execution. The return parameters of the function are passed by value<br>back to the caller when the function returns.</p>
</blockquote>
<p>译文：</p>
<blockquote>
<p>在函数调用中，函数值和参数按通常的顺序计算。求值之后，调用的参数通过值传递给函数，被调用的函数开始执行。当函数返回时，函数的返回参数按值返回给调用者。</p>
</blockquote>
<p>来源于：<br><a href="https://golang.org/ref/spec#Calls">https://golang.org/ref/spec#Calls</a></p>
<p>也就是说golang中其实是没有所谓的引用传递的，只有值传递。那为什么我们在函数中对slice进行修改时，有时候会影响到函数外部的slice呢？</p>
<p>这就要从slice的内存模型说起了，slice的内存模型其实非常简单，就是一个结构体，里面包含了三个字段。第一个字段是一个指向底层数组的指针，第二个是slice的长度，第三个是底层数组的大小。具体的可以看这里：<a href="https://blog.csdn.net/qq_49723651/article/details/121267698?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_49723651&#x2F;article&#x2F;details&#x2F;121267698?spm&#x3D;1001.2014.3001.5501</a></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer</span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在传递参数的时候，其实是传递了一个slice结构体，这个时候当然是值传递。我们来验证一下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s)</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%p\n&quot;</span>, &amp;s1)</span><br><span class="line">	SliceRise(s1)</span><br><span class="line">	<span class="comment">//SliceRise(s2)</span></span><br><span class="line">	<span class="comment">//fmt.Println(s1, s2)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="comment">//0xc000004078</span></span><br><span class="line"><span class="comment">//0xc000004090</span></span><br></pre></td></tr></table></figure>



<p>通过计算可以知道slice结构体的大小为24byte，两个地址之差刚好是24byte。<br>地址不同，所以两个结构体不是同一个结构体。</p>
<p><strong>然而结构体中的指针字段却包含了底层数组的地址，这就使得函数中的slice和函数外的slice都指向了同一个底层数组，这也就是有些时候，改变函数内部的slice也能影响到函数外部的slice的原因。</strong></p>
<h2 id="slice的扩容"><a href="#slice的扩容" class="headerlink" title="slice的扩容"></a>slice的扩容</h2><p>有关扩容的详细规则可以看这篇博客：<a href="https://blog.csdn.net/qq_49723651/article/details/121267698?spm=1001.2014.3001.5501">https://blog.csdn.net/qq_49723651&#x2F;article&#x2F;details&#x2F;121267698?spm&#x3D;1001.2014.3001.5501</a>。</p>
<p>slice在append的时候，如果底层数组的大小(cap)不够了，就会发生扩容。发生扩容的时候，slice结构体的指针会指向一个新的底层数组，然后把原来数组中的元素拷贝到新数组中，最后添加上append的新元素，就完成了扩容。<br>所以在这个时候，函数内部slice的改变是不会影响到函数外部slice的。因为此时，两个结构体中的指针指向的底层数组已经不相同了。</p>
<h2 id="回到开始"><a href="#回到开始" class="headerlink" title="回到开始"></a>回到开始</h2><p>然后我们回到最开始的这段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SliceRise</span><span class="params">(s []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> s &#123;</span><br><span class="line">		s[i]++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s1 := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	s2 := s1</span><br><span class="line">	s2 = <span class="built_in">append</span>(s2, <span class="number">3</span>)</span><br><span class="line">	SliceRise(s1)</span><br><span class="line">	SliceRise(s2)</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A: [2,3][2,3,4]</span></span><br><span class="line"><span class="comment">//B: [1,2][1,2,3]</span></span><br><span class="line"><span class="comment">//C: [1,2][2,3,4]</span></span><br><span class="line"><span class="comment">//D: [2,3,1][2,3,4,1]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>选C也就不难解释了：</p>
<ul>
<li>首先s1在初始化的时候，分配了一个底层数组，<code>len=2</code>，<code>cap=2</code> ；</li>
<li>将s1赋值给s2，两者就指向了同一个底层数组；</li>
<li>s2发生扩容，因为cap不够了，这个时候s2指向一个<code>新的底层数组</code>，并且<code>len=3</code>，<code>cap=4</code> ；</li>
<li>然后调用两次<code>SliceRise</code>函数；</li>
<li>s1作为参数进入函数时，发生了扩容，因为<code>cap</code>不够了，所以新分配了一个底层数组，这个时候，main函数中的s1与<code>SliceRise</code>中的s1已经分道扬镳了。所以main函数中的s1不会有任何改变；</li>
<li>s2作为参数进入函数时，同样发生了扩容，但是<code>cap</code>还够，所以不会分配新的底层数组，接下来的所有改变都会影响到s2所指向的底层数组。但是main函数结构体中len字段的值却不会发生变化，所以即使底层数组的第4位append了0，切片s2也访问不到。所以最后在输出s2的时候，只能输出s2的前len位，也就是前3位。</li>
<li>因此最终在main函数中，s1输出[1,2]，而s2输出[2,3,4]。</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 优雅的使用Context</title>
    <url>/2022/09/08/Go/Golang%20%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Context/</url>
    <content><![CDATA[<h2 id="优雅的关闭goroutine"><a href="#优雅的关闭goroutine" class="headerlink" title="优雅的关闭goroutine"></a>优雅的关闭goroutine</h2><p>在很多场景下，在执行一个任务时，我们会将这个任务拆分成几个子任务，然后开启几个不同的goroutine去执行。当因为某些原因这个任务需要终止时，我们需要将这些goroutine也全都终止掉。</p>
<p>比如Go http包的Server中，每一个请求都有对应的goroutine去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p>
<p>下面我们举一个简单的例子，然后分别使用不同的方法去关闭例子中的goroutine。</p>
<h3 id="sync-WaitGroup-实现"><a href="#sync-WaitGroup-实现" class="headerlink" title="sync.WaitGroup 实现"></a>sync.WaitGroup 实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(task <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(task, <span class="string">&quot;start...&quot;</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	<span class="comment">// 每个groutine运行完毕后就释放WaitGroup的计时器</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		taskName := <span class="string">&quot;task&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		<span class="keyword">go</span> run(taskName)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;所有任务结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// task2 start...</span></span><br><span class="line"><span class="comment">// task1 start...</span></span><br><span class="line"><span class="comment">// 所有任务结束</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面例子中，一个任务结束了必须等待另外一个任务也结束了才算全部结束了，先完成的必须等待其他未完成的，所有的goroutine都要全部完成才OK。</p>
<p>这种方式的优点：使用等待组的并发控制模型，尤其适用于好多个goroutine协同做一件事情的时候，因为每个goroutine做的都是这件事情的一部分，只有全部的goroutine都完成，这件事情才算完成。</p>
<p>这种方式的缺陷：在实际生产中，需要我们主动的通知某一个 goroutine 结束。</p>
<h3 id="channel-select-实现"><a href="#channel-select-实现" class="headerlink" title="channel + select 实现"></a>channel + select 实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- stop:</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 结束了&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 运行中&quot;</span>)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行5秒后停止</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	stop &lt;- <span class="literal">true</span></span><br><span class="line">	<span class="comment">// 停止检测goroutine是否已经结束</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 结束了</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用channel + select的优点：比较优雅。<br>使用channel + select的缺点：如果有多个goroutine需要关闭怎么办？可以使用全局bool类型变量的方法，但是在为全局变量赋值的时候需要用到锁来保证协程安全，这样势必会对便利性和性能造成影响。更有甚者，如果每个goroutine中又嵌套了goroutine呢？</p>
<h3 id="context-实现"><a href="#context-实现" class="headerlink" title="context 实现"></a>context 实现</h3><p>将以上的代码使用context重写：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 开启goroutine，传入ctx</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 结束了&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				fmt.Println(<span class="string">&quot;任务1 运行中&quot;</span>)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 运行五秒以后停止</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">// 停止检测goroutine是否已经结束</span></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 运行中</span></span><br><span class="line"><span class="comment">// 任务1 结束了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p>使用context重写比较简单，当然上述只是启动一个goroutine的情况，如果有多个goroutine呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用context控制多个goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;退出, 停止了&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot;运行中&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;任务1&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;任务2&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx, <span class="string">&quot;任务3&quot;</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 通知任务停止</span></span><br><span class="line">	cancel()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;确定任务全部停止&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务3 运行中</span></span><br><span class="line"><span class="comment">//任务1 运行中</span></span><br><span class="line"><span class="comment">//任务2 运行中</span></span><br><span class="line"><span class="comment">//任务2 运行中</span></span><br><span class="line"><span class="comment">//任务3 运行中</span></span><br><span class="line"><span class="comment">//任务1 运行中</span></span><br><span class="line"><span class="comment">//任务1 运行中</span></span><br><span class="line"><span class="comment">//任务2 运行中</span></span><br><span class="line"><span class="comment">//任务3 运行中</span></span><br><span class="line"><span class="comment">//任务2 退出, 停止了</span></span><br><span class="line"><span class="comment">//任务1 退出, 停止了</span></span><br><span class="line"><span class="comment">//任务3 退出, 停止了</span></span><br><span class="line"><span class="comment">//确定任务全部停止</span></span><br></pre></td></tr></table></figure>



<p>上述Context就像一个控制器一样，按下开关后，所有基于这个 Context 或者衍生的子 Context 都会收到通知，这时就可以进行清理操作了，最终释放 goroutine，这就优雅的解决了 goroutine 启动后不可控的问题。</p>
<h2 id="优雅的关闭多个goroutine嵌套"><a href="#优雅的关闭多个goroutine嵌套" class="headerlink" title="优雅的关闭多个goroutine嵌套"></a>优雅的关闭多个goroutine嵌套</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个包含context的新类型</span></span><br><span class="line"><span class="keyword">type</span> otherContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; get msg to cancel&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; is running&quot;</span>)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">workWithValue</span><span class="params">(ctx context.Context, name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; get msg to cancel&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			value := ctx.Value(<span class="string">&quot;key&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">			fmt.Println(name, <span class="string">&quot; is running value = &quot;</span>, value)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用context.Background()构建一个WithCancel类型的上下文</span></span><br><span class="line">	ctxa, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// work模拟运行并检测前端的退出通知</span></span><br><span class="line">	<span class="keyword">go</span> work(ctxa, <span class="string">&quot;work1&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用WithDeadline包装前面的上下文对象ctxa</span></span><br><span class="line">	tm := time.Now().Add(<span class="number">3</span> * time.Second)</span><br><span class="line">	ctxb, _ := context.WithDeadline(ctxa, tm)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> work(ctxb, <span class="string">&quot;work2&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用WithValue包装前面的上下文对象ctxb</span></span><br><span class="line">	oc := otherContext&#123;ctxb&#125;</span><br><span class="line">	ctxc := context.WithValue(oc, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;andes, pass from main&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> workWithValue(ctxc, <span class="string">&quot;work3&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 故意 &quot;sleep&quot; 10秒, 让work2、work3超时退出</span></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示调用work1的cancel方法通知其退出</span></span><br><span class="line">	cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待work1打印退出信息</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> *time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;main stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//work3  is running value =  andes, pass from main</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work2  is running</span></span><br><span class="line"><span class="comment">//work2  is running</span></span><br><span class="line"><span class="comment">//work3  is running value =  andes, pass from main</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work3  is running value =  andes, pass from main</span></span><br><span class="line"><span class="comment">//work2  is running</span></span><br><span class="line"><span class="comment">//work3  get msg to cancel</span></span><br><span class="line"><span class="comment">//work2  get msg to cancel</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  is running</span></span><br><span class="line"><span class="comment">//work1  get msg to cancel</span></span><br><span class="line"><span class="comment">//main stop</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在使用Context的过程中，程序在底层实际上维护了两条关系链。</p>
<ol>
<li><p>children key构成从根到叶子Context实例的引用关系，在调用With函数时，会调用propagateCancel(parent Context, child canceler) 函数进行维护，程序有一层这样的树状结构：</p>
 <figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">ctxa</span>.children --&gt;</span> ctxb</span><br><span class="line"><span class="function"><span class="title">ctxb</span>.children --&gt;</span> ctxc</span><br></pre></td></tr></table></figure>
<p> 这棵树提供一种从根节点开始遍历树的方法，context包的取消广播通知就是基于这棵树实现的，取消通知沿着这条链从根节点向下层节点逐层广播。当然也可以在任意一个子树上调用取消通知，一样会扩散到整棵树。</p>
</li>
<li><p>在构造 context 的对象中不断地包裹 context 实例形成一个引用关系链，这个关系链的方向是相反的，是自底向上的。</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">ctxc<span class="selector-class">.Context</span> --&gt; oc</span><br><span class="line">ctxc<span class="selector-class">.Context</span><span class="selector-class">.Context</span> --&gt; ctxb</span><br><span class="line">ctxc<span class="selector-class">.Context</span><span class="selector-class">.Context</span><span class="selector-class">.cancelCtx</span> --&gt; ctxa</span><br><span class="line">ctxc<span class="selector-class">.Context</span><span class="selector-class">.Context</span><span class="selector-class">.Context</span><span class="selector-class">.cancelCtx</span><span class="selector-class">.Context</span> -&gt; <span class="built_in">new</span>(emptyCtx) <span class="comment">// context.Background()</span></span><br></pre></td></tr></table></figure>
<p> 这个关系链主要用于切断当前Context实例和上层的Context实例之间的关系。，比如 ctxb调用了退出通知或定时器到期了， ctxb 后续就没有必要在通知广播树上继续存在，它需要找到自己的 parent ，然后执行 delete(parent.children,ctxb）， 把自己从广播树上清理掉。</p>
</li>
</ol>
<h2 id="net-x2F-http包中的context"><a href="#net-x2F-http包中的context" class="headerlink" title="net&#x2F;http包中的context"></a>net&#x2F;http包中的context</h2><p>net&#x2F;http包源码在实现http server时就用到了context, 下面简单分析一下:</p>
<p>1.首先Server在开启服务时会创建一个valueCtx,存储了server的相关信息，之后每建立一条连接就会开启一个协程，并携带此valueCtx。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span></span> Serve(l net.Listener) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tempDelay time.Duration     <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line">    baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">    ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        rw, e := l.Accept()</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        tempDelay = <span class="number">0</span></span><br><span class="line">        c := srv.newConn(rw)</span><br><span class="line">        c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">        <span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>2.建立连接之后会基于传入的context创建一个valueCtx用于存储本地地址信息，之后在此基础上又创建了一个cancelCtx，然后开始从当前连接中读取网络请求，每当读取到一个请求则会将该cancelCtx传入，用以传递取消信号。一旦连接断开，即可发送取消信号，取消所有进行中的网络请求。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> serve(ctx context.Context) &#123;</span><br><span class="line">    c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    c.cancelCtx = cancelCtx</span><br><span class="line">    <span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        w, err := c.readRequest(ctx)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>3.读取到请求之后，会再次基于传入的context创建新的cancelCtx,并设置到当前请求对象req上，同时生成的response对象中cancelCtx保存了当前context取消方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span></span> readRequest(ctx context.Context) (w *response, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    req, err := readRequest(c.bufr, keepHostHeader)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">    req.ctx = ctx</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    w = &amp;response&#123;</span><br><span class="line">        conn:          c,</span><br><span class="line">        cancelCtx:     cancelCtx,</span><br><span class="line">        req:           req,</span><br><span class="line">        reqBody:       req.Body,</span><br><span class="line">        handlerHeader: <span class="built_in">make</span>(Header),</span><br><span class="line">        contentLength: <span class="number">-1</span>,</span><br><span class="line">        closeNotifyCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We populate these ahead of time so we&#x27;re not</span></span><br><span class="line">        <span class="comment">// reading from req.Header after their Handler starts</span></span><br><span class="line">        <span class="comment">// and maybe mutates it (Issue 14940)</span></span><br><span class="line">        wants10KeepAlive: req.wantsHttp10KeepAlive(),</span><br><span class="line">        wantsClose:       req.wantsClose(),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> w, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>这样处理的目的主要有以下几点：</p>
<ul>
<li>一旦请求超时，即可中断当前请求；</li>
<li>在处理构建response过程中如果发生错误，可直接调用response对象的cancelCtx方法结束当前请求；</li>
<li>在处理构建response完成之后，调用response对象的cancelCtx方法结束当前请求。</li>
</ul>
<p>在整个server处理流程中，使用了一条context链贯穿Server、Connection、Request，不仅将上游的信息共享给下游任务，同时实现了上游可发送取消信号取消所有下游任务，而下游任务自行取消不会影响上游任务。</p>
<h2 id="关于Context传递数据"><a href="#关于Context传递数据" class="headerlink" title="关于Context传递数据"></a>关于Context传递数据</h2><p>首先要清楚使用 context 包主要是解决 goroutine 的通知退出，传递数据是其一个额外功能。<br>可以使用它传递一些元信息 ，总之使用 context 传递的信息不能影响正常的业务流程，程序不要期待在 context 中传递某些必需的参数等，没有这些参数，程序也应该能正常工作。</p>
<p><strong>context应该传递什么数据</strong></p>
<p>1.日志信息。<br>2.调试信息。<br>3.不影响业务主逻辑的可选数据。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1.context主要用于父子任务之间的同步取消信号，本质上是一种协程调度的方式。另外在使用context时有两点值得注意：上游任务仅仅使用context通知下游任务不再需要，但不会直接干涉和中断下游任务的执行，由下游任务自行决定后续的处理操作，也就是说context的取消操作是无侵入的；context是线程安全的，因为context本身是不可变的（immutable），因此可以放心地在多个协程中传递使用。</p>
<p>2.context 包提供的核心的功能是多 goroutine 之间的退出通知机制，传递数据只是个辅助功能，应谨慎使用 context 传递数据。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 内存对齐</title>
    <url>/2022/09/07/Go/Golang%20%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>为保证程序顺利高效的运行，编译器会把各种类型的数据安排到合适的地址，并占用合适的长度，这就是内存对齐。</p>
<p>每种类型的对齐值就是它的对齐边界，内存对齐要求数据存储地址以及占用的字节数都要是它的对齐边界的倍数。所以下述的int32要错开两个字节，从4开始存，却不能紧接着从2开始。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27d1a924c9da4fa2ab962d6a4e694bb7~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>也可以这样解释：</p>
<p>CPU把内存当成是一块一块的，块的大小可以是2，4，8，16字节大小，因此CPU在读取内存时是一块一块进行读取的。块大小称为memory access granularity（粒度）。</p>
<p><strong>如果不进行内存对齐</strong></p>
<p>比如我们想从地址1开始读8字节的数据：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fe4356adac74364a97a0b2fedb0d78f~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>CPU会分两次读：</p>
<ul>
<li>第一次从 <code>0 - 7</code> 但只取后 <code>7</code> 字节。</li>
<li>第二次从 <code>8 - 15</code> 但只取第 <code>1</code> 字节。</li>
</ul>
<p>分两次读，这样势必会对性能造成影响。</p>
<h2 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h2><p>原因主要有两点：</p>
<ul>
<li><p>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</p>
</li>
<li><p>性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</p>
</li>
</ul>
<h2 id="对齐边界"><a href="#对齐边界" class="headerlink" title="对齐边界"></a>对齐边界</h2><p>那该怎么确定每种数据的对齐边界呢？这和平台有关，go语言支持这些平台：</p>
<p>可以看到常见的32位平台，指针宽度和寄存器宽度都是4字节，64位平台上都是8字节。而被go语言称为寄存器宽度的这个值，就可以理解为机器字长，也是平台对应的最大对齐边界。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7caa71ce7394481fa0859b0d00a90b73~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>而数据类型的对齐边界，是取类型大小与平台最大对齐边界中较小的那个。不过要注意，同一个类型在不同平台上，大小可能不同，对齐边界也可能不同。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/107eaa190d58414aa8a8ed46708b7ee8~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>为什么不统一使用平台最大对齐边界呢？或者统一按各类型大小来对齐呢？</p>
<p>我们来试一下，假设目前是64位平台，最大对齐边界为8字节。int8只有1字节，按照1字节对齐的话，它可以放在任何位置，因为总能通过一次读取把它完整拿出来。如果统一对齐到8字节，虽然同样只要读取一次，但每个int8的变量都要浪费7字节，所以对齐到1。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c11caf6e224409906fe1ab65341061~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>int16占2字节，按照2字节对齐，可以从这些地址开始存，而且能保证只用读取一次。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823563ae13c748c6aebdeea433c6e3c1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果按1字节对齐就可能存成这样，那就要读取两次再截取拼接，会影响性能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d66d5c8b42344e8aa0ebadb3d15f5f41~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果按8字节对齐，会与int8一样浪费内存，所以对齐到2。</p>
<p>这是小于最大对齐边界的情况，再来看看大于的情况。</p>
<p>假设要在32位的平台下存储一个int64类型的数据，在0和1位置被占用的情况下，就要从位置8开始存。而如果对齐到4，就可以从位置4开始，内存浪费更少，所以选择对齐到4。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b97bd152f5eb486ea29d388e02285f8f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>因此类型对齐边界会这样选择，依然是为了减少浪费提升性能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a95f00887fa2432e9c57dd48c2eabf74~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="GO-计算对齐边界函数"><a href="#GO-计算对齐边界函数" class="headerlink" title="GO 计算对齐边界函数"></a>GO 计算对齐边界函数</h3><p>在go语言中可以调用 <code>unsafe.Alignof</code> 来返回相应类型的对齐边界：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;bool align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">bool</span>(<span class="literal">true</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;int32 align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">int32</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;int8 align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">int8</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;int64 align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">int64</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;byte align: %d\n&quot;</span>, unsafe.Alignof(<span class="type">byte</span>(<span class="number">0</span>)))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;string align: %d\n&quot;</span>, unsafe.Alignof(<span class="string">&quot;EDDYCJY&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;map align: %d\n&quot;</span>, unsafe.Alignof(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> align: <span class="number">1</span></span><br><span class="line"><span class="type">int32</span> align: <span class="number">4</span></span><br><span class="line"><span class="type">int8</span> align: <span class="number">1</span></span><br><span class="line"><span class="type">int64</span> align: <span class="number">8</span></span><br><span class="line"><span class="type">byte</span> align: <span class="number">1</span></span><br><span class="line"><span class="type">string</span> align: <span class="number">8</span></span><br><span class="line"><span class="keyword">map</span> align: <span class="number">8</span></span><br></pre></td></tr></table></figure>



<h2 id="确定结构体的对齐边界"><a href="#确定结构体的对齐边界" class="headerlink" title="确定结构体的对齐边界"></a>确定结构体的对齐边界</h2><p>对结构体而言，首先要确定每个成员的对齐边界，然后取其中最大的，这就是这个结构体的对齐边界。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3989cfb7a55f453cb811c8537a9f7877~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后来存储这个结构体变量：</p>
<p><strong>内存对齐要求一：</strong></p>
<ul>
<li><p><strong>存储这个结构体的起始地址，是对齐边界的倍数。</strong></p>
<pre><code>  假设从0开始存，结构体的每个成员在存储时，都要把这个起始地址当作地址0，然后再用相对地址来决定自己该放在哪里。
</code></pre>
</li>
</ul>
<p><strong>内存对齐要求2：</strong></p>
<ul>
<li><p><strong>结构体整体占用字节数需要是类型对齐边界的倍数，不够的话要往后扩张一下。</strong></p>
<pre><code>  所以最终上述结构体类型的大小就是24字节。
</code></pre>
</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 下面的数字是大小，不是对其边界</span></span><br><span class="line">	a <span class="type">bool</span>  <span class="comment">// 1</span></span><br><span class="line">	b <span class="type">int32</span> <span class="comment">// 4</span></span><br><span class="line">	c <span class="type">int8</span>  <span class="comment">// 1</span></span><br><span class="line">	d <span class="type">int64</span> <span class="comment">// 8</span></span><br><span class="line">	e <span class="type">byte</span>  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Part2 <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="type">bool</span>	<span class="comment">// 1</span></span><br><span class="line">	c <span class="type">int8</span>	<span class="comment">// 1</span></span><br><span class="line">	e <span class="type">byte</span>	<span class="comment">// 1</span></span><br><span class="line">	b <span class="type">int32</span>	<span class="comment">// 4</span></span><br><span class="line">	d <span class="type">int64</span>	<span class="comment">// 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别求以上两个结构体占用的字节：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;part1 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part1), unsafe.Alignof(part1))</span><br><span class="line">fmt.Printf(<span class="string">&quot;part2 size: %d, align: %d\n&quot;</span>, unsafe.Sizeof(part2), unsafe.Alignof(part2))</span><br></pre></td></tr></table></figure>

<p>这里我们直接调用函数求得：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">part1 size: <span class="number">24</span>, align: <span class="number">4</span></span><br><span class="line">part2 size: <span class="number">16</span>, align: <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 函数调用栈</title>
    <url>/2022/09/07/Go/Golang%20%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<p>如果在一个函数中调用另一个函数，编译器就会对应生成一条call指令，程序执行到这条指令时，就会跳转到被调用函数入口处开始执行，而每个函数的最后都有一条ret指令，负责在函数结束后跳回到调用处，继续执行。</p>
<h2 id="函数栈帧"><a href="#函数栈帧" class="headerlink" title="函数栈帧"></a>函数栈帧</h2><p>函数执行时需要有足够的内存空间，供它存放局部变量、参数等数据，这段空间对应到虚拟地址空间的<strong>栈</strong>。<br><strong>运行时栈，上面是高地址，向下增长</strong>，栈底通常被称为<strong>栈基</strong>，栈顶被称为<strong>栈指针</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48e94d6ad9124a839a3f426cb8ce4b06~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>分配给函数的栈空间被称为<strong>函数栈帧</strong>。<br>Go语言中函数栈帧布局是这样的，先是调用者栈基地址，然后是函数的局部变量，最后是被调用函数的返回值和参数。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cff3cdf4d02b473ca16061f5c708f18e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p><strong>BP of callee</strong>和<strong>SP of callee</strong>标识被调用函数执行时，栈基寄存器和栈指针寄存器指向的位置，但是注意“BP of caller”不一定会存在，有些情况下可能会被优化掉，也有可能是平台不支持。我们只关注局部变量和参数、返回值的相对位置就好。</p>
<p>下面举一个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a1, a2, r1, r2 <span class="type">int64</span></span><br><span class="line">    a1, a2 = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    r1, r2 = B(a1, a2)</span><br><span class="line">    r1 = C(a1)</span><br><span class="line">    <span class="built_in">println</span>(r1, r2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(p1, p2 <span class="type">int64</span>)</span></span> (<span class="type">int64</span>, <span class="type">int64</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> p2, p1</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span><span class="params">(p1 <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>函数A的栈帧布局如下图所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/16faf75eb4da48f39faccbb0cfb925cf~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>注意观察参数的顺序，先入栈第二个参数，再入栈第一个参数，返回值也是一样的，上面是第二个返回值的空间，然后才是第一个返回值的空间。<br>因为这些是被调用函数的返回值和参数，被调用函数是通过栈指针加上偏移值这样相对寻址的方式来定位到自己的参数和返回值的，这样由下至上正好先找到第一个参数，再找到第二个参数。所以参数和返回值采用由右至左的入栈顺序比较合适。<br>通常，我们认为返回值是通过寄存器传递的，但是Go语言支持多返回值，所以在栈上分配返回值空间更合适。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7ca3d67c4bd4dd6a3112cb636ff06de~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>对函数B的调用会被编译器编译为call指令。实际上call指令只做两件事情：</p>
<ul>
<li>将下一条指令的地址入栈，被调用函数执行结束后会跳回到这个地址继续执行，这就是函数调用的“返回地址”。</li>
<li>跳转到被调用的函数B指令入口处执行，所以在“返回地址”下面就是函数B的栈帧了。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67a50afccbfb44d79c6814ab2bac27eb~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>所有函数的栈帧布局都遵循统一的约定，函数B结束后它的栈帧被释放，回到函数A中继续执行。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5543c1b59d4affa37692d9b723d903~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>到了调用函数C的时候，它只有一个参数和一个返回值，它们会占用函数A栈帧中最下面的一部分空间，所以上面会空出来一块，这是为了在被调用函数中可以用标准的相对地址定位到自己的参数和返回值，而无需顾虑其它。</p>
<p>同样的，call指令会压入返回地址，并跳转到函数C的指令入口处，所以下面就是函数C的栈帧了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c87508517934a96a99de20de7678a15~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>Go语言中，函数栈帧是一次性分配的，也就是在函数开始执行的时候分配足够大的栈帧空间。就像上例中函数A一样，它要调用两个函数，除了调用者栈基地址、局部变量以外，再有四个int64的空间用作被调用函数的参数与返回值就足够了。<br>一次性分配函数栈帧的主要原因是避免栈访问越界，如下图所示，三个goroutine初始分配的栈空间是一样的，如果g2剩余的栈空间不够执行接下来的函数，若函数栈帧是逐步扩张的，那么执行期间就可能发生栈访问越界。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1dbb5c85066b4a2184527c4a3acb20f2~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>其实，对于栈消耗较大的函数，go语言的编译器还会在函数头部插入检测代码，如果发现需要进行“栈增长”，就会另外分配一段足够大的栈空间，并把原来栈上的数据拷过来，原来的这段栈空间就被释放了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40b5900b53ce42b28bd6bbfd148fb99b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="函数跳转与返回"><a href="#函数跳转与返回" class="headerlink" title="函数跳转与返回"></a>函数跳转与返回</h2><p>程序执行时 CPU用特定寄存器来存储运行时栈基与栈指针，同时也有指令指针寄存器用于存储下一条要执行的指令地址。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea9a4eb2076a4604af5e2155a7d2d847~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>如果接下来要执行”push 3”这条指令，CPU读取后，会将指令指针移向下一条指令，然后栈指针向下移动，数字3入栈。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/325745465f424c0181d538e31f226b36~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>继续执行下一条指令，再次移动栈指针入栈数字4。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a50baad027e40588bf19eca01321378~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>前面我们提过Go语言中函数栈帧不是这样逐步扩张的，而是一次性分配，也就是在分配栈帧时，直接将栈指针移动到所需最大栈空间的位置。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad767d182fbf4e428546c5ffd1d54cd1~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后通过栈指针加上偏移值这种相对寻址方式使用函数栈帧。例如sp加16字节处存储3，加8字节处存储4，诸如此类。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58549eccc8dd4badbeeee657be772803~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>接下来我们来看看call指令和ret指令，是怎样实现函数跳转与返回的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a,b := <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">    B(a,b)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(c,d <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">println</span>(c,d)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用函数B之前函数A栈帧如下图所示，注意函数A和函数B的指令分布在代码段，而且函数A调用函数B的call指令在地址a1处，函数B入口地址在b1处。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48f7a55d795049fe8c10496bf320291f~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>然后到call指令这里，它的作用有两点：</p>
<ul>
<li>第一，把返回地址a2入栈保存起来；</li>
<li>第二，跳转到指令地址b1处。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f32fbe284f18467c82898f0305c2b6ee~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>call指令结束。函数B开始执行，我们先看它最开始的三条指令：</p>
<ul>
<li>第一条指令，把SP向下移动24字节（从s6挪到s9），为自己分配足够大的栈帧；</li>
<li>第二条指令，要把调用者栈基s1存到SP+16字节的地方(s7那里)；</li>
<li>第三条指令，把s7（SP+16）存入BP寄存器。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a89bff5c734c4db4ab2b1897115831~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>接下来就是执行函数B剩下的指令了，没有局部变量，只有被调用者的参数空间。在最后的ret指令之前，编译器还会插入两条指令：</p>
<ul>
<li>第1条指令：恢复调用者A的栈基地址，它之前被存储在SP+16字节（s7）这里，所以BP恢复到s1；</li>
<li>第2条指令：释放自己的栈帧空间，分配时向下移动多少（从s6到s9）释放时就向上移动多少(从s9到s6)。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be4e351b0bcd495aa13a7b1da003157c~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>现在可以从a2这里继续执行了。简单来说，函数通过call指令实现跳转，而每个函数开始时会分配栈帧，结束前又释放自己的栈帧，ret指令又会把栈恢复到call之前的样子，通过这些指令的配合最终实现了函数跳转与返回。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 匿名函数的活用</title>
    <url>/2022/09/07/Go/Golang%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E6%B4%BB%E7%94%A8/</url>
    <content><![CDATA[<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FuncType <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Calc 计算函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Calc</span><span class="params">(a, b <span class="type">int</span>, fTest FuncType)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">	result = fTest(a, b)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x, y := <span class="number">2</span>, <span class="number">2</span></span><br><span class="line">	<span class="comment">// Add</span></span><br><span class="line">	<span class="comment">// 回调函数是匿名函数</span></span><br><span class="line">	addResult := Calc(x, y, <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 回调函数是匿名函数</span></span><br><span class="line">	subResult := Calc(x, y, <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b</span><br><span class="line">	&#125;)</span><br><span class="line">	fmt.Println(<span class="string">&quot;addResult: &quot;</span>, addResult)</span><br><span class="line">	fmt.Println(<span class="string">&quot;subResult: &quot;</span>, subResult)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">addResult:  <span class="number">4</span></span><br><span class="line">subResult:  <span class="number">0</span></span><br></pre></td></tr></table></figure>




<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>我们使用一个特殊的情况来举例子，顺便巩固一下并发的知识。</p>
<p>请看以下代码，是golang并发中的闭包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	runtime.GOMAXPROCS(runtime.NumCPU())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>



<p>造成这一输出结果的原因是启动一个goroutine的时间慢于主goroutine中循环的执行时间。<br>这个时候你可能会想到使用循环延时的办法，但是一旦这样做，就失去了并发优势。</p>
<p>所以一般采用以下两个方法：</p>
<ol>
<li><p>将循环变量作为参数传递给匿名函数，原因在于传参的速度几乎是瞬时的，且在启动goroutine前执行。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用同名变量保留当前循环变量的状态</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">     	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		i := i</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			fmt.Println(i)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="其它用法"><a href="#其它用法" class="headerlink" title="其它用法"></a>其它用法</h2><p><strong>定义时调用匿名函数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>将匿名函数复制给变量</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> sayHi <span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>带有return的匿名函数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	greet := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(greet())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>遍历对象数组时做一些回调操作</strong></p>
<p>在学习godis的时候，其中有一个数据引擎接口：<code>EmbedDB</code>。里面有一个遍历当前数据库所有内容的函数：<code>forEach</code>，该函数的形参列表中有一个匿名函数，可以在函数调用的时候，做一些回调操作，我觉得很巧妙。于是就有了下面的例子，该例子没有任何意义，仅仅是展现匿名函数的该种用法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> function <span class="keyword">interface</span> &#123;</span><br><span class="line">	forEach(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 数组结构体实现了接口</span></span><br><span class="line"><span class="keyword">type</span> Array <span class="keyword">struct</span> &#123;</span><br><span class="line">	array []<span class="type">int</span></span><br><span class="line">	length <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Array)</span></span> forEach(callBack <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; a.length; i++ &#123;</span><br><span class="line">		callBack(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Array)</span></span> Add(value <span class="type">int</span>) &#123;</span><br><span class="line">	a.array = <span class="built_in">append</span>(a.array, value)</span><br><span class="line">	a.length++</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewArray</span><span class="params">()</span></span> Array &#123;</span><br><span class="line">	<span class="keyword">return</span> Array&#123;</span><br><span class="line">		<span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		<span class="number">0</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	arr := NewArray()</span><br><span class="line">	arr.Add(<span class="number">1</span>)</span><br><span class="line">	arr.Add(<span class="number">2</span>)</span><br><span class="line">	arr.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将每个元素++</span></span><br><span class="line">	arr.forEach(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		arr.array[i]++</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 打印每个元素</span></span><br><span class="line">	arr.forEach(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(arr.array[i])</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 协程和IO多路复用</title>
    <url>/2022/09/07/Go/Golang%20%E5%8D%8F%E7%A8%8B%E5%92%8CIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="IO阻塞问题"><a href="#IO阻塞问题" class="headerlink" title="IO阻塞问题"></a>IO阻塞问题</h2><p>我们知道。通过操作系统记录的进程控制信息，可以找到<code>打开文件描述符表</code>。其中，打开的文件、创建的socket等等，都会记录到这张表里面。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3ce0518cf1745289992c8fde353f01b~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>socket的所有操作都由操作系统来提供，也就是要通过系统调用来完成。每创建一个socket，就会在打开文件描述符表中对应增加一条记录，而返回给应用程序的只有一个socket描述符，用于识别不同的socket。而且每个<code>TCP socket</code>在创建时，操作系统都会为它分配一个<code>读缓冲区</code>和一个<code>写缓冲区</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bc1b59bdab14e099f72b876bb1f6049~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>要获得响应数据，就要从读缓冲区拷贝过来。同样的要通过socket发送数据，也要先把数据拷贝到写缓冲区才行。所以，问题出现了：<br>用户程序想要读数据的时候，读缓冲区里未必有数据，想发送数据的时候，写缓冲区里也未必有空间。那怎么办？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c966e6ba71a34612b48d1b4a454e207d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="阻塞式IO"><a href="#阻塞式IO" class="headerlink" title="阻塞式IO"></a>阻塞式IO</h2><p>第一种办法是<code>阻塞式IO</code>，即乖乖的让出CPU，进到等待队列里。等socket就绪后，再次获得时间片就可以继续执行了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53d619cbad3c41bc94c358872a0c8f15~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>使用阻塞式IO，要处理一个socket就要占用一个线程。等这个socket处理完成才能接手下一个，这在高并发场景下会加剧调度开销。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4beecceab0184192a83943ba35d5502d~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="非阻塞式IO"><a href="#非阻塞式IO" class="headerlink" title="非阻塞式IO"></a>非阻塞式IO</h2><p>第二种方法是：<code>非阻塞式IO</code>，也就是不让出CPU。但是需要频繁的检查socket是否就绪了，这是一种<code>忙等待</code>的方式，很难把握轮询的间隔时间，容易造成空耗CPU，加剧响应延时。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4056c9c379d74ef8ad7337f8f2f15f97~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>第三种办法就是<code>IO多路复用</code>，由操作系统提供支持，把需要等待的socket加入到监听集合，这样就可以通过一次系统调用，同时监听多个socket。<br>有socket就绪了，就可以逐个处理了。既不用为等待某个socket而阻塞，也不会陷入<code>忙等待</code>之中。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b1d550ba4e8416f93080052ab7a2356~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>Linux提供了三种IO多路复用实现方式，分别是<code>select</code>、<code>poll</code> 和 <code>epoll</code>。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>第一种是<code>select</code>。<br>我们可以设置要等待的描述符，也可以设置等待超时时间。如果有准备好的fd，或达到指定超时时间，select函数就会返回。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/533ad9ae072a4666a7d6399b48e59ff6~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>从函数签名来看，它支持监听可读、可写、异常三类事件。<br>因为这个fd_set是个unsigned long型的数组。共16个元素，每一位对应一个fd，最多可以监听1024个，这就有点少了。<br>而且<code>每次调用select都要传递所有的监听集合</code>。这就需要频繁的从用户态到内核拷贝数据。除此之外，<code>即便有fd就绪了，也需要遍历整个监听集合，来判断哪个fd是可操作的</code>。这些都会影响性能。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf80c969c7af4edfbb3dff9339a5e1ce~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>第二种IO多路复用的实现方式是<code>poll</code>。<br>虽然支持的fd数目，等于最多可以打开的文件描述符个数。但是另外两个问题依然存在。</p>
<h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>而<code>epoll</code>就没有这些问题了，它提供三个接口。</p>
<ul>
<li><code>epoll_create1</code>用于创建<code>一个epoll</code>，并获取一个句柄。</li>
<li><code>epoll_ctl</code>用于添加或删除fd与对应的事件信息。</li>
<li>除了指定fd和要监听的事件类型，还可以传入一个<code>event data</code>，通常会按需定义一个数据结构，用于处理对应的fd。可以看到，每次都只需传入要操作对的一个fd，无需传入所有监听集合，而且只需要注册这一次。通过<code>epoll_wait</code>得到的fd集合都是以及就绪的，逐个处理即可，无需遍历所有监听集合。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7fd52533ca44c5e991ebc2b6b88359e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>通过IO多路复用，线程再也不用为等待某一个socket，而阻塞或空耗CPU。并发处理能力因而大幅提升。</p>
<h2 id="IO多路复用结合协程"><a href="#IO多路复用结合协程" class="headerlink" title="IO多路复用结合协程"></a>IO多路复用结合协程</h2><p>但是IO多路复用也并非没有问题，例如：一个socket可读了，但是这回只读到了半条请求，也就是说需要再次等待这个socket可读。在继续处理下一个socket之前，需要记录下这个socket的处理状态。下一次这个socket可读时，也需要恢复上次保存的现场，才好继续处理。<br>也就是说，在IO多路复用中实现业务逻辑时，我们需要随着事件的等待和就绪，而频繁的保存和恢复现场，这并不符合常规的开发习惯。如果业务逻辑比较简单还好，若是比较复杂的业务场景，就有些悲剧了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f703ad9bcbca47c9acfcc186fa919305~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>既然业务处理过程中，要等待事件时，需要保存现场并切换到下一个就绪的fd。而事件就绪时，又需要恢复现场继续处理。那岂不是很适合使用协程？</p>
<p>在IO多路复用这里，事件循环依然存在，依然要在循环中逐个处理就绪的fd，但处理过程却不是围绕具体业务，而是面向协程调度。<br>如果是用于监听端口的fd就绪了，就建立连接创建一个新的fd，交给一个协程来负责, 协程执行入口就指向业务处理函数入口，业务处理过程中，需要等待时就注册IO事件，然后让出，这样，执行权就会回到切换到该协程的地方继续执行。如果是其它等待IO事件的fd就绪了，只需要恢复关联的协程即可。</p>
<p>协程拥有自己的栈，要保存和恢复现场都很容易实现。这样，IO多路复用这一层的事件循环，就和具体业务逻辑解耦了。</p>
<p>可以把read、write、connect等可能会发生等待的函数包装一下，在其中实现IO事件注册与主动让出。这样在业务逻辑层面，就可以使用这些包装函数，按照常规的顺序编程方式，来实现业务逻辑了。</p>
<p>这些包装函数在需要等待时，就会注册IO事件，然后让出协程，这样我们在实现业务逻辑时，就完全不用担心保存与恢复现场的问题了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8922d77244c240f8867b153f58266c32~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>协程和IO多路复用之间的合作，不仅保留了IO多路复用的高并发性能，还解放了业务逻辑的实现。</p>
<p>协程与IO多路复用结合的项目：</p>
<p><a href="https://github.com/fengyoulin/ef">https://github.com/fengyoulin/ef</a></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 协程是什么</title>
    <url>/2022/09/07/Go/Golang%20%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>我们都知道，线程是进程中的执行体，拥有一个执行路口，以及从进程虚拟地址空间中分配的栈。包括用户栈和内核栈。<br>操作系统会记录线程控制信息，而线程获得CPU时间片以后才可以执行。CPU的栈指针、指令指针等寄存器，都要切换到对应的线程。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1708581ed9fe47a6a711a1b0b37e99db~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>如果线程自己又创建几个<code>执行体</code>，给他们各自指定执行入口，申请一些内存给它们用做执行栈，那么线程就可以按需调度这几个执行体了。为了实现这些执行体的切换，线程也需要记录它们的控制信息。包括<code>ID</code>、<code>栈的位置</code>、<code>执行入口地址</code>、<code>执行现场</code>等等。<br>线程可以选择一个执行体来执行，此时CPU中指令指针就会指向这个执行体的入口，栈基和栈指针寄存器也会指向线程给它分配的执行栈。</p>
<p><strong>切换执行体</strong></p>
<p>要切换执行体时，需要先保存当前执行体的<code>执行现场</code>，然后切换到另一个执行体。通过同样的方式，可以恢复到之前的执行体，这样就可以从上次中断的地方继续执行。<br>这些由线程创建的执行体就是所谓的<code>协程</code>。<br>因为用户程序不能操作内核空间，所以只能给协程分配用户栈，而操作系统对用户栈一无所知。所以<code>协程</code>又被称为<code>用户态线程</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09938523622a4861a14ced396cd066ca~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<h2 id="协程思想的关键"><a href="#协程思想的关键" class="headerlink" title="协程思想的关键"></a>协程思想的关键</h2><p>在创建协程时，都要指定执行入口，底层都会分配协程执行栈和控制信息，否则又该如何实现用户态调度？<br>而让出执行权时，也都要保存执行现场，不然如何能从中断处恢复执行？<br>所以协程思想的关键在于控制流的<code>主动让出</code>和<code>恢复</code>，每个协程拥有自己的执行栈，可以保存自己的执行现场。所以可以由用户程序，按需创建协程。</p>
<p><strong>协程的主动让出和恢复执行</strong></p>
<p>协程<code>主动让出</code>执行权时，会保存执行现场，然后切换到其它协程。<br>协程<code>恢复执行</code>时，会根据之前保存的执行现场，恢复到中断前的状态，继续执行。<br>这样，就通过协程实现了既轻量又灵活的、由用户态进行调度的<code>多任务模型</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feec9cfcc9844f1daf1811809aa0be94~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>真正让协程大放异彩的是它在<code>IO多路复用</code>中的应用，二者的结合是一种炙手可热的高并发解决方案。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af8befc5b8a945ddba8cba82b2b24bca~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 扇入扇出以及通知退出机制</title>
    <url>/2022/09/07/Go/Golang%20%E6%89%87%E5%85%A5%E6%89%87%E5%87%BA%E4%BB%A5%E5%8F%8A%E9%80%9A%E7%9F%A5%E9%80%80%E5%87%BA%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="扇入和扇出"><a href="#扇入和扇出" class="headerlink" title="扇入和扇出"></a>扇入和扇出</h2><p>编程中经常遇到“扇入和扇出”两个概念，所谓的扇入是指将多路通道聚合到一条通道中处理，Go语言最简单的扇入就是使用select聚合多条通道服务;所谓的扇出是指将一条通道发散到多条通道中处理。在Go语言里面实现就是使用go关键字启动多个goroutine并发处理。</p>
<p>中国有句经典的哲学名句叫“分久必合，合久必分”，软件的设计和开发也遵循同样的哲学思想，扇入就是合，扇出就是分。当生产者的速度很慢时，需要使用扇入技术聚合多个生产者满足消费者，比如很耗时的加密&#x2F;解密服务;当消费者的速度很慢时，需要使用扇出技术，比如Web服务器并发请求处理。扇入和扇出是Go并发编程中常用的技术。</p>
<h2 id="通知退出机制"><a href="#通知退出机制" class="headerlink" title="通知退出机制"></a>通知退出机制</h2><p>读取已经关闭的通道不会引起阻塞，也不会导致panic，而是立即返回该通道存储类型的零值。关闭select监听的某个通道能使select立即感知这种通知，然后进行相应的处理，这就是所谓的退出通知机制(close channel to broadcast)。</p>
<p>其中context标准库就是利用这种机制处理更复杂的通知机制的。</p>
<h2 id="golang实现生成器"><a href="#golang实现生成器" class="headerlink" title="golang实现生成器"></a>golang实现生成器</h2><p>在应用系统编程中，生成器一般用于生成全局事务号、订单号、序列号和随机数等等。</p>
<p>Go 对这种场景的支持非常简单，其中运用了扇入、扇出以及通知退出的思想。</p>
<h3 id="最简单的带缓冲的生成器"><a href="#最简单的带缓冲的生成器" class="headerlink" title="最简单的带缓冲的生成器"></a>最简单的带缓冲的生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="comment">// 启动一个goroutine用于生成随机数，函数返回一个通道用于获取随机数</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := GenerateIntA()</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5577006791947779410</span></span><br><span class="line"><span class="comment">//8674665223082153551</span></span><br></pre></td></tr></table></figure>



<h3 id="扇入技术实现增强型生成器"><a href="#扇入技术实现增强型生成器" class="headerlink" title="扇入技术实现增强型生成器"></a>扇入技术实现增强型生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 使用select的扇入技术(Fan in)增加生成的随机源</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntA():</span><br><span class="line">				<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntB():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := GenerateInt()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="退出通知机制实现自动退出的生成器"><a href="#退出通知机制实现自动退出的生成器" class="headerlink" title="退出通知机制实现自动退出的生成器"></a>退出通知机制实现自动退出的生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Lable:</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// 通过select监听一个信号chan来确定是否停止生成</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">					<span class="keyword">case</span> &lt;- done:</span><br><span class="line">						<span class="keyword">break</span> Lable</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ch := GenerateIntA(done)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line">	fmt.Println(&lt;-ch)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不再需要生成器，通过close chan发送一个通知给生成器</span></span><br><span class="line">	<span class="built_in">close</span>(done)</span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="一个融合了并发、缓冲、退出通知等多重特性的生成器"><a href="#一个融合了并发、缓冲、退出通知等多重特性的生成器" class="headerlink" title="一个融合了并发、缓冲、退出通知等多重特性的生成器"></a>一个融合了并发、缓冲、退出通知等多重特性的生成器</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateIntA done接收通知退出信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Lable:</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">					<span class="keyword">case</span> &lt;- done:</span><br><span class="line">						<span class="keyword">break</span> Lable</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateIntB done接收通知信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">			<span class="keyword">case</span> &lt;- done:</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateInt 通过select 执行扇入操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	send := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		Lable:</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntA(send):</span><br><span class="line">					<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntB(send):</span><br><span class="line">					<span class="keyword">case</span> &lt;- done:</span><br><span class="line">						send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">						send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">						<span class="keyword">break</span> Lable</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个作为退出信号的chan</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动生成器</span></span><br><span class="line">	ch := GenerateInt(done)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取生成器资源</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 通知生产者停止生产</span></span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;stop produce&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 协程调度器原理及GMP设计思想</title>
    <url>/2022/09/07/Go/Golang%20%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h2 id="一、golang”调度器”的由来"><a href="#一、golang”调度器”的由来" class="headerlink" title="一、golang”调度器”的由来"></a>一、golang”调度器”的由来</h2><h3 id="（1）单进程时代不需要调度器"><a href="#（1）单进程时代不需要调度器" class="headerlink" title="（1）单进程时代不需要调度器"></a>（1）单进程时代不需要调度器</h3><p>我们知道，一切的软件都是跑在操作系统上，真正用来干活(计算)的是CPU。早期的操作系统每个程序就是一个进程，知道一个程序运行完，才能进行下一个进程，就是“单进程时代”。</p>
<p>一切的程序只能串行发生。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08e3c609ab684b5f8bfaa68aaf3e98db~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>早期的单进程操作系统，面临2个问题：</p>
<ol>
<li><p>单一的执行流程，计算机只能一个任务一个任务处理。</p>
</li>
<li><p>进程阻塞所带来的CPU时间浪费。</p>
</li>
</ol>
<p>那么能不能有多个进程来宏观一起来执行多个任务呢？</p>
<p>后来操作系统就具有了<strong>最早的并发能力：多进程并发</strong>，当一个进程阻塞的时候，切换到另外等待执行的进程，这样就能尽量把CPU利用起来，CPU就不浪费了。</p>
<h3 id="2-多进程-x2F-线程时代有了调度器需求"><a href="#2-多进程-x2F-线程时代有了调度器需求" class="headerlink" title="(2)多进程&#x2F;线程时代有了调度器需求"></a>(2)多进程&#x2F;线程时代有了调度器需求</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0e02d5390c24ddd88e9453b970c8429~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>在多进程&#x2F;多线程的操作系统中，就解决了阻塞的问题，因为一个进程阻塞cpu可以立刻切换到其他进程中去执行，而且调度cpu的算法可以保证在运行的进程都可以被分配到cpu的运行时间片。这样从宏观来看，似乎多个进程是在同时被运行。</p>
<p>但新的问题就又出现了，进程拥有太多的资源，进程的创建、切换、销毁，都会占用很长的时间，CPU虽然利用起来了，但如果进程过多，CPU有很大的一部分都被用来进行进程调度了。</p>
<p><strong>怎么才能提高CPU的利用率呢？</strong> </p>
<p>但是对于Linux操作系统来讲，cpu对进程的态度和线程的态度是一样的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/191d1e831a2847d6afa2401034644624~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>很明显，CPU调度切换的是进程和线程。尽管线程看起来很美好，但实际上多线程开发设计会变得更加复杂，要考虑很多同步竞争等问题，如锁、竞争冲突等。</p>
<h3 id="3-协程来提高CPU利用率"><a href="#3-协程来提高CPU利用率" class="headerlink" title="(3)协程来提高CPU利用率"></a>(3)协程来提高CPU利用率</h3><p>多进程、多线程已经提高了系统的并发能力，但是在当今互联网高并发场景下，为每个任务都创建一个线程是不现实的，因为会消耗大量的内存(进程虚拟内存会占用<code>4GB[32位操作系统]</code>, 而线程也要大约<code>4MB</code>)。</p>
<p>大量的进程&#x2F;线程出现了新的问题:</p>
<ul>
<li>高内存占用</li>
<li>调度的高消耗CPU</li>
</ul>
<p>好了，然后工程师们就发现，其实一个线程分为<code>内核态</code>线程和<code>用户态</code>线程。</p>
<p>一个“用户态线程”必须要绑定一个“内核态线程”，但是CPU并不知道有“用户态线程”的存在，它只知道它运行的是一个“内核态线程”(Linux的PCB进程控制块)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc955e928704416db3de1b8e193fb34c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这样，我们再去细化去分类一下，内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52f7fa611b0e4d1982027c0d8588382b~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>看到这里，我们就要开脑洞了，既然一个协程(co-routine)可以绑定一个线程(thread)，那么能不能多个协程(co-routine)绑定一个或者多个线程(thread)上呢。</p>
<p>之后，我们就看到了有3种协程和线程的映射关系：</p>
<p><strong>N:1 关系</strong></p>
<p>N个协程绑定1个线程</p>
<p>优点：</p>
<p>就是<strong>协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速</strong>。但也有很大的缺点，1个进程的所有协程都绑定在1个线程上。</p>
<p>缺点：</p>
<ul>
<li>某个程序用不了硬件的多核加速能力</li>
<li>一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63da7f70ab484a2b96bdaad382d8895f~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>1:1 关系</strong></p>
<p>1个协程绑定1个线程，这种最容易实现。协程的调度都由CPU完成了，不存在N:1缺点。</p>
<p>缺点：</p>
<ul>
<li>协程的创建、删除和切换的代价都由CPU完成，有点略显昂贵了。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebd5b08acef745bbbea9d960327d3346~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>M:N 关系</strong></p>
<p>M个协程绑定N个线程，是N:1和1:1类型的结合，克服了以上2种模型的缺点，但实现起来最为复杂。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2ce8e476275421aa829341f9d238790~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>协程跟线程是有区别的，线程由CPU调度是抢占式的，<strong>协程由用户态调度是协作式的</strong>，一个协程让出CPU后，才执行下一个协程。</p>
<h3 id="Go语言的协程goroutine"><a href="#Go语言的协程goroutine" class="headerlink" title="Go语言的协程goroutine"></a>Go语言的协程goroutine</h3><p><strong>Go为了提供更容易使用的并发方法，使用了goroutine和channel</strong>。goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被<code>runtime</code>调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。</p>
<p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，<code>runtime</code>会自动为goroutine分配。</p>
<p>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(runtime调度)</li>
</ul>
<h3 id="5-被废弃的goroutine调度器"><a href="#5-被废弃的goroutine调度器" class="headerlink" title="(5)被废弃的goroutine调度器"></a>(5)被废弃的goroutine调度器</h3><p>好了，既然我们知道了协程和线程的关系，那么最关键的一点就是调度协程的调度器的实现了。</p>
<p>Go目前使用的调度器是2012年重新设计的，因为之前的调度器性能存在问题，所以使用4年就被废弃了，那么我们先来分析一下被废弃的调度器是如何运作的？</p>
<blockquote>
<p>大部分文章都是会用G来表示Goroutine，用M来表示线程，那么我们也会用这种表达的对应关系。</p>
</blockquote>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c37fd7a106fb4c9d87fd1b4326ab79af~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>下面我们来看看被废弃的golang调度器是如何实现的？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81a250d4067e45319e997f7cd5e72ccc~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>老调度器有几个缺点：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了<strong>激烈的锁竞争</strong>。</li>
<li>M转移G会造成<strong>延迟和额外的系统负载</strong>。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了<strong>很差的局部性</strong>，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h2 id="二、Goroutine调度器的GMP模型的设计思想"><a href="#二、Goroutine调度器的GMP模型的设计思想" class="headerlink" title="二、Goroutine调度器的GMP模型的设计思想"></a>二、Goroutine调度器的GMP模型的设计思想</h2><p>面对之前调度器的问题，Go设计了新的调度器。</p>
<p>在新调度器中，出现M(thread)和G(goroutine)，又引进了P(Processor)。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77ff6748e1fd42939988f15c5ea82844~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>Processor，它包含了运行goroutine的资源</strong>，如果线程想运行goroutine，必须先获取P，P中还包含了可运行的G队列。</p>
<h3 id="1-GMP模型"><a href="#1-GMP模型" class="headerlink" title="(1)GMP模型"></a>(1)GMP模型</h3><p>在Go中，<strong>线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52e19b7368d846649db7b776feb31bfe~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<ol>
<li><strong>全局队列</strong>（Global Queue）：存放等待运行的G。</li>
<li><strong>P的本地队列</strong>：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建G’时，G’优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。</li>
<li><strong>P列表</strong>：所有的P都在程序启动时创建，并保存在数组中，最多有<code>GOMAXPROCS</code>(可配置)个。</li>
<li><strong>M</strong>：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列<strong>拿</strong>一批G放到P的本地队列，或从其他P的本地队列<strong>偷</strong>一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。</li>
</ol>
<p><strong>Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行</strong>。</p>
<p><strong>有关P和M的个数问题</strong></p>
<p>1、P的数量：</p>
<ul>
<li>由启动时环境变量<code>$GOMAXPROCS</code>或者是由<code>runtime</code>的方法<code>GOMAXPROCS()</code>决定。这意味着在程序执行的任意时刻都只有<code>$GOMAXPROCS</code>个goroutine在同时运行。</li>
</ul>
<p>2、M的数量:</p>
<ul>
<li>go语言本身的限制：go程序启动时，会设置M的最大数量，默认10000.但是内核很难支持这么多的线程数，所以这个限制可以忽略。</li>
<li>runtime&#x2F;debug中的SetMaxThreads函数，设置M的最大数量</li>
<li>一个M阻塞了，会创建新的M。</li>
</ul>
<p>M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量是1，也有可能会创建很多个M出来。</p>
<p><strong>P和M何时会被创建</strong></p>
<p>1、P何时创建：在确定了P的最大数量n后，运行时系统会根据这个数量创建n个P。</p>
<p>2、M何时创建：没有足够的M来关联P并运行其中的可运行的G。比如所有的M此时都阻塞住了，而P中还有很多就绪任务，就会去寻找空闲的M，而没有空闲的，就会去创建新的M。</p>
<h3 id="2-调度器的设计策略"><a href="#2-调度器的设计策略" class="headerlink" title="(2)调度器的设计策略"></a>(2)调度器的设计策略</h3><p><strong>复用线程</strong>：避免频繁的创建、销毁线程，而是对线程的复用。</p>
<p>1）work stealing机制</p>
<pre><code>    当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。
</code></pre>
<p>2）hand off机制</p>
<pre><code>    当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。
</code></pre>
<p><strong>利用并行</strong>：<code>GOMAXPROCS</code>设置P的数量，最多有<code>GOMAXPROCS</code>个线程分布在多个CPU上同时运行。<code>GOMAXPROCS</code>也限制了并发的程度，比如<code>GOMAXPROCS = 核数/2</code>，则最多利用了一半的CPU核进行并行。</p>
<p><strong>抢占</strong>：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死，这就是goroutine不同于coroutine的一个地方。</p>
<p><strong>全局G队列</strong>：在新的调度器中依然有全局G队列，但功能已经被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。</p>
<h3 id="3-go-func-调度流程"><a href="#3-go-func-调度流程" class="headerlink" title="(3) go func()  调度流程"></a>(3) go func()  调度流程</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6020e7a9c7414062816345993c6a669c~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>从上图我们可以分析出几个结论：</p>
<pre><code>1、我们通过 go func()来创建一个goroutine；

2、有两个存储G的队列，一个是局部调度器P的本地队列、一个是全局G队列。新创建的G会先保存在P的本地队列中，如果P的本地队列已经满了就会保存在全局的队列中；

3、G只能运行在M中，一个M必须持有一个P，M与P是1：1的关系。M会从P的本地队列弹出一个可执行状态的G来执行，如果P的本地队列为空，就会想其他的MP组合偷取一个可执行的G来执行；

4、一个M调度G执行的过程是一个循环机制；

5、当M执行某一个G时候如果发生了syscall或则其余阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除(detach)，然后再创建一个新的操作系统的线程(如果有空闲的线程可用就复用空闲线程)来服务于这个P；

6、当M系统调用结束时候，这个G会尝试获取一个空闲的P执行，并放入到这个P的本地队列。如果获取不到P，那么这个线程M变成休眠状态， 加入到空闲线程中，然后这个G会被放入全局队列中。
</code></pre>
<h3 id="4-调度器的生命周期"><a href="#4-调度器的生命周期" class="headerlink" title="(4)调度器的生命周期"></a>(4)调度器的生命周期</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ea163f1ab2404d609b60151f3b267d92~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>特殊的M0和G0。</p>
<p><strong>M0</strong></p>
<p><code>M0</code>是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，不需要在heap上分配，M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了。</p>
<p><strong>G0</strong></p>
<p><code>G0</code>是每次启动一个M都会第一个创建的gourtine，G0仅用于负责调度的G，G0不指向任何可执行的函数, 每个M都会有一个自己的G0。在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0。</p>
<p>我们来跟踪一段代码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们来针对上面的代码对调度器里面的结构做一个分析。</p>
<p>也会经历如上图所示的过程：</p>
<ol>
<li>runtime创建最初的线程m0和goroutine g0，并把2者关联。</li>
<li>调度器初始化：初始化m0、栈、垃圾回收，以及创建和初始化由GOMAXPROCS个P构成的P列表。</li>
<li>示例代码中的main函数是<code>main.main</code>，<code>runtime</code>中也有1个main函数——<code>runtime.main</code>，代码经过编译后，<code>runtime.main</code>会调用<code>main.main</code>，程序启动时会为<code>runtime.main</code>创建goroutine，称它为main goroutine吧，然后把main goroutine加入到P的本地队列。</li>
<li>启动m0，m0已经绑定了P，会从P的本地队列获取G，获取到main goroutine。</li>
<li>G拥有栈，M根据G中的栈信息和调度信息设置运行环境</li>
<li>M运行G</li>
<li>G退出，再次回到M获取可运行的G，这样重复下去，直到<code>main.main</code>退出，<code>runtime.main</code>执行Defer和Panic处理，或调用<code>runtime.exit</code>退出程序。</li>
</ol>
<p>调度器的生命周期几乎占满了一个Go程序的一生，<code>runtime.main</code>的goroutine执行之前都是为调度器做准备工作，<code>runtime.main</code>的goroutine运行，才是调度器的真正开始，直到<code>runtime.main</code>结束而结束。</p>
<h3 id="5-可视化GMP编程"><a href="#5-可视化GMP编程" class="headerlink" title="(5)可视化GMP编程"></a>(5)可视化GMP编程</h3><p>有2种方式可以查看一个程序的GMP的数据:<br><code>go tool trace </code> 和 <code>Debug trace</code>,这里只介绍第二种。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        fmt.Println(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build trace2.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>



<p>通过Debug方式运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GODEBUG=schedtrace=1000 ./trace2 </span><br><span class="line">SCHED 0ms: gomaxprocs=2 idleprocs=0 threads=4 spinningthreads=1 idlethreads=1 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 1003ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 2014ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 3015ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br><span class="line">SCHED 4023ms: gomaxprocs=2 idleprocs=2 threads=4 spinningthreads=0 idlethreads=2 runqueue=0 [0 0]</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>



<ul>
<li><code>SCHED</code>：调试信息输出标志字符串，代表本行是goroutine调度器的输出；</li>
<li><code>0ms</code>：即从程序启动到输出这行日志的时间；</li>
<li><code>gomaxprocs</code>: P的数量，本例有2个P, 因为默认的P的属性是和cpu核心数量默认一致，当然也可以通过GOMAXPROCS来设置；</li>
<li><code>idleprocs</code>: 处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行go代码的P的数量；</li>
<li>t<code>hreads: os threads/M</code>的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量；</li>
<li><code>spinningthreads</code>: 处于自旋状态的os thread数量；</li>
<li><code>idlethread</code>: 处于idle状态的os thread的数量；</li>
<li><code>runqueue=0</code>： Scheduler全局队列中G的数量；</li>
<li><code>[0 0]</code>: 分别为2个P的local queue中的G的数量。</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 标准库之strconv</title>
    <url>/2022/09/07/Go/Golang%20%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8Bstrconv/</url>
    <content><![CDATA[<p>strconv包实现了基本数据类型与其字符串表示的转换。</p>
<h2 id="string与int转换"><a href="#string与int转换" class="headerlink" title="string与int转换"></a>string与int转换</h2><h3 id="Atoi"><a href="#Atoi" class="headerlink" title="Atoi()"></a>Atoi()</h3><p><code>Atoi()</code>函数用于将字符串类型的整数转换为int类型，函数签名如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (i <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<p>如果传入的字符串参数无法转换为int类型，就会返回错误。</p>
<h3 id="Itoa"><a href="#Itoa" class="headerlink" title="Itoa()"></a>Itoa()</h3><p><code>Itoa()</code>函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h2 id="Parse系列函数"><a href="#Parse系列函数" class="headerlink" title="Parse系列函数"></a>Parse系列函数</h2><p>Parse类函数用于转换字符串为给定类型的值。</p>
<h3 id="ParseBool"><a href="#ParseBool" class="headerlink" title="ParseBool()"></a>ParseBool()</h3><p>返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (value <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h3 id="ParseInt"><a href="#ParseInt" class="headerlink" title="ParseInt()"></a>ParseInt()</h3><p>返回字符串表示的整数值，接受正负号。</p>
<p>base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制；</p>
<p>bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64；</p>
<p>返回的err是*NumErr类型的，如果语法有误，err.Error &#x3D; ErrSyntax；如果结果超出类型范围err.Error &#x3D; ErrRange。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h3 id="ParseUint"><a href="#ParseUint" class="headerlink" title="ParseUint"></a>ParseUint</h3><p>ParseUint类似ParseInt但不接受正负号，用于无符号整型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseUint</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (n <span class="type">uint64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>



<h3 id="ParseFloat"><a href="#ParseFloat" class="headerlink" title="ParseFloat()"></a>ParseFloat()</h3><p>解析一个表示浮点数的字符串并返回其值。<br>bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (f <span class="type">float64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>





<h2 id="Format系列函数"><a href="#Format系列函数" class="headerlink" title="Format系列函数"></a>Format系列函数</h2><p>Format系列函数实现了将给定类型数据格式化为string类型数据的功能。</p>
<h3 id="FormatBool"><a href="#FormatBool" class="headerlink" title="FormatBool()"></a>FormatBool()</h3><p>根据b的值返回”true”或”false”。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatBool</span><span class="params">(b <span class="type">bool</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h3 id="FormatInt"><a href="#FormatInt" class="headerlink" title="FormatInt()"></a>FormatInt()</h3><p>返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h3 id="FormatUint"><a href="#FormatUint" class="headerlink" title="FormatUint()"></a>FormatUint()</h3><p>是FormatInt的无符号整数版本。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatUint</span><span class="params">(i <span class="type">uint64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h3 id="FormatFloat"><a href="#FormatFloat" class="headerlink" title="FormatFloat()"></a>FormatFloat()</h3><p>函数将浮点数表示为字符串并返回。</p>
<p>bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。</p>
<p>fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。</p>
<p>prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>



<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="isPrint"><a href="#isPrint" class="headerlink" title="isPrint()"></a>isPrint()</h3><p>返回一个字符是否是可打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsPrint</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>


<h3 id="CanBackquote"><a href="#CanBackquote" class="headerlink" title="CanBackquote()"></a>CanBackquote()</h3><p>返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CanBackquote</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>



<p>除此之外还有Append系列、Quote系列等函数。可以移步至-&gt;</p>
<h3 id="Go语言中文文档"><a href="#Go语言中文文档" class="headerlink" title="Go语言中文文档"></a><a href="https://studygolang.com/pkgdoc">Go语言中文文档</a></h3>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 实现RPC的几种方式</title>
    <url>/2022/09/07/Go/Golang%20%E5%AE%9E%E7%8E%B0RPC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p><code>远程过程调用（Remote Procedure Call，缩写为 RPC）</code>是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。 如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用。</p>
<p>用通俗易懂的语言描述就是：RPC允许跨机器、跨语言调用计算机程序方法。打个比方，我用go语言写了个获取用户信息的方法getUserInfo，并把go程序部署在阿里云服务器上面，现在我有一个部署在腾讯云上面的php项目，需要调用golang的getUserInfo方法获取用户信息，php跨机器调用go方法的过程就是RPC调用。</p>
<h2 id="golang中使用RPC"><a href="#golang中使用RPC" class="headerlink" title="golang中使用RPC"></a>golang中使用RPC</h2><p>golang官方的<code>net/rpc</code>库使用encoding&#x2F;gob进行编解码，支持tcp或http数据传输方式，不支持跨语言调用。<br>官方还提供了<code>net/rpc/jsonrpc</code>库实现RPC，支持跨语言调用，但是不支持http。</p>
<p><strong>RPC格式的函数</strong></p>
<p>Go RPC的函数只有符合下面的条件才能被远程访问，不然会被忽略，详细的要求如下：</p>
<ul>
<li>函数必须是导出的(首字母大写)</li>
<li>必须有两个导出类型的参数</li>
<li>第一个参数是接收的参数，第二个参数是返回给客- 户端的参数，第二个参数必须是指针类型的</li>
<li>函数还要有一个返回值error</li>
</ul>
<p>比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> MethodName(argType T1, replyType *T2) <span class="type">error</span></span><br></pre></td></tr></table></figure>




<h2 id="net-x2F-rpc库"><a href="#net-x2F-rpc库" class="headerlink" title="net&#x2F;rpc库"></a>net&#x2F;rpc库</h2><p>下面的例子演示一下如何使用golang官方的net&#x2F;rpc库实现RPC方法，使用http作为RPC的载体，通过net&#x2F;http包监听客户端连接请求。</p>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arith 算数运算结构体</span></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 乘积</span></span><br><span class="line">	Pro <span class="type">int</span></span><br><span class="line">	<span class="comment">// 商</span></span><br><span class="line">	Quo <span class="type">int</span></span><br><span class="line">	<span class="comment">// 余数</span></span><br><span class="line">	Rem <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiply 乘法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Multiply(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	res.Pro = req.A * req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Divide 除法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Divide(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> req.B == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;divide by zero&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	res.Quo = req.A / req.B</span><br><span class="line">	res.Rem = req.A % req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注册rpc服务</span></span><br><span class="line">	rpc.Register(<span class="built_in">new</span>(Arith))</span><br><span class="line">	<span class="comment">// 采用http协议作为rpc载体</span></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 服务器创建监听端口</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8095&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;fatal error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start connection&quot;</span>)</span><br><span class="line">	<span class="comment">// 处理请求</span></span><br><span class="line">	http.Serve(listen, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 乘积</span></span><br><span class="line">	Pro <span class="type">int</span></span><br><span class="line">	<span class="comment">// 商</span></span><br><span class="line">	Quo <span class="type">int</span></span><br><span class="line">	<span class="comment">// 余数</span></span><br><span class="line">	Rem <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 请求服务器连接</span></span><br><span class="line">	conn, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8095&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;dailing error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req := ArithRequest&#123;<span class="number">9</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> res ArithResponse</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call函数远程调用服务器的函数</span></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Multiply&quot;</span>, req, &amp;res) <span class="comment">// 乘法运算</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, req.A, req.B, res.Pro)</span><br><span class="line"></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Divide&quot;</span>, req, &amp;res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d / %d, quo is %d, rem is %d\n&quot;</span>, req.A, req.B, res.Quo, res.Rem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="net-x2F-rpc-x2F-jsonrpc"><a href="#net-x2F-rpc-x2F-jsonrpc" class="headerlink" title="net&#x2F;rpc&#x2F;jsonrpc"></a>net&#x2F;rpc&#x2F;jsonrpc</h2><p>下面的例子我们演示一下使用<code>net/rpc/jsonrpc</code>库实现RPC方法，此方式实现的RPC方法支持跨语言调用。</p>
<p>server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arith 算数运算结构体</span></span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	Pro <span class="type">int</span> <span class="comment">// 乘积</span></span><br><span class="line">	Quo <span class="type">int</span> <span class="comment">// 商</span></span><br><span class="line">	Rem <span class="type">int</span> <span class="comment">// 余数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiply 乘法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Multiply(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	res.Pro = req.A * req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Divide 除法运算方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Arith)</span></span> Divide(req ArithRequest, res *ArithResponse) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> req.B == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;divide by zero&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	res.Quo = req.A / req.B</span><br><span class="line">	res.Rem = req.A % req.B</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rpc.Register(<span class="built_in">new</span>(Arith)) <span class="comment">// 注册rpc服务</span></span><br><span class="line"></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8096&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;fatal error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;start connection&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := lis.Accept() <span class="comment">// 接收客户端连接请求</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(conn net.Conn)</span></span> &#123; <span class="comment">// 并发处理客户端请求</span></span><br><span class="line">			fmt.Println(<span class="string">&quot;new client in coming&quot;</span>)</span><br><span class="line">			jsonrpc.ServeConn(conn)</span><br><span class="line">		&#125;(conn)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>client.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithRequest 算数运算请求结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	A <span class="type">int</span></span><br><span class="line">	B <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArithResponse 算数运算响应结构体</span></span><br><span class="line"><span class="keyword">type</span> ArithResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">	Pro <span class="type">int</span> <span class="comment">// 乘积</span></span><br><span class="line">	Quo <span class="type">int</span> <span class="comment">// 商</span></span><br><span class="line">	Rem <span class="type">int</span> <span class="comment">// 余数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, err := jsonrpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:8096&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;dailing error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	req := ArithRequest&#123;<span class="number">9</span>, <span class="number">2</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> res ArithResponse</span><br><span class="line"></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Multiply&quot;</span>, req, &amp;res) <span class="comment">// 乘法运算</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d * %d = %d\n&quot;</span>, req.A, req.B, res.Pro)</span><br><span class="line"></span><br><span class="line">	err = conn.Call(<span class="string">&quot;Arith.Divide&quot;</span>, req, &amp;res)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalln(<span class="string">&quot;arith error: &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d / %d, quo is %d, rem is %d\n&quot;</span>, req.A, req.B, res.Quo, res.Rem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 标准库之反射</title>
    <url>/2022/09/07/Go/Golang%20%E6%A0%87%E5%87%86%E5%BA%93%E4%B9%8B%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="变量的内在机制"><a href="#变量的内在机制" class="headerlink" title="变量的内在机制"></a>变量的内在机制</h2><p>Go语言中的变量是分为两部分的:</p>
<ul>
<li>类型信息：预先定义好的元信息。</li>
<li>值信息：程序运行过程中可动态变化的。</li>
</ul>
<h2 id="反射介绍"><a href="#反射介绍" class="headerlink" title="反射介绍"></a>反射介绍</h2><p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时,程序无法获取自身的信息。</p>
<p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p>
<p>Go程序在运行期使用reflect包访问程序的反射信息。</p>
<p>我们都知道go语言中的<code>interface&#123;&#125;</code>可以储存任何类型的变量，那我们怎么知道这个空接口保存的数据是什么呢？而反射就是在运行时动态的获取一个变量的类型信息和值信息。</p>
<p><strong>反射和接口的关系：</strong></p>
<p>我们通过interface聚合、兼容了各种不同的插件，最终通过用户输入在main程序通过反射技术把不同的需求调度到各个功能插件本身。</p>
<p>可能有些拗口，下面来举一个例子：</p>
<p>下述代码是golang运行时多态的一个实现：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B 实现了A接口</span></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">	greet <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b B)</span></span> <span class="built_in">print</span>()  &#123;</span><br><span class="line">	fmt.Println(b.greet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C 实现了A接口</span></span><br><span class="line"><span class="keyword">type</span> C <span class="keyword">struct</span> &#123;</span><br><span class="line">	greet <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c C)</span></span> <span class="built_in">print</span> ()  &#123;</span><br><span class="line">	fmt.Println(c.greet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create 函数返回一个A接口类型的值</span></span><br><span class="line"><span class="comment">// 首先生成一个随机数num，num的值为0或1</span></span><br><span class="line"><span class="comment">// 如果num=0，返回B对象，如果num=1，返回C对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">()</span></span> (res A) &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	num := rand.Intn(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="number">0</span> == num &#123;</span><br><span class="line">		<span class="keyword">return</span> B&#123;greet: <span class="string">&quot;B: hello!&quot;</span>&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">1</span> == num &#123;</span><br><span class="line">		<span class="keyword">return</span> C&#123;greet: <span class="string">&quot;C: hello!&quot;</span>&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	A := Create()</span><br><span class="line">	A.<span class="built_in">print</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>运行时多态是一种很神奇的现象，main函数中的A对象会根据返回的实际类型调用不同的print函数。这是因为接口变量是动态的值和动态的类型，得需要做<code>类型断言/反射确定当前变量A属于哪种具体的类型之后才能调用接口中定义的方法。</code></p>
<h2 id="reflect包"><a href="#reflect包" class="headerlink" title="reflect包"></a>reflect包</h2><p>reflect 包封装了反射相关的方法。其中，最核心的是这两个方法：</p>
<ul>
<li>获取类型信息：reflect.TypeOf，是静态的。</li>
<li>获取值信息：reflect.ValueOf，是动态的。</li>
</ul>
<h3 id="TypeOf"><a href="#TypeOf" class="headerlink" title="TypeOf"></a>TypeOf</h3><p>在Go语言中，使用<code>reflect.TypeOf()</code>函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	v  := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%v\n\n&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">	reflectType(a)</span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	reflectType(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>:<span class="type">float32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>:<span class="type">int64</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="type-name、type-kind"><a href="#type-name、type-kind" class="headerlink" title="type name、type kind"></a>type name、type kind</h4><p>在反射中关于类型还划分为两种：<code>类型（Type）</code>和<code>种类（Kind）</code>。因为在Go语言中我们可以使用type关键字构造很多自定义类型，而<code>种类（Kind）</code>就是指底层的类型，但在反射中，当需要区分指针、结构体等大品种的类型时，就会用到<code>种类（Kind）</code>。 举个例子，我们定义了两个指针类型和两个结构体类型，通过反射查看它们的类型和种类。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> myInt <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a *<span class="type">float32</span> <span class="comment">// 指针</span></span><br><span class="line">	<span class="keyword">var</span> b myInt    <span class="comment">// 自定义类型</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="type">rune</span>     <span class="comment">// 类型别名</span></span><br><span class="line">	reflectType(a) <span class="comment">// type: kind:ptr</span></span><br><span class="line">	reflectType(b) <span class="comment">// type:myInt kind:int64</span></span><br><span class="line">	reflectType(c) <span class="comment">// type:int32 kind:int32</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">		name <span class="type">string</span></span><br><span class="line">		age  <span class="type">int</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">type</span> book <span class="keyword">struct</span>&#123; title <span class="type">string</span> &#125;</span><br><span class="line">	<span class="keyword">var</span> d = person&#123;</span><br><span class="line">		name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		age:  <span class="number">18</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> e = book&#123;title: <span class="string">&quot;《张三学法》&quot;</span>&#125;</span><br><span class="line">	reflectType(d) <span class="comment">// type:person kind:struct</span></span><br><span class="line">	reflectType(e) <span class="comment">// type:book kind:struct</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>: kind:ptr</span><br><span class="line"><span class="keyword">type</span>:myInt kind:<span class="type">int64</span></span><br><span class="line"><span class="keyword">type</span>:<span class="type">int32</span> kind:<span class="type">int32</span></span><br><span class="line"><span class="keyword">type</span>:person kind:<span class="keyword">struct</span></span><br><span class="line"><span class="keyword">type</span>:book kind:<span class="keyword">struct</span></span><br></pre></td></tr></table></figure>



<p>简单来说就是<code>变量.Name()</code>可以返回我们使用type定义的自定义类型和类型别名的底层类型。而<code>变量.Kind()</code>可以直接返回变量的底层类型。</p>
<p>Go语言的反射中像数组、切片、Map、指针等类型的变量，它们的.Name()都是返回空。</p>
<p>在<code>reflect</code>包中定义的Kind类型如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Kind <span class="type">uint</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Invalid Kind = <span class="literal">iota</span>  <span class="comment">// 非法类型</span></span><br><span class="line">    Bool                 <span class="comment">// 布尔型</span></span><br><span class="line">    Int                  <span class="comment">// 有符号整型</span></span><br><span class="line">    Int8                 <span class="comment">// 有符号8位整型</span></span><br><span class="line">    Int16                <span class="comment">// 有符号16位整型</span></span><br><span class="line">    Int32                <span class="comment">// 有符号32位整型</span></span><br><span class="line">    Int64                <span class="comment">// 有符号64位整型</span></span><br><span class="line">    Uint                 <span class="comment">// 无符号整型</span></span><br><span class="line">    Uint8                <span class="comment">// 无符号8位整型</span></span><br><span class="line">    Uint16               <span class="comment">// 无符号16位整型</span></span><br><span class="line">    Uint32               <span class="comment">// 无符号32位整型</span></span><br><span class="line">    Uint64               <span class="comment">// 无符号64位整型</span></span><br><span class="line">    Uintptr              <span class="comment">// 指针</span></span><br><span class="line">    Float32              <span class="comment">// 单精度浮点数</span></span><br><span class="line">    Float64              <span class="comment">// 双精度浮点数</span></span><br><span class="line">    Complex64            <span class="comment">// 64位复数类型</span></span><br><span class="line">    Complex128           <span class="comment">// 128位复数类型</span></span><br><span class="line">    Array                <span class="comment">// 数组</span></span><br><span class="line">    Chan                 <span class="comment">// 通道</span></span><br><span class="line">    Func                 <span class="comment">// 函数</span></span><br><span class="line">    Interface            <span class="comment">// 接口</span></span><br><span class="line">    Map                  <span class="comment">// 映射</span></span><br><span class="line">    Ptr                  <span class="comment">// 指针</span></span><br><span class="line">    Slice                <span class="comment">// 切片</span></span><br><span class="line">    String               <span class="comment">// 字符串</span></span><br><span class="line">    Struct               <span class="comment">// 结构体</span></span><br><span class="line">    UnsafePointer        <span class="comment">// 底层指针</span></span><br></pre></td></tr></table></figure>



<h3 id="ValueOf"><a href="#ValueOf" class="headerlink" title="ValueOf"></a>ValueOf</h3><p><code>reflect.ValueOf()</code>返回的是<code>reflect.Value</code>类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</p>
<p>reflect.Value类型提供的获取原始值的方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Interface() interface {}</td>
<td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>
<tr>
<td>Int() int64</td>
<td>将值以 int 类型返回，所有有符号整型均可以以此方式返回</td>
</tr>
<tr>
<td>Uint() uint64</td>
<td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Float() float64</td>
<td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>
<tr>
<td>Bool() bool</td>
<td>将值以字节数组 []bytes 类型返回</td>
</tr>
<tr>
<td>String() string</td>
<td>将值以字符串类型返回</td>
</tr>
</tbody></table>
<h4 id="通过反射获取值"><a href="#通过反射获取值" class="headerlink" title="通过反射获取值"></a>通过反射获取值</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectValue</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	k := v.Kind()</span><br><span class="line">	<span class="keyword">switch</span> k &#123;</span><br><span class="line">	<span class="keyword">case</span> reflect.Int64:</span><br><span class="line">		<span class="comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is int64, value is %d\n&quot;</span>, <span class="type">int64</span>(v.Int()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float32:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float32, value is %f\n&quot;</span>, <span class="type">float32</span>(v.Float()))</span><br><span class="line">	<span class="keyword">case</span> reflect.Float64:</span><br><span class="line">		<span class="comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;type is float64, value is %f\n&quot;</span>, <span class="type">float64</span>(v.Float()))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">3.14</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	reflectValue(a) <span class="comment">// type is float32, value is 3.140000</span></span><br><span class="line">	reflectValue(b) <span class="comment">// type is int64, value is 100</span></span><br><span class="line">	<span class="comment">// 将int类型的原始值转换为reflect.Value类型</span></span><br><span class="line">	c := reflect.ValueOf(<span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;type c :%T\n&quot;</span>, c) <span class="comment">// type c :reflect.Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> is <span class="type">float32</span>, value is <span class="number">3.140000</span></span><br><span class="line"><span class="keyword">type</span> is <span class="type">int64</span>, value is <span class="number">100</span></span><br><span class="line"><span class="keyword">type</span> c :reflect.Value</span><br></pre></td></tr></table></figure>



<h4 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h4><p>想要在函数中通过反射修改变量的值，需要注意函数参数传递的是值拷贝，必须传递变量地址才能修改变量值。而反射中使用专有的<code>Elem()</code>方法来获取指针对应的值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue1</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="keyword">if</span> v.Kind() == reflect.Int64 &#123;</span><br><span class="line">		v.SetInt(<span class="number">200</span>) <span class="comment">//修改的是副本，reflect包会引发panic</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectSetValue2</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">	<span class="comment">// 反射中使用 Elem()方法获取指针对应的值</span></span><br><span class="line">	<span class="keyword">if</span> v.Elem().Kind() == reflect.Int64 &#123;</span><br><span class="line">		v.Elem().SetInt(<span class="number">200</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="type">int64</span> = <span class="number">100</span></span><br><span class="line">	<span class="comment">// reflectSetValue1(a) //panic: reflect: reflect.Value.SetInt using unaddressable value</span></span><br><span class="line">	reflectSetValue2(&amp;a)</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>



<h4 id="isNil-、isValid"><a href="#isNil-、isValid" class="headerlink" title="isNil() 、isValid"></a>isNil() 、isValid</h4><p><strong>isNil()</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsNil() <span class="type">bool</span></span><br></pre></td></tr></table></figure>




<p><code>IsNil()</code>报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p>
<p><strong>isValid()</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span></span> IsValid() <span class="type">bool</span></span><br></pre></td></tr></table></figure>



<p><code>IsValid()</code>返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。</p>
<p>举个例子：</p>
<p><code>IsNil()</code>常被用于判断指针是否为空；<code>IsValid()</code>常被用于判定返回值是否有效。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// *int类型空指针</span></span><br><span class="line">	<span class="keyword">var</span> a *<span class="type">int</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())</span><br><span class="line">	<span class="comment">// nil值</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="literal">nil</span>).IsValid())</span><br><span class="line">	<span class="comment">// 实例化一个匿名结构体</span></span><br><span class="line">	b := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="comment">// 尝试从结构体中查找&quot;abc&quot;字段</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line">	<span class="comment">// 尝试从结构体中查找&quot;abc&quot;方法</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="string">&quot;abc&quot;</span>).IsValid())</span><br><span class="line">	<span class="comment">// map</span></span><br><span class="line">	c := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 尝试从map中查找一个不存在的键</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="string">&quot;z张三&quot;</span>)).IsValid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span> IsNil: <span class="literal">true</span></span><br><span class="line"><span class="literal">nil</span> IsValid: <span class="literal">false</span></span><br><span class="line">不存在的结构体成员: <span class="literal">false</span></span><br><span class="line">不存在的结构体方法: <span class="literal">false</span></span><br><span class="line"><span class="keyword">map</span>中不存在的键： <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h3 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h3><h4 id="与结构体相关的方法"><a href="#与结构体相关的方法" class="headerlink" title="与结构体相关的方法"></a>与结构体相关的方法</h4><p>任意值通过<code>reflect.TypeOf()</code>获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象<code>（reflect.Type）</code>的<code>NumField()</code>和<code>Field()</code>方法获得结构体成员的详细信息。</p>
<p><code>reflect.Type</code>中与获取结构体成员相关的的方法如下表所示:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field(i int) StructField</td>
<td>根据索引，返回索引对应的结构体字段的信息。</td>
</tr>
<tr>
<td>NumField() int</td>
<td>返回结构体成员字段数量。</td>
</tr>
<tr>
<td>FieldByName(name string) (StructField, bool)</td>
<td>根据给定字符串返回字符串对应的结构体字段的信息。</td>
</tr>
<tr>
<td>FieldByIndex(index []int) StructField</td>
<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。</td>
</tr>
<tr>
<td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td>
<td>根据传入的匹配函数匹配需要的字段。</td>
</tr>
<tr>
<td>NumMethod() int</td>
<td>返回该类型的方法集中方法的数目</td>
</tr>
<tr>
<td>Method(int) Method</td>
<td>返回该类型方法集中的第i个方法</td>
</tr>
<tr>
<td>MethodByName(string)(Method, bool)</td>
<td>根据方法名返回该类型方法集中的方法</td>
</tr>
</tbody></table>
<h4 id="StructField类型"><a href="#StructField类型" class="headerlink" title="StructField类型"></a>StructField类型</h4><p><code>StructField</code>类型用来描述结构体中的一个字段的信息。<br><code>StructField</code>的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> StructField <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span></span><br><span class="line">    <span class="comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span></span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    PkgPath <span class="type">string</span></span><br><span class="line">    Type      Type      <span class="comment">// 字段的类型</span></span><br><span class="line">    Tag       StructTag <span class="comment">// 字段的标签</span></span><br><span class="line">    Offset    <span class="type">uintptr</span>   <span class="comment">// 字段在结构体中的字节偏移量</span></span><br><span class="line">    Index     []<span class="type">int</span>     <span class="comment">// 用于Type.FieldByIndex时的索引切片</span></span><br><span class="line">    Anonymous <span class="type">bool</span>      <span class="comment">// 是否匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="结构体反射示例"><a href="#结构体反射示例" class="headerlink" title="结构体反射示例"></a>结构体反射示例</h4><p>当我们使用反射得到一个结构体数据之后可以通过索引依次获取其字段信息，也可以通过字段名去获取指定的字段信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Score <span class="type">int</span>    <span class="string">`json:&quot;score&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stu1 := student&#123;</span><br><span class="line">		Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Score: <span class="number">90</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	t := reflect.TypeOf(stu1)</span><br><span class="line">	fmt.Println(t.Name(), t.Kind()) <span class="comment">// student struct</span></span><br><span class="line">	<span class="comment">// 通过for循环遍历结构体的所有字段信息</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		field := t.Field(i)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通过字段名获取指定结构体字段信息</span></span><br><span class="line">	<span class="keyword">if</span> scoreField, ok := t.FieldByName(<span class="string">&quot;Score&quot;</span>); ok &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="string">&quot;json&quot;</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">student <span class="keyword">struct</span></span><br><span class="line">name:Name index:[<span class="number">0</span>] <span class="keyword">type</span>:<span class="type">string</span> json tag:name</span><br><span class="line">name:Score index:[<span class="number">1</span>] <span class="keyword">type</span>:<span class="type">int</span> json tag:score</span><br><span class="line">name:Score index:[<span class="number">1</span>] <span class="keyword">type</span>:<span class="type">int</span> json tag:score</span><br></pre></td></tr></table></figure>



<p>接下来编写一个函数printMethod(s interface{})来遍历打印s包含的方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给student添加两个方法 Study和Sleep(注意首字母大写)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Study() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好学习，天天向上。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s student)</span></span> Sleep() <span class="type">string</span> &#123;</span><br><span class="line">	msg := <span class="string">&quot;好好睡觉，快快长大。&quot;</span></span><br><span class="line">	fmt.Println(msg)</span><br><span class="line">	<span class="keyword">return</span> msg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMethod</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	t := reflect.TypeOf(x)</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line"></span><br><span class="line">	fmt.Println(t.NumMethod())</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; v.NumMethod(); i++ &#123;</span><br><span class="line">		methodType := v.Method(i).Type()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;method:%s\n&quot;</span>, methodType)</span><br><span class="line">		<span class="comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span></span><br><span class="line">		<span class="keyword">var</span> args = []reflect.Value&#123;&#125;</span><br><span class="line">		v.Method(i).Call(args)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="反射是把双刃剑"><a href="#反射是把双刃剑" class="headerlink" title="反射是把双刃剑"></a>反射是把双刃剑</h2><p>反射是一个强大并富有表现力的工具，能让我们写出更灵活的代码。但是反射不应该被滥用，原因有以下三个。</p>
<ol>
<li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li>
<li>大量使用反射的代码通常难以理解。</li>
<li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li>
</ol>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 类型系统</title>
    <url>/2022/09/07/Go/Golang%20%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><p>如果我们自定义一个结构体类型T，并给它关联一个方法F1。我们知道变量t的内存布局只包含一个字符串变量，那它和F1之间怎样建立关联？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t T)</span></span> F1() &#123;</span><br><span class="line">    fmt.Println(t.name)</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    t := T&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">    t.F1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>由于编译阶段，编译器知道每种类型定义了哪些方法，之前我们也介绍过，方法本质上就是函数，只不过在调用时，接收者会作为第一个参数传入。所以通过变量t来调用方法F1时，编译器自然知道要调用哪个函数。</p>
<p><img src="https://img-blog.csdnimg.cn/2fc4c30edf324af48429a9e3b309494f.png" alt="在这里插入图片描述"></p>
<p>但是到了执行阶段，为了支持反射、接口动态派发、类型断言这些语言特性或机制，编译器会给每种类型生成对应的类型描述信息写入可执行文件，这些类型描述信息就是“类型元数据”。</p>
<p>在Go语言里，int、float、string、slice、map、interface等属于内置类型（built-in），而我们自己通过下面这三种方式定义的类型，都属于自定义类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T1 <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    F1()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 给内置类型定义方法是不被允许的，而接口类型是无效的方法接收者，所以我们只能给上面第一、第二种形式的自定义类型定义方法。</p>
<p>数据类型虽然很多，但是不管是内置类型还是自定义类型，它的“类型元数据”都是全局唯一的。这些类型元数据共同构成了Go语言的类型系统。</p>
<p><img src="https://img-blog.csdnimg.cn/c57ff44f523248acbac3abdb28983b3f.png" alt="在这里插入图片描述"></p>
<p>下面就把类型元数据展开，看看里面究竟是什么结构，有什么内容。</p>
<h2 id="内置类型元数据"><a href="#内置类型元数据" class="headerlink" title="内置类型元数据"></a>内置类型元数据</h2><p>像类型名称，大小，对齐边界，是否为自定义类型等信息，是每个类型元数据都要记录的。所以被放到了runtime._type结构体中，作为每个类型元数据的Header。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size       <span class="type">uintptr</span></span><br><span class="line">    ptrdata    <span class="type">uintptr</span></span><br><span class="line">    hash       <span class="type">uint32</span></span><br><span class="line">    tflag      tflag</span><br><span class="line">    align      <span class="type">uint8</span></span><br><span class="line">    fieldalign <span class="type">uint8</span></span><br><span class="line">    kind       <span class="type">uint8</span></span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    gcdata     *<span class="type">byte</span></span><br><span class="line">    str        nameOff</span><br><span class="line">    ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在_type之后存储的是各类型额外需要描述的信息，例如slice的类型元数据在_type结构体后面，记录着一个*_type，指向其存储的元素的类型元数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    elem  *_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 如果是存储string的slice类型，这个指针就指向string类型的元数据。</p>
<p><img src="https://img-blog.csdnimg.cn/63cf0a59ad5142b0bab1a1d46d4da516.png" alt="在这里插入图片描述"></p>
<p>再看看指针类型的元数据，它在_type后面也额外存储了一个*_type，指向指针类型指向的那个类型的元数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ptrtype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    elem  *_type</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/b071622330854350938679b3ea25ebe8.png" alt="在这里插入图片描述"></p>
<p>内置类型的元数据都是这样的结构，可以到runtime包下的type.go查看struct、map等类型的元数据信息。</p>
<h2 id="自定义类型元数据"><a href="#自定义类型元数据" class="headerlink" title="自定义类型元数据"></a>自定义类型元数据</h2><p>然而如果是自定义类型，这后面还会有一个uncommontype结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> uncommontype <span class="keyword">struct</span> &#123;</span><br><span class="line">    pkgpath nameOff</span><br><span class="line">    mcount  <span class="type">uint16</span> </span><br><span class="line">    _       <span class="type">uint16</span> <span class="comment">// unused</span></span><br><span class="line">    moff    <span class="type">uint32</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>pkgpath 记录类型所在的包路径；</li>
<li>mcount 记录了该类型关联到多少个方法；</li>
<li>moff 记录的是这些方法的元数据组成的数组，相对于这个uncommontype结构体偏移了多少字节。方法元数据结构如下：</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> method <span class="keyword">struct</span> &#123;</span><br><span class="line">    name nameOff</span><br><span class="line">    mtyp typeOff</span><br><span class="line">    ifn  textOff</span><br><span class="line">    tfn  textOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例如，我们基于[]string定义一个新类型myslice，它就是一个自定义类型，可以给它定义两个方法Len和Cap。</p>
<p>myslice的类型元数据中，首先是slicetype类型描述信息，然后在后面加上uncommontype结构体。注意通过uncommontype这里记录的信息，我们就可以找到myslice的方法元数据列表了。</p>
<p><img src="https://img-blog.csdnimg.cn/36e2adf581de4eb79a052faa1388bd9a.png" alt="在这里插入图片描述"></p>
<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>现在我们可以利用类型元数据来描述下面这两种写法的不同了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyType1 = <span class="type">int32</span></span><br><span class="line"><span class="keyword">type</span> MyType2 <span class="type">int32</span></span><br></pre></td></tr></table></figure>



<p>MyType1这种写法，叫做给类型int32取别名，实际上MyType1和int32会关联到同一个类型元数据，属于同一种类型。rune和int32就是这样的关系。</p>
<p><img src="https://img-blog.csdnimg.cn/3f6b8e4cffd14a4e829f83fa873086c5.png" alt="在这里插入图片描述"></p>
<p>而MyType2这种写法，属于基于已有类型创建新类型，MyType2会自立门户，拥有自己的类型元数据，即使MyType2相对于int32来说没有做任何改变，它们两个对应的类型元数据也已经不同了。</p>
<p><img src="https://img-blog.csdnimg.cn/fa233136675b48e89edac65c2c4f8554.png" alt="在这里插入图片描述"></p>
<p>既然每种类型都有唯一对应的类型元数据，而类型定义的方法能通过类型元数据找到，那么，很多问题就变得好解释了，例如接下来的“接口”。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 自定义排序</title>
    <url>/2022/09/08/Go/Golang%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>C++中实现自定义排序，可以在sort函数的最后一个参数位上，加上一个<code>自定义的比大小函数</code>或者<code>仿函数</code>来实现：</p>
<p><strong>lambda表达式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v是vector&lt;int&gt;类型</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">     <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>仿函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SortInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a &gt; b;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">SortInt</span>());</span><br></pre></td></tr></table></figure>


<p>Go语言中通过sort包提供的接口和函数，也可以实现自定义排序.</p>
<h2 id="三种基本类型升序排序"><a href="#三种基本类型升序排序" class="headerlink" title="三种基本类型升序排序"></a>三种基本类型升序排序</h2><p>如果要排序的切片是<code>int64, float64, string</code>类型，且是升序排序，可以使用下面三个函数进行排序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sort.Ints(x []<span class="type">int</span>)</span><br><span class="line">sort.Float64s(x []<span class="type">float64</span>)</span><br><span class="line">sort.Strings(x []<span class="type">string</span>)</span><br></pre></td></tr></table></figure>


<h2 id="sort-Sort-data-Interface"><a href="#sort-Sort-data-Interface" class="headerlink" title="sort.Sort(data Interface)"></a>sort.Sort(data Interface)</h2><p>这个函数可以对自定义类型的切片进行排序，前提是这种自定义类型得实现<code>Interface</code>接口.</p>
<p><strong>Interface</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	Len() <span class="type">int</span></span><br><span class="line">	Less(i, j <span class="type">int</span>) <span class="type">bool</span></span><br><span class="line">	Swap(i, j <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>int类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> sortInt []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr sortInt)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr sortInt)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[i] &lt; arr[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(arr sortInt)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> _arr sortInt = arr</span><br><span class="line">	sort.Sort(_arr)</span><br><span class="line">	sort.Sort(sort.Reverse(_arr))  <span class="comment">// 逆序排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>struct类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Students []Student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Students)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Students)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i].score &lt; s[j].score</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Students)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> students Students</span><br><span class="line">	students = []Student&#123;</span><br><span class="line">		Student&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">89</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">98</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;wangwu&quot;</span>, <span class="number">78</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(students)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="sort-Slice-x-interface-less-func-i-j-int-bool"><a href="#sort-Slice-x-interface-less-func-i-j-int-bool" class="headerlink" title="sort.Slice(x interface{}, less func(i, j int) bool)"></a>sort.Slice(x interface{}, less func(i, j int) bool)</h2><p>这个函数可以对切片类型进行排序，还需要提供一个返回值为bool类型的函数对象.</p>
<p><strong>int类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">10</span>&#125;</span><br><span class="line">sort.Slice(arr, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[i] &gt; arr[j]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>struct类型举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">students := []Student&#123;</span><br><span class="line">		Student&#123;<span class="string">&quot;zhangsan&quot;</span>, <span class="number">89</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;lisi&quot;</span>, <span class="number">98</span>&#125;,</span><br><span class="line">		Student&#123;<span class="string">&quot;wangwu&quot;</span>, <span class="number">78</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(students, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> students[i].score &gt; students[j].score</span><br><span class="line">&#125;)</span><br><span class="line">fmt.Println(students)</span><br></pre></td></tr></table></figure>


<p>这样看来使用<code>sort.Slice</code>好像更加方便一些，之后发现更加高级的功能再追加.</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 类型断言</title>
    <url>/2022/09/07/Go/Golang%20%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<p>我们已经知道接口可以分为空接口与非空接口两类。相对于接口这种“抽象类型”，像int，slice，string，map，struct等类型被称为“具体类型”。<br>类型断言是Go语言中应用在接口值上的一个神奇特性，而类型断言的目标类型可以是某种具体类型，也可以是某种非空接口类型。这样我们就组合出四种类型断言，接下来就逐一看看它们究竟是如何断言的！</p>
<h2 id="空接口-具体类型"><a href="#空接口-具体类型" class="headerlink" title="空接口.(具体类型)"></a>空接口.(具体类型)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">r,ok := e.(*os.File)</span><br></pre></td></tr></table></figure>

<p>e.(<em>os.File)就是要判断e存储的_type是否指向</em>os.File的类型元数据。反正我们介绍过Go语言里每种类型的类型元数据都是全局唯一的。</p>
<p><img src="https://img-blog.csdnimg.cn/90e7ecea33f94225a93bc144381ab3f1.png" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f,_ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>如果e像上面这样赋值，e的动态类型就是*os.File，所以e.(*os.File)类型断言成功，ok为true，r为e的动态值。</p>
<p><img src="https://img-blog.csdnimg.cn/6570ad6661ae4000be8d5f5fe043092c.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/cab1b8951c75441c9dc8f04f050c0cf1.png" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/828ba2fff97848f9a4cf157820fb52f8.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/bf6b30ac285147078ab499aacff5b8c1.png" alt="在这里插入图片描述"></p>
<p>请看以下代码的演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;   <span class="comment">//e为空接口类型</span></span><br><span class="line">	r, ok := e.(*os.File)  <span class="comment">//将e与*os.File类型进行类型断言</span></span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	e = f    <span class="comment">//将*os.File类型的f赋值给e</span></span><br><span class="line">	r, ok = e.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">	e = f1  <span class="comment">//将string类型的f1赋值给e</span></span><br><span class="line">	r, ok = e.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>go run</code>以后的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&amp;&#123;<span class="number">0xc000088780</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>





<h2 id="非空接口-具体类型"><a href="#非空接口-具体类型" class="headerlink" title="非空接口.(具体类型)"></a>非空接口.(具体类型)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">r,ok := rw.(*os.File)</span><br></pre></td></tr></table></figure>



<p>rw.(<em>os.File)是要判断rw的动态类型是否为</em>os.File。前面我们介绍过，程序中用到的itab结构体都会缓存起来，可以通过&lt;接口类型, 动态类型&gt;组合起来的key，查找到对应的itab指针。<br>所以这里的类型断言只需要一次比较就能完成，就是看iface.tab是否等于&lt;io.ReadWriter, *os.File&gt;这个组合对应的itab指针就好。</p>
<p><img src="https://img-blog.csdnimg.cn/a52a868e2e4c4cb5a8bce4bccec4fcbd.png" alt="在这里插入图片描述"></p>
<p>如果把一个<em>os.File类型的变量f赋给rw，它的动态值就是f，动态类型就是</em>os.File。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f,_ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">rw = f</span><br></pre></td></tr></table></figure>



<p>rw这里存储的itab指针就指向&lt;io.ReadWriter, *os.File&gt;组合对应的itab，所以类型断言成功，ok为true，r被赋值为rw的动态值。</p>
<p><img src="https://img-blog.csdnimg.cn/dfa526ca79074ac2bf05926267954da8.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e591caa12fc84f5f9885e24267787796.png" alt="在这里插入图片描述"></p>
<p>下面我们定义一个eggo类型，并且由*eggo类型实现io.ReadWriter接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果把一个<em>eggo类型的变量赋值给rw，rw的动态类型就是</em>eggo，rw持有的itab指针就不指向&lt;io.ReadWriter, <em>os.File&gt;组合对应的itab结构体，类型断言就会失败，ok为false，而r就会被置为</em>os.File的类型零值nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">rw = &amp;f</span><br></pre></td></tr></table></figure>



<p><img src="https://img-blog.csdnimg.cn/31a46be7b0014ef3951a5cd74c055df5.png" alt="在这里插入图片描述"></p>
<p>请看以下代码的演示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个eggo类型</span></span><br><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Read(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line"></span><br><span class="line">	r, ok := rw.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	rw = f</span><br><span class="line">	r, ok = rw.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">	rw = &amp;f1</span><br><span class="line">	r, ok = rw.(*os.File)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>go run</code>以后的运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>




<h2 id="空接口-非空接口"><a href="#空接口-非空接口" class="headerlink" title="空接口.(非空接口)"></a>空接口.(非空接口)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">rw,ok := e.(io.ReadWriter)</span><br></pre></td></tr></table></figure>



<p>e.(io.ReadWriter)就是要判断e的动态类型是否实现了io.ReadWriter接口。</p>
<p><img src="https://img-blog.csdnimg.cn/a3efd28621484cd1b2a8d2dbf614f87d.png" alt="在这里插入图片描述"></p>
<p>如果e像这样赋值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f,_ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>e的动态类型就是<em>os.File，我们知道</em>os.File类型元数据的后面可以找到该类型实现的方法列表描述信息。</p>
<p><img src="https://img-blog.csdnimg.cn/46af630a89614fb99b753dbd6858e7a8.png" alt="在这里插入图片描述"></p>
<p>其实并不需要每次都检查动态类型的方法列表，还记得itab缓存吗？ 实际上，当类型断言的目标类型为非空接口时，会首先去itabTable里查找对应的itab指针，若没有找到，再去检查动态类型的方法列表。<br>此处注意，就算从itabTable中找到了itab指针，也要进一步确认itab.fun[0]是否等于0。这是因为一旦通过方法列表确定某个具体类型没有实现指定接口，就会把itab这里的fun[0]置为0，然后同样会把这个itab结构体缓存起来，和那些断言成功的itab缓存一样。这样做的目的是避免再遇到同种类型断言时重复检查方法列表。</p>
<p>回到例子中，这里会断言成功，ok为true，rw就是一个io.ReadWriter类型的变量，其动态值与e相同。tab指向&lt;io.ReadWriter, *os.File&gt;对应的itab结构体。</p>
<p><img src="https://img-blog.csdnimg.cn/0fb30a797dce4245908d572528f53673.png" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = f</span><br></pre></td></tr></table></figure>



<p>然而如果把一个字符串赋值给e，它的动态类型就是string，&lt;io.ReadWriter, string&gt;这个组合会对应下面这个itab，它也会被缓存起来。</p>
<p><img src="https://img-blog.csdnimg.cn/99a89cd590554578997cc58f2140db97.png" alt="在这里插入图片描述"></p>
<p>断言失败，ok为false，rw为io.ReadWriter的类型零值，即tab和data均为nil。</p>
<p><img src="https://img-blog.csdnimg.cn/ec7641aa4b1a4b9f96a96e5d70466319.png" alt="在这里插入图片描述"></p>
<p>示例请看以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	rw, ok := e.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _  := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	e = f</span><br><span class="line">	rw, ok = e.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">	e = f1</span><br><span class="line">	rw, ok = e.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行&#96;&#96;&#96;go run&#96;&#96;以后的运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&amp;&#123;<span class="number">0xc000108780</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>





<h2 id="非空接口-非空接口"><a href="#非空接口-非空接口" class="headerlink" title="非空接口.(非空接口)"></a>非空接口.(非空接口)</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">rw,ok := w.(io.ReadWriter)</span><br></pre></td></tr></table></figure>



<p>w.(io.ReadWriter)是要判断w的动态类型是否实现了io.ReadWriter接口。</p>
<p><img src="https://img-blog.csdnimg.cn/3c5e5a8e43d940e1af7c4e372db1e28b.png" alt="在这里插入图片描述"></p>
<p>下面同样把一个<em>os.File类型的变量f赋值给w，它的动态值就是f，动态类型就是</em>os.File。</p>
<p>f,_ :&#x3D; os.Open(“hello.txt”)<br>w &#x3D; f</p>
<p><img src="https://img-blog.csdnimg.cn/b10f509d95954a43accb0cb5397419c7.png" alt="在这里插入图片描述"></p>
<p>要确定<em>os.File是否实现了io.ReadWriter接口，同样会先去itab缓存里查找&lt;io.ReadWriter,*os.File&gt;对应的itab，若存在，且itab.fun[0]不等于0，则断言成功；若不存在，再去检查</em>os.File的方法列表，创建并缓存itab信息。</p>
<p>这里断言成功，ok为true，rw为io.ReadWriter类型的变量，动态值与w相同，而itab是&lt;io.ReadWriter, *os.File&gt;对应的那一个。</p>
<p><img src="https://img-blog.csdnimg.cn/64ef6f0190d043e0968333d4f3aa4238.png" alt="在这里插入图片描述"></p>
<p>下面我们自定义一个eggo类型，且<em>eggo类型只实现io.Writer要求的Write方法，并没有实现io.ReadWriter额外要求的Read方法。如果把一个</em>eggo类型的变量赋给w：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">w = &amp;f</span><br></pre></td></tr></table></figure>




<p>此时，w的动态类型为<em>eggo，而</em>eggo的方法列表里缺少一个Read方法，所以类型断言失败，下面这个itab被缓存起来。</p>
<p><img src="https://img-blog.csdnimg.cn/5e123aaa8a0942a38558e990442fa748.png" alt="在这里插入图片描述"></p>
<p>断言失败后，ok为false，rw的data和tab均为nil。</p>
<p><img src="https://img-blog.csdnimg.cn/98ad94ecdcb34f8298adacda56acd23b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/fd7b2085924a417bb3fa6b548f36493b.png" alt="在这里插入图片描述"></p>
<p>示例请看以下代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> eggo <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *eggo)</span></span> Write(b []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(e.name), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> w io.Writer</span><br><span class="line">	rw, ok := w.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f, _ := os.Open(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">	w = f</span><br><span class="line">	rw, ok = w.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	f1 := eggo&#123;name: <span class="string">&quot;eggo&quot;</span>&#125;</span><br><span class="line">	w = &amp;f1</span><br><span class="line">	rw, ok = w.(io.ReadWriter)</span><br><span class="line">	fmt.Println(rw)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行go run以后的结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&amp;&#123;<span class="number">0xc000108780</span>&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"></span><br><span class="line">&lt;<span class="literal">nil</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>




<p>综上，类型断言的关键是<strong>明确接口的动态类型，以及对应的类型实现了哪些方法</strong>。而明确这些的关键，还是类型元数据，以及空接口与非空接口的数据结构。接下来的<code>Type Switch</code>也不外如是。</p>
<h2 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">str := <span class="string">&quot;eggo&quot;</span></span><br><span class="line">e = str</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> b := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *os.File:</span><br><span class="line">    &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;*os.File&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        fmt.Println(b)    <span class="comment">//选择这个分支</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的b会被赋值为e的动态值，下面每个case都是把e的动态类型和某个具体类型作比较，相等则选择这个分支，没有匹配的则走到default分支。</p>
<p><img src="https://img-blog.csdnimg.cn/a5d3369f7d23430f9b698dbb74bdb012.png" alt="在这里插入图片描述"></p>
<p>有时会遇到多个类型放在一个分支的情况，这时b的类型是interface{}。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> b := e.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *os.File:</span><br><span class="line">    &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;这里b的类型为*os.File&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;这里b的类型为string&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">case</span> <span class="type">int</span>, <span class="type">int32</span>, <span class="type">int64</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;多类型分支里b的类型为interface&#123;&#125;&quot;</span>, b)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;default&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 调度器调度场景</title>
    <url>/2022/09/07/Go/Golang%20%E8%B0%83%E5%BA%A6%E5%99%A8%E8%B0%83%E5%BA%A6%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h2 id="场景1-创建G"><a href="#场景1-创建G" class="headerlink" title="场景1 创建G"></a>场景1 创建G</h2><p>P拥有G1，M1获取P后开始运行G1，G1使用<code>go func()</code>创建了G2，为了局部性G2优先加入到P1的本地队列。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfeaa60d987644d980865d74991c6a11~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景2-G执行完毕"><a href="#场景2-G执行完毕" class="headerlink" title="场景2 G执行完毕"></a>场景2 G执行完毕</h2><p>G1运行完成后(函数：<code>goexit</code>)，M上运行的goroutine切换为G0，G0负责调度时协程的切换（函数：<code>schedule</code>）。从P的本地队列取G2，从G0切换到G2，并开始运行G2(函数：<code>execute</code>)。实现了线程M1的复用。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cce4ac9c9ad7461e9fbc06c37ebb65b2~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景3-G2开辟过多的G"><a href="#场景3-G2开辟过多的G" class="headerlink" title="场景3 G2开辟过多的G"></a>场景3 G2开辟过多的G</h2><p>假设每个P的本地队列只能存3个G。G2要创建了6个G，前3个G（G3, G4, G5）已经加入p1的本地队列，p1本地队列满了。接着触发场景4和5。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/756a5c3a77f142beabfbd6ac55180b79~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景4-G2本地满再创建G7"><a href="#场景4-G2本地满再创建G7" class="headerlink" title="场景4 G2本地满再创建G7"></a>场景4 G2本地满再创建G7</h2><p>G2在创建G7的时候，发现P1的本地队列已满，需要执行<strong>负载均衡</strong>(把P1中本地队列中前一半的G，还有新创建G<strong>转移</strong>到全局队列)</p>
<p><em>（实现中并不一定是新的G，如果G是G2之后就执行的，会被保存在本地队列，利用某个老的G替换新G加入全局队列）</em></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/236b992afea2467a81891b736375377a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>这些G被转移到全局队列时，会被打乱顺序。所以G3,G4,G7被转移到全局队列。</p>
<h2 id="场景5-G2本地未满创建G8"><a href="#场景5-G2本地未满创建G8" class="headerlink" title="场景5 G2本地未满创建G8"></a>场景5 G2本地未满创建G8</h2><p>G2创建G8时，P1的本地队列未满，所以G8会被加入到P1的本地队列。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e96d82277fa4d5ca52148fdbfab2a22~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>G8加入到P1点本地队列的原因还是因为P1此时在与M1绑定，而G2此时是M1在执行。所以G2创建的新的G会优先放置到自己的M绑定的P上。</p>
<h2 id="场景6-唤醒正在休眠的M"><a href="#场景6-唤醒正在休眠的M" class="headerlink" title="场景6 唤醒正在休眠的M"></a>场景6 唤醒正在休眠的M</h2><p>规定：<strong>在创建G时，运行的G会尝试唤醒其他空闲的P和M组合去执行</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5be54b4f302e455c8d6ca6d44497091a~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>假定G2唤醒了M2，M2绑定了P2，并运行G0，但P2本地队列没有G，M2此时为自旋线程<strong>（没有G但为运行状态的线程，不断寻找G）</strong>。</p>
<h2 id="场景7-被唤醒的M从全局取C"><a href="#场景7-被唤醒的M从全局取C" class="headerlink" title="场景7 被唤醒的M从全局取C"></a>场景7 被唤醒的M从全局取C</h2><p>M2尝试从全局队列(简称“GQ”)取一批G放到P2的本地队列（函数：<code>findrunnable()</code>）。M2从全局队列取的G数量符合下面的公式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">n = min(<span class="built_in">len</span>(GQ)/GOMAXPROCS + <span class="number">1</span>, <span class="built_in">len</span>(GQ/<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>至少从全局队列取1个g，但每次不要从全局队列移动太多的g到p本地队列，给其他p留点。这是<strong>从全局队列到P本地队列的负载均衡</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7ecd577cde04ca7b7b57d7bd1131da0~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>假定我们场景中一共有4个P（GOMAXPROCS设置为4，那么我们允许最多就能用4个P来供M使用）。所以M2只从能从全局队列取1个G（即G3）移动P2本地队列，然后完成从G0到G3的切换，运行G3。</p>
<h2 id="场景8-偷取G情况"><a href="#场景8-偷取G情况" class="headerlink" title="场景8 偷取G情况"></a>场景8 偷取G情况</h2><p>假设G2一直在M1上运行，经过2轮后，M2已经把G7、G4从全局队列获取到了P2的本地队列并完成运行，全局队列和P2的本地队列都空了,如场景8图的左半部分。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b41a8f29987a4ed0a521bc2c15704918~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p><strong>全局队列已经没有G，那m就要执行work stealing(偷取)：从其他有G的P哪里偷取一半G过来，放到自己的P本地队列</strong>。P2从P1的本地队列尾部取一半的G，本例中一半则只有1个G8，放到P2的本地队列并执行。</p>
<h2 id="场景9-自旋线程的最大限制"><a href="#场景9-自旋线程的最大限制" class="headerlink" title="场景9 自旋线程的最大限制"></a>场景9 自旋线程的最大限制</h2><p>G1本地队列G5、G6已经被其他M偷走并运行完成，当前M1和M2分别在运行G2和G8，M3和M4没有goroutine可以运行，M3和M4处于<strong>自旋状态</strong>，它们不断寻找goroutine。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539b15a133f64241b13805a5287c35ab~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>为什么要让m3和m4自旋，自旋本质是在运行，线程在运行却没有执行G，就变成了浪费CPU.  为什么不销毁现场，来节约CPU资源。因为创建和销毁CPU也会浪费时间，我们<strong>希望当有新goroutine创建时，立刻能有M运行它</strong>，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费CPU，所以系统中最多有<code>自旋线程 + 执行线程 &lt;= GOMAXPROCS</code>个线程(当前例子中的<code>GOMAXPROCS</code>&#x3D;4，所以一共4个P，2个自旋线程)，多余的没事做线程会让他们休眠。</p>
<h2 id="场景10-G发生调用阻塞"><a href="#场景10-G发生调用阻塞" class="headerlink" title="场景10 G发生调用阻塞"></a>场景10 G发生调用阻塞</h2><p>假定当前除了M3和M4为自旋线程，还有M5和M6为空闲的线程(没有得到P的绑定，注意我们这里最多就只能够存在4个P，所以P的数量应该永远是M&gt;&#x3D;P, 大部分都是M在抢占需要运行的P)，G8创建了G9，G8进行了<strong>阻塞的系统调用</strong>，M2和P2立即解绑，P2会执行以下判断：如果P2本地队列有G、全局队列有G或有空闲的M，P2都会立马唤醒1个M和它绑定，否则P2则会加入到空闲P列表，等待M来获取可用的p。本场景中，P2本地队列有G9，可以和其他空闲的线程M5绑定。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22dbdcf494d54982ad06990fb533eff6~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<h2 id="场景11-G发生非阻塞系统调用"><a href="#场景11-G发生非阻塞系统调用" class="headerlink" title="场景11 G发生非阻塞系统调用"></a>场景11 G发生非阻塞系统调用</h2><p>G8创建了G9，假如G8进行了<strong>非阻塞系统调用</strong>，就是当G8的阻塞结束的时候。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8c2c7de8dea4abf8c607fd2bf21cd87~tplv-k3u1fbpfcp-zoom-1.image" alt="请添加图片描述"></p>
<p>M2和P2会解绑，但M2会记住P2，然后G8和M2进入<strong>系统调用</strong>状态。当G8和M2退出系统调用时，会尝试获取P2，如果无法获取，则获取空闲的P，如果依然没有，G8会被记为可运行状态，并加入到全局队列,M2因为没有P的绑定而变成休眠状态(长时间休眠等待GC回收销毁)。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总结，Go调度器很轻量也很简单，足以撑起goroutine的调度工作，并且让Go具有了原生（强大）并发的能力。<strong>Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</strong></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 错误处理</title>
    <url>/2022/09/07/Go/Golang%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>panic相当于throw exception，recover相当于try catch。<br>所以经过recover接收的异常被处理后，不会让程序crash。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(r)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;异常信息&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常信息</span></span><br></pre></td></tr></table></figure>




<p>panic 和 recover 的函数签名如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>(<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">revover()<span class="keyword">interface</span>&#123;&#125; </span><br></pre></td></tr></table></figure>



<p><strong>panic的引发</strong></p>
<p>1.程序主动调用panic函数。<br>2.程序产生运行时错误，由运行时检测并抛出。</p>
<p>发生panic后，程序会从调用panic的函数位置或发生panic的地方立即返回，逐层向上执行函数的defer语句，然后逐层打印函数调用堆栈，直到被recover捕获或运行到最外层函数而退出。<br>不仅如此，在defer逻辑里也可以再次调用panic或抛出panic。defer 里面的 panic 能够被后续执行的 defer 捕获。</p>
<p><strong>recover</strong></p>
<p>recover()用来捕获panic,阻止panic 继续向上传递。recover()和defer一起使用，但是recover()只有在defer后面的函数体内被直接调用才能捕获panic终止异常，否则返回nil,异常继续向外传递。</p>
<p>以下场景会捕获失败：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个会捕获失败</span></span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">recover</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个会捕获失败</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="built_in">recover</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个嵌套两层也会捕获失败</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;defer inner&quot;</span>)</span><br><span class="line">		<span class="built_in">recover</span>()  <span class="comment">// 无效</span></span><br><span class="line">	&#125; ()</span><br><span class="line">&#125; ()</span><br></pre></td></tr></table></figure>

<p>以下场景会捕获成功：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(<span class="string">&quot;defer inner&quot;</span>)</span><br><span class="line">	<span class="built_in">recover</span>()</span><br><span class="line">&#125; ()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">except</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">recover</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> except()</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;test panic&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p><strong>连续多个panic抛出</strong></p>
<p>可以有连续多个panic被抛出，连续多个panic的场景只能出现在defer调用里面，否则不会出现多个panic被抛出的场景。但只有最后一次panic能被捕获。例如:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 只有最后一次panic调用能够被捕获</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;first defer panic&quot;</span>)</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;second defer panic&quot;</span>)</span><br><span class="line">	&#125; ()</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;main body panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">first <span class="keyword">defer</span> <span class="built_in">panic</span></span><br></pre></td></tr></table></figure>



<p><strong>新goroutine中抛出的panic</strong></p>
<p>函数并不能捕获内部新启动的 goroutine 所抛出的 panic ，所以比如init函数引发的panic只能在init函数中捕获，在main中无法捕获。</p>
<p>例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span> <span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 这里不能捕获da函数中的panic</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; ()</span><br><span class="line">	<span class="keyword">go</span> da()</span><br><span class="line">	<span class="keyword">go</span> db()</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">da</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;panic da&quot;</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">db</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>Go语言内置错误接口类型error。任何类型只要实现Error() string 方法，都可以传递error 接口类型变量。Go语言典型的错误处理方式是将error作为函数最后一个返回值。在调用函数时，通过检测其返回的error值是否为nil来进行错误处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>错误处理的最佳实践</strong>：</p>
<p>1.在多个返回值的函数，error通常作为函数最后一个返回值。<br>2.如果一个函数返回 error 类型变量，则先用 if 语句处理 error !&#x3D; nil 的异常场景，正常逻辑放到if语句块的后面，保持代码平坦。<br>3.defer语句应该放到err判断的后面，不然有可能产生panic。<br>4.在错误处理逐级向上传递的过程中，错误信息应该不断地丰富和完善，而不是简单地抛出下层调用的错误。这在错误日志分析时非常有用和友好。</p>
<h2 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h2><p><strong>广义上的错误</strong>：发生非期望的行为。<br><strong>狭义的错误</strong>：发生非期望的已知行为，这里的已知是指错误的类型是预料并定义好的。<br><strong>异常</strong>：发生非期待的未知行为。这里的未知是指错误的类型不在预先定义的范围内。又被称为未捕获的错误 (untrapped error) 。，程序编译器和运行时都没有及时将其捕获处理。而是由操作系统进行异常处理。</p>
<p><strong>错误分类关系如图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb2be9e93d8d4246a8863cacf95da694~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>Go是一门类型安全的语言，不会出现 <strong>untrapped error</strong> ，所以Go语言不存在所谓的异常，出现的”异常”全是错误。</p>
<p><strong>Go语言的两种错误处理机制</strong></p>
<p>1.通过函数返回错误类型(error)的值来处理错误。<br>2.通过panic打印程序调用栈，终止程序执行来处理错误。</p>
<p><strong>对应的也有两条错误处理规则</strong>：</p>
<p>1.程序发生的错误导致程序不能容错继续执行，此时程序应该主动调用panic或由运行时抛出 panic 。<br>2.程序虽然发生错误，但是程序能够容错继续执行，此时应该使用错误返回值的方式处理错误，或者在可能发生运行时错误的非关键分支.上使用recover捕获panic。</p>
<p>go的整个错误处理过程如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e47ae73897bd475ca7c4ebdcbb6a7e5e~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang1.18 泛型初探</title>
    <url>/2022/09/08/Go/Golang1.18%20%E6%B3%9B%E5%9E%8B%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="泛型出现之前"><a href="#泛型出现之前" class="headerlink" title="泛型出现之前"></a>泛型出现之前</h2><p>在泛型出现之前，go语言的灵活性很大部分是基于<code>interface&#123;&#125;</code>这个空接口来保证的。任何变量都可以继承空接口，但是在使用变量的时候，就需要对变量进行<code>类型断言</code>。而类型断言是基于<code>反射</code>来实现的，反射中的类型错误在真正运行的时候才会引发panic，而且大量使用反射会使得程序的效率变得非常低。</p>
<p>下面我们来看一个类型断言的例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumInt</span><span class="params">(param []<span class="keyword">interface</span>&#123;&#125;)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> param &#123;</span><br><span class="line">		sum += v.(<span class="type">int</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConnStrings</span><span class="params">(param []<span class="keyword">interface</span>&#123;&#125;)</span></span> (str <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> param &#123;</span><br><span class="line">		str += v.(<span class="type">string</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddSum</span><span class="params">(param ...<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">switch</span> param[<span class="number">0</span>].(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">int</span>:</span><br><span class="line">		<span class="keyword">return</span> SumInt(param)</span><br><span class="line">	<span class="keyword">case</span> <span class="type">string</span>:</span><br><span class="line">		<span class="keyword">return</span> ConnStrings(param)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;不支持相加的类型&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(AddSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">	fmt.Println(AddSum(<span class="string">&quot;hello, &quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">	fmt.Println(AddSum([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, []<span class="type">int</span>&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AddSum</code>函数的参数是空接口类型，保证了传入参数的灵活性，但是参数在传入以后，需要进行<code>解继承</code>才能真正去使用。</p>
<p>但是泛型出现以后，就不需要这么麻烦了，使用以下的方式就可以去解决：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型约束函数的传入参数只能是int 和 string</span></span><br><span class="line"><span class="comment">// 如果是其它类型将会报错</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddSum</span>[<span class="title">T</span> <span class="title">int</span> | <span class="title">string</span>]<span class="params">(param ...T)</span></span> (sum T) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> param &#123;</span><br><span class="line">		sum += v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(AddSum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">	fmt.Println(AddSum(<span class="string">&quot;hello, &quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>go1.18正式支持泛型，在goland中可以直接下载1.18版本。</p>
<h2 id="泛型特性"><a href="#泛型特性" class="headerlink" title="泛型特性"></a>泛型特性</h2><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Print(v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	printSlice[<span class="type">int</span>]([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">	printSlice[<span class="type">string</span>]([]<span class="type">string</span>&#123;<span class="string">&quot;how&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;you&quot;</span>&#125;)</span><br><span class="line">	printSlice[[]<span class="type">int</span>]([][]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;, &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12345</span></span><br><span class="line"><span class="comment">//howareyou</span></span><br><span class="line"><span class="comment">//[1 2 3][4 5 6][7 8 9]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>T</code>的后面是<code>any</code>表示传入函数的参数可以是任意类型，该函数的功能是打印传入切片的元素。</p>
<h3 id="泛型slice"><a href="#泛型slice" class="headerlink" title="泛型slice"></a>泛型slice</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> vector[T any] []T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span>[<span class="title">T</span> <span class="title">any</span>]<span class="params">(s []T)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Print(v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := vector[<span class="type">int</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	printSlice(arr)</span><br><span class="line">	str := vector[<span class="type">string</span>]&#123;<span class="string">&quot;how&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;you&quot;</span>&#125;</span><br><span class="line">	printSlice(str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//123</span></span><br><span class="line"><span class="comment">//howareyou</span></span><br></pre></td></tr></table></figure>

<p>上例中我们自定义了一种切片数据类型，该切片可以储存任意一种类型，但是要注意，声明一次只能存同一种数据类型。</p>
<h3 id="泛型map"><a href="#泛型map" class="headerlink" title="泛型map"></a>泛型map</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> M[K <span class="type">string</span>, V any] <span class="keyword">map</span>[K]V</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m1 := <span class="built_in">make</span>(M[<span class="type">string</span>, <span class="type">int</span>])</span><br><span class="line">	m1[<span class="string">&quot;key1&quot;</span>] = <span class="number">1</span></span><br><span class="line">	m1[<span class="string">&quot;key2&quot;</span>] = <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m1&#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	m2 := <span class="built_in">make</span>(M[<span class="type">string</span>, <span class="type">string</span>])</span><br><span class="line">	m2[<span class="string">&quot;key1&quot;</span>] = <span class="string">&quot;hello&quot;</span></span><br><span class="line">	m2[<span class="string">&quot;key2&quot;</span>] = <span class="string">&quot;world&quot;</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m2&#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//key1 1</span></span><br><span class="line"><span class="comment">//key2 2</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//key1 hello</span></span><br><span class="line"><span class="comment">//key2 world</span></span><br></pre></td></tr></table></figure>

<p>要注意，map的K是不支持any的，所以在这里我把K约束成了string类型。</p>
<h3 id="泛型channel"><a href="#泛型channel" class="headerlink" title="泛型channel"></a>泛型channel</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C[T any] <span class="keyword">chan</span> T</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	chan1 := <span class="built_in">make</span>(C[<span class="type">int</span>], <span class="number">2</span>)</span><br><span class="line">	chan1 &lt;- <span class="number">1</span></span><br><span class="line">	chan1 &lt;- <span class="number">2</span></span><br><span class="line">	fmt.Println(&lt;-chan1)</span><br><span class="line"></span><br><span class="line">	chan2 := <span class="built_in">make</span>(C[<span class="type">string</span>], <span class="number">2</span>)</span><br><span class="line">	chan2 &lt;- <span class="string">&quot;hello&quot;</span></span><br><span class="line">	chan2 &lt;- <span class="string">&quot;world&quot;</span></span><br><span class="line">	fmt.Println(&lt;-chan2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="可比较类型"><a href="#可比较类型" class="headerlink" title="可比较类型"></a>可比较类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FindFunc 泛型约束：可比较类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindFunc</span>[<span class="title">T</span> <span class="title">comparable</span>]<span class="params">(a []T, v T)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, e := <span class="keyword">range</span> a &#123;</span><br><span class="line">		<span class="keyword">if</span> e == v &#123;</span><br><span class="line">			<span class="keyword">return</span> i</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(FindFunc([]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;, <span class="number">10</span>))</span><br><span class="line">	fmt.Println(FindFunc([]<span class="type">string</span>&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>&#125;, <span class="string">&quot;def&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-1</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型还可以约束一种可比较类型<code>comparable</code>，大致功能就是在一个切片中找一个数，具体的算法需要自己实现，在这里我简单的演示了一下。</p>
<h3 id="使用interface中规定的类型来约束函数的参数"><a href="#使用interface中规定的类型来约束函数的参数" class="headerlink" title="使用interface中规定的类型来约束函数的参数"></a>使用interface中规定的类型来约束函数的参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number 使用interface来约束泛型中可以传入的类型</span></span><br><span class="line"><span class="keyword">type</span> Number <span class="keyword">interface</span> &#123;</span><br><span class="line">	~<span class="type">int</span> | <span class="type">float64</span> | <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span>[<span class="title">T</span> <span class="title">Number</span>]<span class="params">(a, b T)</span></span> T &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(Add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">	fmt.Println(Add(<span class="number">1.1</span>, <span class="number">2.2</span>))</span><br><span class="line">	fmt.Println(Add(<span class="string">&quot;hello, &quot;</span>, <span class="string">&quot;world&quot;</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//3.3000000000000003</span></span><br><span class="line"><span class="comment">//hello, world</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果函数的约束类型过多怎么办，如果直接写在函数名后面的方括号中，代码将显得非常丑陋，这个时候我们使用interface约束类型。注意，~符号表示约束某种类型的底层类型。</p>
<h3 id="使用interface中规定的方法来约束函数的参数"><a href="#使用interface中规定的方法来约束函数的参数" class="headerlink" title="使用interface中规定的方法来约束函数的参数"></a>使用interface中规定的方法来约束函数的参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Price <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ShowPrice 使用interface来约束传入ShowPriceList函数中的类型必须实现了String方法，不然就报错</span></span><br><span class="line"><span class="keyword">type</span> ShowPrice <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i Price)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(<span class="type">int</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowPriceList</span>[<span class="title">T</span> <span class="title">ShowPrice</span>]<span class="params">(s []T)</span></span> (res []<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(ShowPriceList([]Price&#123;<span class="number">1</span>, <span class="number">2</span>&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传入ShowPriceList函数的参数，必须实现String方法。</p>
<h3 id="使用interface中规定的类型和方法来双重约束函数的参数"><a href="#使用interface中规定的类型和方法来双重约束函数的参数" class="headerlink" title="使用interface中规定的类型和方法来双重约束函数的参数"></a>使用interface中规定的类型和方法来双重约束函数的参数</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;strconv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriceInt <span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i PriceInt)</span></span>String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strconv.Itoa(<span class="type">int</span>(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PriceString <span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i PriceString)</span></span>String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShowPrice 约束底层类型必须是int和string 且 必须实现String方法</span></span><br><span class="line"><span class="keyword">type</span> ShowPrice <span class="keyword">interface</span> &#123;</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">	~<span class="type">int</span> | ~<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShowPriceList</span>[<span class="title">T</span> <span class="title">ShowPrice</span>]<span class="params">(s []T)</span></span> (res []<span class="type">string</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, v.String())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ShowPriceList([]PriceInt&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">	ShowPriceList([]PriceString&#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传入ShowPriceList函数的参数的底层类型必须是int或者string且必须实现String方法。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 闭包</title>
    <url>/2022/09/07/Go/Golang%20%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h2 id="实例引入"><a href="#实例引入" class="headerlink" title="实例引入"></a>实例引入</h2><p>先来看一段代码，下面的addr函数的返回值是另一个函数，被返回的这个函数中，又对addr函数中的变量进行了累加，然后返回。<br>在main函数中，使用变量pos接收addr()函数返回的函数对象，然后在for循环中调用5次。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addr</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		sum += x</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pos := addr()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Println(pos(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>以上被return的函数就是闭包。</p>
<h2 id="什么是函数闭包"><a href="#什么是函数闭包" class="headerlink" title="什么是函数闭包"></a>什么是函数闭包</h2><h3 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h3><p>是可以包含自由（未绑定到特定对象）变量的代码块，这些变量不在这个代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。要执行的代码块（由于自由变量包含在代码块中，所以这些自由变量以及它们引用的对象没有被释放）为自由变量提供绑定的计算环境（作用域）。 </p>
<p>简而言之，闭包就是能够读取其他函数内部变量的函数。</p>
<h3 id="闭包的价值"><a href="#闭包的价值" class="headerlink" title="闭包的价值"></a>闭包的价值</h3><p>闭包的价值在于可以作为函数对象或者匿名函数，对于类型系统而言，这意味着不仅要表示数据还要表示代码。支持闭包的多数语言都将函数作为第一级对象，就是说这些函数可以存储到变量中作为参数传递给其他函数，最重要的是能够被函数动态创建和返回。</p>
<p>Go语言中的闭包同样也会引用到函数外的变量。闭包的实现确保只要闭包还被使用，那么被闭包引用的变量会一直存在。</p>
<h2 id="闭包的机制"><a href="#闭包的机制" class="headerlink" title="闭包的机制"></a>闭包的机制</h2><h3 id="function-value"><a href="#function-value" class="headerlink" title="function value"></a>function value</h3><p>go语言中函数是头等对象，可以作为参数传递，可以做函数返回值，也可以绑定到变量。go语言称这样的参数、返回值或变量为<code>function value</code> （函数变量）。</p>
<p><img src="https://img-blog.csdnimg.cn/0a5d36c93e284fb2b05aa5a959a18444.png" alt="在这里插入图片描述"></p>
<p>函数的指令在编译期间生成。而<code>function value</code>本质上是一个函数指针，但是并不直接指向函数指令入口。而是直接指向一个<code>runtime.funcval</code>结构体。这个结构体里只有一个地址，就是这个函数指令的入口地址。</p>
<p>再来看一个例子：</p>
<p><img src="https://img-blog.csdnimg.cn/d4cbc453973e4fd0ab71eba03bc5e8f9.png" alt="在这里插入图片描述"></p>
<p>函数A被赋值给f1和f2两个变量，这种情况，编译器会做出优化。让f1和f2共用一个<code>funcval</code>结构体。<br>如果函数A的指令在addr1所指的位置。编译阶段，会在只读数据段分配一个<code>funcval</code>结构体。fn指向函数指令入口，而它本身的起始地址，会在执行阶段赋给f1和f2。 通过f1来执行函数， 就会通过它储存的地址，找到对应的funcval结构体，拿到函数入口地址，然后跳转执行，参数为1，下一步输出为2。f2的调用完全相同。</p>
<p><img src="https://img-blog.csdnimg.cn/624413bc02334bd782c3771889c28b7b.png" alt="在这里插入图片描述"></p>
<p>既然只要有函数入口地址就能调用，为什么要通过funcval结构体来包装这个地址，然后使用一个二级指针来调用呢？<br><strong>这里其实就是为了处理闭包的情况。</strong></p>
<p>再来看一种情况：</p>
<p><img src="https://img-blog.csdnimg.cn/09299de1393d4b479c8abff2f95a6d73.png" alt="在这里插入图片描述"></p>
<p>函数create的返回值是一个函数，但这个函数内部使用了外部定义的变量c。即使create执行结束，通过f1和f2依然能够正常调用这个闭包函数。并使用定义在create函数内部的局部变量c。<br>这里符合闭包的定义，通常称这个变量c为捕获变量。<br>闭包函数的指令自然也在编译阶段生成。但因为每个闭包对象都要保存自己的捕获变量，所以要到执行阶段才创建对应的闭包对象。<br>到执行阶段，main函数栈帧有两个局部变量，然后是返回值空间。到create函数栈帧这里，有一个局部变量c&#x3D;2。create函数会在堆上分配一个funcval结构体。<br>fn指向闭包函数入口，除此之外还有一个捕获列表。这里只捕获一个变量c，然后这个结构的起始地址就被作为返回值写入返回值空间。所以f1被赋值为addr2。<br>下面再次调用create函数。它就会再次创建一个funccval结构体。同样捕获变量c，然后这个起始地址addr3作为返回值写入。最终f2被赋值为addr3。<br>通过f1和f2调用闭包函数，就会找到各自对应的funcval结构体。拿到同一个函数入口，但是通过f1调用时要使用addr1指向的捕获列表，而使用f2调用时要使用addr2指向的捕获列表。<strong>这就是称闭包为有状态的函数的原因。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/38af1fc057134c8080153a1f6ca0d837.png" alt="在这里插入图片描述"></p>
<p>那究竟闭包函数是如何找到对应的捕获列表呢？</p>
<p>go语言中通过一个<code>function value</code>调用函数时，会把对应的<code>funcval</code>结构体地址存入特定寄存器，例如amd64平台使用的是DX寄存器。这样，在闭包函数中，就可以通过寄存器取出funcval结构体的地址，然后加上相应的偏移来找到每一个被捕获的变量。所以go语言中闭包就是有捕获列表的<code>Function Value</code>。而没有捕获列表的<code>Function Value</code>直接忽略这个寄存器的值就好了。</p>
<p>最后来看看捕获列表：</p>
<p>它可不是拷贝变量值这么简单，被闭包捕获的变量要在外层函数与闭包函数中表现一致，好像它们在使用同一个变量。</p>
<p><img src="https://img-blog.csdnimg.cn/f1303db55d2044e69fa41f7480c7bb48.png" alt="在这里插入图片描述"></p>
<p>为此，go语言的编译器针对不同的情况做了不同的处理。</p>
<ul>
<li>被捕获的变量除了初始化赋值外，在任何地方都没有被修改过，所以直接拷贝值到捕获列表中就可以了。</li>
<li>但是如果除了初始化赋值外还被修改过，那就要再做细分了。<ul>
<li>如果被捕获的是局部变量，而且除了初始化赋值外还被修改过， 那么这个局部变量就会被分配到堆上，是变量逃逸的一种场景。</li>
<li>如果修改并被捕获的是参数，涉及到函数原型，就不能像局部变量那样处理了。参数依然通过调用者栈帧传入。但是编译器会把栈上这个参数拷贝到堆上一份。然后外层函数和闭包函数都使用堆上分配的这一个。</li>
<li>如果被捕获的是返回值，处理方式就又有些不同，调用者栈帧上依然会分配返回值空间。不过闭包的外层函数会在堆上也分配一个。但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间。</li>
</ul>
</li>
</ul>
<p>处理方式虽然多样，但是目标只有一个，就是保持捕获变量在外层函数与闭包函数中的一致性。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Master-Worker模式 Golang实现</title>
    <url>/2022/09/08/Go/Master-Worker%E6%A8%A1%E5%BC%8F%20Golang%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="Master-Worker模式"><a href="#Master-Worker模式" class="headerlink" title="Master-Worker模式"></a>Master-Worker模式</h1><p>Master-Worker模式是常用的并行计算模式。它的核心思想是系统由两类进程协作工作：Master进行和Worker进行。Master负责接收和分配任务，Worker负责处理子任务。当各个Worker子进程处理完成后，会将结果返回给Master，由Master做归纳和总结。其好处是能将一个大任务分解成若干个子任务，并行执行，从而提高系统的吞吐量。 </p>
<p><strong>master-worker模式流程图</strong></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7639ce670f3246b5937efbc17d8712e4~tplv-k3u1fbpfcp-zoom-1.image" alt="在这里插入图片描述"></p>
<p>下面是一个master-worker模式的例子：</p>
<p>worker.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Job 需要处理的任务，简单定义一下</span></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">	num <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(num <span class="type">int</span>)</span></span> Job &#123;</span><br><span class="line">	<span class="keyword">return</span> Job&#123;num: num&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">	id        <span class="type">int</span>                <span class="comment">//workerID</span></span><br><span class="line">	WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job      <span class="comment">//worker池</span></span><br><span class="line">	JobChannel <span class="keyword">chan</span> Job            <span class="comment">//worker从JobChannel中获取Job进行处理</span></span><br><span class="line">	Result    <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span> <span class="comment">//worker将处理结果放入reuslt</span></span><br><span class="line">	quit      <span class="keyword">chan</span> <span class="type">bool</span>          <span class="comment">//停止worker信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(workerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job, result <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>, id <span class="type">int</span>)</span></span> Worker &#123;</span><br><span class="line">	<span class="keyword">return</span> Worker&#123;</span><br><span class="line">		id:        id,</span><br><span class="line">		WorkerPool: workerPool,</span><br><span class="line">		JobChannel: <span class="built_in">make</span>(<span class="keyword">chan</span> Job),</span><br><span class="line">		Result:    result,</span><br><span class="line">		quit:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span></span> Start() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="comment">//将worker的JobChannel放入master的workerPool中</span></span><br><span class="line">			w.WorkerPool &lt;- w.JobChannel</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="comment">//从JobChannel中获取Job进行处理，JobChannel是同步通道，会阻塞于此</span></span><br><span class="line">			<span class="keyword">case</span> job := &lt;-w.JobChannel:</span><br><span class="line">				<span class="comment">//处理这个job</span></span><br><span class="line">				<span class="comment">//并将处理得到的结果存入master中的结果集</span></span><br><span class="line">				x := job.num * job.num</span><br><span class="line">				fmt.Println(w.id, <span class="string">&quot;:&quot;</span>, x)</span><br><span class="line">				w.Result[x] = w.id</span><br><span class="line">			<span class="comment">//停止信号</span></span><br><span class="line">			<span class="keyword">case</span> &lt;-w.quit:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span></span> Stop() &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		w.quit &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>master.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Master <span class="keyword">struct</span> &#123;</span><br><span class="line">	WorkerPool <span class="keyword">chan</span> <span class="keyword">chan</span> Job <span class="comment">//worker池</span></span><br><span class="line">	Result    <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>  <span class="comment">//存放worker处理后的结果集</span></span><br><span class="line">	jobQueue  <span class="keyword">chan</span> Job      <span class="comment">//待处理的任务chan</span></span><br><span class="line">	workerList []Worker      <span class="comment">//存放worker列表，用于停止worker</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> maxWorker <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NewMaster maxWorkers:开启线程数</span></span><br><span class="line"><span class="comment">//result :结果集</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMaster</span><span class="params">(maxWorkers <span class="type">int</span>, result <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>)</span></span> *Master &#123;</span><br><span class="line">	pool := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">chan</span> Job, maxWorkers)</span><br><span class="line">	maxWorker = maxWorkers</span><br><span class="line">	<span class="keyword">return</span> &amp;Master&#123;WorkerPool: pool, Result: result, jobQueue: <span class="built_in">make</span>(<span class="keyword">chan</span> Job, <span class="number">2</span>*maxWorkers)&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Run() &#123;</span><br><span class="line">	<span class="comment">//启动所有的Worker</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxWorker; i++ &#123;</span><br><span class="line">		work := NewWorker(m.WorkerPool, m.Result, i)</span><br><span class="line">		m.workerList = <span class="built_in">append</span>(m.workerList, work)</span><br><span class="line">		work.Start()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> m.dispatch()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分配任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> dispatch() &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 从作业队列中获取一个待处理的作业，因为是无缓冲通道，所以会阻塞</span></span><br><span class="line">		<span class="keyword">case</span> job := &lt;-m.jobQueue:</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">				<span class="comment">//从workerPool中取出一个worker的JobChannel</span></span><br><span class="line">				jobChannel := &lt;-m.WorkerPool</span><br><span class="line">				<span class="comment">//向这个JobChannel中发送job，worker中的接收配对操作会被唤醒</span></span><br><span class="line">				jobChannel &lt;- job</span><br><span class="line">			&#125;(job)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AddJob 添加任务到任务通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> AddJob(num <span class="type">int</span>) &#123;</span><br><span class="line">	job := NewJob(num)</span><br><span class="line">	<span class="comment">//向任务通道发送任务</span></span><br><span class="line">	m.jobQueue &lt;- job</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop 停止所有任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Master)</span></span> Stop() &#123;</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> m.workerList &#123;</span><br><span class="line">		v.Stop()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>test.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	result := <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	mas := NewMaster(<span class="number">4</span>, result)</span><br><span class="line">	mas.Run()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		mas.AddJob(i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Millisecond)</span><br><span class="line">	<span class="comment">//mas.Stop()</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;result=&quot;</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果每次都是不同的，这里只展示某一次的运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> : <span class="number">81</span></span><br><span class="line"><span class="number">2</span> : <span class="number">4</span></span><br><span class="line"><span class="number">2</span> : <span class="number">9</span></span><br><span class="line"><span class="number">2</span> : <span class="number">16</span></span><br><span class="line"><span class="number">2</span> : <span class="number">64</span></span><br><span class="line"><span class="number">2</span> : <span class="number">36</span></span><br><span class="line"><span class="number">2</span> : <span class="number">49</span></span><br><span class="line"><span class="number">3</span> : <span class="number">1</span></span><br><span class="line"><span class="number">0</span> : <span class="number">0</span></span><br><span class="line"><span class="number">1</span> : <span class="number">25</span></span><br><span class="line">result= <span class="keyword">map</span>[<span class="number">0</span>:<span class="number">0</span> <span class="number">1</span>:<span class="number">3</span> <span class="number">4</span>:<span class="number">2</span> <span class="number">9</span>:<span class="number">2</span> <span class="number">16</span>:<span class="number">2</span> <span class="number">25</span>:<span class="number">1</span> <span class="number">36</span>:<span class="number">2</span> <span class="number">49</span>:<span class="number">2</span> <span class="number">64</span>:<span class="number">2</span> <span class="number">81</span>:<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Golang 逃逸分析</title>
    <url>/2022/09/06/Go/%E6%B5%85%E8%B0%88golang%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-栈和堆"><a href="#1-栈和堆" class="headerlink" title="1.栈和堆"></a>1.栈和堆</h2><p>在golang中，应用程序的内存载体，可以简单的分为栈和堆。<br>栈的内存是由编译器自动进行分配和释放，栈区往往存储着函数参数、局部变量和函数栈帧，它们随着函数的创建而分配，函数的退出而销毁。<br>与栈不同的是，应用程序在运行时只会存在一个堆。狭隘地说，内存管理只是针对堆内存而言的。程序在运行期间可以主动从堆上申请内存，这些内存通过Go的内存分配器分配，并由垃圾收集器回收。</p>
<p>那么一个问题就来了，<strong>我们怎么知道一个对象是应该放在堆内存还是栈内存之上的呢？</strong></p>
<p>其实golang的官网上已经给出了答案：</p>
<p><a href="https://golang.org/doc/faq#stack_or_heap">https://golang.org/doc/faq#stack_or_heap</a></p>
<p><img src="https://img-blog.csdnimg.cn/358747fa08c946f59de2fc16be230424.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_20,color_FFFFFF,t_70,g_se,x_16"><br>中文版：</p>
<p><img src="https://img-blog.csdnimg.cn/a272814aa9eb4a1e83e9935f7bd92bde.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBARGF3bmxpZ2h0Xy1f,size_20,color_FFFFFF,t_70,g_se,x_16"><br>我们发现了一个名词：<strong>逃逸分析</strong>。</p>
<h2 id="2-逃逸分析"><a href="#2-逃逸分析" class="headerlink" title="2.逃逸分析"></a>2.逃逸分析</h2><p><strong>对于Golang程序，编译器是怎么判断一个变量到底是分配堆内存还是栈内存的呢？编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)。逃逸分析由编译器完成，作用于编译阶段。</strong></p>
<p>官网中虽然没有明确说明逃逸分析规则，但是有以下几点准则，是可以参考的：</p>
<ul>
<li>逃逸分析是在编译期间完成的，而不是在运行时;</li>
<li>如果变量在函数外部没有引用，则优先放到栈中；</li>
<li>如果变量在函数外部存在引用，则必定放在堆中；</li>
</ul>
<h2 id="3-几种常见的逃逸情况："><a href="#3-几种常见的逃逸情况：" class="headerlink" title="3.几种常见的逃逸情况："></a>3.几种常见的逃逸情况：</h2><p>我们可通过<code>go build -gcflags &#39;-m -l&#39;</code>命令来查看逃逸分析结果，其中-m 打印逃逸分析信息，-l禁止内联优化。</p>
<h3 id="3-1-指针逃逸"><a href="#3-1-指针逃逸" class="headerlink" title="3.1 指针逃逸"></a>3.1 指针逃逸</h3><p>如果一个函数内部创建了一个对象(局部变量)，但是在函数返回时是返回该对象的指针，那么该变量的生命周期就变了，即使当前函数执行结束了，但是变量的指针还在，并不是随着函数结束就被回收的，那么这个局部变量就会被分配在堆上，这就产生了指针逃逸。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(argVal <span class="type">int</span>)</span></span> *<span class="type">int</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> fooVal1 <span class="type">int</span> = <span class="number">11</span></span><br><span class="line">	<span class="keyword">var</span> fooVal2 <span class="type">int</span> = <span class="number">12</span></span><br><span class="line">	<span class="keyword">var</span> fooVal3 <span class="type">int</span> = <span class="number">13</span></span><br><span class="line">	<span class="keyword">var</span> fooVal4 <span class="type">int</span> = <span class="number">14</span></span><br><span class="line">	<span class="keyword">var</span> fooVal5 <span class="type">int</span> = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(&amp;argVal, &amp;fooVal1, &amp;fooVal2, &amp;fooVal3, &amp;fooVal4, &amp;fooVal5)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;fooVal3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mainVal := foo(<span class="number">666</span>)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">println</span>(*mainVal, mainVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">6</span>: moved to heap: fooVal3</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0xc000045f58</span> <span class="number">0xc000045f38</span> <span class="number">0xc000045f30</span> <span class="number">0xc00000e040</span> <span class="number">0xc000045f28</span> <span class="number">0xc000045f20</span></span><br><span class="line"><span class="number">13</span> <span class="number">0xc00000e040</span></span><br></pre></td></tr></table></figure>



<p>结果显示，逃逸分析结果显示fooVal3逃逸到了堆中，通过打印出来的变量地址我们可以发现，fooVal3的地址是0xc00000e040，与其他地址是不连续的。</p>
<h3 id="3-2-interface-动态类型逃逸"><a href="#3-2-interface-动态类型逃逸" class="headerlink" title="3.2 interface{} 动态类型逃逸"></a>3.2 interface{} 动态类型逃逸</h3><p>在golang中空接口interface{}可以是任意类型，因此编译器并不能确定其类型，所以也会被分配到堆上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> valA <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	valA = <span class="number">666</span></span><br><span class="line">	fmt.Println(&amp;valA)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: moved to heap: valA</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">7</span>: <span class="number">666</span> escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">13</span>: ... argument does not escape</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">0xc00004a230</span></span><br></pre></td></tr></table></figure>



<p>通过运行结果我们可以发现，interface{}变量varA逃逸到了堆中。</p>
<p>再来看下面这段程序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	varB := <span class="number">666</span></span><br><span class="line">	fmt.Println(varB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: varB escapes to heap</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">666</span></span><br></pre></td></tr></table></figure>

<p>可以看到，分析结果告诉我们变量varB逃逸到了堆上。但是，我们并没有外部引用啊，为什么也会有逃逸呢？为了看到更多细节，可以在语句中再添加一个-m参数：<code>go build -gcflags &#39;-m -m -l&#39;</code>。得到信息如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: varB escapes to heap:</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:   flow: &#123;storage <span class="keyword">for</span> ... argument&#125; = &amp;&#123;storage <span class="keyword">for</span> varB&#125;:</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from varB (spill) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from ... argument (slice-literal-element) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:   flow: &#123;heap&#125; = &#123;storage <span class="keyword">for</span> ... argument&#125;:</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from ... argument (spill) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>:     from fmt.Println(... argument...) (call parameter) at .\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">13</span>: varB escapes to heap</span><br></pre></td></tr></table></figure>

<p>varB逃逸是因为它被传入了fmt.Println的参数中，这个方法参数自己发生了逃逸。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>因为fmt.Println的函数参数为interface类型，编译期不能确定其参数的具体类型，所以将其分配于堆上。</p>
<h3 id="3-3-栈空间不足"><a href="#3-3-栈空间不足" class="headerlink" title="3.3 栈空间不足"></a>3.3 栈空间不足</h3><p>如果程序中需要分配一个空间比较大的局部变量，栈空间已经不够分配了，那么也会被分配到堆上。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		s[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">4</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">10000</span>, <span class="number">10000</span>) escapes to heap</span><br></pre></td></tr></table></figure>




<h3 id="3-4-变量大小不确定"><a href="#3-4-变量大小不确定" class="headerlink" title="3.4 变量大小不确定"></a>3.4 变量大小不确定</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	s := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		s[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	foo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">5</span>:<span class="number">11</span>: <span class="built_in">make</span>([]<span class="type">int</span>, n) escapes to heap</span><br></pre></td></tr></table></figure>



<h3 id="3-5-闭包"><a href="#3-5-闭包" class="headerlink" title="3.5 闭包"></a>3.5 闭包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>  &#123;</span><br><span class="line">	num := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		num++</span><br><span class="line">		<span class="keyword">return</span> num</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fn := Add()</span><br><span class="line">	fmt.Println(fn())</span><br><span class="line">	fmt.Println(fn())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">.\main.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">2</span>: moved to heap: num</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">9</span>: <span class="function"><span class="keyword">func</span> <span class="title">literal</span> <span class="title">escapes</span> <span class="title">to</span> <span class="title">heap</span></span></span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">14</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">14</span>:<span class="number">16</span>: fn() escapes to heap</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">13</span>: ... argument does not escape</span><br><span class="line">.\main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">16</span>: fn() escapes to heap</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上述代码块中，Add() 返回的是一个闭包，并且该闭包访问了外部变量num，那么num将会被分配到堆上，因为num此时生命周期已经不会随着Add() 函数的结束而被回收，直到 fn 被销毁，num才会被回收。</p>
<h2 id="4-传值还是传指针"><a href="#4-传值还是传指针" class="headerlink" title="4.传值还是传指针"></a>4.传值还是传指针</h2><p>传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。</p>
<p>一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>GORM 预加载和自引用</title>
    <url>/2022/11/02/Gorm/GORM%20%E9%A2%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%87%AA%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><h3 id="从传统的外键约束说起"><a href="#从传统的外键约束说起" class="headerlink" title="从传统的外键约束说起"></a>从传统的外键约束说起</h3><p>在传统的数据库设计中，如果我们想创建一个主表和从表，得在创建从表语句的时候添加外键约束（一般在创建的时候添加）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">CONSTRAINT</span>] [外键约束名称] <span class="keyword">FOREIGN</span> KEY(外键字段名) <span class="keyword">REFERENCES</span> 主表名(主键字段名)</span><br></pre></td></tr></table></figure>

<p>比如现在有一个部门表和一个员工表，他们之间是一对多关系，部门表是主表，员工表是从表。那么在创建员工表的时候，我们得为它添加上外键约束：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 先建立主表：department表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	dep_location <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#  创建从表 employee 并添加外键约束 emp_depid_fk</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">int</span>,</span><br><span class="line">	dep_id <span class="type">int</span>, <span class="comment">-- 外键对应主表的主键</span></span><br><span class="line">	<span class="comment">-- 创建外键约束</span></span><br><span class="line">	<span class="keyword">constraint</span> emp_depid_fk <span class="keyword">foreign</span> key (dep_id) <span class="keyword">references</span> department(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但是这样做存在一些问题，因为数据表的设计一般是在项目开发的起始阶段，我们不太可能一开始就把数据表设计的很完美，后期可能会对数据表之间的关系做一些调整，而添加外键约束无疑是提前把数据表之间的关系给写死了（如果没有添加级联操作的话），耦合度比较低。</p>
<h3 id="ORM数据库"><a href="#ORM数据库" class="headerlink" title="ORM数据库"></a>ORM数据库</h3><p>ORM数据库就考虑到了这一点，我们以GORM框架举例。在创建数据表的时候，可以不用对数据表添加任何约束，而是把这项任务延后到了创建models的时候，降低了耦合度，后期可以直接修改代码而不用去修改数据库。</p>
<p>我们来举一个例子，假如现在要创建三张数据表，学生表与成绩表是多对一，成绩表与课程表之间是一对多：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE test01;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">	sno <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade (</span><br><span class="line">	sno <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	grade <span class="type">INT</span>,</span><br><span class="line">	cno <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course (</span><br><span class="line">	cno <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	cname <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(&quot;01&quot;, &quot;张三&quot;, <span class="number">19</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(&quot;02&quot;, &quot;李四&quot;, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(&quot;02&quot;, &quot;王五&quot;, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;01&quot;, <span class="number">90</span>, &quot;0001&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;01&quot;, <span class="number">80</span>, &quot;0002&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;01&quot;, <span class="number">30</span>, &quot;0003&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;02&quot;, <span class="number">80</span>, &quot;0001&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;02&quot;, <span class="number">50</span>, &quot;0002&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;02&quot;, <span class="number">60</span>, &quot;0003&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(&quot;0001&quot;, &quot;数学&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(&quot;0002&quot;, &quot;语文&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(&quot;0003&quot;, &quot;英语&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/07f22e546be041899e4743e3d7460cd6.png" alt="在这里插入图片描述"></p>
<p>我们在创建数据表的时候没有指定任何约束，而是把这项工作延后到了创建models的时候：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sno <span class="type">string</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Grades []grade <span class="string">`gorm:&quot;foreignKey:Sno;association_foreignkey:Sno&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(student)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;student&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> grade <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sno <span class="type">string</span></span><br><span class="line">	Grade <span class="type">int</span></span><br><span class="line">	Cno <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(grade)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;grade&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> course <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cno <span class="type">string</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">	Cname <span class="type">string</span></span><br><span class="line">	Grades []grade <span class="string">`gorm:&quot;foreignKey:Cno;association_foreignkey:Cno&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(course)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;course&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主表中，我们创建了从表映射结构体的切片，然后使用结构体tag来指定外键约束的字段，使用这种方式来表达主表和从表之间的关系。</p>
<h3 id="预加载-1"><a href="#预加载-1" class="headerlink" title="预加载"></a>预加载</h3><p>创建好models以后，我们试着使用查询语句来查询表中的信息，比如查询学生表中张三的信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> st student</span><br><span class="line">db.Where(<span class="string">&quot;Name=?&quot;</span>, <span class="string">&quot;张三&quot;</span>).Find(&amp;st)</span><br><span class="line"><span class="comment">// &#123;01 张三 19 []&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以发现，虽然学号、姓名和年龄都被打印出来了，但是从表的信息却没有打印出来，虽然在一般情况下，从表的信息是不用打印出来的，但是我们在student结构体中声明了Grades字段，这个字段的值按道理是应该和其他字段一样被打印出来的。</p>
<p>这个时候就需要使用预加载了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Preload(<span class="string">&quot;Grades&quot;</span>).Where(<span class="string">&quot;Name=?&quot;</span>, <span class="string">&quot;张三&quot;</span>).Find(&amp;st)</span><br><span class="line"><span class="comment">// &#123;01 张三 19 [&#123;01 90 0001&#125; &#123;01 80 0002&#125; &#123;01 30 0003&#125;]&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Preload</code>中指定的是映射结构体中的切片字段名。</p>
<p><strong>自定义预加载</strong></p>
<p>我们还可以自定义预加载，比如我们只想显示张三的数学成绩：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Preload(<span class="string">&quot;Grades&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(db *gorm.DB)</span></span> *gorm.DB &#123;</span><br><span class="line">		<span class="comment">// 原生的sql语句, 这里的sno和cno是数据库中的字段，不是结构体中的字段</span></span><br><span class="line">		<span class="keyword">return</span> db.Where(<span class="string">&quot;sno=? and cno=?&quot;</span>, <span class="string">&quot;01&quot;</span>, <span class="string">&quot;0001&quot;</span>)</span><br><span class="line">	&#125;).Where(<span class="string">&quot;Name=?&quot;</span>, <span class="string">&quot;张三&quot;</span>).Find(&amp;st)</span><br><span class="line"><span class="comment">// &#123;01 张三 19 [&#123;01 90 0001&#125;]&#125;</span></span><br></pre></td></tr></table></figure>


<h2 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h2><p>假如现在有一张员工表：</p>
<p><img src="https://img-blog.csdnimg.cn/fad75b2d680f41cca9d8f341f73d41a6.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee (</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	lid <span class="type">INT</span>,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">0</span>, &quot;领导&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="number">1</span>, &quot;员工1&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="number">1</span>, &quot;员工2&quot;);</span><br></pre></td></tr></table></figure>


<p>三个字段分别是员工编号、领导编号和员工姓名，某条数据的lid可能是另一条数据的id，即一个员工可能是另一个员工的领导，一张表中的数据构成了一对多关系，这就是自引用。</p>
<p>在models中可以这样来写tag：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id <span class="type">int</span></span><br><span class="line">	Lid <span class="type">int</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Employees []employee <span class="string">`gorm:&quot;foreignkey:Lid;association_foreignkey:Id&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(employee)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;employee&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们可以使用预加载来打印领导的信息：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emp employee</span><br><span class="line">db.Preload(<span class="string">&quot;Employees&quot;</span>).Where(<span class="string">&quot;Name=?&quot;</span>, <span class="string">&quot;领导&quot;</span>).Find(&amp;emp)</span><br><span class="line">fmt.Println(emp)</span><br><span class="line"><span class="comment">// &#123;1 0 领导 [&#123;2 1 员工1 []&#125; &#123;3 1 员工2 []&#125;]&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Gorm</category>
      </categories>
  </entry>
  <entry>
    <title>GORM CRUD操作</title>
    <url>/2022/11/02/Gorm/GORM%20CRUD%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>首先要连接到数据库：<br>本文中的<code>db</code>变量为 <code>*gorm.DB</code>对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:123456@(127.0.0.1:3306)/db6?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!= <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><h3 id="创建记录"><a href="#创建记录" class="headerlink" title="创建记录"></a>创建记录</h3><p>首先定义模型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="type">int64</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用<code>NewRecord()</code>查询主键是否存在，主键为空使用<code>Create()</code>创建记录。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;zhangsan&quot;</span>, Age: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">db.NewRecord(user)  <span class="comment">//主键为空返回`true`</span></span><br><span class="line">db.Create(&amp;user)  	<span class="comment">//创建user</span></span><br><span class="line">db.NewRecord(user) <span class="comment">//创建`user`后返回`false`</span></span><br></pre></td></tr></table></figure>




<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>可以通过tag定义字段的默认值，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="type">int64</span></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`gorm:&quot;default:&#x27;张三&#x27;&quot;`</span></span><br><span class="line">	Age <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>注意：通过tag定义字段的默认值，在创建记录时候生成的 SQL 语句会排除没有值或值为 零值 的字段。 在将记录插入到数据库后，Gorm会从数据库加载那些字段的默认值。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = USer&#123;Name: <span class="string">&quot;&quot;</span>, Age: <span class="number">99</span>&#125;</span><br><span class="line">db.Create(&amp;user)</span><br></pre></td></tr></table></figure>



<p>上面代码执行的SQL语句是 <code>INSERT INTO users(&quot;age&quot;) values(&#39;99&#39;);</code> ，排除了零值字段<code>Name </code> ，而在数据库中这一条数据会使用默认值<code>张三</code>作为<code>Name</code>字段的值。</p>
<p>注意：所有字段的零值, 比如<code>0</code>,<code> &quot;&quot;</code>,<code>false</code>或者其它<code>零值</code>，都不会保存到数据库内，但会使用他们的默认值。 如果你想避免这种情况，可以考虑使用指针或实现 <code>Scanner/Valuer</code>接口，比如：</p>
<p>使用指针方式实现零值存入数据库:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int64</span></span><br><span class="line">  Name *<span class="type">string</span> <span class="string">`gorm:&quot;default:&#x27;张三&#x27;&quot;`</span></span><br><span class="line">  Age  <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: <span class="built_in">new</span>(<span class="type">string</span>), Age: <span class="number">18</span>))&#125;</span><br><span class="line">db.Create(&amp;user)  <span class="comment">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<p>使用Scanner&#x2F;Valuer接口方式实现零值存入数据库:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Scanner/Valuer</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="type">int64</span></span><br><span class="line">	Name sql.NullString <span class="string">`gorm:&quot;default:&#x27;小王子&#x27;&quot;`</span> <span class="comment">// sql.NullString 实现了Scanner/Valuer接口</span></span><br><span class="line">	Age  <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;Name: sql.NullString&#123;<span class="string">&quot;&quot;</span>, <span class="literal">true</span>&#125;, Age:<span class="number">18</span>&#125;</span><br><span class="line">db.Create(&amp;user)  <span class="comment">// 此时数据库中该条记录name字段的值就是&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="扩展创建选项"><a href="#扩展创建选项" class="headerlink" title="扩展创建选项"></a>扩展创建选项</h3><p>例如<code>PostgreSQL</code>数据库中可以使用下面的方式实现合并插入,有则更新，无则插入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为Instert语句添加扩展SQL选项</span></span><br><span class="line">db.Set(<span class="string">&quot;gorm:insert_option&quot;</span>, <span class="string">&quot;ON CONFLICT&quot;</span>).Create(&amp;product)</span><br><span class="line"><span class="comment">// INSERT INTO products (name, code) VALUES (&quot;name&quot;, &quot;code&quot;) ON CONFLICT;</span></span><br></pre></td></tr></table></figure>




<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="一般查询"><a href="#一般查询" class="headerlink" title="一般查询"></a>一般查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 根据主键查询第一条记录</span><br><span class="line">db.First(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 随机获取一条记录</span><br><span class="line">db.Take(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 根据主键查询最后一条记录</span><br><span class="line">db.Last(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">ORDER</span> <span class="keyword">BY</span> id <span class="keyword">DESC</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询所有的记录</span><br><span class="line">db.Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询指定的某条记录(仅当主键为整型时可用)</span><br><span class="line">db.First(<span class="operator">&amp;</span><span class="keyword">user</span>, <span class="number">10</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>




<h3 id="Where条件"><a href="#Where条件" class="headerlink" title="Where条件"></a>Where条件</h3><p><strong>普通SQL查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Get</span> <span class="keyword">first</span> matched record</span><br><span class="line">db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> limit <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Get</span> <span class="keyword">all</span> matched records</span><br><span class="line">db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="operator">&lt;&gt;</span></span><br><span class="line">db.Where(&quot;name &lt;&gt; ?&quot;, &quot;jinzhu&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">&lt;&gt;</span> <span class="string">&#x27;jinzhu&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">IN</span></span><br><span class="line">db.Where(&quot;name IN (?)&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">in</span> (<span class="string">&#x27;jinzhu&#x27;</span>,<span class="string">&#x27;jinzhu 2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">LIKE</span></span><br><span class="line">db.Where(&quot;name LIKE ?&quot;, &quot;%jin%&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%jin%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">AND</span></span><br><span class="line">db.Where(&quot;name = ? AND age &gt;= ?&quot;, &quot;jinzhu&quot;, &quot;22&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;=</span> <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="type">Time</span></span><br><span class="line">db.Where(&quot;updated_at &gt; ?&quot;, lastWeek).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> updated_at <span class="operator">&gt;</span> <span class="string">&#x27;2000-01-01 00:00:00&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">BETWEEN</span></span><br><span class="line">db.Where(&quot;created_at BETWEEN ? AND ?&quot;, lastWeek, today).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> created_at <span class="keyword">BETWEEN</span> <span class="string">&#x27;2000-01-01 00:00:00&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2000-01-08 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>




<p><strong>Struct &amp; Map查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Struct</span><br><span class="line">db.Where(<span class="operator">&amp;</span><span class="keyword">User</span>&#123;Name: &quot;jinzhu&quot;, Age: <span class="number">20</span>&#125;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;jinzhu&quot; <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">20</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Map</span><br><span class="line">db.Where(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu&quot;, &quot;age&quot;: <span class="number">20</span>&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;jinzhu&quot; <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 主键的切片</span><br><span class="line">db.Where([]int64&#123;<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>



<p>提示：当通过结构体进行查询时，GORM将会只通过非零值字段查询，这意味着如果你的字段值为<code>0</code>，<code>&#39;&#39;</code>，<code>false</code>或者其他零值时，将不会被用于构建查询条件，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Where(<span class="operator">&amp;</span><span class="keyword">User</span>&#123;Name: &quot;jinzhu&quot;, Age: <span class="number">0</span>&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;jinzhu&quot;;</span><br></pre></td></tr></table></figure>



<p>你可以使用指针或实现 Scanner&#x2F;Valuer 接口来避免这个问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用指针</span><br><span class="line">type <span class="keyword">User</span> struct &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name string</span><br><span class="line">  Age  <span class="operator">*</span><span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用 Scanner<span class="operator">/</span>Valuer</span><br><span class="line">type <span class="keyword">User</span> struct &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name string</span><br><span class="line">  Age  sql.NullInt64  <span class="operator">/</span><span class="operator">/</span> sql.NullInt64 实现了 Scanner<span class="operator">/</span>Valuer 接口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Not-条件"><a href="#Not-条件" class="headerlink" title="Not 条件"></a>Not 条件</h3><p>作用与Where类似的情形如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Not(&quot;name&quot;, &quot;jinzhu&quot;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">&lt;&gt;</span> &quot;jinzhu&quot; LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Not</span> <span class="keyword">In</span></span><br><span class="line">db.Not(&quot;name&quot;, []string&#123;&quot;jinzhu&quot;, &quot;jinzhu 2&quot;&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">NOT</span> <span class="keyword">IN</span> (&quot;jinzhu&quot;, &quot;jinzhu 2&quot;);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Not</span> <span class="keyword">In</span> slice <span class="keyword">of</span> <span class="keyword">primary</span> keys</span><br><span class="line">db.Not([]int64&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">db.Not([]int64&#123;&#125;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Plain <span class="keyword">SQL</span></span><br><span class="line">db.Not(&quot;name = ?&quot;, &quot;jinzhu&quot;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> <span class="keyword">NOT</span>(name <span class="operator">=</span> &quot;jinzhu&quot;);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Struct</span><br><span class="line">db.Not(<span class="keyword">User</span>&#123;Name: &quot;jinzhu&quot;&#125;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">&lt;&gt;</span> &quot;jinzhu&quot;;</span><br></pre></td></tr></table></figure>




<h3 id="Or条件"><a href="#Or条件" class="headerlink" title="Or条件"></a>Or条件</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Where(&quot;role = ?&quot;, &quot;admin&quot;).<span class="keyword">Or</span>(&quot;role = ?&quot;, &quot;super_admin&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> role <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="keyword">OR</span> role <span class="operator">=</span> <span class="string">&#x27;super_admin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Struct</span><br><span class="line">db.Where(&quot;name = &#x27;jinzhu&#x27;&quot;).<span class="keyword">Or</span>(<span class="keyword">User</span>&#123;Name: &quot;jinzhu 2&quot;&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu 2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Map</span><br><span class="line">db.Where(&quot;name = &#x27;jinzhu&#x27;&quot;).<span class="keyword">Or</span>(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu 2&quot;&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu 2&#x27;</span>;</span><br></pre></td></tr></table></figure>




<h3 id="内联条件"><a href="#内联条件" class="headerlink" title="内联条件"></a>内联条件</h3><p>作用与<code>Where</code>查询类似，当内联条件与多个立即执行方法一起使用时, 内联条件不会传递给后面的立即执行方法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 根据主键获取记录 (只适用于整形主键)</span><br><span class="line">db.First(<span class="operator">&amp;</span><span class="keyword">user</span>, <span class="number">23</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">23</span> LIMIT <span class="number">1</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 根据主键获取记录, 如果它是一个非整形主键</span><br><span class="line">db.First(<span class="operator">&amp;</span><span class="keyword">user</span>, &quot;id = ?&quot;, &quot;string_primary_key&quot;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="string">&#x27;string_primary_key&#x27;</span> LIMIT <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Plain <span class="keyword">SQL</span></span><br><span class="line">db.Find(<span class="operator">&amp;</span><span class="keyword">user</span>, &quot;name = ?&quot;, &quot;jinzhu&quot;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;jinzhu&quot;;</span><br><span class="line"></span><br><span class="line">db.Find(<span class="operator">&amp;</span>users, &quot;name &lt;&gt; ? AND age &gt; ?&quot;, &quot;jinzhu&quot;, <span class="number">20</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">&lt;&gt;</span> &quot;jinzhu&quot; <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Struct</span><br><span class="line">db.Find(<span class="operator">&amp;</span>users, <span class="keyword">User</span>&#123;Age: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Map</span><br><span class="line">db.Find(<span class="operator">&amp;</span>users, map[string]interface&#123;&#125;&#123;&quot;age&quot;: <span class="number">20</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="额外查询选项"><a href="#额外查询选项" class="headerlink" title="额外查询选项"></a>额外查询选项</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 为查询 <span class="keyword">SQL</span> 添加额外的 <span class="keyword">SQL</span> 操作</span><br><span class="line">db.Set(&quot;gorm:query_option&quot;, &quot;FOR UPDATE&quot;).<span class="keyword">First</span>(<span class="operator">&amp;</span><span class="keyword">user</span>, <span class="number">10</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>



<h3 id="FirstOrInit"><a href="#FirstOrInit" class="headerlink" title="FirstOrInit"></a>FirstOrInit</h3><p>获取匹配的第一条记录，否则根据给定的条件初始化一个新的对象 (仅支持 struct 和 map 条件)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 未找到</span><br><span class="line">db.FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>, <span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;Jinzhu&quot;&#125;).FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">111</span>, Name: &quot;Jinzhu&quot;, Age: <span class="number">20</span>&#125;</span><br><span class="line">db.FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>, map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;jinzhu&quot;&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">111</span>, Name: &quot;Jinzhu&quot;, Age: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Attrs</strong></p>
<p>如果记录未找到，将使用参数初始化 struct。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 未找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;).Attrs(<span class="keyword">User</span>&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> USERS <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;non_existing&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;, Age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;).Attrs(&quot;age&quot;, <span class="number">20</span>).FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> USERS <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;non_existing&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;, Age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;Jinzhu&quot;&#125;).Attrs(<span class="keyword">User</span>&#123;Age: <span class="number">30</span>&#125;).FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> USERS <span class="keyword">WHERE</span> name <span class="operator">=</span> jinzhu<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 20&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>Assign</strong></p>
<p>不管记录是否找到，都将参数赋值给 struct。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 未找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;).Assign(<span class="keyword">User</span>&#123;Age: <span class="number">20</span>&#125;).FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;, Age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;Jinzhu&quot;&#125;).Assign(<span class="keyword">User</span>&#123;Age: <span class="number">30</span>&#125;).FirstOrInit(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> USERS <span class="keyword">WHERE</span> name <span class="operator">=</span> jinzhu<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">//// user -&gt; User&#123;Id: 111, Name: &quot;Jinzhu&quot;, Age: 30&#125;</span></span><br></pre></td></tr></table></figure>




<h3 id="FirstOrCreate"><a href="#FirstOrCreate" class="headerlink" title="FirstOrCreate"></a>FirstOrCreate</h3><p>获取匹配的第一条记录, 否则根据给定的条件创建一个新的记录 (仅支持 struct 和 map 条件)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 未找到</span><br><span class="line">db.FirstOrCreate(<span class="operator">&amp;</span><span class="keyword">user</span>, <span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> &quot;users&quot; (name) <span class="keyword">VALUES</span> (&quot;non_existing&quot;);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">112</span>, Name: &quot;non_existing&quot;&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;Jinzhu&quot;&#125;).FirstOrCreate(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">111</span>, Name: &quot;Jinzhu&quot;&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Attrs</strong></p>
<p>如果记录未找到，将使用参数创建 struct 和记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="operator">/</span><span class="operator">/</span> 未找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;).Attrs(<span class="keyword">User</span>&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;non_existing&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> &quot;users&quot; (name, age) <span class="keyword">VALUES</span> (&quot;non_existing&quot;, <span class="number">20</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">112</span>, Name: &quot;non_existing&quot;, Age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;jinzhu&quot;&#125;).Attrs(<span class="keyword">User</span>&#123;Age: <span class="number">30</span>&#125;).FirstOrCreate(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">111</span>, Name: &quot;jinzhu&quot;, Age: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Assign</strong></p>
<p>不管记录是否找到，都将参数赋值给 struct 并保存至数据库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 未找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;non_existing&quot;&#125;).Assign(<span class="keyword">User</span>&#123;Age: <span class="number">20</span>&#125;).FirstOrCreate(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;non_existing&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> &quot;users&quot; (name, age) <span class="keyword">VALUES</span> (&quot;non_existing&quot;, <span class="number">20</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">112</span>, Name: &quot;non_existing&quot;, Age: <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 找到</span><br><span class="line">db.Where(<span class="keyword">User</span>&#123;Name: &quot;jinzhu&quot;&#125;).Assign(<span class="keyword">User</span>&#123;Age: <span class="number">30</span>&#125;).FirstOrCreate(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">30</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">user</span> <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">User</span>&#123;Id: <span class="number">111</span>, Name: &quot;jinzhu&quot;, Age: <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>





<h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><p><strong>子查询</strong></p>
<p>基于 <code>*gorm.expr</code> 的子查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Where(&quot;amount &gt; ?&quot;, db.Table(&quot;orders&quot;).<span class="keyword">Select</span>(&quot;AVG(amount)&quot;).<span class="keyword">Where</span>(&quot;state = ?&quot;, &quot;paid&quot;).SubQuery()).Find(<span class="operator">&amp;</span>orders)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> &quot;orders&quot;  <span class="keyword">WHERE</span> &quot;orders&quot;.&quot;deleted_at&quot; <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> (amount <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(amount) <span class="keyword">FROM</span> &quot;orders&quot;  <span class="keyword">WHERE</span> (state <span class="operator">=</span> <span class="string">&#x27;paid&#x27;</span>)));</span><br></pre></td></tr></table></figure>



<p><strong>选择字段</strong></p>
<p>Select，指定你想从数据库中检索出的字段，默认会选择全部字段。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Select(&quot;name, age&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line">db.Select([]string&#123;&quot;name&quot;, &quot;age&quot;&#125;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> name, age <span class="keyword">FROM</span> users;</span><br><span class="line"></span><br><span class="line">db.Table(&quot;users&quot;).<span class="keyword">Select</span>(&quot;COALESCE(age,?)&quot;, <span class="number">42</span>).<span class="keyword">Rows</span>()</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(age,<span class="string">&#x27;42&#x27;</span>) <span class="keyword">FROM</span> users;</span><br></pre></td></tr></table></figure>



<p><strong>排序</strong></p>
<p>Order，指定从数据库中检索出记录的顺序。设置第二个参数 reorder 为 true ，可以覆盖前面定义的排序条件。</p>
<p><strong>数量</strong></p>
<p>Limit，指定从数据库检索出的最大记录数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Limit(<span class="number">3</span>).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users LIMIT <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="number">-1</span> 取消 Limit 条件</span><br><span class="line">db.Limit(<span class="number">10</span>).Find(<span class="operator">&amp;</span>users1).Limit(<span class="number">-1</span>).Find(<span class="operator">&amp;</span>users2)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users LIMIT <span class="number">10</span>; (users1)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users; (users2)</span><br></pre></td></tr></table></figure>



<p><strong>偏移</strong></p>
<p>Offset，指定开始返回记录前要跳过的记录数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Offset(<span class="number">3</span>).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">OFFSET</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="number">-1</span> 取消 <span class="keyword">Offset</span> 条件</span><br><span class="line">db.Offset(<span class="number">10</span>).Find(<span class="operator">&amp;</span>users1).<span class="keyword">Offset</span>(<span class="number">-1</span>).Find(<span class="operator">&amp;</span>users2)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">OFFSET</span> <span class="number">10</span>; (users1)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users; (users2)</span><br></pre></td></tr></table></figure>



<p><strong>总数</strong></p>
<p>Count，该 model 能获取的记录总数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;).<span class="keyword">Or</span>(&quot;name = ?&quot;, &quot;jinzhu 2&quot;).Find(<span class="operator">&amp;</span>users).<span class="built_in">Count</span>(<span class="operator">&amp;</span>count)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> USERS <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu 2&#x27;</span>; (users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu 2&#x27;</span>; (count)</span><br><span class="line"></span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">User</span>&#123;&#125;).<span class="keyword">Where</span>(&quot;name = ?&quot;, &quot;jinzhu&quot;).<span class="built_in">Count</span>(<span class="operator">&amp;</span>count)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span>; (count)</span><br><span class="line"></span><br><span class="line">db.Table(&quot;deleted_users&quot;).<span class="built_in">Count</span>(<span class="operator">&amp;</span>count)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> deleted_users;</span><br><span class="line"></span><br><span class="line">db.Table(&quot;deleted_users&quot;).<span class="keyword">Select</span>(&quot;count(distinct(name))&quot;).<span class="built_in">Count</span>(<span class="operator">&amp;</span>count)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="built_in">count</span>( <span class="keyword">distinct</span>(name) ) <span class="keyword">FROM</span> deleted_users; (count)</span><br></pre></td></tr></table></figure>



<p>注意 <code>Count</code> 必须是链式查询的最后一个操作 ，因为它会覆盖前面的 <code>SELECT</code>，但如果里面使用了<code>count</code>时不会覆盖。</p>
<p><strong>Group &amp; Having</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span>, err :<span class="operator">=</span> db.Table(&quot;orders&quot;).<span class="keyword">Select</span>(&quot;date(created_at) as date, sum(amount) as total&quot;).<span class="keyword">Group</span>(&quot;date(created_at)&quot;).<span class="keyword">Rows</span>()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用Scan将多条结果扫描进事先准备好的结构体切片中</span><br><span class="line">type <span class="keyword">Result</span> struct &#123;</span><br><span class="line">	<span class="type">Date</span> time.Time</span><br><span class="line">	Total <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">var rets []<span class="keyword">Result</span></span><br><span class="line">db.Table(&quot;users&quot;).<span class="keyword">Select</span>(&quot;date(created_at) as date, sum(age) as total&quot;).<span class="keyword">Group</span>(&quot;date(created_at)&quot;).Scan(<span class="operator">&amp;</span>rets)</span><br><span class="line"></span><br><span class="line"><span class="keyword">rows</span>, err :<span class="operator">=</span> db.Table(&quot;orders&quot;).<span class="keyword">Select</span>(&quot;date(created_at) as date, sum(amount) as total&quot;).<span class="keyword">Group</span>(&quot;date(created_at)&quot;).<span class="keyword">Having</span>(&quot;sum(amount) &gt; ?&quot;, <span class="number">100</span>).<span class="keyword">Rows</span>()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="keyword">Result</span> struct &#123;</span><br><span class="line">  <span class="type">Date</span>  time.Time</span><br><span class="line">  Total int64</span><br><span class="line">&#125;</span><br><span class="line">db.Table(&quot;orders&quot;).<span class="keyword">Select</span>(&quot;date(created_at) as date, sum(amount) as total&quot;).<span class="keyword">Group</span>(&quot;date(created_at)&quot;).<span class="keyword">Having</span>(&quot;sum(amount) &gt; ?&quot;, <span class="number">100</span>).Scan(<span class="operator">&amp;</span>results)</span><br></pre></td></tr></table></figure>




<h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>Joins，指定连接条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span>, err :<span class="operator">=</span> db.Table(&quot;users&quot;).<span class="keyword">Select</span>(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).<span class="keyword">Rows</span>()</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Table(&quot;users&quot;).<span class="keyword">Select</span>(&quot;users.name, emails.email&quot;).Joins(&quot;left join emails on emails.user_id = users.id&quot;).Scan(<span class="operator">&amp;</span>results)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 多连接及参数</span><br><span class="line">db.Joins(&quot;JOIN emails ON emails.user_id = users.id AND emails.email = ?&quot;, &quot;jinzhu@example.org&quot;).Joins(&quot;JOIN credit_cards ON credit_cards.user_id = users.id&quot;).<span class="keyword">Where</span>(&quot;credit_cards.number = ?&quot;, &quot;411111111111&quot;).Find(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br></pre></td></tr></table></figure>

<p><strong>样例</strong></p>
<p>首先我们在mysql中创建了三张表：</p>
<p><img src="https://img-blog.csdnimg.cn/bc9f3670f9ab4f8dbbc1547b91abb9f6.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE test01;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">	sno <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> grade (</span><br><span class="line">	sno <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	grade <span class="type">INT</span>,</span><br><span class="line">	cno <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course (</span><br><span class="line">	cno <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">	cname <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(&quot;01&quot;, &quot;张三&quot;, <span class="number">19</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(&quot;02&quot;, &quot;李四&quot;, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(&quot;02&quot;, &quot;王五&quot;, <span class="number">21</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;01&quot;, <span class="number">90</span>, &quot;0001&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;01&quot;, <span class="number">80</span>, &quot;0002&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;01&quot;, <span class="number">30</span>, &quot;0003&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;02&quot;, <span class="number">80</span>, &quot;0001&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;02&quot;, <span class="number">50</span>, &quot;0002&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> grade <span class="keyword">VALUES</span>(&quot;02&quot;, <span class="number">60</span>, &quot;0003&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(&quot;0001&quot;, &quot;数学&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(&quot;0002&quot;, &quot;语文&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> course <span class="keyword">VALUES</span>(&quot;0003&quot;, &quot;英语&quot;);</span><br></pre></td></tr></table></figure>

<p>目标是查询张三所有课程的成绩，要求显示学生姓名、课程名和分数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建映射结构体</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sno <span class="type">string</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Grades []grade <span class="string">`gorm:&quot;foreignKey:Sno;association_foreignkey:Sno&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(student)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;student&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> grade <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sno <span class="type">string</span></span><br><span class="line">	Grade <span class="type">int</span></span><br><span class="line">	Cno <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(grade)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;grade&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> course <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cno <span class="type">string</span></span><br><span class="line">	Cname <span class="type">string</span></span><br><span class="line">	Grades []grade <span class="string">`gorm:&quot;foreignKey:Cno&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(course)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;course&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> result <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Cname <span class="type">string</span></span><br><span class="line">	Grade <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询语句</span></span><br><span class="line"><span class="keyword">var</span> res []result</span><br><span class="line">	<span class="comment">// 注意：Select里面是原生的sql语句，这里的字段名是数据库中的字段名而不是model结构体中的字段名</span></span><br><span class="line">	db.Table(<span class="string">&quot;student&quot;</span>).Select(<span class="string">&quot;student.name, course.cname, grade.grade&quot;</span>).</span><br><span class="line">		Joins(<span class="string">&quot;join grade on student.Sno=grade.Sno&quot;</span>).Where(<span class="string">&quot;student.Name=?&quot;</span>, <span class="string">&quot;张三&quot;</span>).</span><br><span class="line">		Joins(<span class="string">&quot;join course on course.Cno=grade.Cno&quot;</span>).Scan(&amp;res)</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>




<h3 id="Pluck"><a href="#Pluck" class="headerlink" title="Pluck"></a>Pluck</h3><p>Pluck，查询 model 中的一个列作为切片，如果您想要查询多个列, 您应该使用 <code>Scan</code> 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">var ages []int64</span><br><span class="line">db.Find(<span class="operator">&amp;</span>users).Pluck(&quot;age&quot;, <span class="operator">&amp;</span>ages)</span><br><span class="line"></span><br><span class="line">var names []string</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">User</span>&#123;&#125;).Pluck(&quot;name&quot;, <span class="operator">&amp;</span>names)</span><br><span class="line"></span><br><span class="line">db.Table(&quot;deleted_users&quot;).Pluck(&quot;name&quot;, <span class="operator">&amp;</span>names)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 想查询多个字段？ 这样做：</span><br><span class="line">db.Select(&quot;name, age&quot;).Find(<span class="operator">&amp;</span>users)</span><br></pre></td></tr></table></figure>



<h3 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h3><p>Scan，扫描结果至一个 struct。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">type <span class="keyword">Result</span> struct &#123;</span><br><span class="line">  Name string</span><br><span class="line">  Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="keyword">result</span> <span class="keyword">Result</span></span><br><span class="line">db.Table(&quot;users&quot;).<span class="keyword">Select</span>(&quot;name, age&quot;).<span class="keyword">Where</span>(&quot;name = ?&quot;, &quot;Antonio&quot;).Scan(<span class="operator">&amp;</span><span class="keyword">result</span>)</span><br><span class="line"></span><br><span class="line">var results []<span class="keyword">Result</span></span><br><span class="line">db.Table(&quot;users&quot;).<span class="keyword">Select</span>(&quot;name, age&quot;).<span class="keyword">Where</span>(&quot;id &gt; ?&quot;, <span class="number">0</span>).Scan(<span class="operator">&amp;</span>results)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 原生 <span class="keyword">SQL</span></span><br><span class="line">db.Raw(&quot;SELECT name, age FROM users WHERE name = ?&quot;, &quot;Antonio&quot;).Scan(<span class="operator">&amp;</span><span class="keyword">result</span>)</span><br></pre></td></tr></table></figure>




<h2 id="链式操作相关"><a href="#链式操作相关" class="headerlink" title="链式操作相关"></a>链式操作相关</h2><h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><p>Method Chaining，Gorm 实现了链式操作接口，所以你可以把代码写成这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 创建一个查询</span><br><span class="line">tx :<span class="operator">=</span> db.Where(&quot;name = ?&quot;, &quot;jinzhu&quot;)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 添加更多条件</span><br><span class="line">if someCondition &#123;</span><br><span class="line">  tx <span class="operator">=</span> tx.Where(&quot;age = ?&quot;, <span class="number">20</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  tx <span class="operator">=</span> tx.Where(&quot;age = ?&quot;, <span class="number">30</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if yetAnotherCondition &#123;</span><br><span class="line">  tx <span class="operator">=</span> tx.Where(&quot;active = ?&quot;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在调用立即执行方法前不会生成Query语句，借助这个特性你可以创建一个函数来处理一些通用逻辑。</p>
<h3 id="立即执行方法"><a href="#立即执行方法" class="headerlink" title="立即执行方法"></a>立即执行方法</h3><p>Immediate methods ，立即执行方法是指那些会立即生成<code>SQL</code>语句并发送到数据库的方法, 他们一般是<code>CRUD</code>方法，比如：</p>
<p><code>Create</code>, <code>First</code>, <code>Find</code>, <code>Take</code>, <code>Save</code>, <code>UpdateXXX</code>, <code>Delete</code>, <code>Scan</code>, <code>Row</code>, <code>Rows</code>…</p>
<p>这有一个基于上面链式方法代码的立即执行方法的例子：</p>
<p>这有一个基于上面链式方法代码的立即执行方法的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">tx.Find(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br></pre></td></tr></table></figure>



<p>生成的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;jinzhu&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">AND</span> active <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p><code>Scopes</code>，Scope是建立在链式操作的基础之上的。</p>
<p>基于它，你可以抽取一些通用逻辑，写出更多可重用的函数库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">func AmountGreaterThan1000(db <span class="operator">*</span>gorm.DB) <span class="operator">*</span>gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(&quot;amount &gt; ?&quot;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PaidWithCreditCard(db <span class="operator">*</span>gorm.DB) <span class="operator">*</span>gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(&quot;pay_mode_sign = ?&quot;, &quot;C&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PaidWithCod(db <span class="operator">*</span>gorm.DB) <span class="operator">*</span>gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> db.Where(&quot;pay_mode_sign = ?&quot;, &quot;C&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func OrderStatus(status []string) func (db <span class="operator">*</span>gorm.DB) <span class="operator">*</span>gorm.DB &#123;</span><br><span class="line">  <span class="keyword">return</span> func (db <span class="operator">*</span>gorm.DB) <span class="operator">*</span>gorm.DB &#123;</span><br><span class="line">    <span class="keyword">return</span> db.Scopes(AmountGreaterThan1000).<span class="keyword">Where</span>(&quot;status IN (?)&quot;, status)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(<span class="operator">&amp;</span>orders)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查找所有金额大于 <span class="number">1000</span> 的信用卡订单</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(<span class="operator">&amp;</span>orders)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查找所有金额大于 <span class="number">1000</span> 的 COD 订单</span><br><span class="line"></span><br><span class="line">db.Scopes(AmountGreaterThan1000, OrderStatus([]string&#123;&quot;paid&quot;, &quot;shipped&quot;&#125;)).Find(<span class="operator">&amp;</span>orders)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查找所有金额大于 <span class="number">1000</span> 且已付款或者已发货的订单</span><br></pre></td></tr></table></figure>



<h3 id="多个立即执行方法"><a href="#多个立即执行方法" class="headerlink" title="多个立即执行方法"></a>多个立即执行方法</h3><p>Multiple Immediate Methods，在 GORM 中使用多个立即执行方法时，后一个立即执行方法会复用前一个立即执行方法的条件 (不包括内联条件) 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Where(&quot;name LIKE ?&quot;, &quot;jinzhu%&quot;).Find(<span class="operator">&amp;</span>users, &quot;id IN (?)&quot;, []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;).<span class="built_in">Count</span>(<span class="operator">&amp;</span>count)</span><br></pre></td></tr></table></figure>



<p>生成的Sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span> <span class="keyword">AND</span> id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;jinzhu%&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="更新所有字段"><a href="#更新所有字段" class="headerlink" title="更新所有字段"></a>更新所有字段</h3><p><code>Save()</code>默认会更新该对象的所有字段，即使你没有赋值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.First(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"></span><br><span class="line">user.Name <span class="operator">=</span> &quot;七米&quot;</span><br><span class="line">user.Age <span class="operator">=</span> <span class="number">99</span></span><br><span class="line">db.Save(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span>  <span class="keyword">UPDATE</span> `users` <span class="keyword">SET</span> `created_at` <span class="operator">=</span> <span class="string">&#x27;2020-02-16 12:52:20&#x27;</span>, `updated_at` <span class="operator">=</span> <span class="string">&#x27;2020-02-16 12:54:55&#x27;</span>, `deleted_at` <span class="operator">=</span> <span class="keyword">NULL</span>, `name` <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>, `age` <span class="operator">=</span> <span class="number">99</span>, `active` <span class="operator">=</span> <span class="literal">true</span>  <span class="keyword">WHERE</span> `users`.`deleted_at` <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> `users`.`id` <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>




<h3 id="更新修改字段"><a href="#更新修改字段" class="headerlink" title="更新修改字段"></a>更新修改字段</h3><p>如果你只希望更新指定字段，可以使用<code>Update</code>或者<code>Updates</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 更新单个属性，如果它有变化</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).<span class="keyword">Update</span>(&quot;name&quot;, &quot;hello&quot;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, updated_at<span class="operator">=</span><span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 根据给定的条件更新单个属性</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).<span class="keyword">Where</span>(&quot;active = ?&quot;, <span class="literal">true</span>).<span class="keyword">Update</span>(&quot;name&quot;, &quot;hello&quot;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, updated_at<span class="operator">=</span><span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111</span> <span class="keyword">AND</span> active<span class="operator">=</span><span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用 map 更新多个属性，只会更新其中有变化的属性</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: <span class="number">18</span>, &quot;active&quot;: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, age<span class="operator">=</span><span class="number">18</span>, active<span class="operator">=</span><span class="literal">false</span>, updated_at<span class="operator">=</span><span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).Updates(<span class="keyword">User</span>&#123;Name: &quot;hello&quot;, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, age<span class="operator">=</span><span class="number">18</span>, updated_at <span class="operator">=</span> <span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 对于下面的操作，不会发生任何更新，&quot;&quot;, <span class="number">0</span>, <span class="literal">false</span> 都是其类型的零值</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).Updates(<span class="keyword">User</span>&#123;Name: &quot;&quot;, Age: <span class="number">0</span>, Active: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="更新选定字段"><a href="#更新选定字段" class="headerlink" title="更新选定字段"></a>更新选定字段</h3><p>如果你想更新或忽略某些字段，你可以使用 <code>Select</code>，<code>Omit</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).<span class="keyword">Select</span>(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: <span class="number">18</span>, &quot;active&quot;: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, updated_at<span class="operator">=</span><span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111</span>;</span><br><span class="line"></span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).<span class="keyword">Omit</span>(&quot;name&quot;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: <span class="number">18</span>, &quot;active&quot;: <span class="literal">false</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> age<span class="operator">=</span><span class="number">18</span>, active<span class="operator">=</span><span class="literal">false</span>, updated_at<span class="operator">=</span><span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111</span>;</span><br></pre></td></tr></table></figure>



<h3 id="无Hooks更新"><a href="#无Hooks更新" class="headerlink" title="无Hooks更新"></a>无Hooks更新</h3><p>上面的更新操作会自动运行 model 的 BeforeUpdate, AfterUpdate 方法，更新 UpdatedAt 时间戳, 在更新时保存其 Associations, 如果你不想调用这些方法，你可以使用 UpdateColumn， UpdateColumns。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 更新单个属性，类似于 `<span class="keyword">Update</span>`</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).UpdateColumn(&quot;name&quot;, &quot;hello&quot;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 更新多个属性，类似于 `Updates`</span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).UpdateColumns(<span class="keyword">User</span>&#123;Name: &quot;hello&quot;, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, age<span class="operator">=</span><span class="number">18</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">111</span>;</span><br></pre></td></tr></table></figure>



<h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>批量更新时Hooks（钩子函数）不会运行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Table(&quot;users&quot;).<span class="keyword">Where</span>(&quot;id IN (?)&quot;, []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">11</span>&#125;).Updates(map[string]interface&#123;&#125;&#123;&quot;name&quot;: &quot;hello&quot;, &quot;age&quot;: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, age<span class="operator">=</span><span class="number">18</span> <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface&#123;&#125;</span><br><span class="line">db.Model(<span class="keyword">User</span>&#123;&#125;).Updates(<span class="keyword">User</span>&#123;Name: &quot;hello&quot;, Age: <span class="number">18</span>&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, age<span class="operator">=</span><span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 使用 `RowsAffected` 获取更新记录总数</span><br><span class="line">db.Model(<span class="keyword">User</span>&#123;&#125;).Updates(<span class="keyword">User</span>&#123;Name: &quot;hello&quot;, Age: <span class="number">18</span>&#125;).RowsAffected</span><br></pre></td></tr></table></figure>



<h3 id="使用SQL表达式更新"><a href="#使用SQL表达式更新" class="headerlink" title="使用SQL表达式更新"></a>使用SQL表达式更新</h3><p>先查询表中的第一条数据保存至user变量。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">user</span> <span class="keyword">User</span></span><br><span class="line">db.First(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).<span class="keyword">Update</span>(&quot;age&quot;, gorm.Expr(&quot;age * ? + ?&quot;, <span class="number">2</span>, <span class="number">100</span>))</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> `users` <span class="keyword">SET</span> `age` <span class="operator">=</span> age <span class="operator">*</span> <span class="number">2</span> <span class="operator">+</span> <span class="number">100</span>, `updated_at` <span class="operator">=</span> <span class="string">&#x27;2020-02-16 13:10:20&#x27;</span>  <span class="keyword">WHERE</span> `users`.`id` <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).Updates(map[string]interface&#123;&#125;&#123;&quot;age&quot;: gorm.Expr(&quot;age * ? + ?&quot;, <span class="number">2</span>, <span class="number">100</span>)&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> &quot;users&quot; <span class="keyword">SET</span> &quot;age&quot; <span class="operator">=</span> age <span class="operator">*</span> <span class="string">&#x27;2&#x27;</span> <span class="operator">+</span> <span class="string">&#x27;100&#x27;</span>, &quot;updated_at&quot; <span class="operator">=</span> <span class="string">&#x27;2020-02-16 13:05:51&#x27;</span> <span class="keyword">WHERE</span> `users`.`id` <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).UpdateColumn(&quot;age&quot;, gorm.Expr(&quot;age - ?&quot;, <span class="number">1</span>))</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> &quot;users&quot; <span class="keyword">SET</span> &quot;age&quot; <span class="operator">=</span> age <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> &quot;id&quot; <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).<span class="keyword">Where</span>(&quot;age &gt; 10&quot;).UpdateColumn(&quot;age&quot;, gorm.Expr(&quot;age - ?&quot;, <span class="number">1</span>))</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> &quot;users&quot; <span class="keyword">SET</span> &quot;age&quot; <span class="operator">=</span> age <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> &quot;id&quot; <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">AND</span> quantity <span class="operator">&gt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="修改Hooks中的值"><a href="#修改Hooks中的值" class="headerlink" title="修改Hooks中的值"></a>修改Hooks中的值</h3><p>如果你想修改 BeforeUpdate, BeforeSave 等 Hooks 中更新的值，你可以使用 scope.SetColumn, 例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">func (<span class="keyword">user</span> <span class="operator">*</span><span class="keyword">User</span>) BeforeSave(<span class="keyword">scope</span> <span class="operator">*</span>gorm.Scope) (err error) &#123;</span><br><span class="line">  if pw, err :<span class="operator">=</span> bcrypt.GenerateFromPassword(user.Password, <span class="number">0</span>); err <span class="operator">=</span><span class="operator">=</span> nil &#123;</span><br><span class="line">    scope.SetColumn(&quot;EncryptedPassword&quot;, pw)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="其它更新选项"><a href="#其它更新选项" class="headerlink" title="其它更新选项"></a>其它更新选项</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 为 <span class="keyword">update</span> <span class="keyword">SQL</span> 添加其它的 <span class="keyword">SQL</span></span><br><span class="line">db.Model(<span class="operator">&amp;</span><span class="keyword">user</span>).<span class="keyword">Set</span>(&quot;gorm:update_option&quot;, &quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;).<span class="keyword">Update</span>(&quot;name&quot;, &quot;hello&quot;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> name<span class="operator">=</span><span class="string">&#x27;hello&#x27;</span>, updated_at <span class="operator">=</span> <span class="string">&#x27;2013-11-17 21:34:10&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">111</span> OPTION (OPTIMIZE <span class="keyword">FOR</span> <span class="literal">UNKNOWN</span>);</span><br></pre></td></tr></table></figure>




<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p>删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除现有记录</span><br><span class="line">db.Delete(<span class="operator">&amp;</span>email)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">DELETE</span> <span class="keyword">from</span> emails <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 为删除 <span class="keyword">SQL</span> 添加额外的 <span class="keyword">SQL</span> 操作</span><br><span class="line">db.Set(&quot;gorm:delete_option&quot;, &quot;OPTION (OPTIMIZE FOR UNKNOWN)&quot;).<span class="keyword">Delete</span>(<span class="operator">&amp;</span>email)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">DELETE</span> <span class="keyword">from</span> emails <span class="keyword">where</span> id<span class="operator">=</span><span class="number">10</span> OPTION (OPTIMIZE <span class="keyword">FOR</span> <span class="literal">UNKNOWN</span>);</span><br></pre></td></tr></table></figure>



<h3 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h3><p>删除全部匹配的记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Where(&quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;).<span class="keyword">Delete</span>(Email&#123;&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">DELETE</span> <span class="keyword">from</span> emails <span class="keyword">where</span> email <span class="keyword">LIKE</span> &quot;%jinzhu%&quot;;</span><br><span class="line"></span><br><span class="line">db.Delete(Email&#123;&#125;, &quot;email LIKE ?&quot;, &quot;%jinzhu%&quot;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">DELETE</span> <span class="keyword">from</span> emails <span class="keyword">where</span> email <span class="keyword">LIKE</span> &quot;%jinzhu%&quot;;</span><br></pre></td></tr></table></figure>



<h3 id="软删除"><a href="#软删除" class="headerlink" title="软删除"></a>软删除</h3><p>如果一个 model 有 DeletedAt 字段，他将自动获得软删除的功能！ 当调用 Delete 方法时， 记录不会真正的从数据库中被删除， 只会将DeletedAt 字段的值会被设置为当前时间。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">db.Delete(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> deleted_at<span class="operator">=</span>&quot;2013-10-29 10:23&quot; <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 批量删除</span><br><span class="line">db.Where(&quot;age = ?&quot;, <span class="number">20</span>).<span class="keyword">Delete</span>(<span class="operator">&amp;</span><span class="keyword">User</span>&#123;&#125;)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> users <span class="keyword">SET</span> deleted_at<span class="operator">=</span>&quot;2013-10-29 10:23&quot; <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查询记录时会忽略被软删除的记录</span><br><span class="line">db.Where(&quot;age = 20&quot;).Find(<span class="operator">&amp;</span><span class="keyword">user</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span> <span class="keyword">AND</span> deleted_at <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> Unscoped 方法可以查询被软删除的记录</span><br><span class="line">db.Unscoped().<span class="keyword">Where</span>(&quot;age = 20&quot;).Find(<span class="operator">&amp;</span>users)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>



<h3 id="物理删除"><a href="#物理删除" class="headerlink" title="物理删除"></a>物理删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> Unscoped 方法可以物理删除记录</span><br><span class="line">db.Unscoped().<span class="keyword">Delete</span>(<span class="operator">&amp;</span><span class="keyword">order</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span><span class="operator">/</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">10</span>;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Gorm</category>
      </categories>
  </entry>
  <entry>
    <title>生产者-消费者模式 Golang实现</title>
    <url>/2022/09/08/Go/%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%20Golang%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h1><p>生产者消费者模型具体来讲，就是在一个系统中，存在生产者和消费者两种角色，他们通过内存缓冲区进行通信，生产者生产消费者需要的资料，消费者把资料做成产品。</p>
<p><strong>基本工作原理</strong></p>
<p>生产者线程增加资源数，如果资源数大于最大值则生产者线程挂起等待，当收到消费者线程的通知后继续生产。<br>消费者线程减少资源数，如果资源数为0，则消费者线程挂起，等待生产者通知后继续生产。</p>
<p><strong>举例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	PRODUCERS  = <span class="number">5</span></span><br><span class="line">	CONSUMERS = <span class="number">2</span></span><br><span class="line">	PRODUCTS  = <span class="number">20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// productCount为资源的数量，需要互斥处理</span></span><br><span class="line"><span class="keyword">var</span> productCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> lock sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制生产者阻塞等待</span></span><br><span class="line"><span class="keyword">var</span> produceWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 控制消费者阻塞等待</span></span><br><span class="line"><span class="keyword">var</span> consumeWait <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当资源达到上限或下限时，挂起单个协程，通过这两个变量休眠同类协程</span></span><br><span class="line"><span class="keyword">var</span> stopProduce = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> stopConsume = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Produce 生产者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Produce</span><span class="params">(index <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Producer &quot;</span>, index, <span class="string">&quot; panic&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="comment">// 生产者协程发现stopProduce为true，则睡眠5秒</span></span><br><span class="line">		<span class="keyword">if</span> stopProduce &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Producer &quot;</span>, index, <span class="string">&quot; stop produce, sleep 5 seconds&quot;</span>)</span><br><span class="line">			lock.Unlock()</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Producer &quot;</span>, index, <span class="string">&quot; begin produce&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> productCount &gt;= PRODUCTS &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Products are full&quot;</span>)</span><br><span class="line">			<span class="comment">// 如果产品满了就停止生产</span></span><br><span class="line">			stopProduce = <span class="literal">true</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="comment">//将当前生产者挂起，等待</span></span><br><span class="line">			&lt;-produceWait</span><br><span class="line">			lock.Lock()</span><br><span class="line">			stopProduce = <span class="literal">false</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		productCount++</span><br><span class="line">		fmt.Println(<span class="string">&quot;Products count is &quot;</span>, productCount)</span><br><span class="line">		<span class="comment">// 产品从空的状态到被生产了一个，激活消费者</span></span><br><span class="line">		<span class="keyword">if</span> stopConsume &#123;</span><br><span class="line">			<span class="keyword">var</span> consumerActive <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">			consumeWait &lt;- consumerActive</span><br><span class="line">		&#125;</span><br><span class="line">		lock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consume 消费者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consume</span><span class="params">(index <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Consumer &quot;</span>, index, <span class="string">&quot; panic&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		lock.Lock()</span><br><span class="line">		<span class="keyword">if</span> stopConsume &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Consumer &quot;</span>, index, <span class="string">&quot; stop consume, sleep 5 seconds&quot;</span>)</span><br><span class="line">			lock.Unlock()</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Consumer &quot;</span>, index, <span class="string">&quot; begin consume&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> productCount &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;Products are empty&quot;</span>)</span><br><span class="line">			stopConsume = <span class="literal">true</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="comment">//产品空了，将当前消费者挂起</span></span><br><span class="line">			&lt;-consumeWait</span><br><span class="line">			lock.Lock()</span><br><span class="line">			stopConsume = <span class="literal">false</span></span><br><span class="line">			lock.Unlock()</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		productCount--</span><br><span class="line">		fmt.Println(<span class="string">&quot;Products count is &quot;</span>, productCount)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 产品从满的状态被消费了一个，激活生产者</span></span><br><span class="line">		<span class="keyword">if</span> stopProduce &#123;</span><br><span class="line">			<span class="keyword">var</span> producerActive <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">			produceWait &lt;- producerActive</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg.Add(PRODUCERS + CONSUMERS)</span><br><span class="line">	produceWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	consumeWait = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; CONSUMERS; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Consume(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; PRODUCERS; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> Produce(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在程序中可以发现，在produce函数中，当我们发现系统资源到达临界值时，使用channel将当前的协程阻塞了，然后将bool变量stopProduce置为true，让其它协程进入休眠。为什么要这样做呢？<br>因为程序中的produceWait是非缓冲的，所以一次只能激活一个生产者，这么做在一定程度限制了生产者，所以我们引入bool变量通知其他协程睡眠，避免此问题，consume函数中也是同样的道理。</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
  </entry>
  <entry>
    <title>Gorm连接MySQL</title>
    <url>/2022/11/02/Gorm/GORM%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Gorm是一个使用Go语言编写的ORM框架。它文档齐全，对开发者友好，支持主流数据库。</p>
<p>详细介绍及使用请移步官方中文文档：<br><a href="https://gorm.io/zh_CN/docs/">https://gorm.io/zh_CN&#x2F;docs&#x2F;</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装gorm</span></span><br><span class="line"><span class="keyword">go</span> get github.com/jinzhu/gorm</span><br><span class="line"><span class="comment">// 安装mysql驱动</span></span><br><span class="line"><span class="keyword">go</span> get github.com/jinzhu/gorm/dialects/mysql</span><br></pre></td></tr></table></figure>




<h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	  db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:password@(localhost)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">	  <span class="keyword">defer</span> db.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p><strong>创建数据库</strong></p>
<p>在使用GORM之前手动创建数据库 <code>db6</code> :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE db6;</span><br></pre></td></tr></table></figure>




<h3 id="GORM操作MySQL"><a href="#GORM操作MySQL" class="headerlink" title="GORM操作MySQL"></a>GORM操作MySQL</h3><p>使用GORM连接上面的db6进行创建、查询、更新、删除操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/jinzhu/gorm&quot;</span></span><br><span class="line">	_ <span class="string">&quot;github.com/jinzhu/gorm/dialects/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserInfo 用户信息</span></span><br><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID <span class="type">uint</span></span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Gender <span class="type">string</span></span><br><span class="line">	Hobby <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := gorm.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;root:123456@(127.0.0.1:3306)/db6?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err!= <span class="literal">nil</span>&#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> db.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自动迁移</span></span><br><span class="line">	db.AutoMigrate(&amp;UserInfo&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	u1 := UserInfo&#123;<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;篮球&quot;</span>&#125;</span><br><span class="line">	u2 := UserInfo&#123;<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="string">&quot;足球&quot;</span>&#125;</span><br><span class="line">	<span class="comment">// 创建记录</span></span><br><span class="line">	db.Create(&amp;u1)</span><br><span class="line">	db.Create(&amp;u2)</span><br><span class="line">	<span class="comment">// 查询</span></span><br><span class="line">	<span class="keyword">var</span> u = <span class="built_in">new</span>(UserInfo)</span><br><span class="line">	db.First(u)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, u)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> uu UserInfo</span><br><span class="line">	db.Find(&amp;uu, <span class="string">&quot;hobby=?&quot;</span>, <span class="string">&quot;足球&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, uu)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新</span></span><br><span class="line">	db.Model(&amp;u).Update(<span class="string">&quot;hobby&quot;</span>, <span class="string">&quot;双色球&quot;</span>)</span><br><span class="line">	<span class="comment">// 删除</span></span><br><span class="line">	db.Delete(&amp;u)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="GORM-Model定义"><a href="#GORM-Model定义" class="headerlink" title="GORM Model定义"></a>GORM Model定义</h3><p>在使用ORM工具时，通常我们需要在代码中定义模型（Models）与数据库中的数据表进行映射，在GORM中模型（Models）通常是正常定义的结构体、基本的go类型或它们的指针。 同时也支持<code>sql.Scanner</code>及<code>driver.Valuer</code>接口（interfaces）。</p>
<p><strong>gorm.Model</strong></p>
<p>为了方便模型定义，GORM内置了一个<code>gorm.Model</code>结构体。<code>gorm.Model</code>是一个包含了<code>ID</code>,<code>CreatedAt</code>, <code>UpdatedAt</code>, <code>eletedA</code>t四个字段的Golang结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt *time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>你可以将它嵌入到你自己的模型中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 `ID`, `CreatedAt`, `UpdatedAt`, `DeletedAt`字段注入到`User`模型中</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当然也可以完全定义自己的模型：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用gorm.Model，自行定义模型</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">int</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>模型定义示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  gorm.Model</span><br><span class="line">  Name         <span class="type">string</span></span><br><span class="line">  Age          sql.NullInt64</span><br><span class="line">  Birthday     *time.Time</span><br><span class="line">  Email        <span class="type">string</span>  <span class="string">`gorm:&quot;type:varchar(100);unique_index&quot;`</span></span><br><span class="line">  Role         <span class="type">string</span>  <span class="string">`gorm:&quot;size:255&quot;`</span> <span class="comment">// 设置字段大小为255</span></span><br><span class="line">  MemberNumber *<span class="type">string</span> <span class="string">`gorm:&quot;unique;not null&quot;`</span> <span class="comment">// 设置会员号（member number）唯一并且不为空</span></span><br><span class="line">  Num          <span class="type">int</span>     <span class="string">`gorm:&quot;AUTO_INCREMENT&quot;`</span> <span class="comment">// 设置 num 为自增类型</span></span><br><span class="line">  Address      <span class="type">string</span>  <span class="string">`gorm:&quot;index:addr&quot;`</span> <span class="comment">// 给address字段创建名为addr的索引</span></span><br><span class="line">  IgnoreMe     <span class="type">int</span>     <span class="string">`gorm:&quot;-&quot;`</span> <span class="comment">// 忽略本字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="结构体标记"><a href="#结构体标记" class="headerlink" title="结构体标记"></a>结构体标记</h3><div id="Tag">
使用结构体声明模型时，标记（tags）是可选项。gorm支持以下标记:



<p><strong>支持的结构体标记（Struct tags）</strong></p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Column</td>
<td>指定列名</td>
</tr>
<tr>
<td>Type</td>
<td>指定列数据类型</td>
</tr>
<tr>
<td>Size</td>
<td>指定列大小，默认值255</td>
</tr>
<tr>
<td>PRIMARY_KEY</td>
<td>将列指定为主键</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>将列指定为唯一</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>指定列默认值</td>
</tr>
<tr>
<td>PRECISION</td>
<td>指定列精细度</td>
</tr>
<tr>
<td>NOT NULL</td>
<td>将列指定为非NULL</td>
</tr>
<tr>
<td>AUTO_INCREMENT</td>
<td>指定列是否为自增类型</td>
</tr>
<tr>
<td>INDEX</td>
<td>创建具有或不带名称的索引，如果多个索引同名则创建复合索引</td>
</tr>
<tr>
<td>UNIQUE_INDEX</td>
<td>和 <code>INDEX</code> 类似，只不过创建的是唯一索引</td>
</tr>
<tr>
<td>EMBEDDED</td>
<td>将结构设置为嵌入</td>
</tr>
<tr>
<td>EMBEDDED_PREFIX</td>
<td>设置嵌入结构的前缀</td>
</tr>
<tr>
<td>-</td>
<td>忽略此字段</td>
</tr>
</tbody></table>
<p><strong>关联相关标记（tags）</strong></p>
<table>
<thead>
<tr>
<th>Tag</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>MANY2MANY</td>
<td>指定连接表</td>
</tr>
<tr>
<td>FOREIGNKEY</td>
<td>设置外键</td>
</tr>
<tr>
<td>ASSOCIATION_FOREIGNKEY</td>
<td>设置关联外键</td>
</tr>
<tr>
<td>POLYMORPHIC</td>
<td>指定多态类型</td>
</tr>
<tr>
<td>POLYMORPHIC_VALUE</td>
<td>指定多态值</td>
</tr>
<tr>
<td>JOINTABLE_FOREIGNKEY</td>
<td>指定多态值</td>
</tr>
<tr>
<td>ASSOCIATION_JOINTABLE_FOREIGNKEY</td>
<td>指定连接表的关键外键</td>
</tr>
<tr>
<td>SAVE_ASSOCIATIONS</td>
<td>是否自动完成 save 的相关操作</td>
</tr>
<tr>
<td>ASSOCIATION_AUTOUPDATE</td>
<td>是否自动完成 update 的相关操作</td>
</tr>
<tr>
<td>ASSOCIATION_AUTOCREATE</td>
<td>是否自动完成 create 的相关操作</td>
</tr>
<tr>
<td>ASSOCIATION_SAVE_REFERENCE</td>
<td>是否自动完成引用的 save 的相关操作</td>
</tr>
<tr>
<td>PRELOAD</td>
<td>是否自动完成预加载的相关操作</td>
</tr>
</tbody></table>
<h3 id="主键、表名、列名的约定"><a href="#主键、表名、列名的约定" class="headerlink" title="主键、表名、列名的约定"></a>主键、表名、列名的约定</h3><h4 id="主键（Primary-Key）"><a href="#主键（Primary-Key）" class="headerlink" title="主键（Primary Key）"></a>主键（Primary Key）</h4><p>GORM 默认会使用名为ID的字段作为表的主键。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID   <span class="type">string</span> <span class="comment">// 名为`ID`的字段会默认作为表的主键</span></span><br><span class="line">  Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用`AnimalID`作为主键</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalID <span class="type">int64</span> <span class="string">`gorm:&quot;primary_key&quot;`</span></span><br><span class="line">  Name     <span class="type">string</span></span><br><span class="line">  Age      <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="表名（Table-Name）"><a href="#表名（Table-Name）" class="headerlink" title="表名（Table Name）"></a>表名（Table Name）</h4><p>表名默认就是结构体名称的复数，例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;&#125; <span class="comment">// 默认表名是 `users`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 User 的表名设置为 `profiles`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;profiles&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> u.Role == <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin_users&quot;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;users&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁用默认表名的复数形式，如果置为 true，则 `User` 的默认表名是 `user`</span></span><br><span class="line">db.SingularTable(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>



<p>也可以通过<code>Table()</code>指定表名:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用User结构体创建名为`deleted_users`的表</span></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).CreateTable(&amp;User&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> deleted_users []User</span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Find(&amp;deleted_users)</span><br><span class="line"><span class="comment">//// SELECT * FROM deleted_users;</span></span><br><span class="line"></span><br><span class="line">db.Table(<span class="string">&quot;deleted_users&quot;</span>).Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete()</span><br><span class="line"><span class="comment">//// DELETE FROM deleted_users WHERE name = &#x27;jinzhu&#x27;;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>GORM还支持更改默认表名称规则：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">gorm.DefaultTableNameHandler = <span class="function"><span class="keyword">func</span> <span class="params">(db *gorm.DB, defaultTableName <span class="type">string</span>)</span></span> <span class="type">string</span>  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;prefix_&quot;</span> + defaultTableName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="列名（Column-Name）"><a href="#列名（Column-Name）" class="headerlink" title="列名（Column Name）"></a>列名（Column Name）</h4><p>列名由字段名称进行下划线分割来生成：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>      <span class="comment">// column name is `id`</span></span><br><span class="line">  Name      <span class="type">string</span>    <span class="comment">// column name is `name`</span></span><br><span class="line">  Birthday  time.Time <span class="comment">// column name is `birthday`</span></span><br><span class="line">  CreatedAt time.Time <span class="comment">// column name is `created_at`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以使用结构体tag指定列名：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">  AnimalId    <span class="type">int64</span>     <span class="string">`gorm:&quot;column:beast_id&quot;`</span>         <span class="comment">// set column name to `beast_id`</span></span><br><span class="line">  Birthday    time.Time <span class="string">`gorm:&quot;column:day_of_the_beast&quot;`</span> <span class="comment">// set column name to `day_of_the_beast`</span></span><br><span class="line">  Age         <span class="type">int64</span>     <span class="string">`gorm:&quot;column:age_of_the_beast&quot;`</span> <span class="comment">// set column name to `age_of_the_beast`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="时间戳跟踪"><a href="#时间戳跟踪" class="headerlink" title="时间戳跟踪"></a>时间戳跟踪</h3><h4 id="CreateAt"><a href="#CreateAt" class="headerlink" title="CreateAt"></a>CreateAt</h4><p>如果模型有 <code>CreatedAt</code>字段，该字段的值将会是初次创建记录的时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Create(&amp;user) <span class="comment">// `CreatedAt`将会是当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用`Update`方法来改变`CreateAt`的值</span></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;CreatedAt&quot;</span>, time.Now())</span><br></pre></td></tr></table></figure>



<h4 id="UpdateAt"><a href="#UpdateAt" class="headerlink" title="UpdateAt"></a>UpdateAt</h4><p>如果模型有<code>UpdatedAt</code>字段，该字段的值将会是每次更新记录的时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Save(&amp;user) <span class="comment">// `UpdatedAt`将会是当前时间</span></span><br><span class="line"></span><br><span class="line">db.Model(&amp;user).Update(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>) <span class="comment">// `UpdatedAt`将会是当前时间</span></span><br></pre></td></tr></table></figure>



<h4 id="DeleteAt"><a href="#DeleteAt" class="headerlink" title="DeleteAt"></a>DeleteAt</h4><p>如果模型有<code>DeletedAt</code>字段，调用<code>Delete</code>删除该记录时，将会设置<code>DeletedAt</code>字段为当前时间，而不是直接将记录从数据库中删除（软删除）。</p>
]]></content>
      <categories>
        <category>Gorm</category>
      </categories>
  </entry>
  <entry>
    <title>Linux命令笔记</title>
    <url>/2022/11/02/Linux/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="1-只读文件改为可编辑"><a href="#1-只读文件改为可编辑" class="headerlink" title="1.只读文件改为可编辑"></a>1.只读文件改为可编辑</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 666 test.txt</span><br></pre></td></tr></table></figure>
<p>666的意思就是可读可写</p>
<h2 id="2-修改目录的所属"><a href="#2-修改目录的所属" class="headerlink" title="2.修改目录的所属"></a>2.修改目录的所属</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> admin:admin <span class="built_in">test</span>/ -R</span><br></pre></td></tr></table></figure>
<p>将test目录改为admin所属</p>
<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="1-查找文件关键字"><a href="#1-查找文件关键字" class="headerlink" title="1.查找文件关键字"></a>1.查找文件关键字</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vim 文件以后打&#x27;:&#x27; ，然后</span></span><br><span class="line">/关键字</span><br></pre></td></tr></table></figure>

<h2 id="2-撤销操作"><a href="#2-撤销操作" class="headerlink" title="2.撤销操作"></a>2.撤销操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在vi编辑模式中</span></span><br><span class="line">:u  <span class="comment"># 可以撤销一次</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在vim编辑模式中</span></span><br><span class="line">:u  <span class="comment"># 可以撤销无限次</span></span><br></pre></td></tr></table></figure>

<h2 id="3-解压和打包文件"><a href="#3-解压和打包文件" class="headerlink" title="3.解压和打包文件"></a>3.解压和打包文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压tar文件</span></span><br><span class="line">tar -xvf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压tar.gz文件</span></span><br><span class="line">tar -zxvf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包tar文件</span></span><br><span class="line">tar -cvf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包tar.gz文件</span></span><br><span class="line">tar -cvzf</span><br></pre></td></tr></table></figure>

<h2 id="4-修改文件名"><a href="#4-修改文件名" class="headerlink" title="4.修改文件名"></a>4.修改文件名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> 旧文件名 新文件名</span><br></pre></td></tr></table></figure>

<h2 id="5-复制文件"><a href="#5-复制文件" class="headerlink" title="5.复制文件"></a>5.复制文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> 文件 文件路径</span><br></pre></td></tr></table></figure>

<h1 id="修改用户操作"><a href="#修改用户操作" class="headerlink" title="修改用户操作"></a>修改用户操作</h1><h2 id="1-添加一个用户"><a href="#1-添加一个用户" class="headerlink" title="1.添加一个用户"></a>1.添加一个用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd admin</span><br></pre></td></tr></table></figure>
<p>添加一个名为admin的用户。</p>
<h2 id="2-切换用户"><a href="#2-切换用户" class="headerlink" title="2.切换用户"></a>2.切换用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - admin</span><br></pre></td></tr></table></figure>
<p>将用户切换为admin。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure>

<p>将用户切换为root，需要输入密码。</p>
<h1 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h1><h2 id="1-查看端口占用"><a href="#1-查看端口占用" class="headerlink" title="1.查看端口占用"></a>1.查看端口占用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -tunlp|grep [端口号]</span><br></pre></td></tr></table></figure>

<p>杀死进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 [pid]</span><br></pre></td></tr></table></figure>

<h2 id="2-防火墙命令"><a href="#2-防火墙命令" class="headerlink" title="2.防火墙命令"></a>2.防火墙命令</h2><p>查看防火墙状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure>

<p>关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure>

<p>查看防火墙服务是否开机启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl is-enabled firewalld</span><br></pre></td></tr></table></figure>

<p>关闭防火墙开机启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>

<h1 id="操作系统命令"><a href="#操作系统命令" class="headerlink" title="操作系统命令"></a>操作系统命令</h1><h2 id="1-杀死进程"><a href="#1-杀死进程" class="headerlink" title="1.杀死进程"></a>1.杀死进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 [pid]</span><br></pre></td></tr></table></figure>
<h2 id="2-查看进程是否在运行"><a href="#2-查看进程是否在运行" class="headerlink" title="2.查看进程是否在运行"></a>2.查看进程是否在运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux | grep elasticsearch</span><br></pre></td></tr></table></figure>

<h2 id="3-查看每个目录的内存占用"><a href="#3-查看每个目录的内存占用" class="headerlink" title="3.查看每个目录的内存占用"></a>3.查看每个目录的内存占用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Shell脚本基本使用</title>
    <url>/2022/11/02/Linux/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Shell简介"><a href="#Shell简介" class="headerlink" title="Shell简介"></a>Shell简介</h2><p>Shell是一个用c语言编写的程序，它是用户使用Linux的桥梁. Shell 既是命令语言，又是一种程序设计语言.<br>Shell脚本（shell script），是一种为Shell编写的脚本程序。业界所说的Shell通常指的是Shell脚本. Shell 与Shell脚本是两个不同的概念.</p>
<p>Linux中的shell有很多种类，常用的几种:</p>
<ul>
<li>Bourne Shell (&#x2F;usr&#x2F;bin&#x2F;sh 或&#x2F;bin&#x2F;sh)</li>
<li>Bourne Again Shell (&#x2F;bin&#x2F;bash)</li>
<li>C Shell (&#x2F;usrbin&#x2F;csh)</li>
<li>K Shell (&#x2F;usr&#x2F;bin&#x2F;ksh)</li>
<li>Shell for Root (&#x2F;sbin&#x2F;sh)</li>
</ul>
<p><code>Bash（Bourne Again Shell）</code>由于易用和免费，在日常工作中被<br>广泛使用。同时，Bash也是大多数Linux系统默认的Shell.</p>
<h2 id="第一个Shell脚本"><a href="#第一个Shell脚本" class="headerlink" title="第一个Shell脚本"></a>第一个Shell脚本</h2><p>创建一个<code>first.sh</code>文件，Shell脚本文件以<code>.sh结尾</code>，然后开始编辑文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<p>编写完之后使用<code>ll</code>命令查看文件的权限：</p>
<p><img src="https://img-blog.csdnimg.cn/637663e771ef4653a0e22fe150b7475d.png" alt="在这里插入图片描述"></p>
<p>只允许读和写，不能执行，所以要为它加上可执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x first.sh</span><br></pre></td></tr></table></figure>

<p>看到文件变成绿色以后，使用<code>./firsh.sh</code>执行：<br><img src="https://img-blog.csdnimg.cn/dc391bcc515844e6957a1453bb8f1c65.png" alt="在这里插入图片描述"></p>
<h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><p><strong>定义变量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">greet=<span class="string">&quot;hello program&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greet</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/0cebefa3b0af4ffb9c55e31fc260423a.png" alt="在这里插入图片描述"></p>
<ul>
<li>注意定义变量的时候，<code>=</code>号的两边不能有空格.</li>
<li>后面在使用变量的时候，变量的前面要加上<code>$</code>符号.</li>
</ul>
<p><strong>if条件判断</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">num=1</span><br><span class="line"><span class="keyword">if</span> [<span class="variable">$num</span> -eq 0]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;num is 0&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [<span class="variable">$num</span> -eq 1]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;num is 1&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;num is not 0 and 1&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>


<p><strong>for循环</strong></p>
<p>假设要打印<code>/opt/module</code>目录下面的所有文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> $(<span class="built_in">ls</span> /opt/module/); <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/787be3f959274d33b7705647b14c04ee.png" alt="在这里插入图片描述"><br></p>
<p>从1加到100：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">let</span> <span class="built_in">sum</span>+=i;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/511b084ba5b643c293b450ad64b8d1fa.png" alt="在这里插入图片描述"></p>
<p>检测局域网内机器的工作状态：</p>
<p>假设现在处于的网段是<code>192.168.199</code>，要求打印出当前网段下所有机器的工作状态.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..254&#125;; <span class="keyword">do</span></span><br><span class="line">        ping -c 2 -i 0.5 192.168.199.<span class="variable">$i</span> &amp;&gt;/dev/null</span><br><span class="line">        <span class="keyword">if</span> [$? -eq 0]; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;192.168.199.<span class="variable">$i</span> is up&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;192.168.199.<span class="variable">$i</span> is down&quot;</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>ping -c [count] </code> 表示ping的次数.</li>
<li><code>ping -i [time]</code> 表示每次ping的时间间隔.</li>
<li><code>/dev/null</code> 表示把打印的一些无用信息过滤掉.</li>
<li><code>$?</code> 表示上一行指令的执行结果.</li>
</ul>
<p>后面使用到再进行追加.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>vue-cli 安装与使用</title>
    <url>/2022/11/02/Vue.js/vue-cli/</url>
    <content><![CDATA[<h2 id="什么是vue-cli"><a href="#什么是vue-cli" class="headerlink" title="什么是vue-cli"></a>什么是vue-cli</h2><p>vue-cli官方提供的一个脚手架，用于快速生成一个vue的项目模板。<br>预先定义好的目录结构及基础代码，就好比咱们在创建Maven项目时可以选择创建一个骨架项目，这个估计项目就是脚手架，我们的开发更加的快速。</p>
<p><strong>功能</strong></p>
<ul>
<li>统一的目录结构</li>
<li>本地调试</li>
<li>热部署</li>
<li>单元测试</li>
<li>集成打包上线</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="1-安装nvm-Node-Version-Manager"><a href="#1-安装nvm-Node-Version-Manager" class="headerlink" title="1. 安装nvm (Node Version Manager)"></a>1. 安装nvm (Node Version Manager)</h3><p>下载地址： <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a> ， win下载nvm-setup.zip即可。</p>
<p><img src="https://img-blog.csdnimg.cn/da66b31171d045efa61ff40130c35710.png" alt="在这里插入图片描述"><br>然后傻瓜式安装即可，我都安装在了D盘。</p>
<p><img src="https://img-blog.csdnimg.cn/4723c93e2fef4f2eb92449f0b13deb7f.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/cac2134f38454a9b9574c4064e47ee60.png" alt="在这里插入图片描述"></p>
<p><strong>验证</strong></p>
<p>在cmd中输入：<code>nvm</code></p>
<p><img src="https://img-blog.csdnimg.cn/10fe3d15568747908e6101fdb05aa176.png" alt="在这里插入图片描述"></p>
<p><strong>nvm常用命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install [version] <span class="comment">#安装指定版本的node.js 。</span></span><br><span class="line">nvm use [version] <span class="comment">#使用某个版本的node。</span></span><br><span class="line">nvm list <span class="comment">#列出当前安装了哪些版本的node。</span></span><br><span class="line">nvm uninstall [version] <span class="comment">#卸载指定版本的node。</span></span><br><span class="line">nvm node_mirror [url] <span class="comment">#设置nvm的镜像。</span></span><br><span class="line">nvm npm_mirror [url] <span class="comment">#设置npm的镜像。</span></span><br></pre></td></tr></table></figure>

<h3 id="2-安装node-js和npm"><a href="#2-安装node-js和npm" class="headerlink" title="2. 安装node.js和npm"></a>2. 安装node.js和npm</h3><p>首先设置一下nvm的下载源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置nvm的镜像</span></span><br><span class="line">nvm node_mirrorhttps://npm.taobao.org/mirrors/node/</span><br><span class="line"><span class="comment"># 设置npm的镜像</span></span><br><span class="line">nvm npm_mirrorhttps://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></table></figure>

<p>然后以管理员模式打开cmd：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvm install [版本号]</span><br><span class="line"><span class="comment"># 我下载的是14.19.1</span></span><br><span class="line">nvm install 14.19.1</span><br></pre></td></tr></table></figure>

<p>如果卡住，就停止，多试几次。</p>
<p>然后就可以看到nvm的安装目录中多了一个以版本号命名的目录，里面是</p>
<p><img src="https://img-blog.csdnimg.cn/98a95586a58a430db9587f5552d33928.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/3600684b91184389843513085779492e.png" alt="在这里插入图片描述"><br>里面是<code>node.js</code>可执行文件以及附带的<code>npm</code>。</p>
<p>在使用npm之前，我们需要<code>use</code>刚刚下载的node.js版本， 注意要用管理员身份运行cmd窗口，不然可能会出现乱码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出我们下载的node</span></span><br><span class="line">nvm list</span><br><span class="line"><span class="comment"># 使用某个版本的node</span></span><br><span class="line">nvm use 14.19.1</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/1e0cf8697f4a437d8802a99d6727ad4b.png" alt="在这里插入图片描述"><br>然后查看一下npm的版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/0d264e529056404fafc128686303f1dc.png" alt="在这里插入图片描述"><br><strong>手动安装npm</strong></p>
<p>有时候使用nvm安装完node后，npm没有跟着安装，这时候可以到<a href="https://github.com/npm/cli/releases">https://github.com/npm/cli/releases</a>下载比较新的版本。然后下载完成后，解压开来，放到v[版本号]&#x2F;node_modules下，然后修改名字为npm，并且把npm&#x2F;bin中的npm和npm.cmd两个文件放到v[版本号]的根目录下。</p>
<h3 id="3-使用淘宝镜像"><a href="#3-使用淘宝镜像" class="headerlink" title="3. 使用淘宝镜像"></a>3. 使用淘宝镜像</h3><p>因为使用npm可能会比较慢，所以我们可以使用国内的cnpm：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h3 id="4-安装vue和vue-cli"><a href="#4-安装vue和vue-cli" class="headerlink" title="4. 安装vue和vue-cli"></a>4. 安装vue和vue-cli</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我用的都是全局安装</span></span><br><span class="line"><span class="comment"># 安装vue</span></span><br><span class="line">cnpm install vue  -g</span><br><span class="line"><span class="comment"># 安装vue-cli</span></span><br><span class="line">cnpm install -g @vue/cli </span><br></pre></td></tr></table></figure>



<h2 id="使用vue-cli创建第一个vue项目"><a href="#使用vue-cli创建第一个vue项目" class="headerlink" title="使用vue-cli创建第一个vue项目"></a>使用vue-cli创建第一个vue项目</h2><p>在存放项目路径下打开cmd，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create [项目名称]</span><br><span class="line"><span class="comment"># 选择vue3，其它的都选择no</span></span><br></pre></td></tr></table></figure>

<p>也可以使用镜像安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create -r https://registry.npm.taobao.org [项目名称]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者在文件中设置：在当前用户目录下，找到.npmrc，然后设置</span></span><br><span class="line">registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>完成后，项目目录多了很多东西：</p>
<p><img src="https://img-blog.csdnimg.cn/0d585be5b33f4545bbd67e64d547c7d5.png" alt="在这里插入图片描述"></p>
<p><strong>项目结构介绍</strong></p>
<pre><code>1.node_modules：本地安装的包的文件夹。

2.public：项目出口文件。

3.src：项目源文件：

    assets：资源文件，包括字体，图片等。
    components：组件文件。
    App.vue：入口组件。
    main.js：webpack在打包的时候的入口文件。

4.babel.config.js：es*转低级js语言的配置文件。

5.package.json：项目包管理文件。

注意：vscode安装vetur包用来识别.vue文件
</code></pre>
<p><strong>启动项目</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/e18351f2d67d473bad87a16cc0733a28.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
  </entry>
  <entry>
    <title>vue-router 安装与使用</title>
    <url>/2022/11/02/Vue.js/vue-router/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>Vue Router是Vue.js官方的路由管理器。它和Vue.js的核心深度集成， 让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由&#x2F;视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于Vue js过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的CSS class的链接</li>
<li>HTML5 历史模式或hash模式， 在IE 9中自动自定义的滚动行为</li>
</ul>
<p>官方文档:</p>
<p><a href="https://router.vuejs.org/installation.html">https://router.vuejs.org/installation.html</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>基于第一个vue-cli进行测试学习； 先查看node modules中是否存在vue-router</strong></p>
<p> vue-router是一个插件包， 所以我们还是需要用npm&#x2F;cnpm来进行安装的。打开命令行工具，进入你的项目目录，输入下面命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// vue3</span><br><span class="line">npm install vue-router:4.0.0-alpha.6 --save</span><br><span class="line">// vue2</span><br><span class="line">npm install vue-router@3.2.0</span><br></pre></td></tr></table></figure>




<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="vue3测试"><a href="#vue3测试" class="headerlink" title="vue3测试"></a>vue3测试</h3><p>首先在<code>components</code>目录下创建两个组件：</p>
<p>myHome组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个home组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&quot;myHome&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>myInfo组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个Information组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>:<span class="string">&quot;myInfo&quot;</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: green;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>安装路由，在src目录下，新建一个router.js，专门用来放路由。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue3导入vue-router管理器写法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHistory&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span></span><br><span class="line"><span class="comment">// 导入两个组件的路径</span></span><br><span class="line"><span class="keyword">import</span> myHome <span class="keyword">from</span> <span class="string">&#x27;./components/myHome&#x27;</span></span><br><span class="line"><span class="keyword">import</span> myInfo <span class="keyword">from</span> <span class="string">&#x27;./components/myInfo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置路由模式路径不带#号</span></span><br><span class="line"><span class="keyword">const</span> webHistory = <span class="title function_">createWebHistory</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">		<span class="comment">//设置路由模式路径不带#号</span></span><br><span class="line">    <span class="attr">history</span>:webHistory,</span><br><span class="line">    <span class="comment">// 设置路由</span></span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:myHome</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/info&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;info&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:myInfo</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在main.js中使用路由</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ant <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;ant-design-vue/dist/antd.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>);</span><br><span class="line">app.<span class="title function_">use</span>(ant);</span><br><span class="line"><span class="comment">// 使用路由，一定要加</span></span><br><span class="line">app.<span class="title function_">use</span>(router);</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在App.vue中设置两个组件的入口</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;Vue logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;a-button type=&quot;danger&quot;&gt;这是一个按钮&lt;/a-button&gt;</span></span><br><span class="line"><span class="comment">      &lt;a-button type=&quot;primary&quot;&gt;按钮&lt;/a-button&gt; --&gt;</span></span><br><span class="line">      </span><br><span class="line">			<span class="comment">&lt;!-- 类似于超链接 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/info&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span>&gt;</span>Infomation<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 不加就看不见 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> ant <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="string">&#x27;ant-design-vue/dist/antd&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// HelloWorld</span></span></span><br><span class="line"><span class="language-javascript">    [ant.<span class="property">name</span>]: ant</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>运行</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/872f729fec4140998426b1af3280a8da.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c05670478dfa4f1c83fff9128397f334.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/138ac7c0c5b94bd49b3445cd974bd7c3.png" alt="在这里插入图片描述"></p>
<p>点击两个按钮就会将两个按钮渲染出来。</p>
<h3 id="vue2测试"><a href="#vue2测试" class="headerlink" title="vue2测试"></a>vue2测试</h3><p>vue2的语法与vue3略有不同，但我们只以<code>router.js</code>文件和<code>main.js</code>文件举例。</p>
<p>router.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./components/myHome.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p>main.js:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
  </entry>
  <entry>
    <title>vue不刷新页面更新组件</title>
    <url>/2022/11/02/Vue.js/vue%E4%B8%8D%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%9B%B4%E6%96%B0%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="router-go和router-view"><a href="#router-go和router-view" class="headerlink" title="router.go和router-view"></a>router.go和router-view</h2><p>使用Vue我们可以实现组件化开发，有些时候，数据只存在于某个组件上，当数据发生变化时，我们只希望更新这个组件而不是刷新整个页面。<br>但是不管是<code>使用this.$router.go(0)</code>还是通过在<code>app.vue</code>中重新加载组件，都没有预期的效果。前者会重新加载页面，后者虽然不会重新加载页面，但是会出现肉眼可见的页面空白，用户体验非常不好。</p>
<h2 id="使用key属性"><a href="#使用key属性" class="headerlink" title="使用key属性"></a>使用key属性</h2><p>我们可以为要改变的标签设置一个key属性，key属性用于vue 元素渲染，每次渲染的时候会去拿这个key 值做对比，如果这一次的key 值和上一次的key值是不一样的才会重新渲染dom 元素，否则保持上一次的元素状态。</p>
<p>根据这个原理，我们可以给key绑定一个获取时间戳的变量，当我们需要更新组件的时候就让这个变量获取一次时间戳，这个时候，key就会检测到变量的变化然后重新生成DOM元素。</p>
<p>在下面的代码中，我们实现了组件的复用，div标签会根据<code>this.$store.state.tab.type</code>的值去渲染不同的组件，但是这个不是重点。我们为每个组件设置了一个<code>:key</code>，<code>:key</code>绑定在本地变量timer上，当我们在子组件中调用父组件中的handler函数，父组件的<code>:key</code>就会检测到timer变量的改变而去重新加载DOM元素，实现页面的数据刷新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">show-message</span> <span class="attr">:key</span>=<span class="string">&quot;timer&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;this.$store.state.tab.type == 0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">show-message</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">release-message</span> <span class="attr">v-if</span>=<span class="string">&quot;this.$store.state.tab.type == 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">release-message</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">update-message</span> <span class="attr">:key</span>=<span class="string">&quot;timer&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;this.$store.state.tab.type == 2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">update-message</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">reply-message</span> <span class="attr">:key</span>=<span class="string">&quot;timer&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;this.$store.state.tab.type == 3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">reply-message</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">timer</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="comment">// 刷新子组件</span></span><br><span class="line">      <span class="title function_">handler</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">timer</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="comment">// 刷新子组件</span></span><br><span class="line">      <span class="title function_">reply</span>(<span class="params">id</span>) &#123;</span><br><span class="line">	      <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">tab</span>.<span class="property">type</span> = <span class="number">3</span>;</span><br><span class="line">	      <span class="comment">// 调用父组件的方法</span></span><br><span class="line">	      <span class="variable language_">this</span>.<span class="property">$parent</span>.<span class="title function_">handler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
  </entry>
  <entry>
    <title>vue路由重定向和动态路由</title>
    <url>/2022/11/02/Vue.js/vue%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h2 id="vue路由重定向"><a href="#vue路由重定向" class="headerlink" title="vue路由重定向"></a>vue路由重定向</h2><p>实现页面跳转一般有两种方式：重定向页面和转发页面。</p>
<p>重定向页面的具体实现方式就是更改页面的URL，跳转到指定的地方。vue中实现路由重定向比较简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(<span class="string">&#x27;/home&#x27;</span>)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;Home&#x27;</span>&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>动态路由就是在路由中携带参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在定义路由的时候指定参数</span></span><br><span class="line"><span class="keyword">const</span> router1 = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>:webHistory,</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 动态路由传参 */</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/book_detail/:id&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;book_detail&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:bookDetail</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>点击BookDetail就可以重定向，book1是我们需要传的参数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态路由传参 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;book_detail&#x27;, params:&#123;id:book1&#125;&quot;</span>&gt;</span>BookDetail<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
  </entry>
  <entry>
    <title>vue与服务端交互</title>
    <url>/2022/11/02/Vue.js/vue%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>前面我们在使用vue的时候，都是对客户端浏览器进行渲染，现在我们使用vue来和服务端进行简单的交互，客户端使用的技术是axios，服务端使用的是gin框架。</p>
<h2 id="编写客户端代码"><a href="#编写客户端代码" class="headerlink" title="编写客户端代码"></a>编写客户端代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先新建一个文件夹，然后打开cmd，使用vue-cli新建一个项目</span></span><br><span class="line">vue create [项目名]</span><br><span class="line"><span class="comment"># 然后下载一些基本要用到的库</span></span><br><span class="line">cnpm install axios --save  <span class="comment"># axios库</span></span><br><span class="line"></span><br><span class="line">cnpm install vue-router@3.2.0 <span class="comment"># vue-router库 （这个版本对应vue2）</span></span><br></pre></td></tr></table></figure>

<p><strong>main.js</strong></p>
<p>在main.js中我们需要创建一个vue对象，然后设置一些全局属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入需要的库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建axios对象，设置全局服务端URL</span></span><br><span class="line"><span class="comment">// 然后把axios对象设置为vue实例的全局属性，这样就不用在每个组件中单独导入axios了</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;/api&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$axios</span> = instance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>vue.config.js</strong></p>
<p>这个文件主要管项目配置，这里我只设置一个允许跨域：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;  <span class="comment">//配置跨域</span></span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://127.0.0.1:9090/&#x27;</span>,  <span class="comment">//这里后台的地址模拟的;应该填写你们真实的后台接口</span></span><br><span class="line">        <span class="attr">changOrigin</span>: <span class="literal">true</span>,  <span class="comment">//允许跨域</span></span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="comment">/* 重写路径，当我们在浏览器中看到请求的地址为：http://localhost:8080/hello 时</span></span><br><span class="line"><span class="comment">            实际上访问的地址是：http://127.0.0.1:9090/core/getData/hello,因为重写了 /api</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<p><strong>HelloWorld.vue</strong></p>
<p>在componment目录下创建一个<code>HelloWorld.vue组件</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&#x27;HelloWorld&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">msg</span>:<span class="literal">null</span>,</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 加载页面完成的时候 就向服务端发送请求</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 然后将返回的数据渲染到页面上</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.<span class="property">$axios</span>.<span class="title function_">get</span>(<span class="string">&quot;/hello&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">msg</span> = res.<span class="property">data</span>.<span class="property">message</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>.<span class="property">message</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p><strong>router.js</strong></p>
<p>编写前端路由：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/helloworld&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;helloworld&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./components/HelloWorld.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">    routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<p><strong>App.vue</strong></p>
<p>修改挂载的根组件，在<code>router.js</code>中定义的组件在访问的时候都会被放在这个根组件中，根组件上要加入<code>&lt;router-view&gt;&lt;/router-view&gt;</code>，不然子组件不会显示。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">name</span>: <span class="string">&quot;app&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="编写服务端代码"><a href="#编写服务端代码" class="headerlink" title="编写服务端代码"></a>编写服务端代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装gin</span></span><br><span class="line">go get -u github.com/gin-gonic/gin</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	r.GET(<span class="string">&quot;/hello&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span> : <span class="string">&quot;success&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	r.Run(<span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>测试</strong></p>
<p><img src="https://img-blog.csdnimg.cn/df6dd656639d4ac091891c4203c2b698.png" alt="在这里插入图片描述"></p>
<p>成功获取到服务端发来的数据，并渲染到页面上。</p>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
  </entry>
  <entry>
    <title>vue组件之间传递参数</title>
    <url>/2022/11/02/Vue.js/vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>Vue的组件与组件之间各自定义的变量是无法共享的，需要通过其他方式进行共享，比如使用vuex集中管理所有组件的状态，还可以使用props传递参数，props一般用户父子组件之间的通信。</p>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p>在传递一些数据量小并且非隐私变量的时候，比如<code>id、key、username</code>等等，我们可以把变量放在路由中。我一般使用以下两种方式进行传参：</p>
<p><strong>1. params</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;user&#x27;</span>,  <span class="comment">// 路由</span></span><br><span class="line">  <span class="attr">params</span>:&#123;      <span class="comment">// 待传递的参数</span></span><br><span class="line">     <span class="attr">id</span>: <span class="variable language_">this</span>.<span class="property">id</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">params</span>.<span class="property">id</span>    <span class="comment">// 取出参数</span></span><br></pre></td></tr></table></figure>

<p>这种传参方式的特点是，当你刷新一次页面时，路由参数会消失。</p>
<p><strong>2. query</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">path</span>:<span class="string">&#x27;/user&#x27;</span>,  <span class="comment">// 路由</span></span><br><span class="line">  <span class="attr">query</span>:&#123;      <span class="comment">// 待传递的参数</span></span><br><span class="line">     <span class="attr">id</span>: <span class="variable language_">this</span>.<span class="property">id</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$route</span>.<span class="property">query</span>.<span class="property">id</span>    <span class="comment">// 取出参数</span></span><br></pre></td></tr></table></figure>

<p>这种传参方式的特点是，刷新页面之后的路由参数不会消失。</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>props一般用于父组件向子组件传递值，但默认在子组件内部无法改变父组件传过来的值，也即默认是单向传递。所以<code>props</code>默认有以下两个特点：</p>
<ul>
<li>总是根据父组件的值进行变化</li>
<li>作为子组件data属性的初始值</li>
</ul>
<p>下面我们来演示一下默认的用法：</p>
<p>父组件<code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">children</span></span></span><br><span class="line"><span class="tag">		<span class="attr">:userInfo</span>=<span class="string">&quot;userInfo&quot;</span></span></span><br><span class="line"><span class="tag">		&gt;</span><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Children</span> <span class="keyword">from</span> <span class="string">&quot;./Children.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">	      <span class="title class_">Children</span>,</span></span><br><span class="line"><span class="language-javascript">	    &#125;,</span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="attr">userInfo</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件：<code>Children.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		&#123;&#123;this.userInfo&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="attr">userInfo</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">default</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后子组件中的<code>userInfo</code>就和父组件中的<code>userInfo</code>动态绑定起来了，但是在子组件中是无法改变<code>userInfo</code>的。</p>
<p>但是我们通过<code>sync</code>修饰符去实现双向绑定：</p>
<p>父组件<code>Father.vue</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">children</span></span></span><br><span class="line"><span class="tag">		<span class="attr">:userInfo.sync</span>=<span class="string">&quot;userInfo&quot;</span></span></span><br><span class="line"><span class="tag">		&gt;</span><span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">Children</span> <span class="keyword">from</span> <span class="string">&quot;./Children.vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">	      <span class="title class_">Children</span>,</span></span><br><span class="line"><span class="language-javascript">	    &#125;,</span></span><br><span class="line"><span class="language-javascript">	<span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="attr">userInfo</span>: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子组件：<code>Children.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		&#123;&#123;this.userInfo&#125;&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">	<span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="attr">userInfo</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">type</span>: <span class="title class_">String</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">default</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">	&#125;,</span></span><br><span class="line"><span class="language-javascript">	<span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">		<span class="title function_">updateUserInfo</span>(<span class="params">userInfo</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">			<span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:userInfo&#x27;</span>, userInfo);</span></span><br><span class="line"><span class="language-javascript">		&#125;</span></span><br><span class="line"><span class="language-javascript">	&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们就可以调用<code>updateUserInfo</code>函数在子组件中修改userInfo的值。</p>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>Vuex将多个组件共享的变量全部存储在一个对象里面，然后将这个对象放在顶层的 Vue 实例中，让其他组件可以使用，它最大的特点是响应式。<br>vuex由五个部分组成，分别是<code>State，Mutation，Action，Module，Getter</code>。<br>由于我们只是单纯的用于传递参数，所以只介绍state：</p>
<p>安装vue2对应的vuex：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install vuex@3.4.0 --save</span><br></pre></td></tr></table></figure>


<p>首先在src目录下创建一个<code>store</code>文件夹：<br>在里面定义一个<code>index.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="comment">// 用户信息</span></span><br><span class="line">    <span class="attr">userInfo</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// 更新用户信息</span></span><br><span class="line">    <span class="title function_">updateUserInfo</span>(<span class="params">state, userInfo</span>) &#123;</span><br><span class="line">      state.<span class="property">userInfo</span> = userInfo;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后在<code>main.js</code>中注册<code>store</code>全局变量:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p>我们可以使用以下的方式来获取和修改在vuex中定义的全局变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改用户信息</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;updateUserInfo&quot;</span>, res.<span class="property">data</span>.<span class="property">user_info</span>)</span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">userInfo</span></span><br></pre></td></tr></table></figure>

<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><p>当我们需要传递的变量比较大的时候，比如购物车列表、用户信息、token等等，可以存到浏览器缓存中，要使用的时候就取出来。</p>
<p>原生的javascript提供了一个API来访问浏览器缓存：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存数据</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line"><span class="comment">// 取数据</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="comment">// 删数据</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&quot;key&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>另外如果要存的是map、array这种类型，可以先把数据格式化为json，取出来的时候再解码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存数据</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;key&quot;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value));</span><br><span class="line"><span class="comment">// 取数据</span></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;key&quot;</span>));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue.js</category>
      </categories>
  </entry>
  <entry>
    <title>快速排序算法 Go实现</title>
    <url>/2022/11/02/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20Go%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>算法描述：是对插入算法的一种优化，利用对问题的二分化，实现递归完成快速排序 ，在所有算法中二分化是最常用的方式，将问题尽量的分成两种情况加以分析， 最终以形成类似树的方式加以利用，因为在比较模型中的算法中，最快的排序时间复杂度为O(nlgn)。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol>
<li>将数据根据一个值按照大小分成左右两边，左边小于此值，右边大于这个值。</li>
<li>将两边数据进行递归调用步骤1。</li>
<li>将所有数据合并。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort1</span><span class="params">(arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line">	splitData := arr[<span class="number">0</span>]  		 <span class="comment">//第一个数据</span></span><br><span class="line">	low := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">0</span>)  	 <span class="comment">//比第一个数小的数据</span></span><br><span class="line">	high := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">0</span>)   <span class="comment">//比第一个数大的数据</span></span><br><span class="line">	mid := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>, <span class="number">0</span>)   	 <span class="comment">//与第一个数一样大的数据</span></span><br><span class="line">	mid = <span class="built_in">append</span>(mid, splitData) <span class="comment">//把第一个数加入到mid切片</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; splitData &#123;</span><br><span class="line">			low = <span class="built_in">append</span>(low, arr[i])</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[i] &gt; splitData &#123;</span><br><span class="line">			high = <span class="built_in">append</span>(high, arr[i])</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			mid = <span class="built_in">append</span>(mid, arr[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	low, high = QuickSort1(low), QuickSort1(high)</span><br><span class="line">	myArr := <span class="built_in">append</span>(<span class="built_in">append</span>(low, mid...), high...)</span><br><span class="line">	<span class="keyword">return</span> myArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort2</span><span class="params">(left <span class="type">int</span>, right <span class="type">int</span>, arr []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	i, j := left, right</span><br><span class="line">	mid := arr[(left + right) / <span class="number">2</span>]    <span class="comment">//将当前序列在中间位的数定义为分隔数</span></span><br><span class="line">	<span class="keyword">for</span> i &lt;= j &#123;</span><br><span class="line">		<span class="keyword">for</span> arr[i] &lt; mid &#123;     <span class="comment">//扫描左半部分比分隔数大的数</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> arr[j] &gt; mid &#123;     <span class="comment">//扫描右半部分比分隔数小的数</span></span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i &lt;= j &#123;     <span class="comment">//交换上述找到的两个数</span></span><br><span class="line">			arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">			i++</span><br><span class="line">			j--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> left &lt; j &#123;</span><br><span class="line">		QuickSort2(left, j, arr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i &lt; right &#123;</span><br><span class="line">		QuickSort2(i, right, arr)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">63</span>, <span class="number">234</span>, <span class="number">12</span>&#125;</span><br><span class="line">	fmt.Println(QuickSort1(arr))</span><br><span class="line">	<span class="comment">//QuickSort2(0, len(arr) - 1, arr)</span></span><br><span class="line">	<span class="comment">//fmt.Println(arr)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">12</span> <span class="number">30</span> <span class="number">45</span> <span class="number">63</span> <span class="number">234</span>]</span><br></pre></td></tr></table></figure>



<p>目测QuickSort2会更节约内存，因为每调用一次QuickSort1都会为3个切片分配底层数组，如果数据非常大，可能会非常耗费内存。</p>
]]></content>
      <categories>
        <category>Go数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>堆排序算法 Go实现</title>
    <url>/2022/11/02/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%20Go%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>我们以大根堆举例，堆其实就是<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a>，大根堆的堆顶是堆中的最大元素，大根堆的父节点比左右两个孩子都大：</p>
<p><img src="https://img-blog.csdnimg.cn/69806f3770c74058b8e8d4a68f9a3de6.png" alt="在这里插入图片描述"><br>看完大根堆的结构之后，我们其实还需要将大根堆中的元素都存到数组中，比如上面结构的大根堆对应的数组如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/8f67f41cc7c5423d97de1d7c906a6c53.png" alt="在这里插入图片描述"><br>同时用数组储存大根堆还有一些规则：<br><img src="https://img-blog.csdnimg.cn/4fedf8bfd07b4a52ac6278425ce11f44.png" alt="在这里插入图片描述"><br><strong>大根堆的维护</strong></p>
<p>如果大根堆中的元素不满足大根堆的性质，就要进行堆的维护。比如下图中的红色节点，节点值为4，此时就不满足对的性质了（孩子节点的值比父节点大），需要进行堆的维护。</p>
<p><img src="https://img-blog.csdnimg.cn/30e28c4e554145969d1c1b81f2abc8e8.png" alt="在这里插入图片描述"><br>首先将父节点与左孩子进行交换：</p>
<p><img src="https://img-blog.csdnimg.cn/8e18385d3f564ef89316e265586067d0.png" alt="在这里插入图片描述"><br>接着还需要对左孩子进行堆的维护，因为交换之后，左孩子与它自己的孩子就违反了堆的性质，我们将左孩子与它的右孩子进行交换，就完成了堆的维护：</p>
<p><img src="https://img-blog.csdnimg.cn/4013ae3cce1f4864b917357e03e81c14.png" alt="在这里插入图片描述"></p>
<p>所以堆的维护是一个<code>递归</code>的过程，对堆进行维护的时间复杂度是<code>O(logN)</code>。</p>
<p>以下是堆维护的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n <span class="type">int</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//堆的维护</span></span><br><span class="line">	largest := i  		<span class="comment">//i为当前父节点的下标</span></span><br><span class="line">	lson := i * <span class="number">2</span> + <span class="number">1</span>   <span class="comment">//左孩子</span></span><br><span class="line">	rson := i * <span class="number">2</span> + <span class="number">2</span>   <span class="comment">//右孩子</span></span><br><span class="line">	<span class="comment">// 保存最大值的下标</span></span><br><span class="line">	<span class="keyword">if</span> lson &lt; n &amp;&amp; arr[largest] &lt; arr[lson] &#123;</span><br><span class="line">		largest = lson</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rson &lt; n &amp;&amp; arr[largest] &lt; arr[rson] &#123;</span><br><span class="line">		largest = rson</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> largest != i &#123;</span><br><span class="line">		arr[largest], arr[i] = arr[i], arr[largest]</span><br><span class="line">		<span class="comment">// 往孩子节点递归维护堆</span></span><br><span class="line">		heapify(arr, n, largest)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建堆</strong></p>
<p>在面对一个无序的数组，我们要做的第一件事情就是<code>建堆</code>。</p>
<p>以下面这个无序数组为例：</p>
<p><img src="https://img-blog.csdnimg.cn/fe8d528de9aa4e669024851d2fc5f2d7.png" alt="在这里插入图片描述"><br>堆的初始状态是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/b760be4500924890bf4881f6795049de.png" alt="在这里插入图片描述"><br>我们需要从最后一个元素的父节点开始建堆，根据我们之前堆元素映射到数组中的下标规则，最后一个元素的父节点下标是<code>n / 2 - 1</code>。所以我们应该从<code>n / 2 - 1</code>到<code>0</code>进行堆的维护，这样可以使得我们每进行一次维护都不必去考虑孩子的情况，因为孩子节点已经满足堆的性质了。</p>
<p>所以建堆的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建堆</span></span><br><span class="line">	<span class="comment">// 从最后一个元素的父节点进行建堆（第一次堆的维护）</span></span><br><span class="line">	<span class="keyword">for</span> i := n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		heapify(arr, n, i)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>堆排序</strong></p>
<p>建立好大根堆之后，我们需要进行堆排序，其实就是每次将堆顶元素放到数组的后面（将数组中的当前元素与数组末尾的元素做交换），同时进行堆的维护，这样每一次操作之后堆顶元素始终是堆中的最大元素，那么当结束这个过程之后，数组就是一个递增的有序数组。</p>
<p>堆排序的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="comment">// 每次将堆的最后一个元素与堆顶元素交换，然后从堆中删除最后一个元素放到数组的最后一位</span></span><br><span class="line"><span class="comment">// 堆顶元素就是每次维护结束以后堆中最大的元素</span></span><br><span class="line"><span class="comment">// 到最后数组就会从小到大排序</span></span><br><span class="line"><span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">	arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">	<span class="comment">// 交换元素以后要进行堆的维护</span></span><br><span class="line">	heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">heapify</span><span class="params">(arr []<span class="type">int</span>, n <span class="type">int</span>, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//堆的维护</span></span><br><span class="line">	largest := i  		<span class="comment">//i为当前父节点的下标</span></span><br><span class="line">	lson := i * <span class="number">2</span> + <span class="number">1</span>   <span class="comment">//左孩子</span></span><br><span class="line">	rson := i * <span class="number">2</span> + <span class="number">2</span>   <span class="comment">//右孩子</span></span><br><span class="line">	<span class="comment">// 保存最大值的下标</span></span><br><span class="line">	<span class="keyword">if</span> lson &lt; n &amp;&amp; arr[largest] &lt; arr[lson] &#123;</span><br><span class="line">		largest = lson</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rson &lt; n &amp;&amp; arr[largest] &lt; arr[rson] &#123;</span><br><span class="line">		largest = rson</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> largest != i &#123;</span><br><span class="line">		arr[largest], arr[i] = arr[i], arr[largest]</span><br><span class="line">		<span class="comment">// 往孩子节点递归维护堆</span></span><br><span class="line">		heapify(arr, n, largest)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HeapSort</span><span class="params">(arr []<span class="type">int</span>, n <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 建堆</span></span><br><span class="line">	<span class="comment">// 从最后一个元素的父节点进行建堆（第一次堆的维护）</span></span><br><span class="line">	<span class="keyword">for</span> i := n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		heapify(arr, n, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	<span class="comment">// 每次将堆的最后一个元素与堆顶元素交换，然后从堆中删除最后一个元素放到数组的最后一位</span></span><br><span class="line">	<span class="comment">// 堆顶元素就是每次维护结束以后堆中最大的元素</span></span><br><span class="line">	<span class="comment">// 到最后数组就会从小到大排序</span></span><br><span class="line">	<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		arr[i], arr[<span class="number">0</span>] = arr[<span class="number">0</span>], arr[i]</span><br><span class="line">		<span class="comment">// 交换元素以后要进行堆的维护</span></span><br><span class="line">		heapify(arr, i, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">45</span>, <span class="number">8</span>, <span class="number">63</span>, <span class="number">234</span>, <span class="number">12</span>&#125;</span><br><span class="line">	HeapSort(arr, <span class="built_in">len</span>(arr))</span><br><span class="line">	fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">12</span> <span class="number">30</span> <span class="number">45</span> <span class="number">63</span> <span class="number">234</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找算法 Go实现</title>
    <url>/2022/11/02/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%20Go%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>在一组有序数组中，将数组一分为二，将要查询的元素和分割点进行比较，分为三种情况:</p>
<ul>
<li>相等直接返回</li>
<li>元素大于分割点，在分割点右侧继续查找</li>
<li>元素小于分割点，在分割点左侧继续查找</li>
</ul>
<p>时间复杂度：<strong>O(lgn)</strong></p>
<p><strong>要求</strong></p>
<p>必须是有序的数组，并能支持随机访问。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binSearch</span><span class="params">(arr []<span class="type">int</span>, findData <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	low := <span class="number">0</span></span><br><span class="line">	high := <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := (low + high) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> arr[mid] &gt; findData &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[mid] &lt; findData &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> mid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">1024</span> * <span class="number">1024</span>, <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1024</span> * <span class="number">1024</span>; i++ &#123;</span><br><span class="line">		arr[i] = i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	id := binSearch(arr, <span class="number">1024</span>)</span><br><span class="line">	<span class="keyword">if</span> id != <span class="number">-1</span> &#123;</span><br><span class="line">		fmt.Println(id, arr[id])</span><br><span class="line">	&#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;can&#x27;t find data&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>拓扑排序 Go实现</title>
    <url>/2022/11/02/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%20Go%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若&lt;u，v&gt; ∈E(G)，则u在线性序列中出现在v之前。</p>
<p>通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。</p>
<p> <strong>注意:</strong></p>
<p>   1.只有有向无环图才存在拓扑序列;</p>
<p>   2.对于一个DAG,可能存在多个拓扑序列;</p>
<h2 id="Kahn算法"><a href="#Kahn算法" class="headerlink" title="Kahn算法"></a>Kahn算法</h2><p>利用贪心算法，如果两个顶点，顶点b依赖于顶点a,就将a指向b,当一个顶点的入度为零，将这个顶点就是最优排序点， 并且将顶点从图中移除，将可达顶点的入度减一。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> graph <span class="keyword">struct</span> &#123;</span><br><span class="line">	vertex <span class="type">int</span>    <span class="comment">//顶点</span></span><br><span class="line">	list <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span> <span class="comment">//连接表边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加边</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span></span> addVertex(t <span class="type">int</span>, s <span class="type">int</span>)  &#123;</span><br><span class="line">	g.list[t] = push(g.list[t], s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KhanSort 拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *graph)</span></span> KhanSort()  &#123;</span><br><span class="line">	<span class="comment">// 入度</span></span><br><span class="line">	<span class="keyword">var</span> inDegree = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">	<span class="comment">// 储存结果的队列</span></span><br><span class="line">	<span class="keyword">var</span> queue []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加入度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= g.vertex; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _, m := <span class="keyword">range</span> g.list[i] &#123;</span><br><span class="line">			inDegree[m]++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果某个节点的入度为0，就加入结果队列</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= g.vertex; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> inDegree[i] == <span class="number">0</span> &#123;</span><br><span class="line">			queue = push(queue, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当有值加入结果队列</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> now <span class="type">int</span></span><br><span class="line">		now, queue = pop(queue)</span><br><span class="line">		fmt.Println(<span class="string">&quot;-&gt;&quot;</span>, now)</span><br><span class="line">		<span class="comment">// 将所有相邻的入度减1</span></span><br><span class="line">		<span class="keyword">for</span> _, k := <span class="keyword">range</span> g.list[now] &#123;</span><br><span class="line">			inDegree[k]--</span><br><span class="line">			<span class="comment">//如果相邻点的入度恰好变为0，加入结果队列中</span></span><br><span class="line">			<span class="keyword">if</span> inDegree[k] == <span class="number">0</span> &#123;</span><br><span class="line">				queue = push(queue, k)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewGraph 创建图</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewGraph</span><span class="params">(v <span class="type">int</span>)</span></span> *graph &#123;</span><br><span class="line">	g := <span class="built_in">new</span>(graph)</span><br><span class="line">	g.vertex = v</span><br><span class="line">	g.list = <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; v &#123;</span><br><span class="line">		g.list[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出切片第一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">(list []<span class="type">int</span>)</span></span> (<span class="type">int</span>, []<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(list) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		a := list[<span class="number">0</span>]</span><br><span class="line">		b := list[<span class="number">1</span>:]</span><br><span class="line">		<span class="keyword">return</span> a, b</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, list</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推入切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(list []<span class="type">int</span>, value <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	result := <span class="built_in">append</span>(list, value)</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建八个节点的无向图</span></span><br><span class="line">	g := NewGraph(<span class="number">8</span>)</span><br><span class="line">	g.addVertex(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">	g.addVertex(<span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">	g.addVertex(<span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line">	g.addVertex(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">	g.addVertex(<span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line">	g.addVertex(<span class="number">8</span>, <span class="number">7</span>)</span><br><span class="line">	g.KhanSort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>跳跃表 Go实现</title>
    <url>/2022/11/02/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6%E8%B7%B3%E8%B7%83%E8%A1%A8%20Go%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="跳跃表介绍"><a href="#跳跃表介绍" class="headerlink" title="跳跃表介绍"></a>跳跃表介绍</h2><p>跳跃表（skiplist）是一种有序的数据结构，它通过建立多层”索引”，从而达到快速访问节点的目的. 跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>下面是一个跳表结构的示意图，其实跳表就是一个二维链表，只有最底层的链表中存着数据，其他层都是在第一层基础上建立的索引，越靠近上层，节点之间的跨度就越大，跳表的查询范围也越大。依靠着这些索引，跳表可以实现接近二分查找的查找效率。</p>
<p><img src="https://img-blog.csdnimg.cn/de91bddf6ba4449fad7d54efb6f7192c.png" alt="在这里插入图片描述"></p>
<h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><h3 id="跳跃表的结构"><a href="#跳跃表的结构" class="headerlink" title="跳跃表的结构"></a>跳跃表的结构</h3><p><strong>跳表的元素</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Element 是一个key-score对组</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">	Member <span class="type">string</span></span><br><span class="line">	<span class="comment">// 跳跃表节点依照Score升序排序，若一样，则按照Member的字典升序排序</span></span><br><span class="line">	Score <span class="type">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳表的层结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Level 层</span></span><br><span class="line"><span class="keyword">type</span> Level <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 指向前面一个节点</span></span><br><span class="line">	forward *node</span><br><span class="line">	<span class="comment">// 与前一个节点的跨度</span></span><br><span class="line">	span <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳表的节点</strong></p>
<p>跳表的一个节点有三个字段：元素、指向前一个节点的指针和建立在该节点之上的层级。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// node 跳跃表的一个节点</span></span><br><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Element</span><br><span class="line">	<span class="comment">// 回退指针</span></span><br><span class="line">	backward *node</span><br><span class="line">	<span class="comment">// 每个节点有 1~maxLevel 个层级</span></span><br><span class="line">	level []*Level</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>跳表的表头结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// skiplist 跳表结构</span></span><br><span class="line"><span class="keyword">type</span> skiplist <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 指向表头节点</span></span><br><span class="line">	header *node</span><br><span class="line">	<span class="comment">// 指向表尾节点</span></span><br><span class="line">	tail *node</span><br><span class="line">	<span class="comment">// 跳跃表的长度（除了第一个节点）</span></span><br><span class="line">	length <span class="type">int64</span></span><br><span class="line">	<span class="comment">// 跳跃表的最大层级（除了第一个节点）</span></span><br><span class="line">	level <span class="type">int16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建跳跃表"><a href="#创建跳跃表" class="headerlink" title="创建跳跃表"></a>创建跳跃表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// makeNode 创建一个跳跃表节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeNode</span><span class="params">(level <span class="type">int16</span>, score <span class="type">float64</span>, member <span class="type">string</span>)</span></span> *node &#123;</span><br><span class="line">	n := &amp;node&#123;</span><br><span class="line">		Element: Element&#123;</span><br><span class="line">			Score:  score,</span><br><span class="line">			Member: member,</span><br><span class="line">		&#125;,</span><br><span class="line">		level: <span class="built_in">make</span>([]*Level, level),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> n.level &#123;</span><br><span class="line">		n.level[i] = <span class="built_in">new</span>(Level)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeSkiplist 创建一个跳跃表结构</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSkiplist</span><span class="params">()</span></span> *skiplist &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;skiplist&#123;</span><br><span class="line">		level:  <span class="number">1</span>,</span><br><span class="line">		header: makeNode(maxLevel, <span class="number">0</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳跃表的插入和删除"><a href="#跳跃表的插入和删除" class="headerlink" title="跳跃表的插入和删除"></a>跳跃表的插入和删除</h3><p>在插入跳跃表之前，我们要明确的是新插入的这个节点，我们应该在它之上建立多少层索引呢？我们将通过一个随机算法来计算得到一个随机值，叫做<code>幂次定律</code>。</p>
<p>幂次定律的含义是：如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律。映射到我们的需求就是一个新插入的节点，生成小数值层数的概率很大，而生成大数值层数的概率很小。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	maxLevel = <span class="number">16</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// randomLevel 随机生成一个新跳跃表节点的层数（1~16）</span></span><br><span class="line"><span class="comment">// 满足幂次定律</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">randomLevel</span><span class="params">()</span></span> <span class="type">int16</span> &#123;</span><br><span class="line">	level := <span class="type">int16</span>(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> <span class="type">float32</span>(rand.Int31()&amp;<span class="number">0xFFFF</span>) &lt; (<span class="number">0.25</span> * <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">		level++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> level &lt; maxLevel &#123;</span><br><span class="line">		<span class="keyword">return</span> level</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxLevel</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述函数计算出来的层数将呈现以下概率：</p>
<p>p &#x3D; 0.25（1&#x2F;4）</p>
<p>层数恰好为1的概率（不执行while）为<code>1 - p</code>（3&#x2F;4）.<br>层数恰好为2的概率（执行 1 次while）为<code>p * (1 - p)</code>（3&#x2F;16）.<br>层数恰好为3的概率（执行 2 次while）为<code>p ^ 2 * (1 - p)</code>（3&#x2F;64）.<br>层数恰好为4的概率（执行 3 次while）为<code>p ^ 3 * (1 - p)</code>（3&#x2F;256）.<br>层数恰好为k（k &lt;&#x3D; 32）的概率（执行 k - 1 次while）为<code>p ^ (k - 1) * (1 - p)</code>.</p>
<p>可以发现生成越高层数的概率会越来越小，而且和上一次呈幂关系递减.</p>
<p><strong>插入操作</strong></p>
<p>插入操作的步骤：</p>
<ol>
<li>首先准备两个切片：update（用于保存在每一层，待插入节点的前一个节点）、rank（用于累加每一层的跨度，方便后续待插入节点索引中span字段的计算）。</li>
<li>从上至下遍历每一层索引，在每一层中寻找待插入节点的位置（如果分数比当前节点小，就往后遍历，比当前节点大就下沉），将待插入节点的前一个节点存到update切片中，然后将待插入节点相对起始点的便宜量粗存到rank切片中。</li>
<li>找到待插入节点的位置之后，先使用<code>randomLevel</code>函数获取该节点应该建立索引的层数。</li>
<li>接着构造节点，然后插入到应该插入的位置，首先需要更新每一层索引的状态，新插入节点的forward指针就指向前一个节点的forward指针指向的位置（前一个节点保存在update切片中），新插入节点的索引span字段就是它与前一个节点同层索引的跨度之差（通过rank切片计算得到）。接着因为新插入节点增加了前面节点的跨度，所以需要更新前面一个节点每一层的跨度。</li>
<li>最后设置新插入节点的backward指针指向，直接指向前一个节点即可（通过update切片来实现）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// insert 插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> insert(member <span class="type">string</span>, score <span class="type">float64</span>) *node &#123;</span><br><span class="line">	<span class="comment">// 保存在每一层，待插入节点的前一个节点</span></span><br><span class="line">	update := <span class="built_in">make</span>([]*node, maxLevel)</span><br><span class="line">	<span class="comment">// 用于累加跨度</span></span><br><span class="line">	rank := <span class="built_in">make</span>([]<span class="type">int64</span>, maxLevel)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到待插入的位置</span></span><br><span class="line">	node := skiplist.header</span><br><span class="line">	<span class="keyword">for</span> i := skiplist.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> i == skiplist.level<span class="number">-1</span> &#123;</span><br><span class="line">			rank[i] = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 累加跨度</span></span><br><span class="line">			rank[i] = rank[i+<span class="number">1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.level[i] != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 在第i层找待插入的位置</span></span><br><span class="line">			<span class="keyword">for</span> node.level[i].forward != <span class="literal">nil</span> &amp;&amp;</span><br><span class="line">				(node.level[i].forward.Score &lt; score ||</span><br><span class="line">					(node.level[i].forward.Score == score &amp;&amp; node.level[i].forward.Member &lt; member)) &#123; <span class="comment">// same score, different key</span></span><br><span class="line">				<span class="comment">// 累加与前一个节点的跨度</span></span><br><span class="line">				rank[i] += node.level[i].span</span><br><span class="line">				<span class="comment">// 前进</span></span><br><span class="line">				node = node.level[i].forward</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		update[i] = node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获得随机层数</span></span><br><span class="line">	level := randomLevel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果新插入的节点抽到的层级最大</span></span><br><span class="line">	<span class="keyword">if</span> level &gt; skiplist.level &#123;</span><br><span class="line">		<span class="comment">// 初始化每一层的状态</span></span><br><span class="line">		<span class="keyword">for</span> i := skiplist.level; i &lt; level; i++ &#123;</span><br><span class="line">			rank[i] = <span class="number">0</span></span><br><span class="line">			update[i] = skiplist.header</span><br><span class="line">			update[i].level[i].span = skiplist.length</span><br><span class="line">		&#125;</span><br><span class="line">		skiplist.level = level</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造新节点并插入到跳表</span></span><br><span class="line">	node = makeNode(level, score, member)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">int16</span>(<span class="number">0</span>); i &lt; level; i++ &#123;</span><br><span class="line">		node.level[i].forward = update[i].level[i].forward</span><br><span class="line">		update[i].level[i].forward = node</span><br><span class="line"></span><br><span class="line">		node.level[i].span = update[i].level[i].span - (rank[<span class="number">0</span>] - rank[i])</span><br><span class="line">		update[i].level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 新插入的节点增加了前面节点的跨度</span></span><br><span class="line">	<span class="keyword">for</span> i := level; i &lt; skiplist.level; i++ &#123;</span><br><span class="line">		update[i].level[i].span++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置回退节点</span></span><br><span class="line">	<span class="keyword">if</span> update[<span class="number">0</span>] == skiplist.header &#123;</span><br><span class="line">		node.backward = <span class="literal">nil</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		node.backward = update[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 设置node前面一个节点的回退节点</span></span><br><span class="line">	<span class="keyword">if</span> node.level[<span class="number">0</span>].forward != <span class="literal">nil</span> &#123;</span><br><span class="line">		node.level[<span class="number">0</span>].forward.backward = node</span><br><span class="line">	&#125;</span><br><span class="line">	skiplist.length++</span><br><span class="line">	<span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除操作</strong></p>
<p>删除操作首先要找到待删除节点的位置，找节点的步骤与插入节点的操作类似的，首先创建一个切片：update（用于保存在每一层，待删除节点的前一个节点）。然后在每一层中进行查找，分数比当前节点小，就往后遍历，比当前节点大就下沉，同时用update切片记录每一层中待删除节点的前一个节点。找到该节点之后，就可以进行删除操作了。</p>
<p>先更新每一层索引的状态：更新待删除节点前一个节点的跨度以及forward指针的指向。<br>然后更新后面一个节点的回退指针，最后更新跳表中的最大层级即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找待删除的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> remove(member <span class="type">string</span>, score <span class="type">float64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 储存待删除节点每一层的上一个节点</span></span><br><span class="line">	update := <span class="built_in">make</span>([]*node, maxLevel)</span><br><span class="line">	node := skiplist.header</span><br><span class="line">	<span class="comment">// 寻找待删除节点</span></span><br><span class="line">	<span class="keyword">for</span> i := skiplist.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">for</span> node.level[i].forward != <span class="literal">nil</span> &amp;&amp;</span><br><span class="line">			(node.level[i].forward.Score &lt; score ||</span><br><span class="line">				(node.level[i].forward.Score == score &amp;&amp;</span><br><span class="line">					node.level[i].forward.Member &lt; member)) &#123;</span><br><span class="line">			node = node.level[i].forward</span><br><span class="line">		&#125;</span><br><span class="line">		update[i] = node</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// node在循环中，一直是待删除节点的前一个节点</span></span><br><span class="line">	<span class="comment">// 在最底层的索引处向后移动一位，刚好就是待删除节点</span></span><br><span class="line">	node = node.level[<span class="number">0</span>].forward</span><br><span class="line">	<span class="comment">// 找到该节点</span></span><br><span class="line">	<span class="keyword">if</span> node != <span class="literal">nil</span> &amp;&amp; score == node.Score &amp;&amp; node.Member == member &#123;</span><br><span class="line">		skiplist.removeNode(node, update)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除找到的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> removeNode(node *node, update []*node) &#123;</span><br><span class="line">	<span class="comment">// 更新每一层的状态</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="type">int16</span>(<span class="number">0</span>); i &lt; skiplist.level; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> update[i].level[i].forward == node &#123;</span><br><span class="line">			update[i].level[i].span += node.level[i].span - <span class="number">1</span></span><br><span class="line">			update[i].level[i].forward = node.level[i].forward</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			update[i].level[i].span--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新后面一个节点的回退指针</span></span><br><span class="line">	<span class="keyword">if</span> node.level[<span class="number">0</span>].forward != <span class="literal">nil</span> &#123;</span><br><span class="line">		node.level[<span class="number">0</span>].forward.backward = node.backward</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		skiplist.tail = node.backward</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 更新跳表中的最大层级</span></span><br><span class="line">	<span class="keyword">for</span> skiplist.level &gt; <span class="number">1</span> &amp;&amp; skiplist.header.level[skiplist.level<span class="number">-1</span>].forward == <span class="literal">nil</span> &#123;</span><br><span class="line">		skiplist.level--</span><br><span class="line">	&#125;</span><br><span class="line">	skiplist.length--</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="跳跃表的排名操作"><a href="#跳跃表的排名操作" class="headerlink" title="跳跃表的排名操作"></a>跳跃表的排名操作</h3><p><strong>获取元素的排名</strong></p>
<p>获取元素的排名操作比较简单，首先定义一个rank整型变量，用于在遍历的时候累加跨度。<br>接着逐层进行查找，在某一层进行查找时，每往前遍历一个元素，就使用rank变量累加上它们索引之间的跨度，当遍历到第0层时，就找到了这个节点，rank变量就是当前节点在整个跳跃表中的排名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> getRank(member <span class="type">string</span>, score <span class="type">float64</span>) <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> rank <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">	x := skiplist.header</span><br><span class="line">	<span class="keyword">for</span> i := skiplist.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">for</span> x.level[i].forward != <span class="literal">nil</span> &amp;&amp;</span><br><span class="line">			(x.level[i].forward.Score &lt; score ||</span><br><span class="line">				(x.level[i].forward.Score == score &amp;&amp;</span><br><span class="line">					x.level[i].forward.Member &lt;= member)) &#123;</span><br><span class="line">			rank += x.level[i].span</span><br><span class="line">			x = x.level[i].forward</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> x.Member == member &#123;</span><br><span class="line">			<span class="keyword">return</span> rank</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过排名获取元素</strong></p>
<p>首先定义一个变量i用于累加每一层索引的跨度，接着在每一层索引中进行遍历，如果i累加上当前节点层与下一个节点层的跨度值小于rank，就继续往后遍历，否则就下沉。当i等于rank时，就找到了该节点。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> getByRank(rank <span class="type">int64</span>) *node &#123;</span><br><span class="line">	<span class="comment">// 记录从头节点开始的跨度</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 用于遍历节点的指针</span></span><br><span class="line">	n := skiplist.header</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从最高层级开始遍历</span></span><br><span class="line">	<span class="keyword">for</span> level := skiplist.level - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;</span><br><span class="line">		<span class="keyword">for</span> n.level[level].forward != <span class="literal">nil</span> &amp;&amp; (i+n.level[level].span) &lt;= rank &#123;</span><br><span class="line">			i += n.level[level].span</span><br><span class="line">			n = n.level[level].forward</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i == rank &#123;</span><br><span class="line">			<span class="keyword">return</span> n</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳跃表的区间操作"><a href="#跳跃表的区间操作" class="headerlink" title="跳跃表的区间操作"></a>跳跃表的区间操作</h3><p>我们创建了一个<code>ScoreBorder</code>结构体用于封装跳表的分数，提供了比较大小以及创建<code>ScoreBorder</code>等API。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 负无穷</span></span><br><span class="line">	negativeInf <span class="type">int8</span> = <span class="number">-1</span></span><br><span class="line">	<span class="comment">// 正无穷</span></span><br><span class="line">	positiveInf <span class="type">int8</span> = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ScoreBorder <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 标记当前分数是否为无穷</span></span><br><span class="line">	Inf <span class="type">int8</span></span><br><span class="line">	<span class="comment">// 分数值</span></span><br><span class="line">	Value <span class="type">float64</span></span><br><span class="line">	<span class="comment">// 标记两个分数相等时，是否返回true</span></span><br><span class="line">	Exclude <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(border *ScoreBorder)</span></span> greater(value <span class="type">float64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> border.Inf == negativeInf &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> border.Inf == positiveInf &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> border.Exclude &#123;</span><br><span class="line">		<span class="keyword">return</span> border.Value &gt; value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> border.Value &gt;= value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(border *ScoreBorder)</span></span> less(value <span class="type">float64</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> border.Inf == negativeInf &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> border.Inf == positiveInf &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> border.Exclude &#123;</span><br><span class="line">		<span class="keyword">return</span> border.Value &lt; value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> border.Value &lt;= value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> positiveInfBorder = &amp;ScoreBorder&#123;</span><br><span class="line">	Inf: positiveInf,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> negativeInfBorder = &amp;ScoreBorder&#123;</span><br><span class="line">	Inf: negativeInf,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseScoreBorder 根据参数构造并返回ScoreBorder</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseScoreBorder</span><span class="params">(s <span class="type">string</span>)</span></span> (*ScoreBorder, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> s == <span class="string">&quot;inf&quot;</span> || s == <span class="string">&quot;+inf&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> positiveInfBorder, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s == <span class="string">&quot;-inf&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> negativeInfBorder, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span> &#123;</span><br><span class="line">		value, err := strconv.ParseFloat(s[<span class="number">1</span>:], <span class="number">64</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;ERR min or max is not a float&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;ScoreBorder&#123;</span><br><span class="line">			Inf:     <span class="number">0</span>,</span><br><span class="line">			Value:   value,</span><br><span class="line">			Exclude: <span class="literal">true</span>,</span><br><span class="line">		&#125;, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	value, err := strconv.ParseFloat(s, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;ERR min or max is not a float&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;ScoreBorder&#123;</span><br><span class="line">		Inf:     <span class="number">0</span>,</span><br><span class="line">		Value:   value,</span><br><span class="line">		Exclude: <span class="literal">false</span>,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断[min, max]区间与是否在skiplist的分数区间内（是否有重合）</strong></p>
<p>判断有三个指标：</p>
<ol>
<li>判断[min, max]区间本身是否有效。</li>
<li>判断min是否大于跳表的最大分数值（与表尾元素的分数作比较）。</li>
<li>判断max是否小于跳表的最小分数值（与表头元素的分数作比较）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> hasInRange(min *ScoreBorder, max *ScoreBorder) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// [min, max]无意义或为空</span></span><br><span class="line">	<span class="keyword">if</span> min.Value &gt; max.Value || (min.Value == max.Value &amp;&amp; (min.Exclude || max.Exclude)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// [min, max] &gt; skiplist.tail.Score</span></span><br><span class="line">	n := skiplist.tail</span><br><span class="line">	<span class="keyword">if</span> n == <span class="literal">nil</span> || !min.less(n.Score) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// [min, max] &lt; skiplist.head.Score</span></span><br><span class="line">	n = skiplist.header.level[<span class="number">0</span>].forward</span><br><span class="line">	<span class="keyword">if</span> n == <span class="literal">nil</span> || !max.greater(n.Score) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从跳表中找到处于[min, max]区间的最小值</strong></p>
<p>实现思路比较简单，我们找到跳表中分数第一个大于min的节点即可。找到之后我们还需要将该节点的分数与max作比较，如果大于max，则不存在。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> getFirstInScoreRange(min *ScoreBorder, max *ScoreBorder) *node &#123;</span><br><span class="line">	<span class="keyword">if</span> !skiplist.hasInRange(min, max) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := skiplist.header</span><br><span class="line">	<span class="comment">// 找到第一个大于等于min的节点</span></span><br><span class="line">	<span class="keyword">for</span> level := skiplist.level - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;</span><br><span class="line">		<span class="keyword">for</span> n.level[level].forward != <span class="literal">nil</span> &amp;&amp; !min.less(n.level[level].forward.Score) &#123;</span><br><span class="line">			n = n.level[level].forward</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	n = n.level[<span class="number">0</span>].forward</span><br><span class="line"></span><br><span class="line">	<span class="comment">// n节点的分数在[min, max]区间之外</span></span><br><span class="line">	<span class="keyword">if</span> !max.greater(n.Score) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除跳表中分数值处在[min, max]区间内的元素，并返回它们的切片</strong></p>
<p>首先遍历跳表，然后找到分数值大于min的第一个节点，从这个节点开始删除，删除一个就继续往后遍历，删除的过程中还得判断，待删除的节点分数是否超出了[min, max]区间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> RemoveRangeByScore(min *ScoreBorder, max *ScoreBorder) (removed []*Element) &#123;</span><br><span class="line">	<span class="comment">// 储存待删除节点每一层的前驱节点</span></span><br><span class="line">	update := <span class="built_in">make</span>([]*node, maxLevel)</span><br><span class="line">	removed = <span class="built_in">make</span>([]*Element, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 找到待删除节点每一层的前驱节点</span></span><br><span class="line">	node := skiplist.header</span><br><span class="line">	<span class="keyword">for</span> i := skiplist.level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">for</span> node.level[i].forward != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> min.less(node.level[i].forward.Score) &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			node = node.level[i].forward</span><br><span class="line">		&#125;</span><br><span class="line">		update[i] = node</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	node = node.level[<span class="number">0</span>].forward</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始删除节点</span></span><br><span class="line">	<span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 保证不超出[min, max]区间</span></span><br><span class="line">		<span class="keyword">if</span> !max.greater(node.Score) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		next := node.level[<span class="number">0</span>].forward</span><br><span class="line">		removedElement := node.Element</span><br><span class="line">		removed = <span class="built_in">append</span>(removed, &amp;removedElement)</span><br><span class="line">		skiplist.removeNode(node, update)</span><br><span class="line">		node = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> removed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除排名在[start, stop]区间内的元素，并返回它们的切片</strong></p>
<p>首先定义一个i变量，作为删除节点的迭代器，接着找到排名为start的节点，然后从这个节点往后删除即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(skiplist *skiplist)</span></span> RemoveRangeByRank(start <span class="type">int64</span>, stop <span class="type">int64</span>) (removed []*Element) &#123;</span><br><span class="line">	<span class="comment">// 排名迭代器</span></span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int64</span> = <span class="number">0</span></span><br><span class="line">	update := <span class="built_in">make</span>([]*node, maxLevel)</span><br><span class="line">	removed = <span class="built_in">make</span>([]*Element, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到待删除的第一个节点的前驱节点，并储存在update切片中</span></span><br><span class="line">	node := skiplist.header</span><br><span class="line">	<span class="keyword">for</span> level := skiplist.level - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;</span><br><span class="line">		<span class="keyword">for</span> node.level[level].forward != <span class="literal">nil</span> &amp;&amp; (i+node.level[level].span) &lt; start &#123;</span><br><span class="line">			i += node.level[level].span</span><br><span class="line">			node = node.level[level].forward</span><br><span class="line">		&#125;</span><br><span class="line">		update[level] = node</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	i++</span><br><span class="line">	<span class="comment">// 处在区间的第一个节点</span></span><br><span class="line">	node = node.level[<span class="number">0</span>].forward</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始删除节点</span></span><br><span class="line">	<span class="keyword">for</span> node != <span class="literal">nil</span> &amp;&amp; i &lt; stop &#123;</span><br><span class="line">		next := node.level[<span class="number">0</span>].forward</span><br><span class="line">		removedElement := node.Element</span><br><span class="line">		removed = <span class="built_in">append</span>(removed, &amp;removedElement)</span><br><span class="line">		skiplist.removeNode(node, update)</span><br><span class="line">		node = next</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> removed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p><a href="https://github.com/omlight95/GoRedis/blob/master/datastruct/sortedset/skiplist.go">https://github.com/omlight95/GoRedis/blob/master/datastruct/sortedset/skiplist.go</a></p>
]]></content>
      <categories>
        <category>Go数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>快速列表 Go实现</title>
    <url>/2022/11/02/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8%20Go%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="快速列表介绍"><a href="#快速列表介绍" class="headerlink" title="快速列表介绍"></a>快速列表介绍</h2><p>快速列表（quicklist）是Redis中特有的一种数据结构，主要是为了解决双端链表的弊端：双端链表的附加空间比较高，因为<code>prev</code>和<code>next</code>指针会占掉一部分的空间（64位系统占用8 + 8 &#x3D; 16字节）.而且链表的每个节点都是单独分配内存，会加剧内存的碎片化。</p>
<p>Redis中的快速列表实际上是zipList（经过优化过的数组）和linkedList的混合体，它把zipList放在linkedList的每个结点中，实现紧凑存储。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/86856884560f4d48ab1888e1a1a4c957.png" alt="在这里插入图片描述"></p>
<h2 id="实现快速列表"><a href="#实现快速列表" class="headerlink" title="实现快速列表"></a>实现快速列表</h2><h3 id="快速列表的结构"><a href="#快速列表的结构" class="headerlink" title="快速列表的结构"></a>快速列表的结构</h3><p>由于Go语言自带slice这种操作方便的“动态数组”结构，所以我给链表的每个节点中都分配一个容量为1024大小的切片，那么一个链表节点就可以看作是一页，页大小就是1024。</p>
<p><strong>页大小</strong></p>
<p>首先定义页大小为1024：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pageSize 一页的大小</span></span><br><span class="line"><span class="keyword">const</span> pageSize = <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p><strong>表头结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// QuickList 快速列表是在页（切片）之上建立的链表</span></span><br><span class="line"><span class="comment">// QuickList 比普通链表的插入、遍历以及内存有着更好的性能</span></span><br><span class="line"><span class="keyword">type</span> QuickList <span class="keyword">struct</span> &#123;</span><br><span class="line">	data *list.List <span class="comment">// 每一页就是interface&#123;&#125;的切片，大小为1024</span></span><br><span class="line">	size <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表头结构中的data字段直接使用了Go语言<code>list</code>包中的List结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表标头结构</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">	root Element <span class="comment">// 哨兵节点</span></span><br><span class="line">	<span class="built_in">len</span>  <span class="type">int</span>     <span class="comment">// 链表的节点个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表的节点</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 前向和后向指针</span></span><br><span class="line">	next, prev *Element</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 表头结构</span></span><br><span class="line">	list *List</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值域</span></span><br><span class="line">	Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go语言自带的list包实现了对双向链表的封装，双向链表的节点元素是interface{}类型，利用这种方式实现了泛型。<br>我们对快速列表的实现，使得上述双向链表节点中存储的实际上是容量为1024的切片，此后对于链表的相关操作，直接调用list包向外暴露的API即可。</p>
<h3 id="快速列表的迭代器"><a href="#快速列表的迭代器" class="headerlink" title="快速列表的迭代器"></a>快速列表的迭代器</h3><p>快速列表的迭代器中有三个字段：链表的节点node（可以看成一页），元素在页中的偏移量、表头结构。<br>这样实现的迭代器，使得迭代器既可以在元素之前迭代，也可以在页之间快速迭代。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterator 快速列表的迭代器，在[-1, ql.Len()]之间迭代</span></span><br><span class="line"><span class="keyword">type</span> iterator <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 快速列表的一页</span></span><br><span class="line">	node *list.Element</span><br><span class="line">	<span class="comment">// 元素下标在页中的偏移量</span></span><br><span class="line">	offset <span class="type">int</span></span><br><span class="line">	ql     *QuickList</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>使用迭代器返回一个元素</strong></p>
<p>使用迭代器返回一个元素的复杂度为<code>O(1)</code>，一个元素的位置可以通过 页的位置 + 该元素在页中的位置 快速定位。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器返回一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *iterator)</span></span> get() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> iter.page()[iter.offset]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>返回迭代器对应的那一页</strong></p>
<p>上面我们说过，链表的节点元素其实就是一个容量为1024的slice，通过类型断言直接返回即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回迭代器对应的那一页</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *iterator)</span></span> page() []<span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> iter.node.Value.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据元素下标返回对应的迭代器</strong></p>
<p>快速列表查找元素效率比双向列表要快，首先利用迭代器一页一页进行迭代，首先定义一个累加偏移量的变量pageBeg，每迭代一页就把这页的大小累加到pageBeg中，每次比较<code>pageBeg + len(page)</code>与index的大小，如果前者更大，表示元素就在该页中，如果后者更大，表示元素在后面的页中。<br>当确定了元素在哪一页后，利用元素的下标直接在页内的slice中直接定位即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ql *QuickList)</span></span> find(index <span class="type">int</span>) *iterator &#123;</span><br><span class="line">	<span class="keyword">if</span> ql == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;list is nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> index &lt; <span class="number">0</span> || index &gt;= ql.size &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;index out of bound&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> n *list.Element</span><br><span class="line">	<span class="comment">// 保存当前页的所有元素</span></span><br><span class="line">	<span class="keyword">var</span> page []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 累加遍历到当前页为止，前面的所有元素数量</span></span><br><span class="line">	<span class="keyword">var</span> pageBeg <span class="type">int</span></span><br><span class="line">	<span class="keyword">if</span> index &lt; ql.size/<span class="number">2</span> &#123;</span><br><span class="line">		<span class="comment">// 从表头进行查找</span></span><br><span class="line">		n = ql.data.Front()</span><br><span class="line">		pageBeg = <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			page = n.Value.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">			<span class="keyword">if</span> pageBeg+<span class="built_in">len</span>(page) &gt; index &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			pageBeg += <span class="built_in">len</span>(page)</span><br><span class="line">			n = n.Next()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 从表尾进行查找</span></span><br><span class="line">		n = ql.data.Back()</span><br><span class="line">		pageBeg = ql.size</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			page = n.Value.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">			pageBeg -= <span class="built_in">len</span>(page)</span><br><span class="line">			<span class="keyword">if</span> pageBeg &lt;= index &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			n = n.Prev()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pageOffset := index - pageBeg</span><br><span class="line">	<span class="keyword">return</span> &amp;iterator&#123;</span><br><span class="line">		node:   n,</span><br><span class="line">		offset: pageOffset,</span><br><span class="line">		ql:     ql,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向后迭代一位</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// next 页内迭代器，向后迭代一位</span></span><br><span class="line"><span class="comment">// 如果当前元素下标未出界且不在最后一位，就向后移动一位，返回true</span></span><br><span class="line"><span class="comment">// 如果当前元素下标在快速列表的最后一页且是最后一个元素，直接返回false</span></span><br><span class="line"><span class="comment">// 如果当前元素下标不在快速列表的最后一页，但是是当前页的最后一个元素，跳转到下一页，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *iterator)</span></span> next() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="comment">// 得到迭代器对应的那一页</span></span><br><span class="line">	page := iter.page()</span><br><span class="line">	<span class="comment">// 当前位置未出界且不在最后一位，就向后移动一位，返回true</span></span><br><span class="line">	<span class="keyword">if</span> iter.offset &lt; <span class="built_in">len</span>(page)<span class="number">-1</span> &#123;</span><br><span class="line">		iter.offset++</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当前元素在快速列表的最后一页且是最后一个元素，直接返回false</span></span><br><span class="line">	<span class="keyword">if</span> iter.node == iter.ql.data.Back() &#123;</span><br><span class="line">		<span class="comment">// already at last node</span></span><br><span class="line">		iter.offset = <span class="built_in">len</span>(page)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当前元素不在快速列表的最后一页，但是是当前页的最后一个元素，跳转到下一页，返回true</span></span><br><span class="line">	iter.offset = <span class="number">0</span></span><br><span class="line">	iter.node = iter.node.Next()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>往前迭代一位</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prev 页内迭代器，向前迭代一位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *iterator)</span></span> prev() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> iter.offset &gt; <span class="number">0</span> &#123;</span><br><span class="line">		iter.offset--</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> iter.node == iter.ql.data.Front() &#123;</span><br><span class="line">		iter.offset = <span class="number">-1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	iter.node = iter.node.Prev()</span><br><span class="line">	prevPage := iter.node.Value.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	iter.offset = <span class="built_in">len</span>(prevPage) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加和插入元素"><a href="#添加和插入元素" class="headerlink" title="添加和插入元素"></a>添加和插入元素</h3><p><strong>向表尾添加一个元素</strong></p>
<p>向表尾添加元素需要考虑三种情况：</p>
<ol>
<li>列表是空的，创建新的一页，添加到表尾即可。</li>
<li>表尾节点那一页是满的，获取表尾节点，创建新的一页，添加到表尾节点的后面即可。</li>
<li>表尾节点那一页不是满的，正常添加到表尾即可。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Add 添加元素到表尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ql *QuickList)</span></span> Add(val <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	ql.size++</span><br><span class="line">	<span class="comment">// 列表是空的</span></span><br><span class="line">	<span class="keyword">if</span> ql.data.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		page := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, pageSize)</span><br><span class="line">		page = <span class="built_in">append</span>(page, val)</span><br><span class="line">		ql.data.PushBack(page)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 获取表尾节点</span></span><br><span class="line">	backNode := ql.data.Back()</span><br><span class="line">	backPage := backNode.Value.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 表尾节点页满了，需要新创建一页</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(backPage) == <span class="built_in">cap</span>(backPage) &#123;</span><br><span class="line">		page := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, pageSize)</span><br><span class="line">		page = <span class="built_in">append</span>(page, val)</span><br><span class="line">		ql.data.PushBack(page)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 默认将节点添加进表尾页中</span></span><br><span class="line">	backPage = <span class="built_in">append</span>(backPage, val)</span><br><span class="line">	backNode.Value = backPage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>根据下标插入一个元素</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Insert 插入元素</span></span><br><span class="line"><span class="comment">// 插入元素的策略分三种情况：</span></span><br><span class="line"><span class="comment">// 1. 向最后一页的最后一个位置插入元素，直接调用ql.Add()插入即可</span></span><br><span class="line"><span class="comment">// 2. 某一页插入一个元素，且该页未满，直接插入该页即可</span></span><br><span class="line"><span class="comment">// 3. 某一页插入一个元素，该页满了，就新创建一页，然后将前512个元素留在原来那页，将后512个元素移到新的页中，</span></span><br><span class="line"><span class="comment">//    新插入的元素，如果下标在[0,512]之间，就插入到原来页，如果下标在[516, 1024]之间，就插入到新创建的页中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ql *QuickList)</span></span> Insert(index <span class="type">int</span>, val <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	<span class="comment">// 向表尾插入元素</span></span><br><span class="line">	<span class="keyword">if</span> index == ql.size &#123;</span><br><span class="line">		ql.Add(val)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	iter := ql.find(index)</span><br><span class="line">	page := iter.node.Value.([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 如果待插入页的元素小于1024，直接插入到该页即可</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(page) &lt; pageSize &#123;</span><br><span class="line">		<span class="comment">// insert into not full page</span></span><br><span class="line">		page = <span class="built_in">append</span>(page[:iter.offset+<span class="number">1</span>], page[iter.offset:]...)</span><br><span class="line">		page[iter.offset] = val</span><br><span class="line">		iter.node.Value = page</span><br><span class="line">		ql.size++</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 待插入页的元素已经满1024，就需要新创建一页</span></span><br><span class="line">	<span class="keyword">var</span> nextPage []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 后一半的元素放在新创建的页中，前一半元素放在原来的页中</span></span><br><span class="line">	nextPage = <span class="built_in">append</span>(nextPage, page[pageSize/<span class="number">2</span>:]...) <span class="comment">// pageSize must be even</span></span><br><span class="line">	page = page[:pageSize/<span class="number">2</span>]</span><br><span class="line">	<span class="comment">// 待插入元素的下标小于512，插到前面那页</span></span><br><span class="line">	<span class="keyword">if</span> iter.offset &lt; <span class="built_in">len</span>(page) &#123;</span><br><span class="line">		page = <span class="built_in">append</span>(page[:iter.offset+<span class="number">1</span>], page[iter.offset:]...)</span><br><span class="line">		page[iter.offset] = val</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 待插入元素的下标大于512，插到后面那页</span></span><br><span class="line">		i := iter.offset - pageSize/<span class="number">2</span></span><br><span class="line">		nextPage = <span class="built_in">append</span>(nextPage[:i+<span class="number">1</span>], nextPage[i:]...)</span><br><span class="line">		nextPage[i] = val</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 储存当前页和新创建的下一页</span></span><br><span class="line">	iter.node.Value = page</span><br><span class="line">	ql.data.InsertAfter(nextPage, iter.node)</span><br><span class="line">	ql.size++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="comment">// 删除元素分为四种情况：</span></span><br><span class="line"><span class="comment">// 1.删除后的页不为空，且删除的不是该页的最后一个元素，什么都不用管</span></span><br><span class="line"><span class="comment">// 2.删除后的页不为空，且删除的是该页的最后一个元素，需要将迭代器移动到下一页的最后一个元素</span></span><br><span class="line"><span class="comment">// 3.删除的页为空（需要删除该页），且删除的页是最后一页，将迭代器置空</span></span><br><span class="line"><span class="comment">// 4.删除的页为空（需要删除该页），且删除的页不是最后一页，将迭代器指向下一页</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iter *iterator)</span></span> remove() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	page := iter.page()</span><br><span class="line">	val := page[iter.offset]</span><br><span class="line">	<span class="comment">// 先直接在页中删除这个元素</span></span><br><span class="line">	page = <span class="built_in">append</span>(page[:iter.offset], page[iter.offset+<span class="number">1</span>:]...)</span><br><span class="line">	<span class="comment">// 如果删除后的页不为空，只更新iter.offset即可</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(page) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		iter.node.Value = page</span><br><span class="line">		<span class="comment">// 如果删除的是页中的最后一个元素，那么迭代器需要移动到下一页的第一个元素</span></span><br><span class="line">		<span class="keyword">if</span> iter.offset == <span class="built_in">len</span>(page) &#123;</span><br><span class="line">			<span class="keyword">if</span> iter.node != iter.ql.data.Back() &#123;</span><br><span class="line">				iter.node = iter.node.Next()</span><br><span class="line">				iter.offset = <span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果删除后的页为空，需要删除该页</span></span><br><span class="line">		<span class="comment">// 如果删除的是最后一页，迭代器需要置空</span></span><br><span class="line">		<span class="keyword">if</span> iter.node == iter.ql.data.Back() &#123;</span><br><span class="line">			iter.ql.data.Remove(iter.node)</span><br><span class="line">			iter.node = <span class="literal">nil</span></span><br><span class="line">			iter.offset = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果删除的不是最后一页，迭代器需要指向下一页</span></span><br><span class="line">			nextNode := iter.node.Next()</span><br><span class="line">			iter.ql.data.Remove(iter.node)</span><br><span class="line">			iter.node = nextNode</span><br><span class="line">			iter.offset = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	iter.ql.size--</span><br><span class="line">	<span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历快速列表"><a href="#遍历快速列表" class="headerlink" title="遍历快速列表"></a>遍历快速列表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consumer 用于遍历中断的函数，返回true表示继续遍历，可以在Consumer中调用自定义函数</span></span><br><span class="line"><span class="keyword">type</span> Consumer <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, v <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ForEach 遍历快速列表中的元素</span></span><br><span class="line"><span class="comment">// 如果consumer返回false，结束遍历</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ql *QuickList)</span></span> ForEach(consumer Consumer) &#123;</span><br><span class="line">	<span class="keyword">if</span> ql == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;list is nil&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ql.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	iter := ql.find(<span class="number">0</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		goNext := consumer(i, iter.get())</span><br><span class="line">		<span class="keyword">if</span> !goNext &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">		<span class="comment">// 遍历到表尾，结束</span></span><br><span class="line">		<span class="keyword">if</span> !iter.next() &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p><a href="https://github.com/omlight95/GoRedis/blob/master/datastruct/list/quicklist.go">https://github.com/omlight95/GoRedis/blob/master/datastruct/list/quicklist.go</a></p>
]]></content>
      <categories>
        <category>Go数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>三、RabbitMQ消息的可靠投递</title>
    <url>/2022/11/06/RabbitMQ/%E4%B8%89%E3%80%81RabbitMQ%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%8A%95%E9%80%92/</url>
    <content><![CDATA[<h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p>在使用RabbitMQ的时候，我们需要保证消息不能丢失，消息从生产者生产出来一直到消费者消费成功，这条链路是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/adafd5c784c6445881abffc81812ab76.png" alt="在这里插入图片描述"><br>消息的可靠投递分为了两大内容：发送端的确认（p-&gt;broker和exchange-&gt;queue）和消费端的确认（queue-&gt;c）。</p>
<p><strong>发送端的确认</strong></p>
<p>Rabbit提供了两种方式来保证发送端的消息可靠性投递：confirm 确认模式<br>和return 退回模式。</p>
<p><strong>confirm 确认模式</strong>：消息从 producer 到达 exchange 则会给 producer 发送一个应答，我们需要开启<code>confirm模式</code>，才能接收到这条应答。开启方式是将<code>Channel.Confirm(noWait bool)</code>参数设置为<code>false</code>，表示同意发送者将当前channel信道设置为confirm模式。</p>
<p><strong>return 退回模式</strong>：消息从 exchange–&gt;queue 投递失败，会将消息退回给producer。</p>
<p><strong>消费端的确认</strong></p>
<p>消息从Queue发送到消费端之后，消费端会发送一个确认消息：<code>Consumer Ack</code>，有两种确认方式：自动确认和手动确认。</p>
<p>在编码中，关于消息的确认方式，我们需要在消费者端调用<code>Consumer</code>函数时，设置第三个参数：<code>autoAck</code>是false还是true（false表示手动，true表示自动）。</p>
<p>自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应 message 从 RabbitMQ 的消息缓存中移除。<br>但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用<code>ch.Ack(false)</code>，手动签收，如果出现异常，则调用<code>d.Reject(true)</code>让其自动重新发送消息。</p>
<h2 id="Go-实现"><a href="#Go-实现" class="headerlink" title="Go 实现"></a>Go 实现</h2><h3 id="安装操作库"><a href="#安装操作库" class="headerlink" title="安装操作库"></a>安装操作库</h3><p><strong>安装API库</strong></p>
<p>Go可以使用<code>streadway/amqp</code>库来操作rabbit，使用以下命令来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/streadway/amqp</span><br></pre></td></tr></table></figure>

<p><strong>封装rabbitmq</strong></p>
<p>接下来我们对<code>streadway/amqp</code>库的内容进行一个二次封装，封装为一个<code>rabbitmq.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> rabbitmq</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RabbitMQ RabbitMQ结构</span></span><br><span class="line"><span class="keyword">type</span> RabbitMQ <span class="keyword">struct</span> &#123;</span><br><span class="line">	channel  *amqp.Channel</span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	exchange <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect 连接服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(s <span class="type">string</span>)</span></span> *RabbitMQ &#123;</span><br><span class="line">	<span class="comment">//连接rabbitmq</span></span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	failOnError(e, <span class="string">&quot;连接Rabbitmq服务器失败！&quot;</span>)</span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法打开频道！&quot;</span>)</span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 初始化消息队列</span></span><br><span class="line"><span class="comment">//第一个参数：rabbitmq服务器的链接，第二个参数：队列名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="type">string</span>, name <span class="type">string</span>)</span></span> *RabbitMQ &#123;</span><br><span class="line">	<span class="comment">//连接rabbitmq</span></span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	failOnError(e, <span class="string">&quot;连接Rabbitmq服务器失败！&quot;</span>)</span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法打开频道！&quot;</span>)</span><br><span class="line">	q, e := ch.QueueDeclare(</span><br><span class="line">		name,  <span class="comment">//队列名</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//是否开启持久化</span></span><br><span class="line">		<span class="literal">true</span>,  <span class="comment">//不使用时删除</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//排他</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//不等待</span></span><br><span class="line">		<span class="literal">nil</span>,   <span class="comment">//参数</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;初始化消息队列失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	mq.Name = q.Name</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueueDeclare 声明queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> QueueDeclare(queue <span class="type">string</span>) &#123;</span><br><span class="line">	_, e := q.channel.QueueDeclare(queue, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;声明queue失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueueDelete 删除queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> QueueDelete(queue <span class="type">string</span>) &#123;</span><br><span class="line">	_, e := q.channel.QueueDelete(queue, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;删除queue失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qos 配置queue参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Qos() &#123;</span><br><span class="line">	e := q.channel.Qos(<span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法设置QoS&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewExchange 初始化交换机</span></span><br><span class="line"><span class="comment">//第一个参数：rabbitmq服务器的链接，第二个参数：交换机名字，第三个参数：交换机类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewExchange</span><span class="params">(s <span class="type">string</span>, name <span class="type">string</span>, typename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//连接rabbitmq</span></span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	failOnError(e, <span class="string">&quot;连接Rabbitmq服务器失败！&quot;</span>)</span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法打开频道！&quot;</span>)</span><br><span class="line">	e = ch.ExchangeDeclare(</span><br><span class="line">		name,     <span class="comment">// name</span></span><br><span class="line">		typename, <span class="comment">// type</span></span><br><span class="line">		<span class="literal">true</span>,     <span class="comment">// durable</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// auto-deleted</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// internal</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// no-wait</span></span><br><span class="line">		<span class="literal">nil</span>,      <span class="comment">// arguments</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;初始化交换机失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExchangeDelete 删除交换机</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> ExchangeDelete(exchange <span class="type">string</span>) &#123;</span><br><span class="line">	e := q.channel.ExchangeDelete(exchange, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;删除交换机失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind 绑定消息队列到exchange</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Bind(exchange <span class="type">string</span>, key <span class="type">string</span>) &#123;</span><br><span class="line">	e := q.channel.QueueBind(</span><br><span class="line">		q.Name,</span><br><span class="line">		key,</span><br><span class="line">		exchange,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;绑定队列失败！&quot;</span>)</span><br><span class="line">	q.exchange = exchange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 向消息队列发送消息</span></span><br><span class="line"><span class="comment">//Send方法可以往某个消息队列发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Send(queue <span class="type">string</span>, body <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	failOnError(e, <span class="string">&quot;消息序列化失败！&quot;</span>)</span><br><span class="line">	e = q.channel.Publish(</span><br><span class="line">		<span class="string">&quot;&quot;</span>,    <span class="comment">//交换</span></span><br><span class="line">		queue, <span class="comment">//路由键</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//必填</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//立即</span></span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="type">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	msg := <span class="string">&quot;向队列:&quot;</span> + q.Name + <span class="string">&quot;发送消息失败！&quot;</span></span><br><span class="line">	failOnError(e, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish 向exchange发送消息</span></span><br><span class="line"><span class="comment">//Publish方法可以往某个exchange发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Publish(exchange <span class="type">string</span>, body <span class="keyword">interface</span>&#123;&#125;, key <span class="type">string</span>) &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	failOnError(e, <span class="string">&quot;消息序列化失败！&quot;</span>)</span><br><span class="line">	e = q.channel.Publish(</span><br><span class="line">		exchange,</span><br><span class="line">		key,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;ReplyTo: q.Name,</span><br><span class="line">			Body: []<span class="type">byte</span>(str)&#125;,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;向交换机发送消息失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consume 接收某个消息队列的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Consume() &lt;-<span class="keyword">chan</span> amqp.Delivery &#123;</span><br><span class="line">	c, e := q.channel.Consume(</span><br><span class="line">		q.Name, <span class="comment">//指定从哪个队列中接收消息</span></span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;接收消息失败！&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭队列连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Close() &#123;</span><br><span class="line">	q.channel.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err <span class="type">error</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="发送端的确认"><a href="#发送端的确认" class="headerlink" title="发送端的确认"></a>发送端的确认</h3><p>首先初始化消息队列的时候，我们要开启<code>confirm模式</code>，才能接收到这条应答。开启方式是将<code>Channel.Confirm(noWait bool)</code>参数设置为<code>false</code>，表示同意发送者将当前channel信道设置为confirm模式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="type">string</span>, name <span class="type">string</span>)</span></span> *RabbitMQ &#123;</span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	failOnError(e, <span class="string">&quot;连接Rabbitmq服务器失败！&quot;</span>)</span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法打开频道！&quot;</span>)</span><br><span class="line">	q, e := ch.QueueDeclare(</span><br><span class="line">		name,  <span class="comment">//队列名</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//是否开启持久化</span></span><br><span class="line">		<span class="literal">true</span>,  <span class="comment">//不使用时删除</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//排他</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//不等待</span></span><br><span class="line">		<span class="literal">nil</span>,   <span class="comment">//参数</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;初始化消息队列失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	mq.Name = q.Name</span><br><span class="line">	<span class="comment">// 设置为confirm模式</span></span><br><span class="line">	mq.channel.Confirm(<span class="literal">false</span>)</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在封装库中创建一个函数<code>handleConfirm()</code>用于接收来自Borker的回复：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> ConfirmFromBroker(ch <span class="keyword">chan</span> amqp.Confirmation) <span class="keyword">chan</span> amqp.Confirmation &#123;</span><br><span class="line">	<span class="keyword">return</span> q.channel.NotifyPublish(ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产者</strong></p>
<p>生产者端在向Broker发送消息的时候，我们使用一个无缓冲的通道来接收来自Broker的回复，然后创建一个协程监听这个无缓冲通道。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定为topic类型</span></span><br><span class="line">	rabbitmq.NewExchange(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;fanout&quot;</span>)</span><br><span class="line">	confirm := producer.ConfirmFromBroker(<span class="built_in">make</span>(<span class="keyword">chan</span> amqp.Confirmation))</span><br><span class="line">	<span class="keyword">go</span> handleConfirm(confirm)</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		producer.Publish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;fanout message: &quot;</span>+strconv.Itoa(i), <span class="string">&quot;&quot;</span>)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleConfirm</span><span class="params">(confirm &lt;-<span class="keyword">chan</span> amqp.Confirmation)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> message := &lt;-confirm:</span><br><span class="line">			fmt.Println(<span class="string">&quot;接收到来自Broker的回复：&quot;</span>, message)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">接收到来自Broker的回复： &#123;<span class="number">1</span> <span class="literal">true</span>&#125;</span><br><span class="line">接收到来自Broker的回复： &#123;<span class="number">2</span> <span class="literal">true</span>&#125;</span><br><span class="line">接收到来自Broker的回复： &#123;<span class="number">3</span> <span class="literal">true</span>&#125;</span><br><span class="line">接收到来自Broker的回复： &#123;<span class="number">4</span> <span class="literal">true</span>&#125;</span><br><span class="line">接收到来自Broker的回复： &#123;<span class="number">5</span> <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>


<h3 id="消费端的确认"><a href="#消费端的确认" class="headerlink" title="消费端的确认"></a>消费端的确认</h3><p>首先将<code>Consume</code>函数的第三个参数<code>autoAck</code>参数标记为false：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consume 接收某个消息队列的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Consume() &lt;-<span class="keyword">chan</span> amqp.Delivery &#123;</span><br><span class="line">	c, e := q.channel.Consume(</span><br><span class="line">		q.Name,</span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 不自动确认消息</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;接收消息失败！&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在消费者端我们采用<code>公平派遣模式</code>，即队列发送消息给消费者的时候，不再采用轮询机制，而是一个消费者消费完消息之后，会调用<code>Ack(false)</code>函数向队列发送一个回复，队列每次会将消息优先发送给消费完消息的消费者（回复过）。</p>
<p>消费端限流：<br>实现<code>公平派遣模式</code>我们需要设置消费者端一次只能消费一条消息，之前我们已经进行了封装，直接在消费者端调用即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Qos 配置queue参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Qos() &#123;</span><br><span class="line">	e := q.channel.Qos(<span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法设置QoS&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定为direct类型</span></span><br><span class="line">	rabbitmq.NewExchange(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;direct&quot;</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		producer.Publish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routing message: &quot;</span>+strconv.Itoa(i), <span class="string">&quot;key1&quot;</span>)</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<p>消费者2在消费第三条消息的时候，假设发生了错误，我们调用<code>d.Reject(true)</code>函数让队列重新发送消息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer1 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue1&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定一次只消费一条消息，直到消费完才重新接收</span></span><br><span class="line">	consumer1.Qos()</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer1.Bind(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;key1&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer1.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer1 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			<span class="comment">// 假设消费第三条消息的时候出现了错误，我们就调用d.Reject(true)，队列会重新发送消息给消费者</span></span><br><span class="line">			<span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">				d.Reject(<span class="literal">true</span>)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 消息消费成功之后就回复</span></span><br><span class="line">				d.Ack(<span class="literal">false</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer2 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue1&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定一次只消费一条消息，直到消费完才重新接收</span></span><br><span class="line">	consumer2.Qos()</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer2.Bind(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;key1&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer2.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			time.Sleep(time.Second * <span class="number">5</span>)</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer2 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			<span class="comment">// 消息消费成功之后就回复</span></span><br><span class="line">			d.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">06</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">08</span> Consumer1 received a message: <span class="string">&quot;routing message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">06</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">10</span> Consumer1 received a message: <span class="string">&quot;routing message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">06</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">11</span> Consumer1 received a message: <span class="string">&quot;routing message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">06</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">12</span> Consumer1 received a message: <span class="string">&quot;routing message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">06</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">13</span> Consumer1 received a message: <span class="string">&quot;routing message: 4&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">06</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">14</span> Consumer1 received a message: <span class="string">&quot;routing message: 6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">06</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">13</span> Consumer2 received a message: <span class="string">&quot;routing message: 1&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>一、Rabbit的介绍与安装</title>
    <url>/2022/11/06/RabbitMQ/%E4%B8%80%E3%80%81Rabbit%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="MQ概述"><a href="#MQ概述" class="headerlink" title="MQ概述"></a>MQ概述</h2><p>MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。</p>
<p>传统的分布式系统有两种通信方式：</p>
<ol>
<li>以HTTP为代表的REST，操作简单但是缺点很明显，就是没有长连接。</li>
<li>使用RPC通信，缺点是操作一般是同步的，而且各个模块之间的耦合度比较高。</li>
</ol>
<p>消息队列也可以作为一种第三方工具介入分布式系统之间的通信。</p>
<p><strong>MQ的优势和劣势</strong></p>
<p>MQ的优势主要有三种：</p>
<ol>
<li>应用解耦：使用 MQ 使得应用间解耦，提升容错性和可维护性。</li>
<li>异步提速：可以提升用户体验和系统吞吐量（单位时间内处理请求的数目）。</li>
<li>削峰填谷：提高系统稳定性。比如系统的请求量突然暴增，我们可以使用MQ来接收暴增的消息，然后一部分一部分的发送给系统，降低系统的压力。</li>
</ol>
<p>MQ的劣势主要也有三种：<br>4. 系统可用性降低：系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。<br>5. 系统复杂度提高：MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？<br>6. 一致性问题：A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？</p>
<h2 id="RabbitMQ介绍"><a href="#RabbitMQ介绍" class="headerlink" title="RabbitMQ介绍"></a>RabbitMQ介绍</h2><p>RabbitMQ是消息队列的一种，采用Erlang语言开发，下面是Rabbit的基础架构图：</p>
<p><img src="https://img-blog.csdnimg.cn/07202baf32744ccc9027dd6184195781.png" alt="在这里插入图片描述"></p>
<p><strong>RabbitMQ相关概念介绍</strong></p>
<p><strong>Broker</strong>：接收和分发消息的应用，RabbitMQ Server就是 Message Broker。</p>
<p><strong>Connection</strong>：连接，应用服务与Server的连接。</p>
<p><strong>Channel</strong>：信道，客户端可建立多个Channel,每个Channel代表一个会话任务。</p>
<p><strong>Message</strong>：消息，由<code>MessageProperties</code>和<code>body</code>构成，MessageProperties可对消息的优先级、过期时间等参数进行设置，其中参数<code>correlation_id</code>一般作为消息主键。</p>
<p><strong>Exchange</strong>：交换机，用于转发消息，消息将根据<code>routeKey</code>被交换机转发给对应的绑定队列。</p>
<p><strong>Queue</strong>：队列，消息最终被送到这里等待消费者取走，参数中的<code>Auto-delete</code>意为当前队列的最后一个消息被取出后是否自动删除。</p>
<p><strong>Binding</strong>：绑定exchange和queue之间的虚拟连接，二者通过<code>routingkey</code>进行绑定。</p>
<p><strong>Routingkey</strong>：路由规则，交换机可以用它来确定消息被路由到哪里。</p>
<p><strong>Virtual host</strong>：类似于网络中的 namespace 概念，用于进行逻辑隔离，一个虚拟主机中可以有多个Exchange和Queue，同一个虚拟主机中不能有名称一样的Exchange和Queue。</p>
<h2 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h2><p><code>RabbitMQ</code>最简单的一种安装方式就是将它安装在Docker中：</p>
<p>首先创建一个目录用于与容器中的rabbitmq配置文件形成映射：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/module/rabbitmq/data -p</span><br></pre></td></tr></table></figure>
<p>接着在docker中运行rabbitmq镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5672是rabbitmq 默认TCP监听端口，到时候程序连接的也是这个端口</span></span><br><span class="line"><span class="comment"># 15672是rabbitmq提供的ui管理界面的端口</span></span><br><span class="line"><span class="comment"># 25672是rabbitmq集群之间通信的端口</span></span><br><span class="line"><span class="comment"># 如果docker跑在云服务器上，记得在安全组中开放5672和15672端口</span></span><br><span class="line">docker run -d --hostname rabbit-svr --name rabbit -p 5672:5672 -p 15672:15672 -p 25672:25672 -v /opt/module/rabbitmq/data:/var/lib/rabbitmq rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>然后就可以在浏览器中访问rabbitmq的ui控制界面了，默认账号和密码都是<code>guest</code>：</p>
<p><img src="https://img-blog.csdnimg.cn/86f825c0b4744b7286015ee8ce10aa13.png" alt="在这里插入图片描述"><br>我们可以在控制台中创建相应的exchange、queue等等操作：</p>
<p><img src="https://img-blog.csdnimg.cn/8ddb8b5395f14bbc9ddfa64495f261df.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>字符串匹配算法 GO实现</title>
    <url>/2022/11/02/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%20GO%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>KMP算法是一种改进的字符串匹配算法,其关键是利用匹配失败后的信息,尽量减少模式串与主串的匹配次数以达到快速匹配的目的 。</p>
<p>求得模式的特征向量之后，基于特征分析的快速模式匹配算法(KMP模式匹配算法)与朴素匹配算法类似，只是在每次匹配过程中发生某次失配时，不再单纯地把模式后移一位，而是根据当前字符的特征数来决定模式右移的位数 。</p>
<p>视频讲解：</p>
<p><a href="https://www.bilibili.com/video/BV1Px411z7Yo?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1Px411z7Yo?spm_id_from&#x3D;333.999.0.0</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成前缀表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">prefixTable</span><span class="params">(pattern <span class="type">string</span>, prefix []<span class="type">int</span>, n <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 前缀表的第一个为0</span></span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">	<span class="comment">// 当前已经匹配到的长度</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 从第一个开始匹配</span></span><br><span class="line">	i := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">		<span class="comment">// 如果当前遍历到的字符 等于 已经匹配到字符串的下一位，len++</span></span><br><span class="line">		<span class="keyword">if</span> pattern[i] == pattern[<span class="built_in">len</span>] &#123;</span><br><span class="line">			<span class="built_in">len</span>++</span><br><span class="line">			<span class="comment">// 填写最大公共前后缀</span></span><br><span class="line">			prefix[i] = <span class="built_in">len</span></span><br><span class="line">			<span class="comment">// 继续往后遍历</span></span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//当前遍历到的字符 不等于 已经匹配到字符串的下一位，且len不等于0，往斜后方对齐</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">len</span> = prefix[<span class="built_in">len</span> - <span class="number">1</span>]</span><br><span class="line">				<span class="comment">//否则当前最大公共前后缀才等于0，即len</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				prefix[i] = <span class="built_in">len</span></span><br><span class="line">				i++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前缀表向后移动一位</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">movePrefixTable</span><span class="params">(prefix []<span class="type">int</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line">		prefix[i] = prefix[i - <span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 第一位置为-1</span></span><br><span class="line">	prefix[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kmp搜索</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmpSearch</span><span class="params">(text <span class="type">string</span>, pattern <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	m := <span class="built_in">len</span>(text)</span><br><span class="line">	n := <span class="built_in">len</span>(pattern)</span><br><span class="line">	prefix := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line"></span><br><span class="line">	prefixTable(pattern, prefix, n)</span><br><span class="line">	movePrefixTable(prefix, n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// i遍历模式串，j遍历匹配串</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	j := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开始匹配</span></span><br><span class="line">	<span class="keyword">for</span> i &lt; m &#123;</span><br><span class="line">		<span class="comment">//如果j刚好等于匹配串最后一个字符的下标 而且 最后一位字符也相同</span></span><br><span class="line">		<span class="keyword">if</span> j == n - <span class="number">1</span> &amp;&amp; text[i] == pattern[j] &#123;</span><br><span class="line">			<span class="keyword">return</span> i - j</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果两个对应的字符相等，就往后遍历</span></span><br><span class="line">		<span class="keyword">if</span> text[i] == pattern[j] &#123;</span><br><span class="line">			i++</span><br><span class="line">			j++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//如果不相等，那么就将j移动到前缀表对应的那个下标</span></span><br><span class="line">			j = prefix[j]</span><br><span class="line">			<span class="comment">//前缀表的-1表示向后移动一位</span></span><br><span class="line">			<span class="keyword">if</span> j == <span class="number">-1</span> &#123;</span><br><span class="line">				i++</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	pattern := <span class="string">&quot;ABABCABAA&quot;</span></span><br><span class="line">	text := <span class="string">&quot;ABABABCABAABABABAB&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(kmpSearch(text, pattern))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="sunday算法"><a href="#sunday算法" class="headerlink" title="sunday算法"></a>sunday算法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>Sunday算法由Daniel M.Sunday在1990年提出，它的思想跟BM算法很相似。</p>
<p>只不过Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。</p>
<ul>
<li>如果该字符没有在模式串中出现则直接跳过，即移动位数 &#x3D; 模式串长度 + 1；</li>
<li>否则，其移动位数 &#x3D; 模式串长度 - 该字符最右出现的位置(以0开始) &#x3D; 模式串中该字符最右出现的位置到尾部的距离 + 1。</li>
</ul>
<p>视频讲解：</p>
<p><a href="https://www.bilibili.com/video/BV1zf4y1N7H9?from=search&seid=16752958135964048105&spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1zf4y1N7H9?from=search&seid=16752958135964048105&spm_id_from&#x3D;333.337.0.0</a></p>
<p>个人觉得sunday算法的思想要比kmp算法简单很多，效率也比kmp高。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode/utf8&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sundaySearch</span><span class="params">(s <span class="type">string</span>, t <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	index := <span class="number">0</span>   <span class="comment">//index用来遍历模式串的下标</span></span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(t)   <span class="comment">//len等于匹配串长度</span></span><br><span class="line">	<span class="keyword">var</span> flag <span class="type">bool</span>   <span class="comment">//用来标记有没有找到</span></span><br><span class="line">	<span class="keyword">for</span> index &lt; utf8.RuneCountInString(s)  &#123;</span><br><span class="line">		<span class="comment">//字符一样</span></span><br><span class="line">		flag = <span class="literal">true</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">			<span class="comment">//出现了不一样的字符</span></span><br><span class="line">			<span class="keyword">if</span> t[i] != s[index + i] &#123;</span><br><span class="line">				flag = <span class="literal">false</span></span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//都一样 结束 返回</span></span><br><span class="line">		<span class="keyword">if</span> flag &#123;</span><br><span class="line">			<span class="keyword">return</span> index</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//有这个字符</span></span><br><span class="line">			flag = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">				<span class="comment">//在t中找到了末尾后一个字，对齐</span></span><br><span class="line">				<span class="keyword">if</span> t[i] == s[index + <span class="built_in">len</span>] &#123;</span><br><span class="line">					index += <span class="built_in">len</span> - i</span><br><span class="line">					flag = <span class="literal">false</span></span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//没有找到 跳过</span></span><br><span class="line">			<span class="keyword">if</span> flag &#123;</span><br><span class="line">				index += <span class="built_in">len</span> + <span class="number">1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;ABABABCBA&quot;</span></span><br><span class="line">	t := <span class="string">&quot;CBA&quot;</span></span><br><span class="line">	fmt.Println(sundaySearch(s, t))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>四、RabbitMQ TTL、死信队列以及延迟队列</title>
    <url>/2022/11/06/RabbitMQ/%E5%9B%9B%E3%80%81RabbitMQ%20TTL%E3%80%81%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>TTL 全称 Time To Live（存活时间&#x2F;过期时间）。当消息到达存活时间后，还没有被消费，就会被自动清除。RabbitMQ可以设置两种过期时间：</p>
<ul>
<li>对消息设置过期时间。</li>
<li>对整个队列（Queue）设置过期时间。</li>
</ul>
<p><strong>如何设置</strong></p>
<ul>
<li>设置队列过期时间使用参数：<code>x-message-ttl</code>，单位：ms(毫秒)，会对整个队列消息统一过期。</li>
<li>设置消息过期时间使用参数：<code>expiration</code>，单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期。</li>
</ul>
<p>如果两者都设置了过期时间，以时间短的为准。</p>
<p><strong>在streadway&#x2F;amqp库提供的API中设置TTL</strong></p>
<p>设置队列过期时间：</p>
<p><code>QueueDeclare</code>函数的最后一个参数是一个<code>amqp.Table</code>类型，它的声明是这样的: <code>type Table map[string]interface&#123;&#125;</code>，其实是一个可以用于设置队列属性的map。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置Queue ttl为5s</span></span><br><span class="line">args := amqp.Table&#123;<span class="string">&quot;x-message-ttl&quot;</span>: <span class="number">5000</span>&#125;</span><br><span class="line"></span><br><span class="line">q, e := ch.QueueDeclare(</span><br><span class="line">		name,  <span class="comment">//队列名</span></span><br><span class="line">		<span class="literal">false</span>, </span><br><span class="line">		<span class="literal">true</span>, </span><br><span class="line">		<span class="literal">false</span>, </span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		args,   <span class="comment">//设置Queue ttl为5s</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<p>设置消息过期时间：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e = q.channel.Publish(</span><br><span class="line">		<span class="string">&quot;&quot;</span>,    </span><br><span class="line">		queue, </span><br><span class="line">		<span class="literal">false</span>, </span><br><span class="line">		<span class="literal">false</span>, </span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			<span class="comment">// 设置当前发送消息的过期时间为3s</span></span><br><span class="line">			Expiration: <span class="string">&quot;3000&quot;</span>,</span><br><span class="line">			ReplyTo:    q.Name,</span><br><span class="line">			Body:       []<span class="type">byte</span>(str),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当一个队列中存在<code>死信</code>时，RabbitMQ会把消息发送给<code>DLX</code>（死信交换机），进而被路由到另一个队列中，这个队列就叫做死信队列。</p>
<p>死信就是指没有被消费者消费成功的消息，一条消息变成死信有三种情况：</p>
<ol>
<li>如果给消息队列设置了最大容量<code>x-max-length</code>，队列已经满了，后续再进来的消息会溢出，无法被队列接收就会变成死信。</li>
<li>消息接收时被拒绝会变成死信，例如调用<code>Reject()</code>函数，并设置<code>requeue</code>为<code>false</code>。</li>
<li>如果给消息队列设置了消息的过期时间<code>x-message-ttl</code>，或者发送消息时设置了当前消息的过期时间，当消息在队列中的存活时间大于过期时间时，就会变成死信。</li>
</ol>
<p><strong>如何将死信发送给DLX</strong></p>
<p>为队列设置参数即可，将要发送死信的队列配置以下两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x-dead-letter-exchange: [DLX的名字]</span><br><span class="line">x-dead-letter-routing-key: [DLX的routing key]</span><br></pre></td></tr></table></figure>

<p>下面是死信队列的工作流程：</p>
<p><img src="https://img-blog.csdnimg.cn/ca80e810bfb1407f8f71f18a424a65e9.png" alt="在这里插入图片描述"></p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延时队列就是用来存放需要在指定时间被处理的元素的队列，通常可以用来处理一些具有过期性操作的业务。</p>
<p>比如十分钟内未支付则取消订单，原先这个功能我们可以使用定时器来实现，即每隔一段时间去数据库对比未支付订单的当前时间与订单创建时间。但是定时器的时长难以确定，太长会导致订单失效时间出现误差，太短则会增大数据库压力。</p>
<p><strong>实现</strong></p>
<p>在RabbitMQ中没有提供延迟队列的功能，但是我们可以使用：<code>TTL+死信队列</code>组合的方式来实现延迟队列的效果。</p>
<p>下面是实现延迟队列的流程图：</p>
<p><img src="https://img-blog.csdnimg.cn/c611767f8eb648109648a3f015066621.png" alt="在这里插入图片描述"></p>
<h2 id="Go实现延迟队列"><a href="#Go实现延迟队列" class="headerlink" title="Go实现延迟队列"></a>Go实现延迟队列</h2><p><strong>创建一个死信交换机</strong></p>
<p><img src="https://img-blog.csdnimg.cn/12c98f41dff64c75b091e4486fe20b30.png" alt="在这里插入图片描述"></p>
<p><strong>再创建一个死信队列</strong></p>
<p><img src="https://img-blog.csdnimg.cn/e3c07812995d4ab98f104446d9692c0a.png" alt="在这里插入图片描述"></p>
<p><strong>将死信队列绑定至死信交换机</strong></p>
<p><img src="https://img-blog.csdnimg.cn/1f72dcd152794ea8b3752ce10951791b.png" alt="在这里插入图片描述"></p>
<p><strong>创建一个正常队列，并指定消息过期后被发往的死信交换机</strong></p>
<p><img src="https://img-blog.csdnimg.cn/abaa9233693b407aa55ddff7841be043.png" alt="在这里插入图片描述"><br><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, _ := amqp.Dial(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>)</span><br><span class="line">	ch, _ := conn.Channel()</span><br><span class="line">	body := <span class="string">&quot;This is a delayed message, created at &quot;</span> + time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">	fmt.Println(body)</span><br><span class="line">	<span class="comment">// 发送消息到queue.normal队列中</span></span><br><span class="line">	ch.Publish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;queue.normal&quot;</span>, <span class="literal">false</span>, <span class="literal">false</span>, amqp.Publishing&#123;</span><br><span class="line"></span><br><span class="line">		Body:       []<span class="type">byte</span>(body),</span><br><span class="line">		Expiration: <span class="string">&quot;10000&quot;</span>, <span class="comment">// 设置TTL为10秒</span></span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	<span class="keyword">defer</span> ch.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>消费者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	conn, _ := amqp.Dial(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>)</span><br><span class="line">	ch, _ := conn.Channel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听queue.dlx队列</span></span><br><span class="line">	msgs, _ := ch.Consume(</span><br><span class="line">		<span class="string">&quot;queue.dlx&quot;</span>,</span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;receive: %s\n&quot;</span>, d.Body) <span class="comment">// 收到消息，业务处理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>流程说明</strong></p>
<p>生产者生产一条消息，然后指定消息的TTL为10s，接着将消息发给普通队列，消息在普通队列中过期后被发往死信交换机，死信交换机将这条消息路由给延迟队列。消费者一直在监听到延迟队列中的死信后，开始消费。</p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>二、RabbitMQ的五种工作模式</title>
    <url>/2022/11/06/RabbitMQ/%E4%BA%8C%E3%80%81RabbitMQ%E7%9A%84%E4%BA%94%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="六种工作模式介绍"><a href="#六种工作模式介绍" class="headerlink" title="六种工作模式介绍"></a>六种工作模式介绍</h2><p><strong>1.简单（Simple）模式</strong></p>
<p> <img src="https://img-blog.csdnimg.cn/71518fe9cbe34108bdd815602f8918b6.png" alt="在这里插入图片描述"><br>P：生产者，也就是要发送消息的程序。<br>C：消费者：消息的接收者，会一直等待消息到来。<br>queue：消息队列，图中红色部分。类似一个邮箱，可以缓存消息；生产者向其中投递消息，消费者从其中取出消息。</p>
<p>简单模式就是<code>单发单收</code>，消息的消费者监听消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除。</p>
<p><strong>2.工作队列（Work Queue）模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/6653d3c05e50474aa379faf1c6d04f93.png" alt="在这里插入图片描述"><br>这种模式就是多个消费者消费同一个队列中的消息，既然消费者多了那么就出现了消息分配的问题，所以对应着两种分配策略：</p>
<ol>
<li>公平分发：每个消费者接收消息的概率是相等的，消息队列会循环依次给每个消费者发送消息，这种是默认的策略。</li>
<li>公平派遣：保证消费者在消费完某个消息，并发送确认信息后，消息队列才会向它推送新的消息，在此之间若是有新的消息，将会被推送到其它消费者，若所有的消费者都在消费消息，那么就会等待。</li>
</ol>
<p><strong>3.发布&#x2F;订阅（Pub&#x2F;Sub）模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/4bcc17dca8444dc7850f14b2f03c15e3.jpeg" alt="请添加图片描述"><br>在这种模型中，多了一个 Exchange 角色，而且过程略有变化：</p>
<p>P：生产者,也就是要发送消息的程序，但是不再发送到队列中，而是发给X (交换机)。<br>C：消费者，消息的接收者，会一直等待消息到来。<br>Queue：消息队列，接收消息、缓存消息。<br>Exchange：交换机(X) ，一方面，接收生产者发送的消息。另一方面，如何处理消息，递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。 Exchange有以下4种类型：</p>
<ol>
<li>Fanout：广播，将消息交给所有绑定到交换机的队列。</li>
<li>Direct：全值匹配，把消息交给符合指定<code>routing key</code>的队列。</li>
<li>Topic：通配符，与Direct类型类似，但Direct类型要求<code>routing key</code>完全相等，而Topic类型是对<code>routing key</code>进行模糊匹配，比Direct灵活。</li>
<li>Headers：根据Message的一些头部信息来分发过滤Message，用的比较少。</li>
</ol>
<p>注意：Exchange负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失。</p>
<p><strong>4.路由（Routing）模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/0d0d7063c6634765a1f94bbe3927698f.png" alt="在这里插入图片描述"></p>
<p>路由模式其实就是上述发布&#x2F;订阅模式的交换机转发类型变成了Direct类型。在这种模式下：<br>Exchange 不再把消息交给每一个绑定的队列，而是根据消息的<code>routing key</code>进行判断，只有队列的<br><code>routing key</code>与消息的<code>routing key</code>完全一致，才会接收到消息。</p>
<p>P：生产者，向 Exchange 发送消息，发送消息时，会指定一个<code>routing key</code>。<br>X：Exchange（交换机），接收生产者的消息，然后把消息递交给与<code>routing key</code>完全匹配的队列。<br>C1：消费者，其所在队列指定了需要<code>routing key</code>为error的消息。<br>C2：消费者，其所在队列指定了需要<code>routing key</code>为 info、error、warning 的消息。</p>
<p><strong>5.通配符（Tpoic）模式</strong></p>
<p><img src="https://img-blog.csdnimg.cn/0e9a08040e5a40ac9ebb4a1fe5afa3d5.png" alt="在这里插入图片描述"><br>路由模式其实就是上述发布&#x2F;订阅模式的交换机转发类型变成了Topic类型。在这种模式下：</p>
<p>队列的<code>routing key</code>与消息的<code>routing key</code>符合匹配规则，就可以接收到消息，有两种规则：</p>
<p><code>*</code>：可以（只能）匹配一个单词。<br><code>#</code>：可以匹配多个单词（或者零个）。</p>
<p>所以图中，<code>routing key</code>为<code>a.orange.b</code>的消息就会被转发到Q1，而<code>routing key</code>为<code>Lazy.a.b.c</code>的消息就会被发送到Q2。</p>
<h2 id="Go语言的实现"><a href="#Go语言的实现" class="headerlink" title="Go语言的实现"></a>Go语言的实现</h2><h3 id="安装操作库"><a href="#安装操作库" class="headerlink" title="安装操作库"></a>安装操作库</h3><p><strong>安装API库</strong></p>
<p>Go可以使用<code>streadway/amqp</code>库来操作rabbit，使用以下命令来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/streadway/amqp</span><br></pre></td></tr></table></figure>

<p><strong>封装rabbitmq</strong></p>
<p>接下来我们对<code>streadway/amqp</code>库的内容进行一个二次封装，封装为一个<code>rabbitmq.go</code>文件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> rabbitmq</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RabbitMQ RabbitMQ结构</span></span><br><span class="line"><span class="keyword">type</span> RabbitMQ <span class="keyword">struct</span> &#123;</span><br><span class="line">	channel  *amqp.Channel</span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	exchange <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connect 连接服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Connect</span><span class="params">(s <span class="type">string</span>)</span></span> *RabbitMQ &#123;</span><br><span class="line">	<span class="comment">//连接rabbitmq</span></span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	failOnError(e, <span class="string">&quot;连接Rabbitmq服务器失败！&quot;</span>)</span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法打开频道！&quot;</span>)</span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 初始化消息队列</span></span><br><span class="line"><span class="comment">//第一个参数：rabbitmq服务器的链接，第二个参数：队列名字</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s <span class="type">string</span>, name <span class="type">string</span>)</span></span> *RabbitMQ &#123;</span><br><span class="line">	<span class="comment">//连接rabbitmq</span></span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	failOnError(e, <span class="string">&quot;连接Rabbitmq服务器失败！&quot;</span>)</span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法打开频道！&quot;</span>)</span><br><span class="line">	q, e := ch.QueueDeclare(</span><br><span class="line">		name,  <span class="comment">//队列名</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//是否开启持久化</span></span><br><span class="line">		<span class="literal">true</span>,  <span class="comment">//不使用时删除</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//排他</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//不等待</span></span><br><span class="line">		<span class="literal">nil</span>,   <span class="comment">//参数</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;初始化消息队列失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	mq.Name = q.Name</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueueDeclare 声明queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> QueueDeclare(queue <span class="type">string</span>) &#123;</span><br><span class="line">	_, e := q.channel.QueueDeclare(queue, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">nil</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;声明queue失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QueueDelete 删除queue</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> QueueDelete(queue <span class="type">string</span>) &#123;</span><br><span class="line">	_, e := q.channel.QueueDelete(queue, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;删除queue失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Qos 配置queue参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Qos() &#123;</span><br><span class="line">	e := q.channel.Qos(<span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法设置QoS&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewExchange 初始化交换机</span></span><br><span class="line"><span class="comment">//第一个参数：rabbitmq服务器的链接，第二个参数：交换机名字，第三个参数：交换机类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewExchange</span><span class="params">(s <span class="type">string</span>, name <span class="type">string</span>, typename <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//连接rabbitmq</span></span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	failOnError(e, <span class="string">&quot;连接Rabbitmq服务器失败！&quot;</span>)</span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法打开频道！&quot;</span>)</span><br><span class="line">	e = ch.ExchangeDeclare(</span><br><span class="line">		name,     <span class="comment">// name</span></span><br><span class="line">		typename, <span class="comment">// type</span></span><br><span class="line">		<span class="literal">true</span>,     <span class="comment">// durable</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// auto-deleted</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// internal</span></span><br><span class="line">		<span class="literal">false</span>,    <span class="comment">// no-wait</span></span><br><span class="line">		<span class="literal">nil</span>,      <span class="comment">// arguments</span></span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;初始化交换机失败！&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ExchangeDelete 删除交换机</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> ExchangeDelete(exchange <span class="type">string</span>) &#123;</span><br><span class="line">	e := q.channel.ExchangeDelete(exchange, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;删除交换机失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind 绑定消息队列到exchange</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Bind(exchange <span class="type">string</span>, key <span class="type">string</span>) &#123;</span><br><span class="line">	e := q.channel.QueueBind(</span><br><span class="line">		q.Name,</span><br><span class="line">		key,</span><br><span class="line">		exchange,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;绑定队列失败！&quot;</span>)</span><br><span class="line">	q.exchange = exchange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 向消息队列发送消息</span></span><br><span class="line"><span class="comment">//Send方法可以往某个消息队列发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Send(queue <span class="type">string</span>, body <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	failOnError(e, <span class="string">&quot;消息序列化失败！&quot;</span>)</span><br><span class="line">	e = q.channel.Publish(</span><br><span class="line">		<span class="string">&quot;&quot;</span>,    <span class="comment">//交换</span></span><br><span class="line">		queue, <span class="comment">//路由键</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//必填</span></span><br><span class="line">		<span class="literal">false</span>, <span class="comment">//立即</span></span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="type">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	msg := <span class="string">&quot;向队列:&quot;</span> + q.Name + <span class="string">&quot;发送消息失败！&quot;</span></span><br><span class="line">	failOnError(e, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish 向exchange发送消息</span></span><br><span class="line"><span class="comment">//Publish方法可以往某个exchange发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Publish(exchange <span class="type">string</span>, body <span class="keyword">interface</span>&#123;&#125;, key <span class="type">string</span>) &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	failOnError(e, <span class="string">&quot;消息序列化失败！&quot;</span>)</span><br><span class="line">	e = q.channel.Publish(</span><br><span class="line">		exchange,</span><br><span class="line">		key,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;ReplyTo: q.Name,</span><br><span class="line">			Body: []<span class="type">byte</span>(str)&#125;,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;向交换机发送消息失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consume 接收某个消息队列的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Consume() &lt;-<span class="keyword">chan</span> amqp.Delivery &#123;</span><br><span class="line">	c, e := q.channel.Consume(</span><br><span class="line">		q.Name, <span class="comment">//指定从哪个队列中接收消息</span></span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;接收消息失败！&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭队列连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Close() &#123;</span><br><span class="line">	q.channel.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">failOnError</span><span class="params">(err <span class="type">error</span>, msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;%s: %s&quot;</span>, msg, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="简单（Simple）模式"><a href="#简单（Simple）模式" class="headerlink" title="简单（Simple）模式"></a>简单（Simple）模式</h3><p><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;simple&quot;</span>)</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每隔2s发送一次消息</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		producer.Send(<span class="string">&quot;simple&quot;</span>, <span class="string">&quot; simple message: &quot;</span>+strconv.Itoa(i))</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	consumer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;simple&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息时，指定</span></span><br><span class="line">	messages := consumer.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ch := <span class="keyword">range</span> messages &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, ch.Body)</span><br><span class="line">			<span class="comment">// 消费消息要用3s</span></span><br><span class="line">			time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">18</span>:<span class="number">54</span>:<span class="number">47</span> Received a message: <span class="string">&quot; simple message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">18</span>:<span class="number">54</span>:<span class="number">52</span> Received a message: <span class="string">&quot; simple message: 1&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">18</span>:<span class="number">54</span>:<span class="number">57</span> Received a message: <span class="string">&quot; simple message: 2&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="工作队列（Work-Queue）模式"><a href="#工作队列（Work-Queue）模式" class="headerlink" title="工作队列（Work Queue）模式"></a>工作队列（Work Queue）模式</h3><p><strong>公平分发模式：</strong></p>
<p>公平分发模式采用的是轮询机制，它会将数个任务按顺序平均分发给消费者。</p>
<p><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;worker&quot;</span>)</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每隔2s发送一次消息</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		producer.Send(<span class="string">&quot;worker&quot;</span>, <span class="string">&quot; worker message: &quot;</span>+strconv.Itoa(i))</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	consumer1 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;worker&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	messages := consumer1.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ch := <span class="keyword">range</span> messages &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, ch.Body)</span><br><span class="line">			<span class="comment">// 消费消息要用3s</span></span><br><span class="line">			time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	consumer2 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;worker&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	messages := consumer2.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ch := <span class="keyword">range</span> messages &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, ch.Body)</span><br><span class="line">			<span class="comment">// 消费消息要用3s</span></span><br><span class="line">			time.Sleep(time.Second * <span class="number">3</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">19</span>:<span class="number">45</span>:<span class="number">03</span> Received a message: <span class="string">&quot; worker message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">19</span>:<span class="number">45</span>:<span class="number">07</span> Received a message: <span class="string">&quot; worker message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">19</span>:<span class="number">45</span>:<span class="number">11</span> Received a message: <span class="string">&quot; worker message: 4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">19</span>:<span class="number">45</span>:<span class="number">05</span> Received a message: <span class="string">&quot; worker message: 1&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">19</span>:<span class="number">45</span>:<span class="number">09</span> Received a message: <span class="string">&quot; worker message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">19</span>:<span class="number">45</span>:<span class="number">13</span> Received a message: <span class="string">&quot; worker message: 5&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以发现，公平模式下，偶数消息都被发送给了消费者1，而奇数消息都被发送给了消费者2。</p>
<p><strong>公平派遣模式：</strong></p>
<p>有时候，如果消息之间的复杂度不同，那么不同消费者消费消息所用的时间会不同。这个时候如果使用公平派发模式，可能会造成某一个消费者需要消费的消息积压过多。可以采用公平派遣模式：</p>
<p>公平派遣模式下发送端与公平分发相同，消费者端只需要加一段配置代码，我们可以将预取计数设置为1。这告诉RabbitMQ一次不要给消费者一个以上的消息。换句话说，在处理并确认上一条消息之前，不要将新消息发送给消费者。而是将其分派给不忙的下一个消费者。</p>
<p>关于消息的确认：</p>
<p>为了确保消息永不丢失，RabbitMQ支持 消息确认。消费者发送回一个确认（acknowledgement），以告知RabbitMQ已经接收，处理了特定的消息，并且RabbitMQ可以自由删除它。</p>
<p>我们之前的代码中，RabbitMQ一旦向消费者传递了一条消息，便立即将其标记为删除（调用Consumer的第三个参数是autoAck，表示是否自动回复）。在这种情况下，如果你终止一个消费者那么你就可能会丢失这个任务，我们还将丢失所有已经交付给这个消费者的尚未消费的消息。如果一个消费者意外宕机了，那么我们希望将任务交付给其他消费者来消费者。</p>
<p>所以一旦向消费者传递了一条消息，就不能马上将其标记为删除，而是要手动确认。我们需要在创建消费者的时候将<code>autoAck</code>参数标记为false：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consume 接收某个消息队列的消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Consume() &lt;-<span class="keyword">chan</span> amqp.Delivery &#123;</span><br><span class="line">	c, e := q.channel.Consume(</span><br><span class="line">		q.Name, <span class="comment">//指定从哪个队列中接收消息</span></span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="literal">false</span>, <span class="comment">// 不自动确认消息</span></span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>,</span><br><span class="line">	)</span><br><span class="line">	failOnError(e, <span class="string">&quot;接收消息失败！&quot;</span>)</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后每消费完一条消息需要调用<code>Ack(false)</code>函数手动回复。</p>
<p><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;worker&quot;</span>)</span><br><span class="line"></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每隔2s发送一次消息</span></span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">		producer.Send(<span class="string">&quot;worker&quot;</span>, <span class="string">&quot; worker message: &quot;</span>+strconv.Itoa(i))</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费端限流：<br>实现<code>公平派遣模式</code>我们需要设置消费者端一次只能消费一条消息，之前我们已经进行了封装，直接在消费者端调用即可：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Qos 配置queue参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Qos() &#123;</span><br><span class="line">	e := q.channel.Qos(<span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>)</span><br><span class="line">	failOnError(e, <span class="string">&quot;无法设置QoS&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	consumer1 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;worker&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定一次只消费一条消息，直到消费完才重新接收</span></span><br><span class="line">	consumer1.Qos()</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	messages := consumer1.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ch := <span class="keyword">range</span> messages &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, ch.Body)</span><br><span class="line">			<span class="comment">// 消费消息要用10s</span></span><br><span class="line">			time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line">			<span class="comment">// 手动回复</span></span><br><span class="line">			ch.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	consumer2 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;worker&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定一次只消费一条消息，直到消费完才重新接收</span></span><br><span class="line">	consumer2.Qos()</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	messages := consumer2.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> ch := <span class="keyword">range</span> messages &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Received a message: %s&quot;</span>, ch.Body)</span><br><span class="line">			<span class="comment">// 消费消息要用2s</span></span><br><span class="line">			time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">			<span class="comment">// 手动回复</span></span><br><span class="line">			ch.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">26</span> Received a message: <span class="string">&quot; worker message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">36</span> Received a message: <span class="string">&quot; worker message: 5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">28</span> Received a message: <span class="string">&quot; worker message: 1&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">30</span> Received a message: <span class="string">&quot; worker message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">32</span> Received a message: <span class="string">&quot; worker message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">34</span> Received a message: <span class="string">&quot; worker message: 4&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">38</span> Received a message: <span class="string">&quot; worker message: 6&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">20</span>:<span class="number">31</span>:<span class="number">40</span> Received a message: <span class="string">&quot; worker message: 7&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="发布-x2F-订阅（Pub-x2F-Sub）模式"><a href="#发布-x2F-订阅（Pub-x2F-Sub）模式" class="headerlink" title="发布&#x2F;订阅（Pub&#x2F;Sub）模式"></a>发布&#x2F;订阅（Pub&#x2F;Sub）模式</h3><p><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue&quot;</span>)</span><br><span class="line">	rabbitmq.NewExchange(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;fanout&quot;</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="comment">// fanout模式下不用routing key</span></span><br><span class="line">		producer.Publish(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;pubsub message: &quot;</span>+strconv.Itoa(i), <span class="string">&quot;&quot;</span>)</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer1 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue1&quot;</span>)</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer1.Bind(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer1.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer1 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			d.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer2 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue2&quot;</span>)</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer2.Bind(<span class="string">&quot;exchange1&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer2.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer2 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			d.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">19</span> Consumer1 received a message: <span class="string">&quot;pubsub message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">20</span> Consumer1 received a message: <span class="string">&quot;pubsub message: 1&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">21</span> Consumer1 received a message: <span class="string">&quot;pubsub message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">22</span> Consumer1 received a message: <span class="string">&quot;pubsub message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">23</span> Consumer1 received a message: <span class="string">&quot;pubsub message: 4&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">24</span> Consumer1 received a message: <span class="string">&quot;pubsub message: 5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">19</span> Consumer2 received a message: <span class="string">&quot;pubsub message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">20</span> Consumer2 received a message: <span class="string">&quot;pubsub message: 1&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">21</span> Consumer2 received a message: <span class="string">&quot;pubsub message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">22</span> Consumer2 received a message: <span class="string">&quot;pubsub message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">23</span> Consumer2 received a message: <span class="string">&quot;pubsub message: 4&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">32</span>:<span class="number">24</span> Consumer2 received a message: <span class="string">&quot;pubsub message: 5&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="路由（Routing）模式"><a href="#路由（Routing）模式" class="headerlink" title="路由（Routing）模式"></a>路由（Routing）模式</h3><p><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定为direct类型</span></span><br><span class="line">	rabbitmq.NewExchange(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;direct&quot;</span>)</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="comment">// 如果是奇数，就发key1</span></span><br><span class="line">		<span class="comment">// 如果是偶数，就发key2</span></span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">			producer.Publish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routing message: &quot;</span>+strconv.Itoa(i), <span class="string">&quot;key1&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			producer.Publish(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;routing message: &quot;</span>+strconv.Itoa(i), <span class="string">&quot;key2&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		i = i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer1 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue1&quot;</span>)</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer1.Bind(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;key1&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer1.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer1 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			d.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer2 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue2&quot;</span>)</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer2.Bind(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;key2&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer2.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer2 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			d.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">10</span> Consumer1 received a message: <span class="string">&quot;routing message: 1&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">12</span> Consumer1 received a message: <span class="string">&quot;routing message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">14</span> Consumer1 received a message: <span class="string">&quot;routing message: 5&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">16</span> Consumer1 received a message: <span class="string">&quot;routing message: 7&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">11</span> Consumer2 received a message: <span class="string">&quot;routing message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">13</span> Consumer2 received a message: <span class="string">&quot;routing message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">15</span> Consumer2 received a message: <span class="string">&quot;routing message: 4&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">22</span>:<span class="number">51</span>:<span class="number">17</span> Consumer2 received a message: <span class="string">&quot;routing message: 6&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="通配符（Tpoic）模式"><a href="#通配符（Tpoic）模式" class="headerlink" title="通配符（Tpoic）模式"></a>通配符（Tpoic）模式</h3><p><strong>生产者</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	producer := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue&quot;</span>)</span><br><span class="line">	<span class="comment">// 指定为topic类型</span></span><br><span class="line">	rabbitmq.NewExchange(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;exchange2&quot;</span>, <span class="string">&quot;topic&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">			producer.Publish(<span class="string">&quot;exchange2&quot;</span>, <span class="string">&quot;topic message: &quot;</span>+strconv.Itoa(i), <span class="string">&quot;a.test.b.c&quot;</span>)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			producer.Publish(<span class="string">&quot;exchange2&quot;</span>, <span class="string">&quot;topic message: &quot;</span>+strconv.Itoa(i), <span class="string">&quot;a.test.b&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者1</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer1 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue1&quot;</span>)</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer1.Bind(<span class="string">&quot;exchange2&quot;</span>, <span class="string">&quot;*.test.*&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer1.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer1 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			d.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消费者2</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//第一个参数指定rabbitmq服务器的链接，第二个参数指定创建队列的名字</span></span><br><span class="line">	consumer2 := rabbitmq.New(<span class="string">&quot;amqp://guest:guest@35.76.111.125:5672/&quot;</span>, <span class="string">&quot;queue2&quot;</span>)</span><br><span class="line">	<span class="comment">// 队列绑定到exchange</span></span><br><span class="line">	consumer2.Bind(<span class="string">&quot;exchange2&quot;</span>, <span class="string">&quot;#.test.#&quot;</span>)</span><br><span class="line">	<span class="comment">//接收消息</span></span><br><span class="line">	msgs := consumer2.Consume()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> d := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">			log.Printf(<span class="string">&quot;Consumer2 received a message: %s&quot;</span>, d.Body)</span><br><span class="line">			d.Ack(<span class="literal">false</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">53</span> Consumer1 received a message: <span class="string">&quot;topic message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">55</span> Consumer1 received a message: <span class="string">&quot;topic message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">57</span> Consumer1 received a message: <span class="string">&quot;topic message: 4&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">59</span> Consumer1 received a message: <span class="string">&quot;topic message: 6&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">53</span> Consumer2 received a message: <span class="string">&quot;topic message: 0&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">54</span> Consumer2 received a message: <span class="string">&quot;topic message: 1&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">55</span> Consumer2 received a message: <span class="string">&quot;topic message: 2&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">56</span> Consumer2 received a message: <span class="string">&quot;topic message: 3&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">57</span> Consumer2 received a message: <span class="string">&quot;topic message: 4&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">58</span> Consumer2 received a message: <span class="string">&quot;topic message: 5&quot;</span></span><br><span class="line"><span class="attribute">2022</span>/<span class="number">11</span>/<span class="number">05</span> <span class="number">23</span>:<span class="number">09</span>:<span class="number">59</span> Consumer2 received a message: <span class="string">&quot;topic message: 6&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
  </entry>
  <entry>
    <title>CAP原则和BASE理论</title>
    <url>/2022/11/02/%E5%88%86%E5%B8%83%E5%BC%8F/CAP%E5%8E%9F%E5%88%99%E5%92%8CBASE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着分布式计算的发展，事物在分布式计算领域也得到了广泛的应用。在单机数据库中，我们很容易能够实现一套满足ACID特性的事物处理系统，但在分布式数据库中，数据分散在各台不同的机器上，如何对这些数据进行分布式的事物处理具有非常大的挑战。</p>
<h2 id="CAP原则"><a href="#CAP原则" class="headerlink" title="CAP原则"></a>CAP原则</h2><p><img src="https://img-blog.csdnimg.cn/8ded2d415a3e4edc84cbeed0e5f35c04.png" alt="在这里插入图片描述"></p>
<p>CAP原则指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。<br>CAP原则是NOSQL数据库的基石。</p>
<h3 id="分区容错性、可用性和一致性"><a href="#分区容错性、可用性和一致性" class="headerlink" title="分区容错性、可用性和一致性"></a>分区容错性、可用性和一致性</h3><p><strong>分区容错性</strong>：指的是分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍然能对外提供满足一致性和可用性的服务。也就是说部分故障不影响整体使用。</p>
<p>事实上我们在设计分布式系统是都会考虑到bug,硬件，网络等各种原因造成的故障，所以即使部分节点或者网络出现故障，我们要求整个系统还是要继续使用的</p>
<p>(不继续使用,相当于只有一个分区,那么也就没有后续的一致性和可用性了)</p>
<p><strong>可用性</strong>： 一直可以正常的做读写操作。简单而言就是客户端一直可以正常访问并得到系统的正常响应。用户角度来看就是不会出现系统操作失败或者访问超时等问题。</p>
<p><strong>一致性</strong>：在分布式系统完成某写操作后，任何读操作，都应该获取到该写操作写入的那个最新的值。相当于要求分布式系统中的各节点时时刻刻保持数据的一致性。</p>
<h3 id="一致性与可用性的抉择"><a href="#一致性与可用性的抉择" class="headerlink" title="一致性与可用性的抉择"></a>一致性与可用性的抉择</h3><p>CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。<br>对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地 。(Web1.0以静态、单向阅读为主，网站内信息可以直接和其他网站信息进行交互，能通过第三方信息平台同时对多家网站信息进行整合使用。Web2.0以分享为特征的实时网络，用户在互联网上拥有自己的数据，并能在不同的网站上使用。)</p>
<ol>
<li>数据库事务一致性需求<br>很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求并不高。允许实现最终一致性。</li>
<li>数据库的写实时性和读实时性需求<br> 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</li>
<li>对复杂的SQL查询，特别是多表关联查询的需求<br> 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角 度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</li>
</ol>
<h3 id="取舍策略"><a href="#取舍策略" class="headerlink" title="取舍策略"></a>取舍策略</h3><p>CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p>
<p><strong>CA without P</strong>：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。</p>
<p><strong>CP without A</strong>：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<p><strong>AP wihtout C</strong>：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
<h3 id="为什么不能全部满足"><a href="#为什么不能全部满足" class="headerlink" title="为什么不能全部满足"></a>为什么不能全部满足</h3><p>我们来看一个简单的问题, 一个DB服务   搭建在两个机房（北京,广州)，两个DB实例同时提供写入和读取:<br><img src="https://img-blog.csdnimg.cn/d93f0aad543a41248e3c7bf87dff3658.png#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功<br> 在没有出现网络故障的时候，满足CA原则，C 即我的任何一个写入，更新操作成功并返回客户端完成后,分布式的所有节点在同一时间的数据完全一致， A 即我的读写操作都能够成功，但是当出现网络故障时，我不能同时保证CA，即P条件无法满足。</p>
</li>
<li><p>假设DB的更新操作是只写本地机房成功就返回，通过binlog&#x2F;oplog回放方式同步至侧边机房<br> 这种操作保证了在出现网络故障时,双边机房都是可以提供服务的，且读写操作都能成功，意味着他满足了AP ，但是它不满足C，因为更新操作返回成功后，双边机房的DB看到的数据会存在短暂不一致，且在网络故障时，不一致的时间差会很大（仅能保证最终一致性）。</p>
</li>
<li><p>假设DB的更新操作是同时写北京和广州的DB都成功才返回成功且网络故障时提供降级服务<br> 降级服务，如停止写入，只提供读取功能，这样能保证数据是一致的，且网络故障时能提供服务，满足CP原则，但是他无法满足可用性原则。</p>
</li>
</ol>
<h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE是<code>Basically Available（基本可用）</code>、<code>Soft state（软状态）</code>和<code>Eventually consistent（最终一致性）</code>三个短语的简写，BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
<h3 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h3><p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用，以下两个就是“基本可用”的典型例子。</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎需要0.5秒内返回给用户相应的查询结果，但由于出现异常（比如系统部分机房发生断电或断网故障），查询结果的响应时间增加到了1~2秒。</li>
<li>功能上的损失：正常情况下，在一个电子商务网站上进行购物，消费者几乎能够顺利地完成每一笔订单，但是在一些节日大促购物高峰的时候，由于消费者的购物行为激增，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。</li>
</ul>
<h3 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h3><p>弱状态也称为软状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据听不的过程存在延时。</p>
<h3 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h3><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统的事物ACID特性是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性和BASE理论往往又会结合在一起。</p>
<h3 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h3><p>BASE(Basically Available, Soft State, Eventual Consistency  基本可用、软状态、最终一致性) 对CAP AP理论的延伸, Redis等众多系统构建与这个理论之上。<br>ACID  传统数据库常用的设计理念, ACID和BASE代表了两种截然相反的设计哲学。</p>
<p>BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>浅识分布式一致性</title>
    <url>/2022/11/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B5%85%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h2 id="三个业务场景"><a href="#三个业务场景" class="headerlink" title="三个业务场景"></a>三个业务场景</h2><p><strong>1.火车站售票</strong></p>
<p>从A地到B地的票只剩下一张, 但是现在有两个乘客在不同的售票窗口同时购买了这张票。如果售票系统没有一致性的保障, 那么在检票口检票的时候,其中一名乘客会被告知他的票是无效的。</p>
<p>这就对售票系统提出了严格的一致性要求: 系统中的数据无论在哪个售票窗口,每时每刻都必须是准确无误的。</p>
<p><strong>2. 银行转账</strong></p>
<p>我们往家里寄钱, 柜台的服务员告诉我们:”您的转账将于N个工作日后到账”。晚一点到账无所谓, 只需要保证钱寄到的时候分文不少就可以了。</p>
<p><strong>3.选课</strong></p>
<p>开学选课的时候,当我们看见一门心仪的课程, 只有5个名额了,但是当我们按下选课的瞬间, 系统却告诉我们该课程已经满了。</p>
<p>但是实际上在选课页面显示的剩余名额, 通常不是该课程的真实库存量,只有在真正按下选课的时候, 系统才会查询该课程的真实剩余名额。</p>
<h2 id="场景解读"><a href="#场景解读" class="headerlink" title="场景解读"></a>场景解读</h2><p>对于上面三个例子，相信大家一定看出来了，我们的终端用户在使用不同的计算机产品时对于数据一致性的需求是不一样的：</p>
<ol>
<li><p>有些系统，既要快速地响应用户，同时还要保证系统的数据对于任意客户端都是真实可靠的，就像火车站售票系统。</p>
</li>
<li><p>有些系统，需要为用户保证绝对可靠的数据安全，虽然在数据一致性上存在延时，但最终务必保证严格的一致性，就像银行的转账系统。</p>
</li>
<li><p>有些系统，虽然向用户展示了一些可以说是”错误”的数据，但是在整个系统使用过程中，一定会在某一个流程上对系统数据进行准确无误的检查，从而避免用户发生不必要的损失，就像选课系统。</p>
</li>
</ol>
<h2 id="分布一致性的提出"><a href="#分布一致性的提出" class="headerlink" title="分布一致性的提出"></a>分布一致性的提出</h2><p>所谓分布一致性问题，是指在分布式环境中引入数据复制机制之后，不同数据节点之间可能出现的，并无法依靠计算机应用程序自身解决的数据不一致的情况。简单讲，数据一致性就是指在对一个副本数据进行更新的时候，必须确保也能够更新其他的副本，否则不同副本之间的数据将不一致。</p>
<p>那么如何解决这个问题？一种思路是”<strong>既然是由于延时动作引起的问题，那我可以将写入的动作阻塞，直到数据复制完成后，才完成写入动作</strong>“。 没错，这似乎能解决问题，而且有一些系统的架构也确实直接使用了这个思路。但这个思路在解决一致性问题的同时，又带来了新的问题：写入的性能。如果你的应用场景有非常多的写请求，那么使用这个思路之后，后续的写请求都将会阻塞在前一个请求的写操作上，导致系统整体性能急剧下降。</p>
<p>总得来说，我们无法找到一种能够满足分布式系统所有系统属性的分布式一致性解决方案。因此，如何既保证数据的一致性，同时又不影响系统运行的性能，是每一个分布式系统都需要重点考虑和权衡的。于是，一致性级别由此诞生：</p>
<p><strong>1.强一致性</strong></p>
<p>这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大。</p>
<p><strong>2.弱一致性</strong></p>
<p>这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。</p>
<p><strong>3.最终一致性</strong></p>
<p>最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型。</p>
<h2 id="分布式环境的各种问题"><a href="#分布式环境的各种问题" class="headerlink" title="分布式环境的各种问题"></a>分布式环境的各种问题</h2><p>1.通信异常</p>
<p>分布式系统需要在各个节点之间进行网络通信，因此每次网络通信都会伴随着网络不可用的风险，网络光纤、路由器或是DNS等硬件设备或 是系统不可用都会导致最终分布式系统无法顺利完成一次网络通信。另外，即使分布式系统各个节点之间的网络通信能够正常进行，其延时也会大于单机操作。</p>
<p>2.网络分区</p>
<p>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信，而另一些节点则不能—-我们将这个现象称为网络分区。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括对数据的事物处理，这就对分布式一致性提出了非常大的挑战。</p>
<p>3.三态</p>
<p>上面两点，我们已经了解到在分布式环境下，网络可能会出现各式各样的问题，因此分布式系统的每一次请求与响应，存在特有的三态概念，即成功、失败、超时。 在传统的单机系统中，应用程序在调用一个函数之后，能够得到一个非常明确的响应：成功或失败。而在分布式系统中，由于网络是不可靠的，虽然在绝大部分情况 下，网络通信也能够接受到成功或失败的响应，当时当网络出现异常的情况下，就可能会出现超时现象，通常有以下两种情况：</p>
<p>（1）由于网络原因，该请求并没有被成功地发送到接收方，而是在发送过程中就发生了消息丢失现象。</p>
<p>（2）该请求成功地被接收方接收后，进行了处理，但是在将响应反馈给发送方的过程中，发生了消息丢失现象。</p>
<p>当出现这样的超时现象时，网络通信的发起方是无法确定当前请求是否被成功处理的。</p>
<p>4.节点故障</p>
<p>节点故障则是分布式环境下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或”僵死”现象，通常根据经验来说，每个节点都有可能出现故障，并且每天都在发生。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>浅识分布式系统</title>
    <url>/2022/11/02/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B5%85%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="为什么要使用分布式"><a href="#为什么要使用分布式" class="headerlink" title="为什么要使用分布式"></a>为什么要使用分布式</h2><p>分布式系统并非灵丹妙药，解决问题的关键还是看你对问题本身的了解。通常我们需要使用分布式的常见理由是：</p>
<ol>
<li>为了性能扩展——系统负载高，单台机器无法承载，希望通过使用多台机器来提高系统的负载能力。</li>
<li>为了增强可靠性——软件不是完美的，网络不是完美的，甚至机器本身也不可能是完美的，随时可能会出错，为了避免故障，需要将业务分散开保留一定的冗余度。</li>
</ol>
<p>在以提供 Service 为主的服务端软件开发过程中常常遇到这些问题。</p>
<h2 id="分布式系统的本质"><a href="#分布式系统的本质" class="headerlink" title="分布式系统的本质"></a>分布式系统的本质</h2><p>所谓分布式，无非就是”将一个系统拆分成多个子系统并散布到不同设备“的过程而已。</p>
<p>本质上而言，实现一个分布式系统，最核心的部分无非有两点：</p>
<ol>
<li>如何拆分——可以有很多方式，核心依据一是业务需求，二是成本限制。这是实践中构建分布式系统时最主要的设计依据。</li>
<li>如何连接——光把系统拆开成 Process 还不够，关键是拆开后的 Process 之间还要能通信，因此涉及通信协议设计的问题，需要考虑的因素很多，好消息是这部分其实成熟方案很多。</li>
</ol>
<h2 id="分布式的基础要点"><a href="#分布式的基础要点" class="headerlink" title="分布式的基础要点"></a>分布式的基础要点</h2><p>分布式主要有如下要点:</p>
<ol>
<li><p><strong>Process（进程）</strong>:在分布式系统中，进程是基本单元。</p>
</li>
<li><p><strong>通信协议</strong>: Process 间需要相互配合才能完成工作，因此通信协议是最基本要解决的问题。这部分其实挺复杂，牵涉面光，不过核心还是抓住两方面，一是存在哪些需求，二是各个协议如何满足这些需求。</p>
</li>
<li><p><strong>命名法</strong>: 两个 Process 要通信，必须相互知道对方的名字，名字可以是数字，也可以是结构化的字符串。例如众所周知域名系统就是一种命名方案，但是方案还有很多，各有特点。</p>
</li>
<li><p><strong>协作</strong>: 上面都在谈 Process 之间的通信，可是为什么要通信？因为要协作。协作是个复杂的主题，其中最基本最基本的一个问题就是同步问题。</p>
</li>
</ol>
<p>上面几点是最基础的知识。了解了这些其实就算入门了。可是如何进阶呢？那么必然要开始学习下面的问题：</p>
<ol>
<li>一致性: 数据存储时，最基本的问题。其实也是实际设计系统时常常需要反复考虑的问题。</li>
<li>容错: 冗余是容错的基础，但并不是全部，分布式本身为实现容错提供了一些便利，这也是实际设计系统时常常需要考虑的问题。</li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 1.简单动态字符串</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%201.%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，<code>SDS</code> ）的抽象类型，并将<code>SDS</code>用作Redis的默认字符串表示.</p>
<p>比如Redis的字符串对象，当字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用<code>SDS</code>来保存这个字符串值.</p>
<h2 id="2-SDS的定义"><a href="#2-SDS的定义" class="headerlink" title="2.SDS的定义"></a>2.SDS的定义</h2><p>SDS定义在<code>redis</code>源码根目录下的<code>sds.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *sds;</span><br></pre></td></tr></table></figure>

<p><code>SDS</code>有一个表头<code>header</code>用于存放<code>SDS</code>的信息，其中在<code>redis-3.2.0</code>版本之前是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;   <span class="comment">//buf中已占用空间的长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">free</span>;  <span class="comment">//buf中剩余可用空间的长度</span></span><br><span class="line">    <span class="type">char</span> buf[];         <span class="comment">//初始化sds分配的数据空间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中有三个字段，分别是buf中已占用空间的长度、buf中剩余可用的长度以及存储字符串的数组，注意字符串数组末尾的<code>&#39;\0&#39;</code>不计算在SDS的<code>len</code>属性里面. 其中buf数组是一个<code>柔性数组</code>. 关于柔性数组可以看一下这篇博客：<a href="https://coolshell.cn/articles/11377.html">C语言结构体里的成员数组和指针</a>.</p>
<p>根据这个结构体，我们展示一个<code>SDS</code>示例：</p>
<p><img src="https://img-blog.csdnimg.cn/1c3d7b79bfc64f8f8c56b7033d19d40b.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>free</code>属性的值为0，表示这个SDS没有分配任何未使用的空间.</li>
<li><code>len</code>属性的值为5，表示这个SDS保存了一个五字节长的字符串.</li>
<li><code>buf</code>属性是一个char类型的数组，数组的前五个字节分别保存了<code>&#39;R&#39;</code>、<code>&#39;e&#39;</code>、<code>&#39;d&#39;</code>、<code>&#39;i&#39;</code>、<code>&#39;s&#39;</code>五个字符，而最后一个字节则保存了空字符<code>&#39;\0&#39;</code>.</li>
</ul>
<p>从<code>redis-3.2.0</code>版本之后（包括3.2.0），关于SDS表头的定义是这样的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表头的大体思路是一样的，但是高版本一共有五种关于<code>Header</code>的定义，目的是为不同长度的字符串提供不同大小的<code>Header</code>，以节省内存. 以 <code>sdshdr8</code> 为例，其 <code>len</code> 属性为 <code>uint8_t</code> 类型，占用内存大小为 1 字节，则存储的字符串最大长度为256.</p>
<p><code>Header</code>主要包含了四个字段：</p>
<ul>
<li><code>len</code>：字符串的长度，不包含终止字符.</li>
<li><code>alloc</code>：除去表头和<code>&#39;\0&#39;</code>的buf数组长度.</li>
<li><code>flags</code>：标志<code>header</code>的类型.</li>
<li><code>buf</code>：储存字符串的数组.</li>
</ul>
<h2 id="3-SDS的优点"><a href="#3-SDS的优点" class="headerlink" title="3. SDS的优点"></a>3. SDS的优点</h2><h3 id="3-1-兼容C的部分函数"><a href="#3-1-兼容C的部分函数" class="headerlink" title="3.1 兼容C的部分函数"></a>3.1 兼容C的部分函数</h3><p><code>SDS</code>字符串采用<code>&#39;\0&#39;</code>结尾，兼容传统的C风格字符串，因此可以直接使用C的部分字符串函数.</p>
<h3 id="3-2-常数复杂度获取字符串长度"><a href="#3-2-常数复杂度获取字符串长度" class="headerlink" title="3.2 常数复杂度获取字符串长度"></a>3.2 常数复杂度获取字符串长度</h3><p><code>SDS</code>在表头的<code>len</code>属性中记录了<code>SDS</code>本身的长度，所以获取一个SDS长度的复杂度仅为<code>O(1)</code>.</p>
<h3 id="3-3-杜绝缓冲区溢出"><a href="#3-3-杜绝缓冲区溢出" class="headerlink" title="3.3 杜绝缓冲区溢出"></a>3.3 杜绝缓冲区溢出</h3><p><code>SDS</code>字符串表头的<code>free</code>成员记录着buf字符数组中未使用空间的字节数，所以在追加字符串的时候，如果不够用会进行内存扩展，再进行追加.</p>
<h3 id="3-4-二进制安全"><a href="#3-4-二进制安全" class="headerlink" title="3.4 二进制安全"></a>3.4 二进制安全</h3><p>传统的C风格字符串的特点是<code>遇零则止</code>，如果保存的二进制数据（图片、视频等）中含有<code>&#39;\0&#39;</code>，相关操作在这里就会被截断.</p>
<p>而SDS表头的buf字段是一个字节数组，判断是否到达字符串结尾的依据是表头的len成员，因此可以存放任何二进制数据和文本数据不被截断，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/2f61744aa38c4845aee934dd84543477.png" alt="在这里插入图片描述"></p>
<h2 id="4-部分源码剖析"><a href="#4-部分源码剖析" class="headerlink" title="4. 部分源码剖析"></a>4. 部分源码剖析</h2><h3 id="4-1-空间预分配策略"><a href="#4-1-空间预分配策略" class="headerlink" title="4.1 空间预分配策略"></a>4.1 空间预分配策略</h3><ul>
<li>如果对SDS进行修改后，SDS表头的len成员<code>小于1MB</code>，那么就会分配和len长度相同的未使用空间，free和len成员大小相等.</li>
<li>如果对SDS进行修改后，SDS的长度<code>大于等于1MB</code>，那么就会分配<code>1MB</code>的未使用空间</li>
</ul>
<p>通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sds <span class="title function_">sdsMakeRoomFor</span><span class="params">(sds s, <span class="type">size_t</span> addlen)</span>   <span class="comment">// addlen 需要增加的空间长度</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></span><br><span class="line">    <span class="comment">// 获得s的未使用空间的长度</span></span><br><span class="line">    <span class="type">size_t</span> <span class="built_in">free</span> = sdsavail(s);</span><br><span class="line">    <span class="type">size_t</span> len, newlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余空间可以满足需求，无须扩展</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取表头地址</span></span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="comment">// 目前 buf 长度</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="comment">// 新 buf 长度</span></span><br><span class="line">    newlen = (len+addlen);</span><br><span class="line">    <span class="comment">// 如果新 buf 长度小于 SDS_MAX_PREALLOC（1024*1024）长度</span></span><br><span class="line">    <span class="comment">// 那么将 buf 的长度设为新 buf 长度的两倍</span></span><br><span class="line">    <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">        newlen *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        newlen += SDS_MAX_PREALLOC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得新扩展空间的地址</span></span><br><span class="line">    newsh = zrealloc(sh, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+newlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 更新free</span></span><br><span class="line">    newsh-&gt;<span class="built_in">free</span> = newlen - len;</span><br><span class="line">    <span class="keyword">return</span> newsh-&gt;buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-2-惰性空间释放"><a href="#4-2-惰性空间释放" class="headerlink" title="4.2 惰性空间释放"></a>4.2 惰性空间释放</h3><p>惰性空间释放用于优化SDS的字符串缩短操作，当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdsclear</span><span class="params">(sds s)</span> &#123;</span><br><span class="line">	<span class="comment">// 获取表头地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="comment">// 表头free成员+已使用空间的长度len = 新的free</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> += sh-&gt;len;</span><br><span class="line">    <span class="comment">// 已使用的空间变为0</span></span><br><span class="line">    sh-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 字符串置为空</span></span><br><span class="line">    sh-&gt;buf[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-其它部分源码"><a href="#4-3-其它部分源码" class="headerlink" title="4.3 其它部分源码"></a>4.3 其它部分源码</h3><p>Redis为<code>SDS</code>提供了非常丰富的API，这里只展示一小部分.</p>
<h4 id="4-3-1-获取SDS的长度"><a href="#4-3-1-获取SDS的长度" class="headerlink" title="4.3.1 获取SDS的长度"></a>4.3.1 获取SDS的长度</h4><p><code>sdslen</code>是一个定义在<code>sds.h</code>中的内联函数，获取字符串的长度其实就是获取SDS表头的<code>len</code>字段. </p>
<p>而在<code>sds.c</code>中，几乎所有的函数传参都是sds类型，而不是表头<code>sdshdr</code>的地址，所以需要使用指针运算来获取表头的地址，表头结构体中一共有三个字段，最后一个buf成员是一个柔性数组，起一个占位符的作用，并不占用该结构体的大小，所以<code>struct sdshdr</code>的大小是固定的，为<code>8</code>字节.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdslen</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="keyword">return</span> sh-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-获取SDS的剩余长度"><a href="#4-3-2-获取SDS的剩余长度" class="headerlink" title="4.3.2 获取SDS的剩余长度"></a>4.3.2 获取SDS的剩余长度</h4><p>该函数同样是一个定义在<code>sds.h</code>中的内联函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">sdsavail</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="keyword">return</span> sh-&gt;<span class="built_in">free</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-创建SDS"><a href="#4-3-3-创建SDS" class="headerlink" title="4.3.3 创建SDS"></a>4.3.3 创建SDS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为initlen的字符串,并保存init字符串中的值</span></span><br><span class="line">sds <span class="title function_">sdsnewlen</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *init, <span class="type">size_t</span> initlen)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init) &#123;</span><br><span class="line">        sh = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);  <span class="comment">//申请空间：表头+initlen长度+&#x27;\0&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sh = zcalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)+initlen+<span class="number">1</span>);  <span class="comment">//如果init为空，则将申请的空间初始化为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh-&gt;len = initlen;      <span class="comment">//设置表头的len成员</span></span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;           <span class="comment">//设置free，新的sds不预留任何空间</span></span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen); <span class="comment">//将指定的字符串init拷贝到表头的buf中</span></span><br><span class="line">    sh-&gt;buf[initlen] = <span class="string">&#x27;\0&#x27;</span>;    <span class="comment">//以&#x27;\0&#x27;结尾</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">char</span>*)sh-&gt;buf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立一个只有表头，字符串为空&quot;\0&quot;的sds</span></span><br><span class="line">sds <span class="title function_">sdsempty</span><span class="params">(<span class="type">void</span>)</span> &#123;        </span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(<span class="string">&quot;&quot;</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据字符串init，创建一个与init一样长度字符串的sds（表头+buf）</span></span><br><span class="line">sds <span class="title function_">sdsnew</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *init)</span> &#123;  </span><br><span class="line">    <span class="type">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝一份s的副本</span></span><br><span class="line">sds <span class="title function_">sdsdup</span><span class="params">(<span class="type">const</span> sds s)</span> &#123;       </span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-4-销毁SDS"><a href="#4-3-4-销毁SDS" class="headerlink" title="4.3.4 销毁SDS"></a>4.3.4 销毁SDS</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放字符串和表头</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdsfree</span><span class="params">(sds s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    zfree(s-<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-5-SDS的追加"><a href="#4-3-5-SDS的追加" class="headerlink" title="4.3.5 SDS的追加"></a>4.3.5 SDS的追加</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符串t追加到s表头的buf末尾，追加len个字节</span></span><br><span class="line">sds <span class="title function_">sdscatlen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">void</span> *t, <span class="type">size_t</span> len)</span> &#123;   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></span><br><span class="line">    <span class="type">size_t</span> curlen = sdslen(s);  <span class="comment">//原有的长度</span></span><br><span class="line"></span><br><span class="line">    s = sdsMakeRoomFor(s,len);  <span class="comment">//扩展空间</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="built_in">memcpy</span>(s+curlen, t, len);   <span class="comment">//字符串拼接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新属性</span></span><br><span class="line">    sh-&gt;len = curlen+len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>-len;</span><br><span class="line">    s[curlen+len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将t字符串拼接到s的末尾</span></span><br><span class="line">sds <span class="title function_">sdscat</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将sds追加到s末尾</span></span><br><span class="line">sds <span class="title function_">sdscatsds</span><span class="params">(sds s, <span class="type">const</span> sds t)</span> &#123;     </span><br><span class="line">    <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串t覆盖到s表头的buf中，拷贝len个字节</span></span><br><span class="line">sds <span class="title function_">sdscpylen</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t, <span class="type">size_t</span> len)</span> &#123;   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="type">size_t</span> totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;   <span class="comment">//获得总长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totlen &lt; len) &#123;         <span class="comment">//总长度小于len</span></span><br><span class="line">        s = sdsMakeRoomFor(s,len-sh-&gt;len);  <span class="comment">//扩展l空间</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        sh = (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">        totlen = sh-&gt;<span class="built_in">free</span>+sh-&gt;len;  <span class="comment">//更新总长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(s, t, len);  <span class="comment">//拷贝字符串t覆盖s原有的字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新表头</span></span><br><span class="line">    s[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = totlen-len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串覆盖到s表头的buf中</span></span><br><span class="line">sds <span class="title function_">sdscpy</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *t)</span> &#123;      </span><br><span class="line">    <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-6-SDS的删除"><a href="#4-3-6-SDS的删除" class="headerlink" title="4.3.6 SDS的删除"></a>4.3.6 SDS的删除</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去除sds中包含有cset字符串的部分</span></span><br><span class="line">sds <span class="title function_">sdstrim</span><span class="params">(sds s, <span class="type">const</span> <span class="type">char</span> *cset)</span> &#123;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*) (s-(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr)));</span><br><span class="line">    <span class="type">char</span> *start, *end, *sp, *ep;</span><br><span class="line">    <span class="type">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置和备份指针位置</span></span><br><span class="line">    sp = start = s;</span><br><span class="line">    ep = end = s+sdslen(s)<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//strchr()函数功能：查找cset中首次出现*sp字符的位置，成功返回第一次出现的位置</span></span><br><span class="line">    <span class="keyword">while</span>(sp &lt;= end &amp;&amp; <span class="built_in">strchr</span>(cset, *sp)) sp++;         <span class="comment">//从左开始修剪，sp为目标串的左边界</span></span><br><span class="line">    <span class="keyword">while</span>(ep &gt; start &amp;&amp; <span class="built_in">strchr</span>(cset, *ep)) ep--;        <span class="comment">//从右开始修剪，ep为目标串的右边界</span></span><br><span class="line"></span><br><span class="line">    len = (sp &gt; ep) ? <span class="number">0</span> : ((ep-sp)+<span class="number">1</span>);  <span class="comment">//目标串的长度</span></span><br><span class="line">    <span class="keyword">if</span> (sh-&gt;buf != sp) memmove(sh-&gt;buf, sp, len);   <span class="comment">//将字符串的位置前移到buf开头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新表头</span></span><br><span class="line">    sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span>+(sh-&gt;len-len);</span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 10.列表对象</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2010.%E5%88%97%E8%A1%A8%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="1-列表对象的结构"><a href="#1-列表对象的结构" class="headerlink" title="1. 列表对象的结构"></a>1. 列表对象的结构</h2><p>从<code>redis-3.2</code>版本开始，就使用<code>quicklist</code>作为列表键的底层实现，列表对象的大致结构如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/f20cad3c987a4c19886aaae7b2b2af3e.png" alt="在这里插入图片描述"></p>
<h2 id="2-列表对象命令介绍"><a href="#2-列表对象命令介绍" class="headerlink" title="2. 列表对象命令介绍"></a>2. 列表对象命令介绍</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；如但果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>LINSERT key BEFORE[AFTER] pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>LPUSHX key value</td>
<td>将一个或多个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪（trim），就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody></table>
<h2 id="2-列表对象命令的实现"><a href="#2-列表对象命令的实现" class="headerlink" title="2. 列表对象命令的实现"></a>2. 列表对象命令的实现</h2><p>列表对象命令的实现代码在<code>t_list.c</code>源文件中.</p>
<p>Redis先是定义了一些最底层的函数比如<code>listTypePush</code>、<code>listTypePush</code>等等，然后在这些底层命令之上又封装了有特定功能的函数，比如阻塞和非阻塞插入和删除. 这里我们只介绍一些最底层的命令.</p>
<h3 id="2-1-PUSH命令"><a href="#2-1-PUSH命令" class="headerlink" title="2.1 PUSH命令"></a>2.1 PUSH命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> QUICKLIST_HEAD 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> QUICKLIST_TAIL -1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// PUSH命令的底层实现</span></span><br><span class="line"><span class="comment">// 根据where（头插还是尾插），将value插入到列表中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listTypePush</span><span class="params">(robj *subject, robj *value, <span class="type">int</span> where)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对列表对象编码为quicklist类型操作</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="type">int</span> pos = (where == LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得value编码为RAW的字符串对象</span></span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存value的长度</span></span><br><span class="line">        <span class="type">size_t</span> len = sdslen(value-&gt;ptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PUSH value的值到quicklist的头或尾</span></span><br><span class="line">        quicklistPush(subject-&gt;ptr, value-&gt;ptr, len, pos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value的引用计数减1</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		<span class="comment">// 不是quicklist类型的编码则发送错误信息</span></span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-POP命令"><a href="#2-2-POP命令" class="headerlink" title="2.2 POP命令"></a>2.2 POP命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// POP命令底层实现</span></span><br><span class="line"><span class="comment">// 根据where（头还是尾），将value从列表中弹出</span></span><br><span class="line">robj *<span class="title function_">listTypePop</span><span class="params">(robj *subject, <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> vlong;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得POP的位置，quicklist的头部或尾部</span></span><br><span class="line">    <span class="type">int</span> ql_where = where == LIST_HEAD ? QUICKLIST_HEAD : QUICKLIST_TAIL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对列表对象编码为quicklist类型操作</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// 从ql_where位置POP出一个entry节点，保存在value或vlong中</span></span><br><span class="line">        <span class="keyword">if</span> (quicklistPopCustom(subject-&gt;ptr, ql_where, (<span class="type">unsigned</span> <span class="type">char</span> **)&amp;value,</span><br><span class="line">                               <span class="literal">NULL</span>, &amp;vlong, listPopSaver)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!value) <span class="comment">// 如果弹出的entry节点是整型的</span></span><br><span class="line">                <span class="comment">// 则根据整型值创建一个字符串对象</span></span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回弹出entry节点的value值</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-列表迭代器"><a href="#2-3-列表迭代器" class="headerlink" title="2.3 列表迭代器"></a>2.3 列表迭代器</h3><p>其中列表对象还定义了迭代器，以及迭代时候的节点信息，这个迭代器迭代的其实是<code>quicklist</code>的节点<code>quicklistEntry</code>，<code>quicklist</code>的底层实现中，还有专门的用于迭代<code>quicklist</code>节点中<code>ziplist</code>的迭代器.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列表类型迭代器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 迭代器指向的对象</span></span><br><span class="line">    robj *subject;</span><br><span class="line">    <span class="comment">// 迭代器指向对象的编码类型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;</span><br><span class="line">    <span class="comment">// 迭代器的方向</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> direction;</span><br><span class="line">    <span class="comment">// quicklist的迭代器</span></span><br><span class="line">    quicklistIter *iter;</span><br><span class="line">&#125; listTypeIterator;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列表类型的entry结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 所属的列表类型迭代器</span></span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="comment">// quicklist中的entry结构</span></span><br><span class="line">    quicklistEntry entry;</span><br><span class="line">&#125; listTypeEntry;</span><br></pre></td></tr></table></figure>

<p><strong>初始化迭代器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定的索引处初始化迭代器</span></span><br><span class="line">listTypeIterator *<span class="title function_">listTypeInitIterator</span><span class="params">(robj *subject, <span class="type">long</span> index, <span class="type">unsigned</span> <span class="type">char</span> direction)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    listTypeIterator *li = zmalloc(<span class="keyword">sizeof</span>(listTypeIterator));</span><br><span class="line">    <span class="comment">//设置迭代器的各个成员的初始值</span></span><br><span class="line">    li-&gt;subject = subject;</span><br><span class="line">    li-&gt;encoding = subject-&gt;encoding;</span><br><span class="line">    li-&gt;direction = direction;</span><br><span class="line">    <span class="comment">// quicklist迭代器为空</span></span><br><span class="line">    li-&gt;iter = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LIST_HEAD means start at TAIL and move *towards* head.</span></span><br><span class="line"><span class="comment">     * LIST_TAIL means start at HEAD and move *towards tail. */</span></span><br><span class="line">    <span class="comment">// 获得迭代方向</span></span><br><span class="line">    <span class="type">int</span> iter_direction =</span><br><span class="line">        direction == LIST_HEAD ? AL_START_TAIL : AL_START_HEAD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对列表对象编码为quicklist类型操作</span></span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// 将迭代器和下标为index的quicklistNode结合，迭代器指向该节点</span></span><br><span class="line">        li-&gt;iter = quicklistGetIteratorAtIdx(li-&gt;subject-&gt;ptr,</span><br><span class="line">                                             iter_direction, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更新迭代器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将列表类型的迭代器指向的entry保存在提供的listTypeEntry结构中，并且更新迭代器，1表示成功，0失败</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listTypeNext</span><span class="params">(listTypeIterator *li, listTypeEntry *entry)</span> &#123;</span><br><span class="line">    <span class="comment">// 确保对象编码类型和迭代器中encoding成员相等</span></span><br><span class="line">    serverAssert(li-&gt;subject-&gt;encoding == li-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置listTypeEntry的entry成员关联到当前列表类型的迭代器</span></span><br><span class="line">    entry-&gt;li = li;</span><br><span class="line">    <span class="comment">// 对列表对象编码为quicklist类型操作</span></span><br><span class="line">    <span class="keyword">if</span> (li-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// 保存当前的entry到listTypeEntry的entry成员，并更新迭代器</span></span><br><span class="line">        <span class="keyword">return</span> quicklistNext(li-&gt;iter, &amp;entry-&gt;entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回当前迭代器指向的节点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个节点的value对象，根据当前的迭代器</span></span><br><span class="line">robj *<span class="title function_">listTypeGet</span><span class="params">(listTypeEntry *entry)</span> &#123;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 对列表对象编码为quicklist类型操作</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;li-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">    	<span class="comment">// 创建一个字符串对象保存列表类型的entry结构所指向的entry节点的字符串值</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;entry.value) &#123;   </span><br><span class="line">            value = createStringObject((<span class="type">char</span> *)entry-&gt;entry.value,</span><br><span class="line">                                       entry-&gt;entry.sz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 创建一个字符串对象保存列表类型的entry结构所指向的entry节点的整型值</span></span><br><span class="line">            value = createStringObjectFromLongLong(entry-&gt;entry.longval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁迭代器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁迭代器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listTypeReleaseIterator</span><span class="params">(listTypeIterator *li)</span> &#123;</span><br><span class="line">	<span class="comment">// 释放quicklist迭代器</span></span><br><span class="line">    zfree(li-&gt;iter);</span><br><span class="line">    <span class="comment">// 释放列表类型迭代器</span></span><br><span class="line">    zfree(li);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 11.哈希对象</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2011.%E5%93%88%E5%B8%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="1-列表对象的结构"><a href="#1-列表对象的结构" class="headerlink" title="1. 列表对象的结构"></a>1. 列表对象的结构</h2><p>哈希对象的编码可以是<code>ziplist</code>或者<code>字典</code>.</p>
<p>当使用<code>ziplist</code>作为底层实现时，每当有新的键值对要加人到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾，因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起，保存键的节点在前，保存值的节点在后.</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向，而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向.</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/5dd43c983e0c4494a7034920d06bde08.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/7f61739639df4e4890eeac266f918db6.png" alt="在这里插入图片描述"></p>
<p>而当使用<code>字典</code>作为底层实现时，哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li><p>字典的每个键都是一个字符串对象，对象中保存了键值对的键.</p>
</li>
<li><p>字典的每个值都是一个字符串对象，对象中保存了键值对的值.</p>
</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/7446266d9ea14c88a3baac7675755288.png" alt="在这里插入图片描述"></p>
<h2 id="2-哈希对象编码"><a href="#2-哈希对象编码" class="headerlink" title="2. 哈希对象编码"></a>2. 哈希对象编码</h2><h3 id="2-1-编码使用规则"><a href="#2-1-编码使用规则" class="headerlink" title="2.1 编码使用规则"></a>2.1 编码使用规则</h3><p>当哈希对象可以同时满足以下两个条件的时，哈希对象使用<code>ziplist</code>编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于<code>64</code>字节.</li>
<li>哈希对象保存的键值对数量小于<code>512</code>个.</li>
</ul>
<p>不能满足上述任何一个条件的哈希对象都需要使用<code>hashtable</code>编码.</p>
<h3 id="2-2-编码转换"><a href="#2-2-编码转换" class="headerlink" title="2.2 编码转换"></a>2.2 编码转换</h3><p>当哈希对象使用的是<code>ziplist</code>编码时，当保存的键值对发生改变而不满足上诉的任意一个条件时，对象的编码转换操作就会被执行，原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面，对象的编码也会从<code>ziplist</code>变为<code>hashtable</code>.</p>
<h2 id="3-哈希对象命令介绍"><a href="#3-哈希对象命令介绍" class="headerlink" title="3. 哈希对象命令介绍"></a>3. 哈希对象命令介绍</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HDEL key field2 [field2]</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看哈希表 key 中，指定的字段是否存在</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment</td>
</tr>
<tr>
<td>HINCRBYFLOAT key field increment</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
</tr>
<tr>
<td>HKEYS key</td>
<td>获取所有哈希表中的字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td>HMGET key field1 [field2]</td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 [field2 value2 ]</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
</tr>
<tr>
<td>HSET key field value</td>
<td>将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值</td>
</tr>
<tr>
<td>HVALS key</td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td>HSCAN key cursor [MATCH pattern][COUNT count]</td>
<td>迭代哈希表中的键值对</td>
</tr>
</tbody></table>
<h2 id="4-哈希对象命令的实现"><a href="#4-哈希对象命令的实现" class="headerlink" title="4. 哈希对象命令的实现"></a>4. 哈希对象命令的实现</h2><p>字符串对象命令的实现代码在<code>t_hash.c</code>源文件中.</p>
<p>哈希对象的默认编码是<code>ziplist</code>，当元素长度或者元素长度到达一个阈值的时候，才会转化为<code>字典</code>编码.</p>
<p>转换的阈值（在<code>server.h</code>文件中）如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH_MAX_ZIPLIST_ENTRIES 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH_MAX_ZIPLIST_VALUE 64</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-HSET命令"><a href="#4-1-HSET命令" class="headerlink" title="4.1 HSET命令"></a>4.1 HSET命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HSET key field value</span></span><br><span class="line"><span class="comment">// HSET命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hsetCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> update;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写方式取出哈希对象，失败则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否需要进行哈希对象的编码类型转换，是存储在ziplist或字典中</span></span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将键和值对象的编码进行优化，以节省空间，是以embstr或raw或整型存储</span></span><br><span class="line">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class="number">2</span>], &amp;c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置field-value对，update为1则是更新，为0则是替换</span></span><br><span class="line">    update = hashTypeSet(o,c-&gt;argv[<span class="number">2</span>],c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送更新或替换的信息给client</span></span><br><span class="line">    addReply(c, update ? shared.czero : shared.cone);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据库的键则发送信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送&quot;hset&quot;事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新脏键</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建哈希对象</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以写操作在数据库中查找对应key的哈希对象，如果不存在则创建</span></span><br><span class="line">robj *<span class="title function_">hashTypeLookupWriteOrCreate</span><span class="params">(client *c, robj *key)</span> &#123;</span><br><span class="line">    robj *o = lookupKeyWrite(c-&gt;db,key);    <span class="comment">//以写操作在数据库中查找对应key的哈希对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key不存在，则创建一个哈希对象，并加入到数据库中</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        o = createHashObject();</span><br><span class="line">        dbAdd(c-&gt;db,key,o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果key存在于数据库中，检查其类型是否是哈希类型对象</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;type != OBJ_HASH) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断是否需要编码转换</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查一个数字对象的长度判断是否需要进行类型的转换，从ziplist转换到ht类型</span></span><br><span class="line"><span class="comment">// 只检查一个字符串类型长度，因为他的长度可以在常数时间内获取</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashTypeTryConversion</span><span class="params">(robj *o, robj **argv, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只从OBJ_ENCODING_ZIPLIST类型转换为OBJ_ENCODING_HT</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding != OBJ_ENCODING_ZIPLIST) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的数字对象</span></span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前对象是字符串对象的编码且字符串长度大于了配置文件规定的ziplist最大的长度</span></span><br><span class="line">        <span class="keyword">if</span> (sdsEncodedObject(argv[i]) &amp;&amp;</span><br><span class="line">            sdslen(argv[i]-&gt;ptr) &gt; server.hash_max_ziplist_value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将该对象编码转换为OBJ_ENCODING_HT</span></span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优化对象编码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对键和值的对象尝试进行优化编码以节约内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashTypeTryObjectEncoding</span><span class="params">(robj *subject, robj **o1, robj **o2)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前subject对象的编码为OBJ_ENCODING_HT，则对o1对象和o2对象进行尝试优化编码</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1) *o1 = tryObjectEncoding(*o1);</span><br><span class="line">        <span class="keyword">if</span> (o2) *o2 = tryObjectEncoding(*o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将键值对添加到哈希对象中</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将field-value添加到哈希对象中，返回1</span></span><br><span class="line"><span class="comment">// 如果field存在更新新的值，返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashTypeSet</span><span class="params">(robj *o, robj *field, robj *value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是ziplist类型</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果field-value是整数，则解码为字符串类型</span></span><br><span class="line">        field = getDecodedObject(field);</span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 遍历整个ziplist，得到头entry节点的地址</span></span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 在ziplist中查找并返回和field相等的entry节点</span></span><br><span class="line">            fptr = ziplistFind(fptr, field-&gt;ptr, sdslen(field-&gt;ptr), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果field存在</span></span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">                <span class="comment">// 返回当value的entry地址，也就是field的下一个entry</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr);</span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                update = <span class="number">1</span>; <span class="comment">// 设置更新的标志</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Delete value */</span></span><br><span class="line">                <span class="comment">// 将找到的value删除</span></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Insert new value */</span></span><br><span class="line">                <span class="comment">// 插入新的value节点</span></span><br><span class="line">                zl = ziplistInsert(zl, vptr, value-&gt;ptr, sdslen(value-&gt;ptr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到field</span></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            <span class="comment">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class="line">            <span class="comment">// 讲field和value按序压入到ziplist中</span></span><br><span class="line">            zl = ziplistPush(zl, field-&gt;ptr, sdslen(field-&gt;ptr), ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, value-&gt;ptr, sdslen(value-&gt;ptr), ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新哈希对象</span></span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line">        <span class="comment">// 释放临时的field-value</span></span><br><span class="line">        decrRefCount(field);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the ziplist needs to be converted to a hash table */</span></span><br><span class="line">        <span class="comment">// 在配置的条件下，如果能进行优化编码以便节约内存</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是添加到字典</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 插入或替换字典的field-value对，插入返回1，替换返回0</span></span><br><span class="line">        <span class="keyword">if</span> (dictReplace(o-&gt;ptr, field, value)) &#123; <span class="comment">/* Insert */</span></span><br><span class="line">            incrRefCount(field);    <span class="comment">//如果是插入成功，则释放field</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* Update */</span></span><br><span class="line">            update = <span class="number">1</span>;     <span class="comment">//设置更新的标志</span></span><br><span class="line">        &#125;</span><br><span class="line">        incrRefCount(value);    <span class="comment">//释放value对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> update;  <span class="comment">//更新返回1，替换返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-HMSET命令"><a href="#4-2-HMSET命令" class="headerlink" title="4.2 HMSET命令"></a>4.2 HMSET命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HMSET key field value [field value ...]</span></span><br><span class="line"><span class="comment">// HMSET的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmsetCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数必须为奇数，键值对必须成对出现</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;wrong number of arguments for HMSET&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写方式取出哈希对象，失败则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 是否需要进行哈希对象的编码类型转换，是存储在ziplist或字典中</span></span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 遍历所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 将键和值对象的编码进行优化，以节省空间，是以embstr或raw或整型存储</span></span><br><span class="line">        hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[i], &amp;c-&gt;argv[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 设置field-value对</span></span><br><span class="line">        hashTypeSet(o,c-&gt;argv[i],c-&gt;argv[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送设置ok给client</span></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改数据库的键则发送信号，发送&quot;hset&quot;事件通知，更新脏键</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="4-3-HGET命令"><a href="#4-3-HGET命令" class="headerlink" title="4.3 HGET命令"></a>4.3 HGET命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HGET key field</span></span><br><span class="line"><span class="comment">// HGET命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hgetCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以读操作取出哈希对象，若失败，或取出的对象不是哈希类型的对象，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    addHashFieldToReply(c, o, c-&gt;argv[<span class="number">2</span>]);  <span class="comment">//发送相应的值给client</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-HDEL命令"><a href="#4-4-HDEL命令" class="headerlink" title="4.4 HDEL命令"></a>4.4 HDEL命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HDEL key field [field ...]</span></span><br><span class="line"><span class="comment">// HDEL命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hdelCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">int</span> j, deleted = <span class="number">0</span>, keyremoved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写操作取出哈希对象，若失败，或取出的对象不是哈希类型的对象，则发送0后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的字段field</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 从哈希对象中删除当前字段</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeDelete(o,c-&gt;argv[j])) &#123;</span><br><span class="line">            deleted++;  <span class="comment">//更新删除的个数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果哈希对象为空，则删除该对象</span></span><br><span class="line">            <span class="keyword">if</span> (hashTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">                dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">                keyremoved = <span class="number">1</span>; <span class="comment">//设置删除标志</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要删除了字段</span></span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        <span class="comment">// 发送信号表示键被改变</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送&quot;hdel&quot;事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">&quot;hdel&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果哈希对象被删除</span></span><br><span class="line">        <span class="keyword">if</span> (keyremoved)</span><br><span class="line">            <span class="comment">// 发送&quot;hdel&quot;事件通知</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],</span><br><span class="line">                                c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty += deleted;    <span class="comment">// 更新脏键</span></span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,deleted);    <span class="comment">//发送删除的个数给client</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>从字典对象中删除值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从一个哈希对象中删除field，成功返回1，没找到field返回0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashTypeDelete</span><span class="params">(robj *o, robj *field)</span> &#123;</span><br><span class="line">    <span class="type">int</span> deleted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从ziplist中删除</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl, *fptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到字符串类型的field</span></span><br><span class="line">        field = getDecodedObject(field);</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 遍历整个ziplist，得到头entry地址</span></span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找到对应field的entry</span></span><br><span class="line">            fptr = ziplistFind(fptr, field-&gt;ptr, sdslen(field-&gt;ptr), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 删除field和后一个对应value的entry</span></span><br><span class="line">                zl = ziplistDelete(zl,&amp;fptr);</span><br><span class="line">                zl = ziplistDelete(zl,&amp;fptr);</span><br><span class="line">                <span class="comment">// 更新哈希对象的值</span></span><br><span class="line">                o-&gt;ptr = zl;</span><br><span class="line">                deleted = <span class="number">1</span>;    <span class="comment">//设置删除成功标志</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        decrRefCount(field);    <span class="comment">//释放field空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字典中删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 删除成功，设置删除标志</span></span><br><span class="line">        <span class="keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == C_OK) &#123;</span><br><span class="line">            deleted = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Always check if the dictionary needs a resize after a delete. */</span></span><br><span class="line">            <span class="comment">// 删除成功，则按需收缩字典大小</span></span><br><span class="line">            <span class="keyword">if</span> (htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-HLEN命令"><a href="#4-5-HLEN命令" class="headerlink" title="4.5 HLEN命令"></a>4.5 HLEN命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HLEN key</span></span><br><span class="line"><span class="comment">// HLEN命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hlenCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写操作取出哈希对象，若失败，或取出的对象不是哈希类型的对象，则发送0后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送哈希对象的字段数给client</span></span><br><span class="line">    addReplyLongLong(c,hashTypeLength(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回哈希对象的键值对个数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回哈希对象中的键值对个数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">hashTypeLength</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length = ULONG_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回ziplist的entry节点个数的一半，则为一对field-value的个数</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        length = ziplistLen(o-&gt;ptr) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回字典的大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        length = dictSize((dict*)o-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-6-哈希迭代器"><a href="#4-6-哈希迭代器" class="headerlink" title="4.6 哈希迭代器"></a>4.6 哈希迭代器</h3><p>哈希类型也实现了自己的迭代器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 哈希类型迭代器所属的哈希对象</span></span><br><span class="line">    robj *subject;</span><br><span class="line">    <span class="comment">// 哈希对象的编码类型</span></span><br><span class="line">    <span class="type">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ziplist</span></span><br><span class="line">    <span class="comment">// 指向当前的key和value节点的地址，ziplist类型编码时使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *fptr, *vptr; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典</span></span><br><span class="line">    <span class="comment">// 迭代HT类型的哈希对象时的字典迭代器</span></span><br><span class="line">    dictIterator *di;</span><br><span class="line">    <span class="comment">// 指向当前的哈希表节点</span></span><br><span class="line">    dictEntry *de;</span><br><span class="line">&#125; hashTypeIterator;</span><br></pre></td></tr></table></figure>

<p><strong>初始化一个哈希对象的迭代器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个初始化的哈希类型的迭代器</span></span><br><span class="line">hashTypeIterator *<span class="title function_">hashTypeInitIterator</span><span class="params">(robj *subject)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配空间初始化成员</span></span><br><span class="line">    hashTypeIterator *hi = zmalloc(<span class="keyword">sizeof</span>(hashTypeIterator));</span><br><span class="line">    hi-&gt;subject = subject;</span><br><span class="line">    hi-&gt;encoding = subject-&gt;encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同的编码设置不同的成员</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        hi-&gt;fptr = <span class="literal">NULL</span>;</span><br><span class="line">        hi-&gt;vptr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 初始化一个字典迭代器返回给di成员</span></span><br><span class="line">        hi-&gt;di = dictGetIterator(subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁迭代器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放哈希类型迭代器空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hashTypeReleaseIterator</span><span class="params">(hashTypeIterator *hi)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是字典，则需要先释放字典迭代器的空间</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dictReleaseIterator(hi-&gt;di);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zfree(hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>迭代</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将哈希类型迭代器指向哈希对象中的下一个节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashTypeNext</span><span class="params">(hashTypeIterator *hi)</span> &#123;</span><br><span class="line">    <span class="comment">// 迭代ziplist</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 备份迭代器的成员信息</span></span><br><span class="line">        zl = hi-&gt;subject-&gt;ptr;</span><br><span class="line">        fptr = hi-&gt;fptr;</span><br><span class="line">        vptr = hi-&gt;vptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// field的指针为空，则指向第一个entry，只在第一次执行时，初始化指针</span></span><br><span class="line">        <span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Initialize cursor */</span></span><br><span class="line">            serverAssert(vptr == <span class="literal">NULL</span>);</span><br><span class="line">            fptr = ziplistIndex(zl, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Advance cursor */</span></span><br><span class="line">            <span class="comment">// 获取value节点的下一个entry地址，即为下一个field的地址</span></span><br><span class="line">            serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">            fptr = ziplistNext(zl, vptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代完毕或返回C_ERR</span></span><br><span class="line">        <span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">        <span class="comment">// 保存下一个value的地址</span></span><br><span class="line">        vptr = ziplistNext(zl, fptr);</span><br><span class="line">        serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* fptr, vptr now point to the first or next pair */</span></span><br><span class="line">        <span class="comment">// 更新迭代器的成员信息</span></span><br><span class="line">        hi-&gt;fptr = fptr;</span><br><span class="line">        hi-&gt;vptr = vptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是迭代字典</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 得到下一个字典节点的地址</span></span><br><span class="line">        <span class="keyword">if</span> ((hi-&gt;de = dictNext(hi-&gt;di)) == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-7-HSCAN命令"><a href="#4-7-HSCAN命令" class="headerlink" title="4.7 HSCAN命令"></a>4.7 HSCAN命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HSCAN key cursor [MATCH pattern] [COUNT count]</span></span><br><span class="line"><span class="comment">// HSCAN 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hscanCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cursor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取scan命令的游标cursor</span></span><br><span class="line">    <span class="keyword">if</span> (parseScanCursorOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;cursor) == C_ERR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 以写操作取出哈希对象，若失败，或取出的对象不是哈希类型的对象，则发送0后直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptyscan)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 调用底层实现</span></span><br><span class="line">    scanGenericCommand(c,o,cursor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 12.集合对象</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2012.%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="1-集合对象的结构"><a href="#1-集合对象的结构" class="headerlink" title="1. 集合对象的结构"></a>1. 集合对象的结构</h2><p>集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>. 下面分别展示了集合对象分别使用<code>intset</code>和<code>hashtable</code>编码的结构图：</p>
<p><img src="https://img-blog.csdnimg.cn/57ad39b5303a4a81bbef921b9ebfb487.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6e45ec210b324eac8262e0b2d9effebd.png" alt="在这里插入图片描述"></p>
<h2 id="2-集合对象编码"><a href="#2-集合对象编码" class="headerlink" title="2. 集合对象编码"></a>2. 集合对象编码</h2><h3 id="2-1-编码使用规则"><a href="#2-1-编码使用规则" class="headerlink" title="2.1 编码使用规则"></a>2.1 编码使用规则</h3><p>当集合对象可以同时满足以下两个条件时，对象使用<code>intset</code>编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值.</li>
<li>集合对象保存的元素数量不超过<code>512</code>个.</li>
</ul>
<p>不能满足这两个条件的集合对象需要使用<code>hashtable</code>编码.</p>
<h3 id="2-2-编码转换"><a href="#2-2-编码转换" class="headerlink" title="2.2 编码转换"></a>2.2 编码转换</h3><p>对于使用<code>intset</code>编码的集合对象来说，当使用<code>intset</code>编码所需的两个条件的任意一个不能被满足时，就会执行对象的编码转换操作，原本保存在整数集合中的所有元素都会被转移并保存到字典里面，并且对象的编码也会从<code>intset</code>变为<code>hashtable</code>.</p>
<h2 id="3-集合对象命令介绍"><a href="#3-集合对象命令介绍" class="headerlink" title="3. 集合对象命令介绍"></a>3. 集合对象命令介绍</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SADD key member1 [member2]</td>
<td>将一个或多个成员添加到集合</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取集合中的成员数</td>
</tr>
<tr>
<td>SDIFF key1 [key2]</td>
<td>减去多个集合</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 [key2]</td>
<td>减去多个集并将结果集存储在键中</td>
</tr>
<tr>
<td>SINTER key1 [key2]</td>
<td>相交多个集合</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 [key2]</td>
<td>交叉多个集合并将结果集存储在键中</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断确定给定值是否是集合的成员</td>
</tr>
<tr>
<td>SMOVE source destination member</td>
<td>将成员从一个集合移动到另一个集合</td>
</tr>
<tr>
<td>SPOP key</td>
<td>从集合中删除并返回随机成员</td>
</tr>
<tr>
<td>SRANDMEMBER key [count]</td>
<td>从集合中获取一个或多个随机成员</td>
</tr>
<tr>
<td>SREM key member1 [member2]</td>
<td>从集合中删除一个或多个成员</td>
</tr>
<tr>
<td>SUNION key1 [key2]</td>
<td>添加多个集合</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 [key2]</td>
<td>添加多个集并将结果集存储在键中</td>
</tr>
<tr>
<td>SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>递增地迭代集合中的元素</td>
</tr>
</tbody></table>
<h2 id="4-集合对象命令的实现"><a href="#4-集合对象命令的实现" class="headerlink" title="4. 集合对象命令的实现"></a>4. 集合对象命令的实现</h2><p>关于集合对象的源码在<code>server.h</code>头文件和<code>t_set.c</code>源文件中.</p>
<p>集合对象也实现了自己的迭代器，也是基于字典的迭代器封装的，和哈希对象的迭代器类似，这里不再展示.</p>
<p>集合对象可以进行<code>交</code>、<code>差</code>和<code>并</code>运算，源码中对应的宏如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SET_OP_UNION 0      <span class="comment">// 并集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_OP_DIFF 1       <span class="comment">// 差集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_OP_INTER 2      <span class="comment">// 交集</span></span></span><br></pre></td></tr></table></figure>

<p>下面展示一下这些命令的实现.</p>
<h3 id="4-1-交集命令实现"><a href="#4-1-交集命令实现" class="headerlink" title="4.1 交集命令实现"></a>4.1 交集命令实现</h3><p><strong>SINTER命令实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SINTER key [key ...]</span></span><br><span class="line"><span class="comment">// SINTER命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sinterCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SINTERSTORE命令实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SINTERSTORE destination key [key ...]</span></span><br><span class="line"><span class="comment">// 对n个集合做交集，并将结果存到destination集合中</span></span><br><span class="line"><span class="comment">// SINTERSTORE 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sinterstoreCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>底层实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SINTER key [key ...]</span></span><br><span class="line"><span class="comment">// SINTERSTORE destination key [key ...]</span></span><br><span class="line"><span class="comment">// SINTER、SINTERSTORE一类命令的底层实现</span></span><br><span class="line"><span class="comment">// setkeys：集合名称；setnum：集合个数；dstkey：将运算结果保存到dstkey中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sinterGenericCommand</span><span class="params">(client *c, robj **setkeys,</span></span><br><span class="line"><span class="params">                          <span class="type">unsigned</span> <span class="type">long</span> setnum, robj *dstkey)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配存储集合的数组</span></span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *eleobj, *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int64_t</span> intobj;</span><br><span class="line">    <span class="type">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> encoding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历集合数组</span></span><br><span class="line">    <span class="comment">// 将满足要求的集合都存到sets集合数组中（空的集合会被删除）</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果dstkey为空，则是SINTER命令，不为空则是SINTERSTORE命令</span></span><br><span class="line">        <span class="comment">// 如果是SINTER命令，则以读操作读取出集合对象，否则以写操作读取出集合对象</span></span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取的集合对象不存在，执行清理操作</span></span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            zfree(sets);    <span class="comment">//释放集合数组空间</span></span><br><span class="line">            <span class="comment">// 如果是SINTERSTORE命令</span></span><br><span class="line">            <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">                <span class="comment">// 从数据库中删除存储的目标集合对象dstkey</span></span><br><span class="line">                <span class="keyword">if</span> (dbDelete(c-&gt;db,dstkey)) &#123;</span><br><span class="line">                    <span class="comment">// 发送信号表示数据库键被修改，并更新脏键</span></span><br><span class="line">                    signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">                    server.dirty++;</span><br><span class="line">                &#125;</span><br><span class="line">                addReply(c,shared.czero);   <span class="comment">//发送0给client</span></span><br><span class="line">            <span class="comment">// 如果是SINTER命令，发送空回复</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReply(c,shared.emptymultibulk);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取集合对象成功，检查其数据类型</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将读取出的对象保存在集合数组中</span></span><br><span class="line">        sets[j] = setobj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从小到大排序集合数组中的集合大小，能够提高算法的性能</span></span><br><span class="line">    qsort(sets,setnum,<span class="keyword">sizeof</span>(robj*),qsortCompareSetsByCardinality);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先我们应该输出集合中元素的数量，但是现在不知道交集的大小</span></span><br><span class="line">    <span class="comment">// 因此创建一个空对象的链表，然后保存所有的回复</span></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">    	<span class="comment">// STINER命令创建一个链表</span></span><br><span class="line">        replylen = addDeferredMultiBulkLength(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// STINERSTORE命令创建要给整数集合对象</span></span><br><span class="line">        dstset = createIntsetObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代第一个也是集合元素数量最小的集合的每一个元素，将该集合中的所有元素和其他集合作比较</span></span><br><span class="line">    <span class="comment">// 如果至少有一个集合不包括该元素，则该元素不属于交集</span></span><br><span class="line">    si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 创建集合类型的迭代器并迭代器集合数组中的第一个集合的所有元素</span></span><br><span class="line">    <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;eleobj,&amp;intobj)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历其他集合</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过与第一个集合相等的集合，没有必要比较两个相同集合的元素，而且第一个集合作为结果的交集</span></span><br><span class="line">            <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 当前元素为INTSET类型</span></span><br><span class="line">            <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                <span class="comment">/* intset with intset is simple... and fast */</span></span><br><span class="line">                <span class="comment">// 如果在当前intset集合中没有找到该元素则直接跳过当前元素，操作下一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,intobj))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* in order to compare an integer with an object we</span></span><br><span class="line"><span class="comment">                 * have to use the generic function, creating an object</span></span><br><span class="line"><span class="comment">                 * for this */</span></span><br><span class="line">                <span class="comment">// 在字典中查找</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sets[j]-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                    <span class="comment">// 创建字符串对象</span></span><br><span class="line">                    eleobj = createStringObjectFromLongLong(intobj);</span><br><span class="line">                    <span class="comment">// 如果当前元素不是当前集合中的元素，则释放字符串对象跳过for循环体，操作下一个元素</span></span><br><span class="line">                    <span class="keyword">if</span> (!setTypeIsMember(sets[j],eleobj)) &#123;</span><br><span class="line">                        decrRefCount(eleobj);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    decrRefCount(eleobj);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 当前元素为HT字典类型</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                <span class="comment">/* Optimization... if the source object is integer</span></span><br><span class="line"><span class="comment">                 * encoded AND the target set is an intset, we can get</span></span><br><span class="line"><span class="comment">                 * a much faster path. */</span></span><br><span class="line">                <span class="comment">// 当前元素的编码是int类型且当前集合为整数集合，如果该集合不包含该元素，则跳过循环</span></span><br><span class="line">                <span class="keyword">if</span> (eleobj-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</span><br><span class="line">                    sets[j]-&gt;encoding == OBJ_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,(<span class="type">long</span>)eleobj-&gt;ptr))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* else... object to object check is easy as we use the</span></span><br><span class="line"><span class="comment">                 * type agnostic API here. */</span></span><br><span class="line">                <span class="comment">// 其他类型，在当前集合中查找该元素是否存在</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!setTypeIsMember(sets[j],eleobj)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only take action when all sets contain the member */</span></span><br><span class="line">        <span class="comment">// 执行到这里，该元素为结果集合中的元素</span></span><br><span class="line">        <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">            <span class="comment">// 如果是SINTER命令，回复集合</span></span><br><span class="line">            <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_HT)</span><br><span class="line">                    addReplyBulk(c,eleobj);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    addReplyBulkLongLong(c,intobj);</span><br><span class="line">                cardinality++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是SINTERSTORE命令，先将结果添加到集合中，因为还要store到数据库中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                    eleobj = createStringObjectFromLongLong(intobj);</span><br><span class="line">                    setTypeAdd(dstset,eleobj);</span><br><span class="line">                    decrRefCount(eleobj);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setTypeAdd(dstset,eleobj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setTypeReleaseIterator(si); <span class="comment">//释放迭代器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// SINTERSTORE命令，要将结果的集合添加到数据库中</span></span><br><span class="line">    <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">        <span class="comment">/* Store the resulting set into the target, if the intersection</span></span><br><span class="line"><span class="comment">         * is not an empty set. */</span></span><br><span class="line">        <span class="comment">// 如果之前存在该集合则先删除</span></span><br><span class="line">        <span class="type">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="comment">// 结果集大小非空，则将其添加到数据库中</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            <span class="comment">// 回复结果集的大小</span></span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            <span class="comment">// 发送&quot;sinterstore&quot;事件通知</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,<span class="string">&quot;sinterstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 结果集为空，释放空间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            <span class="comment">// 发送0给client</span></span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="comment">// 发送&quot;del&quot;事件通知</span></span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键被修改，发送信号。更新脏键</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SINTER命令，回复结果集合给client</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setDeferredMultiBulkLength(c,replylen,cardinality);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);    <span class="comment">//释放集合数组空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-2-并集和差集命令实现"><a href="#4-2-并集和差集命令实现" class="headerlink" title="4.2 并集和差集命令实现"></a>4.2 并集和差集命令实现</h3><p><strong>SUNION命令实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SUNION key [key ...]</span></span><br><span class="line"><span class="comment">// SUNION命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sunionCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_UNION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SUNIONSTORE命令实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SUNIONSTORE destination key [key ...]</span></span><br><span class="line"><span class="comment">// SUNIONSTORE命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sunionstoreCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_UNION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SDIFF命令实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDIFF key [key ...]</span></span><br><span class="line"><span class="comment">// SDIFF命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdiffCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,SET_OP_DIFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>SDIFFSTORE命令实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SDIFFSTORE destination key [key ...]</span></span><br><span class="line"><span class="comment">// SDIFFSTORE命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sdiffstoreCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],SET_OP_DIFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>底层实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SUNION key [key ...]</span></span><br><span class="line"><span class="comment">// SUNIONSTORE destination key [key ...]</span></span><br><span class="line"><span class="comment">// SDIFF key [key ...]</span></span><br><span class="line"><span class="comment">// SDIFFSTORE destination key [key ...]</span></span><br><span class="line"><span class="comment">// 并集、差集命令的底层实现</span></span><br><span class="line"><span class="comment">// setkeys：集合名称；setnum：集合个数；dstkey：将运算结果保存到dstkey中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sunionDiffGenericCommand</span><span class="params">(client *c, robj **setkeys, <span class="type">int</span> setnum,</span></span><br><span class="line"><span class="params">                              robj *dstkey, <span class="type">int</span> op)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配集合数组的空间</span></span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *ele, *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> diff_algo = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组中集合键对象</span></span><br><span class="line">    <span class="comment">// 将满足要求的集合都存到sets集合数组中（空的集合会被删除）</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        <span class="comment">// 如果dstkey为空，则是SUNION或SDIFF命令，不为空则是SUNIONSTORE或SDIFFSTORE命令</span></span><br><span class="line">        <span class="comment">// 如果是SUNION或SDIFF命令，则以读操作读取出集合对象，否则以写操作读取出集合对象</span></span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="comment">// 不存在的集合键设置为空</span></span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            sets[j] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查存在的集合键是否是集合对象，不是则释放空间</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,OBJ_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sets[j] = setobj;   <span class="comment">//保存到集合数组中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算差集共有两种算法</span></span><br><span class="line">    <span class="comment">// 1.时间复杂度O(N*M)，N是第一个集合中元素的总个数，M是集合的总个数</span></span><br><span class="line">    <span class="comment">// 2.时间复杂度O(N)，N是所有集合中元素的总个数</span></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> algo_one_work = <span class="number">0</span>, algo_two_work = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历集合数组</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sets[j] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算sets[0] × setnum的值</span></span><br><span class="line">            algo_one_work += setTypeSize(sets[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 计算所有集合的元素总个数</span></span><br><span class="line">            algo_two_work += setTypeSize(sets[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Algorithm 1 has better constant times and performs less operations</span></span><br><span class="line"><span class="comment">         * if there are elements in common. Give it some advantage. */</span></span><br><span class="line">        algo_one_work /= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//根据algo_one_work和algo_two_work选择不同算法</span></span><br><span class="line">        diff_algo = (algo_one_work &lt;= algo_two_work) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是算法1，M较小，执行操作少</span></span><br><span class="line">        <span class="keyword">if</span> (diff_algo == <span class="number">1</span> &amp;&amp; setnum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* With algorithm 1 it is better to order the sets to subtract</span></span><br><span class="line"><span class="comment">             * by decreasing size, so that we are more likely to find</span></span><br><span class="line"><span class="comment">             * duplicated elements ASAP. */</span></span><br><span class="line">            <span class="comment">// 将集合数组除第一个集合以外的所有集合，按照集合的元素排序</span></span><br><span class="line">            qsort(sets+<span class="number">1</span>,setnum<span class="number">-1</span>,<span class="keyword">sizeof</span>(robj*),</span><br><span class="line">                qsortCompareSetsByRevCardinality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a temp set object to store our union. If the dstkey</span></span><br><span class="line"><span class="comment">     * is not NULL (that is, we are inside an SUNIONSTORE operation) then</span></span><br><span class="line"><span class="comment">     * this set object will be the resulting object to set into the target key*/</span></span><br><span class="line">    <span class="comment">// 创建一个临时集合对象作为结果集</span></span><br><span class="line">    dstset = createIntsetObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行并集操作</span></span><br><span class="line">    <span class="keyword">if</span> (op == SET_OP_UNION) &#123;</span><br><span class="line">        <span class="comment">/* Union is trivial, just add every element of every set to the</span></span><br><span class="line"><span class="comment">         * temporary set. */</span></span><br><span class="line">        <span class="comment">// 仅仅讲每一个集合中的每一个元素加入到结果集中</span></span><br><span class="line">        <span class="comment">// 遍历每一个集合</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个集合类型的迭代器</span></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="comment">// 遍历当前集合中的所有元素</span></span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 讲迭代器指向的当前元素对象加入到结果集中</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;  <span class="comment">//如果结果集中不存在新加入的元素，则更新结果集的元素个数计数器</span></span><br><span class="line">                decrRefCount(ele);  <span class="comment">//否则直接释放元素对象空间</span></span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);     <span class="comment">//释放迭代器空间</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 执行差集操作并且使用算法1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* DIFF Algorithm 1:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * We perform the diff by iterating all the elements of the first set,</span></span><br><span class="line"><span class="comment">         * and only adding it to the target set if the element does not exist</span></span><br><span class="line"><span class="comment">         * into all the other sets.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This way we perform at max N*M operations, where N is the size of</span></span><br><span class="line"><span class="comment">         * the first set, and M the number of sets. */</span></span><br><span class="line">        <span class="comment">// 我们执行差集操作通过遍历第一个集合中的所有元素，并且将其他集合中不存在元素加入到结果集中</span></span><br><span class="line">        <span class="comment">// 时间复杂度O(N*M)，N是第一个集合中元素的总个数，M是集合的总个数</span></span><br><span class="line">        si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 创建集合类型迭代器遍历第一个集合中的所有元素</span></span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 遍历集合数组中的除了第一个的所有集合，检查元素是否存在在每一个集合</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* no key is an empty set. */</span>   <span class="comment">//集合键不存在跳过本次循环</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">break</span>; <span class="comment">/* same set! */</span>          <span class="comment">//相同的集合没必要比较</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeIsMember(sets[j],ele)) <span class="keyword">break</span>;                <span class="comment">//如果元素存在后面的集合中，遍历下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里，说明当前元素不存在于 除了第一个的所有集合</span></span><br><span class="line">            <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">                <span class="comment">/* There is no other set with this element. Add it. */</span></span><br><span class="line">                <span class="comment">// 因此将当前元素添加到结果集合中，更新计数器</span></span><br><span class="line">                setTypeAdd(dstset,ele);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125;</span><br><span class="line">            decrRefCount(ele);  <span class="comment">//释放元素对象空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si); <span class="comment">//释放迭代器空间</span></span><br><span class="line">    <span class="comment">// 执行差集操作并且使用算法2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == SET_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* DIFF Algorithm 2:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Add all the elements of the first set to the auxiliary set.</span></span><br><span class="line"><span class="comment">         * Then remove all the elements of all the next sets from it.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is O(N) where N is the sum of all the elements in every</span></span><br><span class="line"><span class="comment">         * set. */</span></span><br><span class="line">        <span class="comment">// 将第一个集合的所有元素加入到结果集中，然后遍历其后的所有集合，将有交集的元素从结果集中删除</span></span><br><span class="line">        <span class="comment">// 2.时间复杂度O(N)，N是所有集合中元素的总个数</span></span><br><span class="line">        <span class="comment">// 遍历所有的集合</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line"></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="comment">// 创建集合类型迭代器遍历每一个集合中的所有元素</span></span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果是第一个集合，将每一个元素加入到结果集中</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                <span class="comment">// 如果是其后的集合，将当前元素从结果集中删除，如结果集中有的话</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (setTypeRemove(dstset,ele)) cardinality--;</span><br><span class="line">                &#125;</span><br><span class="line">                decrRefCount(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);<span class="comment">//释放迭代器空间</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Exit if result set is empty as any additional removal</span></span><br><span class="line"><span class="comment">             * of elements will have no effect. */</span></span><br><span class="line">            <span class="comment">// 只要结果集为空，那么差集结果就为空，不用比较后续的集合</span></span><br><span class="line">            <span class="keyword">if</span> (cardinality == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output the content of the resulting set, if not in STORE mode */</span></span><br><span class="line">    <span class="comment">// 如果不是STORE一类的命令，输出所有的结果</span></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        <span class="comment">// 发送结果集的元素个数给client</span></span><br><span class="line">        addReplyMultiBulkLen(c,cardinality);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历结果集中的每一个元素，并发送给client</span></span><br><span class="line">        si = setTypeInitIterator(dstset);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyBulk(c,ele);</span><br><span class="line">            decrRefCount(ele);  <span class="comment">//发送完要释放空间</span></span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si); <span class="comment">//释放迭代器</span></span><br><span class="line">        decrRefCount(dstset);       <span class="comment">//发送集合后要释放结果集的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// STORE一类的命令，输出所有的结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with the result set inside */</span></span><br><span class="line">        <span class="comment">// 先将目标集合从数据库中删除，如果存在的话</span></span><br><span class="line">        <span class="type">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="comment">// 如果结果集合非空</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset); <span class="comment">//将结果集加入到数据库中</span></span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));    <span class="comment">//发送结果集的元素个数给client</span></span><br><span class="line">            <span class="comment">// 发送对应的事件通知</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_SET,</span><br><span class="line">                op == SET_OP_UNION ? <span class="string">&quot;sunionstore&quot;</span> : <span class="string">&quot;sdiffstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结果集为空，则释放空间</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);   <span class="comment">//发送0给client</span></span><br><span class="line">            <span class="comment">// 发送&quot;del&quot;事件通知</span></span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键被修改，发送信号通知，更新脏键</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放集合数组空间</span></span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 14.数据库实现</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2014.%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="1-数据库命令"><a href="#1-数据库命令" class="headerlink" title="1. 数据库命令"></a>1. 数据库命令</h2><p>数据库有一些常用的管理命令.</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FLUSHDB</td>
<td>清空当前数据库的所有key</td>
</tr>
<tr>
<td>FLUSHALL</td>
<td>清空整个Redis服务器的所有key</td>
</tr>
<tr>
<td>DBSIZE</td>
<td>返回当前数据库的key的个数</td>
</tr>
<tr>
<td>DEL key [key …]</td>
<td>删除一个或多个键</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>检查给定key是否存在</td>
</tr>
<tr>
<td>SELECT id</td>
<td>切换到指定的数据库</td>
</tr>
<tr>
<td>RANDOMKEY</td>
<td>从当前数据库中随机返回(不删除)一个 key</td>
</tr>
<tr>
<td>KEYS pattern</td>
<td>查找所有符合给定模式pattern的key</td>
</tr>
<tr>
<td>SCAN cursor [MATCH pattern] [COUNT count]</td>
<td>增量式迭代当前数据库键</td>
</tr>
<tr>
<td>LASTSAVE</td>
<td>返回最近一次成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</td>
</tr>
<tr>
<td>TYPE key</td>
<td>返回指定键的对象类型</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>停止所有客户端，关闭 redis 服务器（server）</td>
</tr>
<tr>
<td>RENAME key newkey</td>
<td>重命名指定的key，newkey存在时覆盖</td>
</tr>
<tr>
<td>RENAMENX key newkey</td>
<td>重命名指定的key，当且仅当newkey不存在时操作</td>
</tr>
<tr>
<td>MOVE key db</td>
<td>移动key到指定数据库</td>
</tr>
<tr>
<td>EXPIREAT key timestamp</td>
<td>为 key 设置生存时间，EXPIREAT 命令接受的时间参数是 UNIX 时间戳</td>
</tr>
<tr>
<td>EXPIRE key seconds</td>
<td>以秒为单位设置 key 的生存时间</td>
</tr>
<tr>
<td>PEXPIRE key milliseconds</td>
<td>以毫秒为单位设置 key 的生存时间</td>
</tr>
<tr>
<td>PEXPIREAT key milliseconds-timestamp</td>
<td>以毫秒为单位设置 key 的过期 unix 时间戳</td>
</tr>
<tr>
<td>TTL key</td>
<td>以秒为单位返回 key 的剩余生存时间</td>
</tr>
<tr>
<td>PTTL key</td>
<td>以毫秒为单位返回 key 的剩余生存时间</td>
</tr>
</tbody></table>
<h2 id="2-数据库的实现"><a href="#2-数据库的实现" class="headerlink" title="2. 数据库的实现"></a>2. 数据库的实现</h2><p>Redis服务器将所有数据库都保存在服务器状态<code>redis.h/redisServer</code>结构的<code>db</code>数组中，<code>db</code>数组的每个项都是一个<code>server.h/ redisDb</code>结构，每个<code>redisDb</code>结构代表一个数据库.</p>
<p>在初始化服务器时，程序会根据服务器状态的<code>dbnum</code>属性来决定应该创建多少个数据库.</p>
<p><code>dbnum</code>属性的值由服务器配置的<code>database</code>选项决定，默认情况下，该选项的值为<code>16</code>，所以Redis服务器默认会创建16个数据库，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/e24e1bea114e48469cc133cb8b26c2a9.png" alt="在这里插入图片描述"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">	redisDb *db;</span><br><span class="line">	<span class="comment">// 创建的数据库数量</span></span><br><span class="line">	<span class="type">int</span> dbnum;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在服务器内部，客户端状态<code>client</code>结构的<code>db</code>属性记录了客户端当前的目标数据库，这个属性是一个指向<code>redisDb</code>结构的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 指向当前的数据库</span></span><br><span class="line">	redisDb *db;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client.db</code>指针指向<code>redisServer.db</code>数组的其中一个元素，而被指向的元素就是客户端的目标数据库. 比如某个客户端的目标数据库为1号数据库，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/d20ee57a6b784002b432ac02249755bf.png" alt="在这里插入图片描述"></p>
<h3 id="2-1-切换数据库"><a href="#2-1-切换数据库" class="headerlink" title="2.1 切换数据库"></a>2.1 切换数据库</h3><p>每个Redis客户端都有自己的目标数据库，默认情况下客户端的默认目标数据库为<code>0号</code>数据库，但是客户端可以执行<code>SELECT</code>命令来切换数据库.</p>
<p>该命令的实现过程很简单，只需要改变<code>client.db</code>指针向<code>redisServer.db</code>数组的元素即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切换数据库</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectDb</span><span class="params">(client *c, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">    <span class="comment">// id非法，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (id &lt; <span class="number">0</span> || id &gt;= server.dbnum)</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 设置当前client的数据库</span></span><br><span class="line">    c-&gt;db = &amp;server.db[id];</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数据库键空间"><a href="#2-2-数据库键空间" class="headerlink" title="2.2 数据库键空间"></a>2.2 数据库键空间</h3><p>Redis是一个键值对（key-value pair）数据库服务器，服务器中的每个数据库都由一个<code>server.h/redisDb</code>结构表示，其中，redisDb结构的<code>dict</code>字典保存了数据库中所有键值对，我们将这个字典称为<code>键空间（key space）</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">	dict *dict;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>键空间的键就是数据库的键，每个见都是一个<code>字符串对象</code>.<br>键空间的值就是数据库的值，每个值可以是<code>字符串对象</code>、<code>列表对象</code>、<code>哈希对象</code>、<code>集合对象</code>或者<code>有序集合对象</code>.</p>
<p>比如数据库中现在有列表键<code>alphabet</code>、哈希键<code>book</code>以及字符串键<code>message</code>，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/73acc559689942c39d7cbbbc9f0f3f2b.png" alt="在这里插入图片描述"><br>所以所有针对数据库的CRUD操作实际上都是在对键空间字典进行操作.</p>
<p>数据库每次根据键名找到值对象时，是分为以<code>读操作 lookupKeyRead()</code>或<code>写操作 lookupKeyWrite()</code>的方式取出的，两种函数有一定的区别.</p>
<p><strong>lookupKey()函数</strong></p>
<p><code>读操作 lookupKeyRead()</code>或<code>写操作 lookupKeyWrite()</code>都会调用这个底层的函数，这个函数非常简单，就是从键值对字典中先找到键名对应的键对象，然后取出值对象.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数被lookupKeyRead()和lookupKeyWrite()和lookupKeyReadWithFlags()调用</span></span><br><span class="line"><span class="comment">// 从数据库db中取出key的值对象，如果存在返回该对象，否则返回NULL</span></span><br><span class="line"><span class="comment">// 返回key对象的值对象</span></span><br><span class="line">robj *<span class="title function_">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    <span class="comment">// 在数据库中查找key对象，返回保存该key的节点地址</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">    	<span class="comment">// 如果找到</span></span><br><span class="line">    	<span class="comment">// 取出键对应的值对象</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新键的使用时间</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">            !(flags &amp; LOOKUP_NOTOUCH))</span><br><span class="line">        &#123;</span><br><span class="line">            val-&gt;lru = LRU_CLOCK();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回值对象</span></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lookupKeyRead()函数</strong></p>
<p><code>lookupKeyRead()</code>函数调用了<code>lookupKeyReadWithFlags()</code>函数，后者其实就判断了一下当前键是否过期，如果没有过期，更新<code>misses</code>和<code>hits</code>信息，然后就返回值对象.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以读操作取出key的值对象，会更新是否命中的信息</span></span><br><span class="line">robj *<span class="title function_">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyReadWithFlags(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以读操作取出key的值对象，没找到返回NULL</span></span><br><span class="line"><span class="comment">// 调用该函数的副作用如下：</span></span><br><span class="line"><span class="comment">// 1.如果一个键的到达过期时间TTL，该键被设置为过期的</span></span><br><span class="line"><span class="comment">// 2.键的使用时间信息被更新</span></span><br><span class="line"><span class="comment">// 3.全局键 hits/misses 状态被更新</span></span><br><span class="line"><span class="comment">// 注意：如果键在逻辑上已经过期但是仍然存在，函数返回NULL</span></span><br><span class="line">robj *<span class="title function_">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    robj *val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果键已经过期且被删除</span></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 键已过期，如果是主节点环境，表示key已经绝对被删除，如果是从节点，</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们在从节点环境， expireIfNeeded()函数不会删除过期的键，它返回的仅仅是键是否被删除的逻辑值</span></span><br><span class="line">        <span class="comment">// 过期的键由主节点负责，为了保证主从节点数据的一致</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp;</span><br><span class="line">            server.current_client != server.master &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;flags &amp; CMD_READONLY)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 键没有过期，则返回键的值对象</span></span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="comment">// 更新 是否命中 的信息</span></span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>)</span><br><span class="line">        server.stat_keyspace_misses++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lookupKeyWrite()函数</strong></p>
<p><code>lookupKeyWrite()</code>函数则先判断键是否过期，然后直接调用最底层的 <code>lookupKey()</code>函数，和<code>lookupKeyRead()</code>函数 相比，少了一步更新<code>misses</code>和<code>hits</code>信息的过程. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以写操作取出key的值对象，不更新是否命中的信息</span></span><br><span class="line">robj *<span class="title function_">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-3-键的过期时间"><a href="#2-3-键的过期时间" class="headerlink" title="2.3 键的过期时间"></a>2.3 键的过期时间</h3><h4 id="2-3-1-保存过期时间"><a href="#2-3-1-保存过期时间" class="headerlink" title="2.3.1 保存过期时间"></a>2.3.1 保存过期时间</h4><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>EXPIREAT key timestamp</td>
<td>为 key 设置生存时间，EXPIREAT 命令接受的时间参数是 UNIX 时间戳</td>
</tr>
<tr>
<td>EXPIRE key seconds</td>
<td>以秒为单位设置 key 的生存时间</td>
</tr>
<tr>
<td>PEXPIRE key milliseconds</td>
<td>以毫秒为单位设置 key 的生存时间</td>
</tr>
<tr>
<td>PEXPIREAT key milliseconds-timestamp</td>
<td>以毫秒为单位设置 key 的过期 unix 时间戳</td>
</tr>
</tbody></table>
<p>以上四个命令都是用来设置键的过期时间的，但在执行时，其它三个命令都会转化成<code>PEXPIREAT</code>命令来执行.</p>
<p><img src="https://img-blog.csdnimg.cn/6862853353dc49ef9a86066ac447da47.png" alt="在这里插入图片描述"></p>
<p><code>redisDb</code>结构中的<code>expires</code>字典保存这设置了过期时间的键和过期的时间，我们称这个字典为过期字典.</p>
<ul>
<li>过期字典的键是一个指针，这个指针指向键空间中的某个键对象（也即是某个数据库键）.</li>
<li>过期字典的值是一个<code>long long</code>类型的整数，这个整数保存了键所指向的数据库键的过期时间，一个毫秒精度的<code>UNIX</code>时间戳.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">	dict *dict;</span><br><span class="line">	<span class="comment">// 过期字典，保存着设置过期的键和键的过期时间</span></span><br><span class="line">    dict *expires;  </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>如下图所示，是一个带有过期字典的数据库例子：</p>
<p><img src="https://img-blog.csdnimg.cn/55e98e116a6a4e64a8b60698b6b2e918.png" alt="在这里插入图片描述"><br>注意在实际中，键空间的键和过期字典的键都指向同一个键对象（只是增加引用计数），所以不会出现任何重复对象，也不会浪费任何空间.</p>
<h4 id="2-3-2-过期键的删除策略"><a href="#2-3-2-过期键的删除策略" class="headerlink" title="2.3.2 过期键的删除策略"></a>2.3.2 过期键的删除策略</h4><p>Redis采用的过期键删除策略是<code>惰性删除</code>和<code>定期删除</code>.</p>
<ul>
<li>惰性删除：当客户度读出带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除并返回空.</li>
<li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键. 至于要删除多少过期键，以及要检查多少个数据库，则由算法决定.</li>
</ul>
<p><strong>惰性删除</strong></p>
<p>惰性删除由<code>expireIfNeeded()</code>函数实现，所有读写数据库的Redis命令在执行前都会调用，删除过期键.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查键是否过期，如果过期，从数据库中删除</span></span><br><span class="line"><span class="comment">// 返回0表示没有过期或没有过期时间，返回1 表示键被删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> &#123;</span><br><span class="line">    <span class="comment">//得到过期时间，单位毫秒</span></span><br><span class="line">    <span class="type">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="type">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有过期时间，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器正在载入，那么不进行过期检查</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个Unix时间，单位毫秒</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务器正在进行主从节点的复制，从节点的过期键应该被主节点发送同步删除的操作 删除，而自己不主动删除</span></span><br><span class="line">    <span class="comment">// 从节点只返回正确的逻辑信息，0表示key仍然没有过期，1表示key过期。</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当键还没有过期时，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键已经过期，删除键</span></span><br><span class="line">    <span class="comment">// 过期键的数量加1</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 将过期键key传播给AOF文件和从节点</span></span><br><span class="line">    propagateExpire(db,key);</span><br><span class="line">    <span class="comment">// 发送&quot;expired&quot;事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">&quot;expired&quot;</span>,key,db-&gt;id);</span><br><span class="line">    <span class="comment">// 从数据库中删除key</span></span><br><span class="line">    <span class="keyword">return</span> dbDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定期删除</strong></p>
<p>过期键的定期删除策略由<code>server.c/activeExpireCycle</code>函数实现，每当Redis的服务器周期性操作<code>server.c/serverCron</code>函数执行时，<code>activeExpireCycle</code>函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的<code>expires</code>字典中随机检查一部分键的过期时间，并删除其中的过期键.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 过期键周期性删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">activeExpireCycle</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    <span class="comment">// 函数的全局状态为了每次调用都持续增加</span></span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> current_db = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最近一个快速模式执行的时间</span></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> last_fast_cycle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 每次测试16个数据库</span></span><br><span class="line">    <span class="type">int</span> dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start = ustime(), timelimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速模式</span></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="comment">// 如果上一个周期没有激活时间限制，不要开始快速循环。不要在与快速循环总持续时间本身相同的时间段内重复快速循环</span></span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 快速模式相隔的时间太短</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通常情况我们每次迭代测试16个数据库，有两个例外：</span></span><br><span class="line">    <span class="comment">//      1. 数据库数量小于16个</span></span><br><span class="line">    <span class="comment">//      2. 如果上一次触发了时间限制，那么这次会扫描所有的数据库，避免过期键占用空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新测试的数据库数量</span></span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 计算时间限制25ms</span></span><br><span class="line">    timelimit = <span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快速模式，更新时间限制</span></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        <span class="comment">// 1000微秒=1ms</span></span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">        <span class="type">int</span> expired;</span><br><span class="line">        <span class="comment">// 循环数据库指针</span></span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前数据库标记加1，下次进入循环直接从当前数据库开始处理</span></span><br><span class="line">        current_db++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Continue to expire if at the end of the cycle more than 25%</span></span><br><span class="line"><span class="comment">         * of the keys were expired. */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> num, slots;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> now, ttl_sum;</span><br><span class="line">            <span class="type">int</span> ttl_samples;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 数据库过期字典的键数量为0，跳过这个数据库</span></span><br><span class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取数据库过期字典的槽位数量</span></span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            <span class="comment">// 当期时间</span></span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过期键的占比小于1%，直接跳出循环，等待resize</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            expired = <span class="number">0</span>;        <span class="comment">// 已删除的过期键数量</span></span><br><span class="line">            ttl_sum = <span class="number">0</span>;        <span class="comment">// 键的总生存时间</span></span><br><span class="line">            ttl_samples = <span class="number">0</span>;    <span class="comment">// 没过期键的数量</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次最多处理20个</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历过期字典</span></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 随机取出一个带过期时间的键</span></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 计算生存时间</span></span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="comment">// 如果键过期，则删除，更新计数器</span></span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                <span class="comment">// 键没过期</span></span><br><span class="line">                <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 累计键的总生存时间</span></span><br><span class="line">                    ttl_sum += ttl;</span><br><span class="line">                    <span class="comment">// 更新没过期键个数</span></span><br><span class="line">                    ttl_samples++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新数据库的平均生存时间的状态</span></span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置平均过期时间</span></span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                <span class="comment">// 这一次的占2%的比重，之前的占98%比重</span></span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 迭代次数</span></span><br><span class="line">            iteration++;</span><br><span class="line">            <span class="comment">// 遍历一轮16次，执行一次</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                <span class="comment">// 计算这一轮执行的时间</span></span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> elapsed = ustime()-start;</span><br><span class="line">                <span class="comment">// 将&quot;expire-cycle&quot;和执行时间加入到延迟诊断字典中</span></span><br><span class="line">                latencyAddSampleIfNeeded(<span class="string">&quot;expire-cycle&quot;</span>,elapsed/<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 如果超过时间限制，那么设置超过退出的标志</span></span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) timelimit_exit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 超时则退出</span></span><br><span class="line">            <span class="keyword">if</span> (timelimit_exit) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果过期删除的键超过25%，那么继续遍历，直到timelimit到达才会退出</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP / <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-数据库相关命令的底层实现"><a href="#3-数据库相关命令的底层实现" class="headerlink" title="3. 数据库相关命令的底层实现"></a>3. 数据库相关命令的底层实现</h2><h3 id="3-1-键空间命令"><a href="#3-1-键空间命令" class="headerlink" title="3.1 键空间命令"></a>3.1 键空间命令</h3><p><strong>RENAME</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RENAME key newkey</span></span><br><span class="line"><span class="comment">// RENAMENX key newkey</span></span><br><span class="line"><span class="comment">// RENAME、RENAMENX命令底层实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">renameGenericCommand</span><span class="params">(client *c, <span class="type">int</span> nx)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> expire;</span><br><span class="line">    <span class="type">int</span> samekey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key和newkey相同的话，设置samekey标志</span></span><br><span class="line">    <span class="keyword">if</span> (sdscmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,c-&gt;argv[<span class="number">2</span>]-&gt;ptr) == <span class="number">0</span>) samekey = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写操作读取key的值对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nokeyerr)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key和newkey相同，nx为1发送0，否则为ok</span></span><br><span class="line">    <span class="keyword">if</span> (samekey) &#123;</span><br><span class="line">        addReply(c,nx ? shared.czero : shared.ok);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加值对象的引用计数，保护起来，用于关联newkey，以防删除了key顺带将值对象也删除</span></span><br><span class="line">    incrRefCount(o);</span><br><span class="line">    <span class="comment">// 备份key的过期时间，将来作为newkey的过期时间</span></span><br><span class="line">    expire = getExpire(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 判断newkey的值对象是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">2</span>]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置nx标志，则不符合已存在的条件，发送0</span></span><br><span class="line">        <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将旧的newkey对象删除</span></span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将newkey和key的值对象关联</span></span><br><span class="line">    dbAdd(c-&gt;db,c-&gt;argv[<span class="number">2</span>],o);</span><br><span class="line">    <span class="comment">// 如果newkey设置过过期时间，则为newkey设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire != <span class="number">-1</span>) setExpire(c-&gt;db,c-&gt;argv[<span class="number">2</span>],expire);</span><br><span class="line">    <span class="comment">// 删除key</span></span><br><span class="line">    dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送这两个键被修改的信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 发送不同命令的事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;rename_from&quot;</span>,</span><br><span class="line">        c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;rename_to&quot;</span>,</span><br><span class="line">        c-&gt;argv[<span class="number">2</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 更新脏键</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,nx ? shared.cone : shared.ok);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RENAME key newkey</span></span><br><span class="line"><span class="comment">// RENAME 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">renameCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    renameGenericCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RENAMENX key newkey</span></span><br><span class="line"><span class="comment">// RENAMENX 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">renamenxCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    renameGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>MOVE</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中</span></span><br><span class="line"><span class="comment">// MOVE 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">moveCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    redisDb *src, *dst;</span><br><span class="line">    <span class="type">int</span> srcid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> dbid, expire;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器处于集群模式，不支持多数据库</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;MOVE is not allowed in cluster mode&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得源数据库和源数据库的id</span></span><br><span class="line">    src = c-&gt;db;</span><br><span class="line">    srcid = c-&gt;db-&gt;id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将参数db的值保存到dbid，并且切换到该数据库中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObject(c-&gt;argv[<span class="number">2</span>],&amp;dbid) == C_ERR ||</span><br><span class="line">        dbid &lt; INT_MIN || dbid &gt; INT_MAX ||</span><br><span class="line">        selectDb(c,dbid) == C_ERR)</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c,shared.outofrangeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 目标数据库</span></span><br><span class="line">    dst = c-&gt;db;</span><br><span class="line">    <span class="comment">// 切换回源数据库</span></span><br><span class="line">    selectDb(c,srcid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前后切换的数据库相同，则返回有关错误</span></span><br><span class="line">    <span class="keyword">if</span> (src == dst) &#123;</span><br><span class="line">        addReply(c,shared.sameobjecterr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以写操作取出源数据库的对象</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (!o) &#123;</span><br><span class="line">    	<span class="comment">// 不存在发送0</span></span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 备份key的过期时间</span></span><br><span class="line">    expire = getExpire(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前key是否存在于目标数据库，存在直接返回，发送0</span></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(dst,c-&gt;argv[<span class="number">1</span>]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将key-value对象添加到目标数据库中</span></span><br><span class="line">    dbAdd(dst,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    <span class="comment">// 设置移动后key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire != <span class="number">-1</span>) setExpire(dst,c-&gt;argv[<span class="number">1</span>],expire);</span><br><span class="line">    incrRefCount(o);    <span class="comment">//增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从源数据库中将key和关联的值对象删除</span></span><br><span class="line">    dbDelete(src,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++; <span class="comment">//更新脏键</span></span><br><span class="line">    addReply(c,shared.cone);    <span class="comment">//回复1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-过期命令"><a href="#3-2-过期命令" class="headerlink" title="3.2 过期命令"></a>3.2 过期命令</h3><p><strong>EXPIRE、PEXPIRE、EXPIREAT和PEXPIREAT</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// EXPIRE key seconds</span></span><br><span class="line"><span class="comment">// EXPIREAT key timestamp</span></span><br><span class="line"><span class="comment">// PEXPIRE key milliseconds</span></span><br><span class="line"><span class="comment">// PEXPIREAT key milliseconds-timestamp</span></span><br><span class="line"><span class="comment">// EXPIRE, PEXPIRE, EXPIREAT,PEXPIREAT命令的底层实现</span></span><br><span class="line"><span class="comment">// basetime参数可能是绝对值，可能是相对值。执行AT命令时basetime为0，否则保存的是当前的绝对时间</span></span><br><span class="line"><span class="comment">// unit 是UNIT_SECONDS 或者 UNIT_MILLISECONDS，但是basetime总是以毫秒为单位的</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expireGenericCommand</span><span class="params">(client *c, <span class="type">long</span> <span class="type">long</span> basetime, <span class="type">int</span> unit)</span> &#123;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>], *param = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出时间参数保存到when中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, param, &amp;when, <span class="literal">NULL</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果过期时间是以秒为单位，则转换为毫秒值</span></span><br><span class="line">    <span class="keyword">if</span> (unit == UNIT_SECONDS) when *= <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// 绝对时间</span></span><br><span class="line">    when += basetime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断key是否在数据库中，不在返回0</span></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前正在载入AOF数据或者在从节点环境中，即使EXPIRE的TTL为负数，或者EXPIREAT的时间戳已经过期</span></span><br><span class="line">    <span class="comment">// 服务器都不会执行DEL命令，且将过期TTL设置为键的过期时间，等待主节点发来的DEL命令</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果when已经过时，服务器为主节点且没有载入AOF数据</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt;= mstime() &amp;&amp; !server.loading &amp;&amp; !server.masterhost) &#123;</span><br><span class="line">        robj *aux;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将key从数据库中删除</span></span><br><span class="line">        serverAssertWithInfo(c,key,dbDelete(c-&gt;db,key));</span><br><span class="line">        <span class="comment">// 更新脏键</span></span><br><span class="line">        server.dirty++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个&quot;DEL&quot;命令</span></span><br><span class="line">        aux = createStringObject(<span class="string">&quot;DEL&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        rewriteClientCommandVector(c,<span class="number">2</span>,aux,key);    <span class="comment">//修改客户端的参数列表为DEL命令</span></span><br><span class="line">        decrRefCount(aux);</span><br><span class="line">        <span class="comment">// 发送键被修改的信号</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        <span class="comment">// 发送&quot;del&quot;的事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        addReply(c, shared.cone);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前服务器是从节点，或者服务器正在载入AOF数据</span></span><br><span class="line">    <span class="comment">// 不管when有没有过时，都设置为过期时间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 设置过期时间</span></span><br><span class="line">        setExpire(c-&gt;db,key,when);</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">        <span class="comment">// 发送键被修改的信号</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        <span class="comment">// 发送&quot;expire&quot;的事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">&quot;expire&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 更新脏键</span></span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EXPIRE key seconds</span></span><br><span class="line"><span class="comment">// EXPIRE 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expireCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EXPIREAT key timestamp</span></span><br><span class="line"><span class="comment">// EXPIREAT 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">expireatCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    expireGenericCommand(c,<span class="number">0</span>,UNIT_SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PEXPIRE key milliseconds</span></span><br><span class="line"><span class="comment">// PEXPIRE 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pexpireCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    expireGenericCommand(c,mstime(),UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PEXPIREAT key milliseconds-timestamp</span></span><br><span class="line"><span class="comment">// PEXPIREAT 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pexpireatCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    expireGenericCommand(c,<span class="number">0</span>,UNIT_MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TTL、PTTL</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TTL key</span></span><br><span class="line"><span class="comment">// PTTL key</span></span><br><span class="line"><span class="comment">// TTL、PTTL命令底层实现，output_ms为1，返回毫秒，为0返回秒</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ttlGenericCommand</span><span class="params">(client *c, <span class="type">int</span> output_ms)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> expire, ttl = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断key是否存在于数据库，并且不修改键的使用时间</span></span><br><span class="line">    <span class="keyword">if</span> (lookupKeyReadWithFlags(c-&gt;db,c-&gt;argv[<span class="number">1</span>],LOOKUP_NOTOUCH) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReplyLongLong(c,<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key存在，则备份当前key的过期时间</span></span><br><span class="line">    expire = getExpire(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire != <span class="number">-1</span>) &#123;</span><br><span class="line">    	<span class="comment">// 计算生存时间</span></span><br><span class="line">        ttl = expire-mstime();</span><br><span class="line">        <span class="keyword">if</span> (ttl &lt; <span class="number">0</span>) ttl = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果键是永久的</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="number">-1</span>) &#123;</span><br><span class="line">    	<span class="comment">// 发送-1</span></span><br><span class="line">        addReplyLongLong(c,<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 发送生存时间</span></span><br><span class="line">        addReplyLongLong(c,output_ms ? ttl : ((ttl+<span class="number">500</span>)/<span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TTL key</span></span><br><span class="line"><span class="comment">// TTL 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ttlCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    ttlGenericCommand(c, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PTTL key</span></span><br><span class="line"><span class="comment">// PTTL 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pttlCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    ttlGenericCommand(c, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 13.有序集合对象</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2013.%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="1-有序集合对象的结构"><a href="#1-有序集合对象的结构" class="headerlink" title="1. 有序集合对象的结构"></a>1. 有序集合对象的结构</h2><p>有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code>.</p>
<p>当使用<code>ziplist</code>编码时，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，而第二个元素则保存元素的分值，压缩列表内的集合元素按分值从小到大进行排序. 分值小的元素靠近表头，分值大的元素靠近表尾. 如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/e5d31ef886af45c5b8a4598a5bfd7a87.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/6bb4cb17e1374d278e5a74c27cd24683.png" alt="在这里插入图片描述"></p>
<p>当使用<code>skiplist</code>编码时，有序集合对象的<code>ptr</code>指针会指向一个<code>zset</code>结构，该结构同时包含一个字典和一个跳跃表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有序集合类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/40b5b489cc0f427db094d20dd57e09c1.png" alt="在这里插入图片描述"></p>
<p>但为什么要使用两种数据结构，而不直接使用跳跃表或者字典任意一种呢？</p>
<p>当对有序集合对象要根据成员查找分值时，将使用字典来实现，时间复杂度为<code>O(1)</code>，而如果单单使用跳跃表的话，这一复杂度将会是<code>O(log(n))</code>.</p>
<p>而当有序集合对象要执行范围型操作时，比如<code>ZRANK</code>、<code>ZRANGE</code>等命令时，将使用跳跃表来实现，而如果单单使用字典来实现的话，每次都要将找出来的元素重新进行排序，完成排序的时间复杂度至少为<code>O(NlogN)</code>，以及额外的<code>O(N)</code>空间复杂度（保存排序结果）.</p>
<p>所以Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合. 但是这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的空间. </p>
<p>可以参考下面的结构图，为了方便展示，在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何空间.</p>
<p><img src="https://img-blog.csdnimg.cn/506845283caa46cf83427f3f32371411.png" alt="在这里插入图片描述"></p>
<h2 id="2-有序集合对象编码"><a href="#2-有序集合对象编码" class="headerlink" title="2. 有序集合对象编码"></a>2. 有序集合对象编码</h2><h3 id="2-1-编码使用规则"><a href="#2-1-编码使用规则" class="headerlink" title="2.1 编码使用规则"></a>2.1 编码使用规则</h3><p>当有序集合对象可以同时满足以下两个条件时，对象使用<code>ziplist</code>编码:</p>
<ul>
<li>有序集合保存的元素数量小于<code>128</code>个.</li>
<li>有序集合保存的所有元素成员的长度都小于64字节.</li>
</ul>
<p>不能满足以上两个条件的有序集合对象将使用<code>skiplist</code>编码.</p>
<h3 id="2-2-编码转换"><a href="#2-2-编码转换" class="headerlink" title="2.2 编码转换"></a>2.2 编码转换</h3><p>对于使用<code>ziplist</code>编码的有序集合对象来说，当使用<code>ziplist</code>编码所需的两个条件中的任意一个不能被满足时，就会执行对象的编码转换操作，原本保存在压缩列表里的所有集合元素都会被转移并保存到<code>zset</code>结构里面，对象的编码也会从<code>ziplist</code>变为<code>skiplist</code>.</p>
<h2 id="3-有序集合对象命令介绍"><a href="#3-有序集合对象命令介绍" class="headerlink" title="3. 有序集合对象命令介绍"></a>3. 有序集合对象命令介绍</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD key score1 member1 [score2 member2]</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>ZCARD key</td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td>ZCOUNT key min max</td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>ZINCRBY key increment member</td>
<td>有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td>ZLEXCOUNT key min max</td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>ZRANK key member</td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>ZREM key member [member …]</td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX key min max</td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK key start stop</td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE key min max</td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<h2 id="4-有序集合对象命令的实现"><a href="#4-有序集合对象命令的实现" class="headerlink" title="4. 有序集合对象命令的实现"></a>4. 有序集合对象命令的实现</h2><p>关于有序集合对象的源码在<code>server.h</code>头文件和<code>t_zset.c</code>源文件中.</p>
<h3 id="4-1-有序集合的范围限定方式"><a href="#4-1-有序集合的范围限定方式" class="headerlink" title="4.1 有序集合的范围限定方式"></a>4.1 有序集合的范围限定方式</h3><p>我们可以发现有序集合有三个主要的关于范围操作的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
</tbody></table>
<p>所以Redis有序集合有三种范围限定：</p>
<ul>
<li>根据字典区间</li>
<li>根据排位（索引）区间</li>
<li>根据分值区间</li>
</ul>
<p>以上三种主要依赖两种排序方式：</p>
<ul>
<li>分值序</li>
<li>字典序</li>
</ul>
<p>以上两种排序所表示的范围，依赖于两个结构，一个规定分值序的范围和边界，一个规定字典序的范围和边界：</p>
<p>以下结构体定义在<code>server.h</code>头文件中.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Struct to hold a inclusive/exclusive range spec by score comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="comment">// 最小值和最大值</span></span><br><span class="line">    <span class="type">double</span> min, max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minex表示最小值是否包含在这个范围，1表示不包含，0表示包含</span></span><br><span class="line">    <span class="comment">// 同理maxex表示最大值</span></span><br><span class="line">    <span class="type">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zrangespec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Struct to hold an inclusive/exclusive range spec by lexicographic comparison. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    robj *min, *max;  <span class="comment">/* May be set to shared.(minstring|maxstring) */</span><span class="comment">//最小值和最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// minex表示最小值是否包含在这个范围，1表示不包含，0表示包含</span></span><br><span class="line">    <span class="comment">// 同理maxex表示最大值</span></span><br><span class="line">    <span class="type">int</span> minex, maxex; <span class="comment">/* are min or max exclusive? */</span></span><br><span class="line">&#125; zlexrangespec;</span><br></pre></td></tr></table></figure>


<h3 id="4-2-有序集合的范围操作"><a href="#4-2-有序集合的范围操作" class="headerlink" title="4.2 有序集合的范围操作"></a>4.2 有序集合的范围操作</h3><h4 id="4-2-1-ZRANGE"><a href="#4-2-1-ZRANGE" class="headerlink" title="4.2.1 ZRANGE"></a>4.2.1 ZRANGE</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="comment">// ZRANGE命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zrangeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    zrangeGenericCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZREVRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="comment">// ZREVRANGE命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zrevrangeCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    zrangeGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>底层实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="comment">// ZREVRANGE key start stop [WITHSCORES]</span></span><br><span class="line"><span class="comment">// ZRANGE、ZREVRANGE命令底层实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zrangeGenericCommand</span><span class="params">(client *c, <span class="type">int</span> reverse)</span> &#123;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    <span class="type">int</span> withscores = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> start;</span><br><span class="line">    <span class="type">long</span> end;</span><br><span class="line">    <span class="type">int</span> llen;</span><br><span class="line">    <span class="type">int</span> rangelen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出起始位置start和结束位置end</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有WITHSCORES参数，设置标志</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">5</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">4</span>]-&gt;ptr,<span class="string">&quot;withscores&quot;</span>)) &#123;</span><br><span class="line">        withscores = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 参数太多发送语法错误信息</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以读操作取出key有序集合并检查集合的数据类型</span></span><br><span class="line">    <span class="keyword">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,zobj,OBJ_ZSET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanitize indexes. */</span></span><br><span class="line">    <span class="comment">// 获得有序集合的下标范围</span></span><br><span class="line">    llen = zsetLength(zobj);</span><br><span class="line">    <span class="comment">// 处理负数下标</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="comment">// 修剪调整下标</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptymultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;       <span class="comment">//范围长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply */</span></span><br><span class="line">    <span class="comment">// 发送回复的行数信息给client</span></span><br><span class="line">    addReplyMultiBulkLen(c, withscores ? (rangelen*<span class="number">2</span>) : rangelen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是ziplist</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据reverse决定遍历的头或尾元素节点地址eptr</span></span><br><span class="line">        <span class="keyword">if</span> (reverse)</span><br><span class="line">            eptr = ziplistIndex(zl,<span class="number">-2</span>-(<span class="number">2</span>*start));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            eptr = ziplistIndex(zl,<span class="number">2</span>*start);</span><br><span class="line"></span><br><span class="line">        serverAssertWithInfo(c,zobj,eptr != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 获得分值节点地址</span></span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出rangelen个元素</span></span><br><span class="line">        <span class="keyword">while</span> (rangelen--) &#123;</span><br><span class="line">            serverAssertWithInfo(c,zobj,eptr != <span class="literal">NULL</span> &amp;&amp; sptr != <span class="literal">NULL</span>);</span><br><span class="line">            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));   <span class="comment">//讲元素信息保存在参数中</span></span><br><span class="line">            <span class="comment">// 元素的类型不同，发送不同类型的回复信息</span></span><br><span class="line">            <span class="keyword">if</span> (vstr == <span class="literal">NULL</span>)</span><br><span class="line">                addReplyBulkLongLong(c,vlong);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class="line">            <span class="comment">// 设置了withscores，发送分值</span></span><br><span class="line">            <span class="keyword">if</span> (withscores)</span><br><span class="line">                addReplyDouble(c,zzlGetScore(sptr));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据reverse，指向下一个元素和分值的节点</span></span><br><span class="line">            <span class="keyword">if</span> (reverse)</span><br><span class="line">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是跳跃表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line">        zskiplistNode *ln;</span><br><span class="line">        robj *ele;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if starting point is trivial, before doing log(N) lookup. */</span></span><br><span class="line">        <span class="comment">// 根据reverse决定，遍历的头或尾元素节点地址</span></span><br><span class="line">        <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">            ln = zsl-&gt;tail;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span>)</span><br><span class="line">                ln = zslGetElementByRank(zsl,llen-start);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ln = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span>)</span><br><span class="line">                ln = zslGetElementByRank(zsl,start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出rangelen个元素</span></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            serverAssertWithInfo(c,zobj,ln != <span class="literal">NULL</span>);</span><br><span class="line">            ele = ln-&gt;obj;</span><br><span class="line">            addReplyBulk(c,ele);    <span class="comment">//发送元素</span></span><br><span class="line">            <span class="keyword">if</span> (withscores)</span><br><span class="line">                addReplyDouble(c,ln-&gt;score);    <span class="comment">//发送分值</span></span><br><span class="line">            <span class="comment">// 指向下一个节点</span></span><br><span class="line">            ln = reverse ? ln-&gt;backward : ln-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-ZRANGEBYSCORE"><a href="#4-2-2-ZRANGEBYSCORE" class="headerlink" title="4.2.2 ZRANGEBYSCORE"></a>4.2.2 ZRANGEBYSCORE</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="comment">// ZRANGEBYSCORE 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zrangebyscoreCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    genericZrangebyscoreCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="comment">// ZREVRANGEBYSCORE 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zrevrangebyscoreCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    genericZrangebyscoreCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>底层实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This command implements ZRANGEBYSCORE, ZREVRANGEBYSCORE. */</span></span><br><span class="line"><span class="comment">// ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="comment">// ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]</span></span><br><span class="line"><span class="comment">// ZRANGEBYSCORE ZREVRANGEBYSCORE命令的底层实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">genericZrangebyscoreCommand</span><span class="params">(client *c, <span class="type">int</span> reverse)</span> &#123;</span><br><span class="line">    zrangespec range;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    <span class="type">long</span> offset = <span class="number">0</span>, limit = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> withscores = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rangelen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> minidx, maxidx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the range arguments. */</span></span><br><span class="line">    <span class="comment">// 解析min和max范围的参数的下标</span></span><br><span class="line">    <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">        <span class="comment">/* Range is given as [max,min] */</span></span><br><span class="line">        maxidx = <span class="number">2</span>; minidx = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Range is given as [min,max] */</span></span><br><span class="line">        minidx = <span class="number">2</span>; maxidx = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析min和max范围参数，保存到zrangespec中，默认是包含[]临界值</span></span><br><span class="line">    <span class="keyword">if</span> (zslParseRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;min or max is not a float&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse optional extra arguments. Note that ZCOUNT will exactly have</span></span><br><span class="line"><span class="comment">     * 4 arguments, so we&#x27;ll never enter the following code path. */</span></span><br><span class="line">    <span class="comment">// 解析其他的参数</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> remaining = c-&gt;argc - <span class="number">4</span>;    <span class="comment">//其他参数个数</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (remaining) &#123;</span><br><span class="line">            <span class="comment">// 如果有WITHSCORES，设置标志</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &gt;= <span class="number">1</span> &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,<span class="string">&quot;withscores&quot;</span>)) &#123;</span><br><span class="line">                pos++; remaining--;</span><br><span class="line">                withscores = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果有LIMIT，取出offset和count值 保存在offset和limit中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining &gt;= <span class="number">3</span> &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,<span class="string">&quot;limit&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class="number">1</span>], &amp;offset, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">                    (getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class="number">2</span>], &amp;limit, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line">                pos += <span class="number">3</span>; remaining -= <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ok, lookup the key and get the range */</span></span><br><span class="line">    <span class="comment">// 以读操作取出有序集合对象</span></span><br><span class="line">    <span class="keyword">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,zobj,OBJ_ZSET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ziplist</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> vlong;</span><br><span class="line">        <span class="type">double</span> score;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If reversed, get the last node in range as starting point. */</span></span><br><span class="line">        <span class="comment">// 获得range范围内的起始元素节点地址</span></span><br><span class="line">        <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">            eptr = zzlLastInRange(zl,&amp;range);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            eptr = zzlFirstInRange(zl,&amp;range);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* No &quot;first&quot; element in the specified interval. */</span></span><br><span class="line">        <span class="comment">// 没有元素在range里，发送空回复</span></span><br><span class="line">        <span class="keyword">if</span> (eptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c, shared.emptymultibulk);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get score pointer for the first element. */</span></span><br><span class="line">        serverAssertWithInfo(c,zobj,eptr != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 分值节点地址</span></span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We don&#x27;t know in advance how many matching elements there are in the</span></span><br><span class="line"><span class="comment">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class="line"><span class="comment">         * length in the output buffer, and will &quot;fix&quot; it later */</span></span><br><span class="line">        <span class="comment">// 回复长度</span></span><br><span class="line">        replylen = addDeferredMultiBulkLength(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is an offset, just traverse the number of elements without</span></span><br><span class="line"><span class="comment">         * checking the score because that is done in the next loop. */</span></span><br><span class="line">        <span class="comment">// 跳过offset设定的长度</span></span><br><span class="line">        <span class="keyword">while</span> (eptr &amp;&amp; offset--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有符合范围的节点</span></span><br><span class="line">        <span class="keyword">while</span> (eptr &amp;&amp; limit--) &#123;</span><br><span class="line">            score = zzlGetScore(sptr);  <span class="comment">//获取分值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Abort when the node is no longer in range. */</span></span><br><span class="line">            <span class="comment">// 检查分值是否符合范围内的分值</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!zslValueGteMin(score,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!zslValueLteMax(score,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We know the element exists, so ziplistGet should always succeed */</span></span><br><span class="line">            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));   <span class="comment">//保存当前元素的值到参数中</span></span><br><span class="line"></span><br><span class="line">            rangelen++;</span><br><span class="line">            <span class="comment">// 不同元素类型，发送不同的类型的值给client</span></span><br><span class="line">            <span class="keyword">if</span> (vstr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                addReplyBulkLongLong(c,vlong);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (withscores) &#123;</span><br><span class="line">                addReplyDouble(c,score);    <span class="comment">//发送分值</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move to next node */</span></span><br><span class="line">            <span class="comment">// 指向下一个元素和分值节点</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 跳跃表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line">        zskiplistNode *ln;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If reversed, get the last node in range as starting point. */</span></span><br><span class="line">        <span class="comment">// 获得range范围内的起始节点地址</span></span><br><span class="line">        <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">            ln = zslLastInRange(zsl,&amp;range);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ln = zslFirstInRange(zsl,&amp;range);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* No &quot;first&quot; element in the specified interval. */</span></span><br><span class="line">        <span class="comment">// 没有元素存在在制定的范围内</span></span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c, shared.emptymultibulk);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We don&#x27;t know in advance how many matching elements there are in the</span></span><br><span class="line"><span class="comment">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class="line"><span class="comment">         * length in the output buffer, and will &quot;fix&quot; it later */</span></span><br><span class="line">        <span class="comment">// 回复长度</span></span><br><span class="line">        replylen = addDeferredMultiBulkLength(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is an offset, just traverse the number of elements without</span></span><br><span class="line"><span class="comment">         * checking the score because that is done in the next loop. */</span></span><br><span class="line">        <span class="comment">// 跳过offset个节点</span></span><br><span class="line">        <span class="keyword">while</span> (ln &amp;&amp; offset--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                ln = ln-&gt;backward;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ln = ln-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有符合范围的节点</span></span><br><span class="line">        <span class="keyword">while</span> (ln &amp;&amp; limit--) &#123;</span><br><span class="line">            <span class="comment">/* Abort when the node is no longer in range. */</span></span><br><span class="line">            <span class="comment">// 检查分值是否符合</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!zslValueGteMin(ln-&gt;score,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!zslValueLteMax(ln-&gt;score,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rangelen++;</span><br><span class="line">            addReplyBulk(c,ln-&gt;obj);    <span class="comment">//发送元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (withscores) &#123;</span><br><span class="line">                addReplyDouble(c,ln-&gt;score);    <span class="comment">//发送分值</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move to next node */</span></span><br><span class="line">            <span class="comment">// 指向下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                ln = ln-&gt;backward;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ln = ln-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (withscores) &#123;   <span class="comment">//更新回复长度</span></span><br><span class="line">        rangelen *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setDeferredMultiBulkLength(c, replylen, rangelen);  <span class="comment">//发送范围的长度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-ZRANGEBYLEX"><a href="#4-2-3-ZRANGEBYLEX" class="headerlink" title="4.2.3 ZRANGEBYLEX"></a>4.2.3 ZRANGEBYLEX</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZRANGEBYLEX key min max [LIMIT offset count]</span></span><br><span class="line"><span class="comment">// ZRANGEBYLEX 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zrangebylexCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    genericZrangebylexCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZREVRANGEBYLEX key min max [LIMIT offset count]</span></span><br><span class="line"><span class="comment">// ZREVRANGEBYLEX命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zrevrangebylexCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    genericZrangebylexCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>底层实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This command implements ZRANGEBYLEX, ZREVRANGEBYLEX. */</span></span><br><span class="line"><span class="comment">// ZRANGEBYLEX key min max [LIMIT offset count]</span></span><br><span class="line"><span class="comment">// ZRANGEBYLEX 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">genericZrangebylexCommand</span><span class="params">(client *c, <span class="type">int</span> reverse)</span> &#123;</span><br><span class="line">    zlexrangespec range;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    <span class="type">long</span> offset = <span class="number">0</span>, limit = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rangelen = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> minidx, maxidx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the range arguments. */</span></span><br><span class="line">    <span class="comment">// 解析min和max范围的参数的下标</span></span><br><span class="line">    <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">        <span class="comment">/* Range is given as [max,min] */</span></span><br><span class="line">        maxidx = <span class="number">2</span>; minidx = <span class="number">3</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Range is given as [min,max] */</span></span><br><span class="line">        minidx = <span class="number">2</span>; maxidx = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析min和max范围的参数，保存到range</span></span><br><span class="line">    <span class="keyword">if</span> (zslParseLexRange(c-&gt;argv[minidx],c-&gt;argv[maxidx],&amp;range) != C_OK) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;min or max not valid string range item&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse optional extra arguments. Note that ZCOUNT will exactly have</span></span><br><span class="line"><span class="comment">     * 4 arguments, so we&#x27;ll never enter the following code path. */</span></span><br><span class="line">    <span class="comment">// 解析其他参数</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">int</span> remaining = c-&gt;argc - <span class="number">4</span>;    <span class="comment">//其他参数的个数</span></span><br><span class="line">        <span class="type">int</span> pos = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (remaining) &#123;</span><br><span class="line">            <span class="comment">// 如果有LIMIT，取出offset和count保存在offset和limit</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &gt;= <span class="number">3</span> &amp;&amp; !strcasecmp(c-&gt;argv[pos]-&gt;ptr,<span class="string">&quot;limit&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class="number">1</span>], &amp;offset, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">                    (getLongFromObjectOrReply(c, c-&gt;argv[pos+<span class="number">2</span>], &amp;limit, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line">                pos += <span class="number">3</span>; remaining -= <span class="number">3</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zslFreeLexRange(&amp;range);</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ok, lookup the key and get the range */</span></span><br><span class="line">    <span class="comment">// 以读操作取出有序集合对象</span></span><br><span class="line">    <span class="keyword">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,zobj,OBJ_ZSET))</span><br><span class="line">    &#123;</span><br><span class="line">        zslFreeLexRange(&amp;range);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ziplist</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If reversed, get the last node in range as starting point. */</span></span><br><span class="line">        <span class="comment">// 获得range范围内的起始元素节点地址</span></span><br><span class="line">        <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">            eptr = zzlLastInLexRange(zl,&amp;range);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            eptr = zzlFirstInLexRange(zl,&amp;range);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* No &quot;first&quot; element in the specified interval. */</span></span><br><span class="line">        <span class="comment">// 没有元素在范围内</span></span><br><span class="line">        <span class="keyword">if</span> (eptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c, shared.emptymultibulk);</span><br><span class="line">            zslFreeLexRange(&amp;range);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get score pointer for the first element. */</span></span><br><span class="line">        serverAssertWithInfo(c,zobj,eptr != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 分数节点的地址</span></span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We don&#x27;t know in advance how many matching elements there are in the</span></span><br><span class="line"><span class="comment">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class="line"><span class="comment">         * length in the output buffer, and will &quot;fix&quot; it later */</span></span><br><span class="line">        <span class="comment">// 回复长度</span></span><br><span class="line">        replylen = addDeferredMultiBulkLength(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is an offset, just traverse the number of elements without</span></span><br><span class="line"><span class="comment">         * checking the score because that is done in the next loop. */</span></span><br><span class="line">        <span class="comment">// 跳过offset设定的长度</span></span><br><span class="line">        <span class="keyword">while</span> (eptr &amp;&amp; offset--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有符合范围的节点</span></span><br><span class="line">        <span class="keyword">while</span> (eptr &amp;&amp; limit--) &#123;</span><br><span class="line">            <span class="comment">/* Abort when the node is no longer in range. */</span></span><br><span class="line">            <span class="comment">// 检查分值是否符合范围内的分值</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!zzlLexValueGteMin(eptr,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!zzlLexValueLteMax(eptr,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We know the element exists, so ziplistGet should always</span></span><br><span class="line"><span class="comment">             * succeed. */</span></span><br><span class="line">            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));   <span class="comment">//保存当前元素的值到参数中</span></span><br><span class="line"></span><br><span class="line">            rangelen++;</span><br><span class="line">            <span class="comment">// 不同元素值类型，发送不同类型的值client</span></span><br><span class="line">            <span class="keyword">if</span> (vstr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                addReplyBulkLongLong(c,vlong);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move to next node */</span></span><br><span class="line">            <span class="comment">// 指向下一个元素和分值节点</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// skiplist</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line">        zskiplistNode *ln;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If reversed, get the last node in range as starting point. */</span></span><br><span class="line">        <span class="comment">// 获得range范围内的起始节点地址</span></span><br><span class="line">        <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">            ln = zslLastInLexRange(zsl,&amp;range);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ln = zslFirstInLexRange(zsl,&amp;range);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* No &quot;first&quot; element in the specified interval. */</span></span><br><span class="line">        <span class="comment">// 没有节点符合范围</span></span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c, shared.emptymultibulk);</span><br><span class="line">            zslFreeLexRange(&amp;range);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We don&#x27;t know in advance how many matching elements there are in the</span></span><br><span class="line"><span class="comment">         * list, so we push this object that will represent the multi-bulk</span></span><br><span class="line"><span class="comment">         * length in the output buffer, and will &quot;fix&quot; it later */</span></span><br><span class="line">        <span class="comment">// 回复长度</span></span><br><span class="line">        replylen = addDeferredMultiBulkLength(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is an offset, just traverse the number of elements without</span></span><br><span class="line"><span class="comment">         * checking the score because that is done in the next loop. */</span></span><br><span class="line">        <span class="comment">// 跳过offset个节点</span></span><br><span class="line">        <span class="keyword">while</span> (ln &amp;&amp; offset--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                ln = ln-&gt;backward;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ln = ln-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有符合范围的节点</span></span><br><span class="line">        <span class="keyword">while</span> (ln &amp;&amp; limit--) &#123;</span><br><span class="line">            <span class="comment">/* Abort when the node is no longer in range. */</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;  <span class="comment">//检查分值是否符合</span></span><br><span class="line">                <span class="keyword">if</span> (!zslLexValueGteMin(ln-&gt;obj,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!zslLexValueLteMax(ln-&gt;obj,&amp;range)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rangelen++;</span><br><span class="line">            addReplyBulk(c,ln-&gt;obj);    <span class="comment">//发送元素</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move to next node */</span></span><br><span class="line">            <span class="comment">// 指向下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">                ln = ln-&gt;backward;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ln = ln-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zslFreeLexRange(&amp;range);    <span class="comment">//释放字典序范围</span></span><br><span class="line">    setDeferredMultiBulkLength(c, replylen, rangelen);  <span class="comment">//发送回复长度值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 17.Redis事件处理</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2017.Redis%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="1-Redis事件介绍"><a href="#1-Redis事件介绍" class="headerlink" title="1. Redis事件介绍"></a>1. Redis事件介绍</h2><p>Redis服务器是一个<code>事件驱动程序</code>，所谓事件驱动就是输入一条命令并且按下回车，然后消息被组装成<code>Redis</code>协议的格式发送给<code>Redis</code>服务器，这个时候就会产生一个事件，<code>Redis</code>服务器会接收改命令，处理该命令和发送回复，而当我们没有与服务器进行交互时，服务器就会处于阻塞等待状态，它会让出CPU然后进入睡眠状态，当事件触发时，就会被操作系统唤醒.</p>
<p>而Redis服务器需要处理以下两类事件：</p>
<ul>
<li><code>文件事件</code>：Redis 服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象. 服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作.</li>
<li><code>时间事件</code>：Redis 服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象.</li>
</ul>
<h2 id="2-事件的抽象"><a href="#2-事件的抽象" class="headerlink" title="2. 事件的抽象"></a>2. 事件的抽象</h2><p>Redis把<code>文件事件</code>和<code>时间事件</code>分别抽象成一个数据结构来管理.</p>
<h3 id="2-1-文件事件结构"><a href="#2-1-文件事件结构" class="headerlink" title="2.1 文件事件结构"></a>2.1 文件事件结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">// 文件时间类型：AE_NONE，AE_READABLE，AE_WRITABLE</span></span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">    <span class="comment">// 可读处理函数</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line">    <span class="comment">// 可写处理函数</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line">    <span class="comment">// 客户端传入的数据</span></span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;  <span class="comment">//文件事件</span></span><br></pre></td></tr></table></figure>

<p>其中<code>rfileProc</code>和<code>wfileProc</code>成员分别为两个函数指针，他们的原型为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">aeFileProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">void</span> *clientData, <span class="type">int</span> mask)</span>;</span><br></pre></td></tr></table></figure>

<p>该函数是<code>回调函数</code>，如果当前文件事件所指定的事件类型发生时，则会调用对应的<code>回调函数</code>来处理该事件.</p>
<p>当事件就绪的时候，我们需要知道文件事件的文件描述符还有事件类型才能对于锁定该事件，因此定义了<code>aeFiredEvent</code>结构统一管理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">// 就绪事件的文件描述符</span></span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="comment">// 就绪事件类型：AE_NONE，AE_READABLE，AE_WRITABLE</span></span><br><span class="line">    <span class="type">int</span> mask;</span><br><span class="line">&#125; aeFiredEvent; <span class="comment">//就绪事件</span></span><br></pre></td></tr></table></figure>

<p>文件事件的类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AE_NONE 0           <span class="comment">//未设置</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AE_READABLE 1       <span class="comment">//事件可读</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AE_WRITABLE 2       <span class="comment">//事件可写</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-时间事件结构"><a href="#2-2-时间事件结构" class="headerlink" title="2.2 时间事件结构"></a>2.2 时间事件结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间事件的id</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="comment">// 时间事件到达的时间的秒数</span></span><br><span class="line">    <span class="type">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="comment">// 时间事件到达的时间的毫秒数</span></span><br><span class="line">    <span class="type">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    <span class="comment">// 时间事件处理函数</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line">    <span class="comment">// 时间事件终结函数</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line">    <span class="comment">// 客户端传入的数据</span></span><br><span class="line">    <span class="type">void</span> *clientData;</span><br><span class="line">    <span class="comment">// 指向下一个时间事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;  <span class="comment">//时间事件</span></span><br></pre></td></tr></table></figure>

<p>可以看出，时间事件的结构就是一个链表的节点，因为<code>struct aeTimeEvent *next</code>是指向下一个时间事件的指针.</p>
<p>和文件事件一样，当时间事件所指定的事件发生时，也会调用对应的<code>回调函数</code>，结构成员<code>timeProc</code>和<code>finalizerProc</code>都是回调函数，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title function_">aeTimeProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">long</span> <span class="type">long</span> id, <span class="type">void</span> *clientData)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> <span class="title function_">aeEventFinalizerProc</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLoop, <span class="type">void</span> *clientData)</span>;</span><br></pre></td></tr></table></figure>

<p>虽然对文件事件和时间事件都做了抽象，<code>Redis</code>仍然需要对事件做一个整体的抽象，用来描述一个事件的状态. 也就是下面要介绍的事件状态结构：<code>aeEventLoop</code>.</p>
<h3 id="2-3-事件状态结构"><a href="#2-3-事件状态结构" class="headerlink" title="2.3 事件状态结构"></a>2.3 事件状态结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前已注册的最大的文件描述符</span></span><br><span class="line">    <span class="type">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line">    <span class="comment">// 文件描述符监听集合的大小</span></span><br><span class="line">    <span class="type">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line">    <span class="comment">// 下一个时间事件的ID</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> timeEventNextId;</span><br><span class="line">    <span class="comment">// 最后一次执行事件的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></span><br><span class="line">    <span class="comment">// 注册的文件事件表</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></span><br><span class="line">    <span class="comment">// 已就绪的文件事件表</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></span><br><span class="line">    <span class="comment">// 时间事件的头节点指针</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    <span class="comment">// 事件处理开关</span></span><br><span class="line">    <span class="type">int</span> stop;</span><br><span class="line">    <span class="comment">// 多路复用库的事件状态数据</span></span><br><span class="line">    <span class="type">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></span><br><span class="line">    <span class="comment">// 执行处理事件之前的函数</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">&#125; aeEventLoop;  <span class="comment">//事件轮询的状态结构</span></span><br></pre></td></tr></table></figure>

<p><code>aeEventLoop</code>结构保存了一个<code>void *</code>类型的万能指针<code>apidata</code>，用来保存轮询事件的状态，也就是保存底层调用的多路复用库的事件状态.</p>
<p><code>Redis</code>的 <code>I/O</code>多路复用程序的所有功能都是通过包装常见的<code>select</code>、<code>epoll</code>、<code>evport</code>和<code>kqueue</code>这些<code>I/O</code>多路复用函数库来实现的，每个I&#x2F;O多路复用函数库在Redis源码中都对应着一个单独的文件，比如<code>ae_select.c</code>、<code>ae_epoll.c</code>等等.</p>
<p>他们在编译阶段，会根据不同的系统选择性能最高的一个多路复用库作为<code>Redis</code>的多路复用程序实现，而且所有库的API都是相同的，这就可以让Redis多路复用程序的底层可以互换.</p>
<p>下面是具体选择库的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IO复用的选择，性能依次下降，Linux支持 &quot;ae_epoll.c&quot; 和 &quot;ae_select.c&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>也可以通过命令<code>INFO server</code>来查看当前使用的是哪个多路复用库：</p>
<p><img src="https://img-blog.csdnimg.cn/589e3d989b4f49bc99a5205212eb3c00.png" alt="在这里插入图片描述"><br>可以看到Linux下默认使用的是<code>epoll</code>多路复用库，那么<code>apidata</code>保存的就是<code>epoll</code>模型的事件状态结构，它在<code>ae_epoll.c</code>源文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="comment">// epoll事件的文件描述符</span></span><br><span class="line">    <span class="type">int</span> epfd;</span><br><span class="line">    <span class="comment">// 事件表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;   <span class="comment">// 事件的状态</span></span><br></pre></td></tr></table></figure>

<p><code>epoll</code>模型的<code>struct epoll_event</code>结构中定义着epoll事件的类型，比如<code>EPOLLIN</code>、<code>EPOLLOUT</code>等等，但是Redis的文件结构<code>aeFileEvent</code>中也在<code>mask</code>中定义了自己的事件类型，例如：<code>AE_READABLE</code>、<code>AE_WRITABLE</code>等等，于是就需要实现一个中间层将两者的事件类型相联系起来，这就是之前提到的<code>ae_epoll.c</code>文件中实现的相同的API：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个epoll实例，保存到eventLoop中</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span></span><br><span class="line"><span class="comment">// 调整事件表的大小</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> setsize)</span>  </span><br><span class="line"><span class="comment">// 释放epoll实例和事件表空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span></span><br><span class="line"><span class="comment">// 在epfd标识的事件表上注册fd的事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span></span><br><span class="line"><span class="comment">// 在epfd标识的事件表上注删除fd的事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> delmask)</span></span><br><span class="line"><span class="comment">// 等待所监听文件描述符上有事件发生</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span></span><br><span class="line"><span class="comment">// 返回正在使用的IO多路复用库的名字</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *<span class="title function_">aeApiName</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>

<p>这些API会讲<code>epoll</code>的底层函数封装起来，Redis实现事件时，只需要调用这些接口即可.</p>
<p>我们以下面两个API的源码举例：</p>
<p><code>aeApiAddEvent</code></p>
<p>该函数会向Redis事件状态结构<code>aeEventLoop</code>的事件表<code>event</code>注册一个事件，对应的是<code>epoll_ctl</code>函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在epfd标识的事件表上注册fd的事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> fd, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// EPOLL_CTL_ADD，向epfd注册fd的上的event</span></span><br><span class="line">    <span class="comment">// EPOLL_CTL_MOD，修改fd已注册的event</span></span><br><span class="line">    <span class="comment">// #define AE_NONE 0           //未设置</span></span><br><span class="line">    <span class="comment">// #define AE_READABLE 1       //事件可读</span></span><br><span class="line">    <span class="comment">// #define AE_WRITABLE 2       //事件可写</span></span><br><span class="line">    <span class="comment">// 判断fd事件的操作，如果没有设置事件，则进行关联mask类型事件，否则进行修改</span></span><br><span class="line">    <span class="type">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct epoll_event &#123;</span></span><br><span class="line">    <span class="comment">//      uint32_t     events;      /* Epoll events */</span></span><br><span class="line">    <span class="comment">//      epoll_data_t data;        /* User data variable */</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果是修改事件，合并之前的事件类型</span></span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="comment">// 根据mask映射epoll的事件类型</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;   <span class="comment">//读事件</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;  <span class="comment">//写事件</span></span><br><span class="line">    ee.data.fd = fd;    <span class="comment">//设置事件所从属的目标文件描述符</span></span><br><span class="line">    <span class="comment">// 将ee事件注册到epoll中</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>aeApiPoll</code></p>
<p>等待所监听文件描述符上有事件发生，对应着底层的<code>epoll_wait</code>函数.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等待所监听文件描述符上有事件发生</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">struct</span> timeval *tvp)</span> &#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="type">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听事件表上是否有事件发生</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 至少有一个就绪的事件</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="comment">// 遍历就绪的事件表，将其加入到eventLoop的就绪事件表中</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="type">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> =</span> state-&gt;events+j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据就绪的事件类型，设置mask</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">// 添加到就绪事件表中</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回就绪的事件个数</span></span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-事件的实现"><a href="#3-事件的实现" class="headerlink" title="3. 事件的实现"></a>3. 事件的实现</h2><p>事件的所有源码都定义在<code>ae.c</code>源文件中，先从<code>aeMain</code>函数说起.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 事件轮询的主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 一直处理事件</span></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        <span class="comment">// 执行处理事件之前的函数</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">        <span class="comment">//处理到时的时间事件和就绪的文件事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，如果服务器一直处理事件，那么就是一个死循环，而一个最典型的事件驱动，就是一个死循环. 在循环中，程序会调用处理事件的函数<code>aeProcessEvents()</code>，它的参数是一个事件状态结构<code>aeEventLoop</code>和<code>AE_ALL_EVENTS</code>.</p>
<p> 事件类型的宏定义，在<code>ae.h</code>头文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AE_FILE_EVENTS 1                                <span class="comment">//文件事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AE_TIME_EVENTS 2                                <span class="comment">//时间事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)   <span class="comment">//文件和时间事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AE_DONT_WAIT 4</span></span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理到时的时间事件和就绪的文件事件</span></span><br><span class="line"><span class="comment">// 如果flags = 0，函数什么都不做，直接返回</span></span><br><span class="line"><span class="comment">// 如果flags设置了 AE_ALL_EVENTS ，则执行所有类型的事件</span></span><br><span class="line"><span class="comment">// 如果flags设置了 AE_FILE_EVENTS ，则执行文件事件</span></span><br><span class="line"><span class="comment">// 如果flags设置了 AE_TIME_EVENTS ，则执行时间事件</span></span><br><span class="line"><span class="comment">// 如果flags设置了 AE_DONT_WAIT ，那么函数处理完事件后直接返回，不阻塞等待</span></span><br><span class="line"><span class="comment">// 函数返回执行的事件个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果什么事件都没有设置则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请注意，既然我们要处理时间事件，即使没有要处理的文件事件，我们仍要调用select（），以便在下一次事件准备启动之前进行休眠</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前还没有要处理的文件事件，或者设置了时间事件但是没有设置不阻塞标识</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了时间事件而没有设置不阻塞标识</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            <span class="comment">// 获取最近到时的时间事件</span></span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="comment">// 获取到了最早到时的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="type">long</span> now_sec, now_ms;</span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待该时间事件到时所需要的时长</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> ms =</span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没到时</span></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 保存时长到tvp中</span></span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            <span class="comment">// 如果已经到时，则将tvp的时间设置为0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有获取到了最早到时的时间事件，时间事件链表为空</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果设置了不阻塞标识</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 将tvp的时间设置为0，就不会阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 阻塞到第一个时间事件的到来</span></span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所监听文件描述符上有事件发生</span></span><br><span class="line">        <span class="comment">// 如果tvp为NULL，则阻塞在此，否则等待tvp设置阻塞的时间，就会有时间事件到时</span></span><br><span class="line">        <span class="comment">// 返回了就绪文件事件的个数</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">        <span class="comment">// 遍历就绪文件事件表</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取就绪文件事件的地址</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="comment">// 获取就绪文件事件的类型，文件描述符</span></span><br><span class="line">            <span class="type">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="type">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="type">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是文件可读事件发生</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">// 设置读事件标识 且 调用读事件方法处理读事件</span></span><br><span class="line">                rfired = <span class="number">1</span>;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是文件可写事件发生</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="comment">// 读写事件的执行发法不同，则执行写事件，避免重复执行相同的方法</span></span><br><span class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line">            processed++;    <span class="comment">//执行的事件次数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Redis服务器在没有被事件触发时，如果没有设置<code>AE_DONT_WAIT</code>标识，就会开始阻塞等待. 但是它不会死等待，因为还需要处理时间事件，所以在调用<code>aeApiPoll</code>进行监听之前，会先从时间事件表中获取一个最近到达的时间，根据需要等待的时间构建一个<code>struct timeval tv, *tvp</code>结构的变量，这个变量保存着服务器阻塞等待文件事件的最长时间，一旦时间到达而没有触发文件事件<code>aeApiPoll</code>函数就会停止阻塞，进而调用<code>processTimeEvents</code>函数处理时间事件.</p>
<p>如果在阻塞等待的最长时间之间，触发了文件事件，就会先执行文件事件，后执行时间事件，因此处理时间事件通常比预设的会晚一点.</p>
<p>而执行文件事件<code>rfileProc</code>和<code>wfileProc</code>也是调用了回调函数，Redis将文件事件的处理分为了好几种，用于处理不同的网络通信需求：</p>
<ul>
<li><code>acceptTcpHandler</code>：用于<code>accept</code> client的<code>connect</code>.</li>
<li><code>acceptUnixHandler</code>：用于<code>accept</code> client的本地<code>connect</code>.</li>
<li><code>sendReplyToClient</code>：用于向client发送命令回复.</li>
<li><code>readQueryFromClient</code>：用于读入client发送的请求.</li>
</ul>
<p>然后我们来看一下获取最快达到时间事件的函数<code>aeSearchNearestTimer</code>实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找第一个快到时的时间事件</span></span><br><span class="line"><span class="comment">// 这个操作是有用的知道有多少时间可以选择该事件设置为不用推迟任何事件的睡眠中。</span></span><br><span class="line"><span class="comment">// 如果事件链表没有时间将返回NULL。</span></span><br><span class="line"><span class="type">static</span> aeTimeEvent *<span class="title function_">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 时间事件头节点地址</span></span><br><span class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    aeTimeEvent *nearest = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的时间事件</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="comment">// 寻找第一个快到时的时间事件，保存到nearest中</span></span><br><span class="line">        <span class="keyword">if</span> (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</span><br><span class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</span><br><span class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</span><br><span class="line">            nearest = te;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nearest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数就是遍历时间事件链表，然后找到最小值.</p>
<p>我们重点看执行时间事件的函数<code>processTimeEvents</code>函数的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行时间事件</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> &#123;</span><br><span class="line">    <span class="type">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te, *prev;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxId;</span><br><span class="line">    <span class="type">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里尝试发现时间混乱的情况，上一次处理事件的时间比当前时间还要大</span></span><br><span class="line">    <span class="comment">// 重置最近一次处理事件的时间</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置上一次时间事件处理的时间为当前时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    prev = <span class="literal">NULL</span>;</span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;   <span class="comment">//当前时间事件表中的最大ID</span></span><br><span class="line">    <span class="comment">// 遍历时间事件链表</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="type">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove events scheduled for deletion. */</span></span><br><span class="line">        <span class="comment">// 如果时间事件已被删除了</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="comment">// 从事件链表中删除事件的节点</span></span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">NULL</span>)</span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="comment">// 调用时间事件终结方法清除该事件</span></span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保我们不处理在此迭代中由时间事件创建的时间事件. 请注意，此检查目前无效：我们总是在头节点添加新的计时器，但是如果我们更改实施细节，则该检查可能会再次有用：我们将其保留在未来的防御</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="comment">// 找到已经到时的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">// 调用时间事件处理方法</span></span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            <span class="comment">// 时间事件次数加1</span></span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">// 如果不是定时事件，则继续设置它的到时时间</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            <span class="comment">// 如果是定时时间，则retval为-1，则将其时间事件删除，惰性删除</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新前驱节点指针和后继节点指针</span></span><br><span class="line">        prev = te;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;   <span class="comment">//返回执行事件的次数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果时间事件不存在，则就调用<code>finalizerProc</code>指向的回调函数，删除当前的时间事件. 如果存在，就调用<code>timeProc</code>指向的回调函数处理时间事件. Redis的时间事件分为两类：</p>
<ul>
<li>定时事件：让一段程序在指定的时间后执行一次.</li>
<li>周期性事件：让一段程序每隔指定的时间后执行一次.</li>
</ul>
<p>如果当前的时间事件是周期性，那么就会在将时间周期添加到周期事件的到时时间中. 如果是定时事件，则将该时间事件删除.</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 15.RDB持久化机制</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2015.RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1-RDB-介绍"><a href="#1-RDB-介绍" class="headerlink" title="1. RDB 介绍"></a>1. RDB 介绍</h2><p>因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见.</p>
<p>为了解决这个问题，Redis 提供了<code>RDB</code>持久化功能，它会生成一个压缩的二进制文件，通过该文件可以还原生成的<code>RDB</code>文件时的数据库状态.</p>
<h3 id="1-1-RDB的优缺点"><a href="#1-1-RDB的优缺点" class="headerlink" title="1.1 RDB的优缺点"></a>1.1 RDB的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li><p><code>RDB</code>是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照. 非常适用于备份，全景复制，大规模的数据恢复等场景.</p>
</li>
<li><p>Redis加载<code>RDB</code>恢复数据远远快于<code>AOF</code>的方式.</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><code>BGSAVE</code>命令每次运行要调用<code>fork()</code>创建子进程，这属于重量级操作，会占用一定的内存空间. </li>
<li>由于RDB是每隔一段时间进行持久化操作，假如Redis意外宕机，可能会造成最后一次数据没有来得及做持久化.</li>
<li>RDB文件使用特定的二进制格式保存，Redis版本演进的过程中，有多个RDB版本，这导致版本兼容的问题.</li>
</ul>
<h2 id="2-RDB-触发机制"><a href="#2-RDB-触发机制" class="headerlink" title="2. RDB 触发机制"></a>2. RDB 触发机制</h2><p>RDB分为自动触发和手动触发.</p>
<p><strong>手动触发</strong></p>
<p>手动触发有两个命令：</p>
<ul>
<li><code>SAVE</code>：阻塞当前Redis服务器，直到RDB过程完成为止.</li>
<li><code>BGSAVE</code>：Redis进程执行<code>fork()</code>操作创建出一个子进程，在后台完成RDB持久化操作的过程（主要用这个）.</li>
</ul>
<p><strong>自动触发</strong></p>
<p>以下三行配置在Redis的配置文件中：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span>  # 服务器在<span class="number">900</span>秒之内，对数据库进行了至少<span class="number">1</span>次修改</span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span> # 服务器在<span class="number">300</span>秒之内，对数据库进行了至少<span class="number">10</span>次修改</span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span> # 服务器在<span class="number">60</span>秒之内，对数据库进行了至少<span class="number">10000</span>次修改</span><br></pre></td></tr></table></figure>

<p>只要满足以上三个条件中的任意一个，<code>BGSAVE</code>命令就会被执行.</p>
<h2 id="3-RDB-的实现"><a href="#3-RDB-的实现" class="headerlink" title="3. RDB 的实现"></a>3. RDB 的实现</h2><p>关于RDB的实现在<code>rdb.h</code>头文件和<code>rdb.c</code>源文件中.</p>
<p><code>BGSAVE</code>命令的实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* BGSAVE [SCHEDULE] */</span></span><br><span class="line"><span class="comment">// BGSAVE 命令实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bgsaveCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">	<span class="comment">// SCHEDULE控制BGSAVE的执行，避免和AOF重写进程冲突</span></span><br><span class="line">    <span class="type">int</span> schedule = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置schedule标志</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;schedule&quot;</span>)) &#123;</span><br><span class="line">            schedule = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在执行RDB持久化操作，则退出</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;Background save already in progress&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果正在执行AOF持久化操作，需要将BGSAVE提上日程，然后退出</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果schedule为真，设置rdb_bgsave_scheduled为1</span></span><br><span class="line">        <span class="keyword">if</span> (schedule) &#123;</span><br><span class="line">            server.rdb_bgsave_scheduled = <span class="number">1</span>;</span><br><span class="line">            addReplyStatus(c,<span class="string">&quot;Background saving scheduled&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyError(c,</span><br><span class="line">                <span class="string">&quot;An AOF log rewriting in progress: can&#x27;t BGSAVE right now. &quot;</span></span><br><span class="line">                <span class="string">&quot;Use BGSAVE SCHEDULE in order to schedule a BGSAVE whenver &quot;</span></span><br><span class="line">                <span class="string">&quot;possible.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行BGSAVE</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbSaveBackground(server.rdb_filename) == C_OK) &#123;</span><br><span class="line">        addReplyStatus(c,<span class="string">&quot;Background saving started&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以发现，当可以执行<code>BGSAVE</code>操作的时候，程序调用了一个<code>rdbSaveBackground</code>函数，该函数会<code>fork()</code>一个子进程，然后这个子进程调用<code>rdbSave()</code>进行<code>RDB</code>持久化，同时父进程会设置一些状态信息以及更新一些日志信息.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后台进行RDB持久化BGSAVE操作</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveBackground</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前没有正在进行AOF和RDB操作，否则返回C_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备份当前数据库的脏键值</span></span><br><span class="line">    server.dirty_before_bgsave = server.dirty;</span><br><span class="line">    <span class="comment">// 最近一个执行BGSAVE的时间</span></span><br><span class="line">    server.lastbgsave_try = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// fork函数开始时间，记录fork函数的耗时</span></span><br><span class="line">    start = ustime();</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line">        <span class="comment">// 子进程执行的代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭监听的套接字</span></span><br><span class="line">        closeListeningSockets(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置进程标题，方便识别</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-rdb-bgsave&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行保存操作，将数据库的写到filename文件中</span></span><br><span class="line">        retval = rdbSave(filename);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            <span class="comment">// 得到子进程进程的脏私有虚拟页面大小，如果做RDB的同时父进程正在写入的数据，那么子进程就会拷贝一个份父进程的内存，而不是和父进程共享一份内存。</span></span><br><span class="line">            <span class="type">size_t</span> private_dirty = zmalloc_get_private_dirty();</span><br><span class="line">            <span class="comment">// 将子进程分配的内容写日志</span></span><br><span class="line">            <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">&quot;RDB: %zu MB of memory used by copy-on-write&quot;</span>,</span><br><span class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 子进程退出，发送信号给父进程，发送0表示BGSAVE成功，1表示失败</span></span><br><span class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程执行的代码</span></span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="comment">// 计算出fork的执行时间</span></span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        <span class="comment">// 计算fork的速率，GB/每秒</span></span><br><span class="line">        server.stat_fork_rate = (<span class="type">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></span><br><span class="line">        <span class="comment">//如果fork执行时长，超过设置的阀值，则要将其加入到一个字典中，与传入&quot;fork&quot;关联，以便进行延迟诊断</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;fork&quot;</span>,server.stat_fork_time/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果fork出错</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            server.lastbgsave_status = C_ERR;   <span class="comment">//设置BGSAVE错误</span></span><br><span class="line">            <span class="comment">// 更新日志信息</span></span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新日志信息</span></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">&quot;Background saving started by pid %d&quot;</span>,childpid);</span><br><span class="line">        server.rdb_save_time_start = time(<span class="literal">NULL</span>);    <span class="comment">//设置BGSAVE开始的时间</span></span><br><span class="line">        server.rdb_child_pid = childpid;            <span class="comment">//设置负责执行BGSAVE操作的子进程id</span></span><br><span class="line">        server.rdb_child_type = RDB_CHILD_TYPE_DISK;<span class="comment">//设置BGSAVE的类型，往磁盘中写入</span></span><br><span class="line">        <span class="comment">//关闭哈希表的resize，因为resize过程中会有复制拷贝动作</span></span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>子进程调用的<code>rdbSave()</code>函数会进行<code>RDB</code>文件的初始化操作，刚开始生成一个临时的<code>RDB</code>文件，只有在执行成功后，才会进行<code>rename</code>操作，然后以写权限打开文件，接着调用<code>rdbSaveRio()</code>函数将数据库的内容写到临时的<code>RDB</code>文件，之后进行刷新缓冲区和同步操作，最后关闭文件进行<code>rename</code>操作和更新服务器状态.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数据库保存在磁盘上，返回C_OK成功，否则返回C_ERR</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSave</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="type">char</span> cwd[MAXPATHLEN]; <span class="comment">/* Current working dir path for error messages. */</span></span><br><span class="line">    FILE *fp;</span><br><span class="line">    rio rdb;</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时文件</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-%d.rdb&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    <span class="comment">// 以写方式打开该文件</span></span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="comment">// 打开失败，获取文件目录，写入日志</span></span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        <span class="type">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        <span class="comment">// 写日志信息到logfile</span></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Failed opening the RDB file %s (in server root dir %s) &quot;</span></span><br><span class="line">            <span class="string">&quot;for saving: %s&quot;</span>,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个rio对象，该对象是一个文件对象IO</span></span><br><span class="line">    rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">    <span class="comment">// 将数据库的内容写到rio中</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error) == C_ERR) &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure data will not remain on the OS&#x27;s output buffers */</span></span><br><span class="line">    <span class="comment">// 冲洗缓冲区，确保所有的数据都写入磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 将fp指向的文件同步到磁盘中</span></span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. */</span></span><br><span class="line">    <span class="comment">// 原子性改变rdb文件的名字</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 改变名字失败，则获得当前目录路径，发送日志信息，删除临时文件</span></span><br><span class="line">        <span class="type">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">&quot;Error moving temp DB file %s on the final &quot;</span></span><br><span class="line">            <span class="string">&quot;destination %s (in server root dir %s): %s&quot;</span>,</span><br><span class="line">            tmpfile,</span><br><span class="line">            filename,</span><br><span class="line">            cwdp ? cwdp : <span class="string">&quot;unknown&quot;</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写日志文件</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;DB saved on disk&quot;</span>);</span><br><span class="line">    <span class="comment">// 重置服务器的脏键</span></span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 更新上一次SAVE操作的时间</span></span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 更新SAVE操作的状态</span></span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rdbSaveRio()函数写错误处理，写日志，关闭文件，删除临时文件，发送C_ERR</span></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error saving DB on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>上述的<code>rdbSave()</code>函数打开文件之后，接着会调用<code>rdbSaveRio()</code>函数，该函数会将往<code>RDB</code>文件中写上固定格式的内容：</p>
<p><img src="https://img-blog.csdnimg.cn/ad921e479c754c678bde364a9c21d3bc.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>REDIS</code>是一个固定的字符串标识，占5字节.</li>
<li><code>db_version</code>是RDB版本，占4字节.</li>
<li><code>默认信息</code>：在db_version与databases之间还有默认信息，由<code>rdbSaveInfoAuxFields()</code>函数写入，包括Redis版本、Redis位数、当前时间喝Redis当前使用的内存数.</li>
<li><code>database</code>部分包含着零个或任意个数据库，以及各个数据库中的键值对数据.</li>
<li><code>EOF</code>常量占1字节，表示文件结束.</li>
<li><code>check_sum</code>是校验和，占8字节.</li>
</ul>
<p><code>rdbSaveRio()</code>函数会遍历所有数据库，然后进行RDB写入.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个RDB格式文件内容写入到rio中，成功返回C_OK，否则C_ERR和一部分或所有的出错信息</span></span><br><span class="line"><span class="comment">// 当函数返回C_ERR，并且error不是NULL，那么error被设置为一个错误码errno</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveRio</span><span class="params">(rio *rdb, <span class="type">int</span> *error)</span> &#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="type">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = mstime();</span><br><span class="line">    <span class="type">uint64_t</span> cksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启了校验和选项</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        <span class="comment">// 设置校验和的函数</span></span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line">    <span class="comment">// 将Redis版本信息保存到magic中</span></span><br><span class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">&quot;REDIS%04d&quot;</span>,RDB_VERSION);</span><br><span class="line">    <span class="comment">// 将magic写到rio中</span></span><br><span class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 将rdb文件的默认信息写到rio中</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有服务器内的数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">    	<span class="comment">// 当前的数据库指针</span></span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        <span class="comment">// 当数据库的键值对字典</span></span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="comment">// 跳过为空的数据库</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 创建一个字典类型的迭代器</span></span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line">        <span class="keyword">if</span> (!di) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></span><br><span class="line">        <span class="comment">// 写入数据库的选择标识码 RDB_OPCODE_SELECTDB为254</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="comment">// 写入数据库的id，占了一个字节的长度</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入调整数据库的操作码，我们将大小限制在UINT32_MAX以内，这并不代表数据库的实际大小，只是提示去重新调整哈希表的大小</span></span><br><span class="line">        <span class="type">uint32_t</span> db_size, expires_size;</span><br><span class="line">        <span class="comment">// 如果字典的大小大于UINT32_MAX，则设置db_size为最大的UINT32_MAX</span></span><br><span class="line">        db_size = (dictSize(db-&gt;dict) &lt;= UINT32_MAX) ?</span><br><span class="line">                                dictSize(db-&gt;dict) :</span><br><span class="line">                                UINT32_MAX;</span><br><span class="line">        <span class="comment">// 设置有过期时间键的大小超过UINT32_MAX，则设置expires_size为最大的UINT32_MAX</span></span><br><span class="line">        expires_size = (dictSize(db-&gt;expires) &lt;= UINT32_MAX) ?</span><br><span class="line">                                dictSize(db-&gt;expires) :</span><br><span class="line">                                UINT32_MAX;</span><br><span class="line">        <span class="comment">// 写入调整哈希表大小的操作码，RDB_OPCODE_RESIZEDB = 251</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="comment">// 写入提示调整哈希表大小的两个值，如果</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="comment">// 遍历数据库所有的键值对</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr = dictGetKey(de);        <span class="comment">//当前键</span></span><br><span class="line">            robj key, *o = dictGetVal(de);      <span class="comment">//当前键的值</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> expire;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 在栈中创建一个键对象并初始化</span></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            <span class="comment">// 当前键的过期时间</span></span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            <span class="comment">// 将键的键对象，值对象，过期时间写到rio中</span></span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);    <span class="comment">//释放迭代器</span></span><br><span class="line">    &#125;</span><br><span class="line">    di = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一个EOF码，RDB_OPCODE_EOF = 255</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CRC64检验和，当校验和计算为0，没有开启是，在载入rdb文件时会跳过</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入错误</span></span><br><span class="line">werr:</span><br><span class="line">	<span class="comment">// 保存错误码</span></span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="comment">// 如果没有释放迭代器，则释放</span></span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>上面说到，程序还会调用<code>rdbSaveInfoAuxFields()</code>函数写入一些默认的辅助信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将一个rdb文件的默认信息写入到rio中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rdbSaveInfoAuxFields</span><span class="params">(rio *rdb)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断主机的总线宽度，是64位还是32位</span></span><br><span class="line">    <span class="type">int</span> redis_bits = (<span class="keyword">sizeof</span>(<span class="type">void</span>*) == <span class="number">8</span>) ? <span class="number">64</span> : <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加rdb文件的状态信息：Redis版本，redis位数，当前时间和Redis当前使用的内存数</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveAuxFieldStrStr(rdb,<span class="string">&quot;redis-ver&quot;</span>,REDIS_VERSION) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveAuxFieldStrInt(rdb,<span class="string">&quot;redis-bits&quot;</span>,redis_bits) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveAuxFieldStrInt(rdb,<span class="string">&quot;ctime&quot;</span>,time(<span class="literal">NULL</span>)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (rdbSaveAuxFieldStrInt(rdb,<span class="string">&quot;used-mem&quot;</span>,zmalloc_used_memory()) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们可以使用<code>od -cx dump.rdb</code>命令来查看保存在<code>dump.rdb</code>文件中的内容：</p>
<p><img src="https://img-blog.csdnimg.cn/ecffe45f244d4630918bc131457521ec.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 16.AOF持久化机制</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2016.AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="1-AOF-介绍"><a href="#1-AOF-介绍" class="headerlink" title="1. AOF 介绍"></a>1. AOF 介绍</h2><p>除了RDB持久化功能之外，Redis 还提供了<code>AOF ( Append Only File )</code>持久化功能。与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是以日志的方式记录Redis服务器所执行的<code>写命令</code>来记录数据库状态的，重启时再重新执行AOF文件中的命令达到恢复数据的目的，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/cd21b2ed93784cdab270ca389fc3de5f.png" alt="在这里插入图片描述"></p>
<h3 id="1-1-AOF的优缺点"><a href="#1-1-AOF的优缺点" class="headerlink" title="1.1 AOF的优缺点"></a>1.1 AOF的优缺点</h3><p><strong>优点</strong></p>
<ul>
<li>该机制可以带来更高的数据安全性，即数据持久性。</li>
<li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。</li>
<li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>相对于RDB，AOF远大于RDB，修复速度也比RDB慢。</li>
<li>AOF运行效率也比RDB慢，因此默认RDB操作。</li>
</ul>
<h2 id="2-AOF持久化的实现"><a href="#2-AOF持久化的实现" class="headerlink" title="2. AOF持久化的实现"></a>2. AOF持久化的实现</h2><h3 id="2-1-命令写入磁盘"><a href="#2-1-命令写入磁盘" class="headerlink" title="2.1 命令写入磁盘"></a>2.1 命令写入磁盘</h3><h4 id="2-1-1-命令追加"><a href="#2-1-1-命令追加" class="headerlink" title="2.1.1 命令追加"></a>2.1.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的<code>aof_buf</code>缓冲区的末尾：</p>
<p>缓冲区由<code>SDS</code>实现，如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">	<span class="comment">// AOF缓冲区</span></span><br><span class="line">	<span class="comment">// 在进入事件循环之前写入</span></span><br><span class="line">	sds aof_buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>在执行<code>AOF</code>文件写入的时候，Redis会直接向这个<code>SDS</code>类型的缓冲区中写入<code>文本协议格式</code>，如下所示：</p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><span class="line">*<span class="number">2</span>\r\n$<span class="number">6</span>\r\nSELECT\r\n$<span class="number">1</span>\r\n0\r\n*<span class="number">5</span>\r\n$<span class="number">4</span>\r\nSADD\r\n$<span class="number">3</span>\r\nkey\r\n$<span class="number">2</span>\r\nm3\r\n$<span class="number">2</span>\r\nm2\r\n$<span class="number">2</span>\r\nm1\r\n</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>*2表示接下来是一行新的命令，该命令由2个单词组成； $6表示第一个单词有6个字符，即SELECT； $1表示第二个单词有1个字符，即0。</li>
<li>*5表示接下来是一行新的命令，该命令由5个单词组成； $4表示第一个单词有4个字符，即SADD； $3表示第二个单词有3个字符，即key； $2表示第三个单词有2个字符，即m3； $2表示第四个单词有2个字符，即m2； $2表示第四个单词有2个字符，即m1。</li>
</ul>
<p>所以这两条命令就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SELECT <span class="number">0</span></span><br><span class="line">SADD key m3 m2 m1</span><br></pre></td></tr></table></figure>

<p>文本协议具有很高的可读性，可以直接进行修改。而且，文本协议还具有很好的兼容性，而且协议采用了<code>\r\n</code>换行符，所以每次写入命令只需执行追加操作。</p>
<p><strong>追加命令到缓冲区中</strong></p>
<p>源码中使用<code>catAppendOnlyGenericCommand()</code>函数实现了追加命令到缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据传入的命令和命令参数，将他们还原成协议格式</span></span><br><span class="line"><span class="comment">// 每次传入一行命令</span></span><br><span class="line"><span class="comment">// 参数： 缓冲区 命令单词数 命令</span></span><br><span class="line">sds <span class="title function_">catAppendOnlyGenericCommand</span><span class="params">(sds dst, <span class="type">int</span> argc, robj **argv)</span> &#123;</span><br><span class="line">		<span class="comment">// 临时缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="type">int</span> len, j;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式：&quot;*&lt;argc&gt;\r\n&quot;</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    <span class="comment">// long long类型转C字符串，成功返回转换后字符串长度，失败返回0</span></span><br><span class="line">    <span class="comment">//这里是将命令的单词个数存入buf中，然后返回len，len作为临时缓冲区buf的下标</span></span><br><span class="line">    len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,argc);</span><br><span class="line">    buf[len++] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">    buf[len++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">// 拼接到dst的后面</span></span><br><span class="line">    dst = sdscatlen(dst,buf,len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的参数，建立命令的格式：$&lt;command_len&gt;\r\n&lt;command&gt;\r\n</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        o = getDecodedObject(argv[j]);  <span class="comment">//解码成字符串对象</span></span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">        <span class="comment">// 表示每个单词的长度</span></span><br><span class="line">        len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,sdslen(o-&gt;ptr));</span><br><span class="line">        buf[len++] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">        buf[len++] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        dst = sdscatlen(dst,buf,len);</span><br><span class="line">        <span class="comment">// 命令本体</span></span><br><span class="line">        dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">        dst = sdscatlen(dst,<span class="string">&quot;\r\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 引用计数减一</span></span><br><span class="line">        <span class="comment">// 当引用对象等于1时，在操作引用计数减1，直接释放对象的ptr和对象空间</span></span><br><span class="line">        decrRefCount(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst; <span class="comment">//返回还原后的协议内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>追加过期命令的键</strong></p>
<p><code>catAppendOnlyGenericCommand()</code>函数只是追加一个普通的键，然而一个过期命令的键，需要全部转换为<code>PEXPIREAT</code>，因为必须将相对时间设置为绝对时间，否则还原数据库时，就无法得知该键是否过期，Redis的<code>catAppendOnlyExpireAtCommand()</code>函数实现了这个功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用sds表示一个 PEXPIREAT 命令，seconds为生存时间，cmd为指定转换的指令</span></span><br><span class="line"><span class="comment">// 这个函数用来转换 EXPIRE and PEXPIRE 命令成 PEXPIREAT ，以便在AOF时，时间总是一个绝对值</span></span><br><span class="line">sds <span class="title function_">catAppendOnlyExpireAtCommand</span><span class="params">(sds buf, <span class="keyword">struct</span> redisCommand *cmd, robj *key, robj *seconds)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> when;</span><br><span class="line">    robj *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we can use strtoll */</span></span><br><span class="line">    <span class="comment">// 解码成字符串对象，以便使用strtoll函数</span></span><br><span class="line">    seconds = getDecodedObject(seconds);</span><br><span class="line">    <span class="comment">// 取出过期值，long long类型</span></span><br><span class="line">    when = strtoll(seconds-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* Convert argument into milliseconds for EXPIRE, SETEX, EXPIREAT */</span></span><br><span class="line">    <span class="comment">// 将 EXPIRE, SETEX, EXPIREAT 参数的秒转换成毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == setexCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Convert into absolute time for EXPIRE, PEXPIRE, SETEX, PSETEX */</span></span><br><span class="line">    <span class="comment">// 将 EXPIRE, PEXPIRE, SETEX, PSETEX 命令的参数，从相对时间设置为绝对时间</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when += mstime();</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(seconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 PEXPIREAT 命令对象</span></span><br><span class="line">    argv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;PEXPIREAT&quot;</span>,<span class="number">9</span>);</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    argv[<span class="number">2</span>] = createStringObjectFromLongLong(when);</span><br><span class="line">    <span class="comment">// 将命令还原成协议格式，追加到buf</span></span><br><span class="line">    buf = catAppendOnlyGenericCommand(buf, <span class="number">3</span>, argv);</span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 返回buf</span></span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>这两个函数都是实现的底层功能，最后它们都会被<code>feedAppendOnlyFile()</code>函数调用。</p>
<h4 id="2-1-2-AOF文件写入"><a href="#2-1-2-AOF文件写入" class="headerlink" title="2.1.2 AOF文件写入"></a>2.1.2 AOF文件写入</h4><p><code>feedAppendOnlyFile()</code>函数会创建一个空的简单<code>动态字符串（sds）</code>，将当前所有追加命令操作都追加到这个sds中，最终将这个sds追加到<code>server.aof_buf</code>。 还有就是，这个函数在写入键之前，需要显式的写入一个<code>SELECT</code>命令，以正确的将所有键还原到正确的数据库中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将命令追加到AOF文件中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">feedAppendOnlyFile</span><span class="params">(<span class="keyword">struct</span> redisCommand *cmd, <span class="type">int</span> dictid, robj **argv, <span class="type">int</span> argc)</span> &#123;</span><br><span class="line">    sds buf = sdsempty();   <span class="comment">//设置一个空sds</span></span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用SELECT命令，显式的设置当前数据库</span></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">        <span class="type">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">&quot;%d&quot;</span>,dictid);</span><br><span class="line">        <span class="comment">// 构造SELECT命令的协议格式</span></span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">&quot;*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n&quot;</span>,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        <span class="comment">// 执行AOF时，当前的数据库ID</span></span><br><span class="line">        server.aof_selected_db = dictid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 EXPIRE/PEXPIRE/EXPIREAT 三个命令，则要转换成 PEXPIREAT 命令</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        <span class="comment">/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是 SETEX/PSETEX 命令，则转换成 SET and PEXPIREAT</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">        <span class="comment">/* Translate SETEX/PSETEX to SET and PEXPIREAT */</span></span><br><span class="line">        <span class="comment">// SETEX key seconds value</span></span><br><span class="line">        <span class="comment">// 构建SET命令对象</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;SET&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 将SET命令按协议格式追加到buf中</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 将SETEX/PSETEX命令和键对象按协议格式追加到buf中</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他命令直接按协议格式转换，然后追加到buf中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在进行AOF，则将命令追加到AOF的缓存中，在重新进入事件循环之前，这些命令会被冲洗到磁盘上，并向client回复</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果后台正在进行重写，那么将命令追加到重写缓存区中，以便我们记录重写的AOF文件于当前数据库的差异</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="type">unsigned</span> <span class="type">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-3-AOF文件同步"><a href="#2-1-3-AOF文件同步" class="headerlink" title="2.1.3 AOF文件同步"></a>2.1.3 AOF文件同步</h4><p>Redis的服务器进程就是一个<code>事件循环（loop）</code>，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像<code>serverCron()</code>函数这样需要定时运行的函数。<br>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到<code>aof_buf</code>缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用<code>flushAppendOnlyFile()</code>函数，考虑是否需要将<code>aof_buf</code>缓冲区中的内容写入和保存到AOF文件里面。</p>
<p><code>flushAppendOnlyFile()</code>函数的行为由服务器配置的<code>appendfsync</code>选项的值来决定，各个不同值产生的行为如下表所示：</p>
<br>

<table>
<thead>
<tr>
<th>appendfsync选项的值</th>
<th>flushAppendOnlyFile函数的行为</th>
</tr>
</thead>
<tbody><tr>
<td>AOF_FSYNC_ALWAYS</td>
<td>命令写入aof_buf后调用系统fsync和操作同步到AOF文件，fsync完成后进程程返回</td>
</tr>
<tr>
<td>AOF_FSYNC_EVERYSEC</td>
<td>命令写入aof_buf后调用系统write操作，write完成后线程返回。fsync同步文件操作由进程每秒调用一次</td>
</tr>
<tr>
<td>AOF_FSYNC_NO</td>
<td>命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘由操作由操作系统负责</td>
</tr>
</tbody></table>
<br>

<p>如果用户没有主动为appendfsync选项设置值，那么appendfsync选项的默认值为everysec。</p>
<br>

<p>我们再来了解一下，<code>write</code>和<code>fsync</code>操作，在系统中都做了哪些事：</p>
<p><strong>write</strong></p>
<p>会触发<code>延迟写（delayed write）机制</code>。Linux在内核提供<code>页缓冲</code>区用来提高IO性能，因此，write操作在将数据写入操作系统的缓冲区后就直接返回，而不一定触发同步到磁盘的操作。只有在页空间写满，或者达到特定的时间周期，才会同步到磁盘。因此单纯的write操作也是有数据丢失的风险。</p>
<p><strong>fsync 和 fdatasync</strong></p>
<p>为此，系统提供了fsync 和fdatasync两个同步函数，它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面，从而确保写入数据的安全性。</p>
<p>接下来看看同步的源码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将AOF缓存写到磁盘中</span></span><br><span class="line"><span class="comment">// 因为我们需要在回复client之前对AOF执行写操作，唯一的机会是在事件loop中，因此累计所有的AOF到缓存中，在下一次重新进入事件loop之前将缓存写到AOF文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于force参数</span></span><br><span class="line"><span class="comment">// 当fsync被设置为每秒执行一次，如果后台仍有线程正在执行fsync操作，我们可能会延迟flush操作，因为write操作可能会被阻塞，当发生这种情况时，说明需要尽快的执行flush操作，会调用 serverCron() 函数。</span></span><br><span class="line"><span class="comment">// 然而如果force被设置为1，我们会无视后台的fsync，直接进行写入操作</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AOF_WRITE_LOG_ERROR_RATE 30</span></span><br><span class="line"><span class="comment">// 将AOF缓存冲洗到磁盘中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">flushAppendOnlyFile</span><span class="params">(<span class="type">int</span> force)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten;</span><br><span class="line">    <span class="type">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="type">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓冲区中没有数据，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步策略是每秒同步一次</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        <span class="comment">// AOF同步操作是否在后台正在运行</span></span><br><span class="line">        sync_in_progress = bioPendingJobsOfType(BIO_AOF_FSYNC) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步策略是每秒同步一次，且不是强制同步的</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">// 根据这个同步策略，且没有设置强制执行，我们在后台执行同步</span></span><br><span class="line">        <span class="comment">// 如果同步已经在后台执行，那么可以延迟两秒，如果设置了force，那么服务器会阻塞在write操作上</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果后台正在执行同步</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="comment">// 延迟执行flush操作的开始时间为0，表示之前没有延迟过write</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 之前没有延迟过write操作，那么将延迟write操作的开始时间保存下来，然后就直接返回</span></span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 如果之前延迟过write操作，如果没到2秒，直接返回，不执行write</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行到这里，表示后台正在执行fsync，但是延迟时间已经超过2秒</span></span><br><span class="line">            <span class="comment">// 那么执行write操作，此时write会被阻塞</span></span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行write操作，保证写操作是原子操作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟检测开始的时间</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="comment">// 将缓冲区的内容写到AOF文件中</span></span><br><span class="line">    nwritten = write(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    <span class="comment">// 设置延迟的时间 = 当前的时间 - 开始的时间</span></span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    <span class="comment">// 捕获不同造成延迟write的事件</span></span><br><span class="line">    <span class="comment">// 如果正在后台执行同步fsync</span></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-write-pending-fsync&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-pending-fsync&quot;</span>,latency);</span><br><span class="line">    <span class="comment">// 如果正在执行AOF或正在执行RDB</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-write-active-child&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-active-child&quot;</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-write-alone&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-write-alone&quot;</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将latency和&quot;aof-write&quot;关联到延迟诊断字典中</span></span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">&quot;aof-write&quot;</span>,latency);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行了write，所以清零延迟flush的时间</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果写入的字节数不等于缓存的字节数，发生异常错误</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="type">signed</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 限制日志的频率每行30秒</span></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果写入错误，写errno到日志</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error writing to the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果是写了一部分，发生错误</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Short write while writing to &quot;</span></span><br><span class="line">                                       <span class="string">&quot;the AOF file: (nwritten=%lld, &quot;</span></span><br><span class="line">                                       <span class="string">&quot;expected=%lld)&quot;</span>,</span><br><span class="line">                                       (<span class="type">long</span> <span class="type">long</span>)nwritten,</span><br><span class="line">                                       (<span class="type">long</span> <span class="type">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将追加的内容截断，删除了追加的内容，恢复成原来的文件</span></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">&quot;Could not remove short write &quot;</span></span><br><span class="line">                             <span class="string">&quot;from the append-only file.  Redis may refuse &quot;</span></span><br><span class="line">                             <span class="string">&quot;to load the AOF the next time it starts.  &quot;</span></span><br><span class="line">                             <span class="string">&quot;ftruncate: %s&quot;</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是写入的策略为每次写入就同步，无法恢复这种策略的写，因为我们已经告知使用者，已经将写的数据同步到磁盘了，因此直接退出程序</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t recover from AOF write error when the AOF fsync policy is &#x27;always&#x27;. Exiting...&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//设置执行write操作的状态</span></span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line">            <span class="comment">// 如果只写入了局部，没有办法用ftruncate()函数去恢复原来的AOF文件</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 只能更新当前的AOF文件的大小</span></span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                <span class="comment">// 删除AOF缓冲区写入的字节数</span></span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* We&#x27;ll try again on the next call... */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nwritten == (signed)sdslen(server.aof_buf</span></span><br><span class="line">    <span class="comment">// 执行write写入成功</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></span><br><span class="line"><span class="comment">         * OK state and log the event. */</span></span><br><span class="line">        <span class="comment">// 更新最近一次写的状态为 C_OK</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;AOF write error looks solved, Redis can write again.&quot;</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只能更新当前的AOF文件的大小</span></span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个缓存足够小，小于4K，那么重用这个缓存，否则释放AOF缓存</span></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        sdsclear(server.aof_buf);   <span class="comment">//将缓存内容清空，重用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdsfree(server.aof_buf);    <span class="comment">//释放缓存空间</span></span><br><span class="line">        server.aof_buf = sdsempty();<span class="comment">//创建一个新缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果no-appendfsync-on-rewrite被设置为yes，表示正在执行重写，则不执行fsync</span></span><br><span class="line">    <span class="comment">// 或者正在执行 BGSAVE 或 BGWRITEAOF，也不执行</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</span><br><span class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行fsync进行同步，每次写入都同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        <span class="comment">// 设置延迟检测开始的时间</span></span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        <span class="comment">// Linux下调用fdatasync()函数更高效的执行同步</span></span><br><span class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let&#x27;s try to get this data on the disk */</span></span><br><span class="line">        <span class="comment">// 设置延迟的时间 = 当前的时间 - 开始的时间</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        <span class="comment">// 将latency和&quot;aof-fsync-always&quot;关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;aof-fsync-always&quot;</span>,latency);</span><br><span class="line">        <span class="comment">// 更新最近一次执行同步的时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每秒执行一次同步，当前时间大于上一次执行同步的时间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="comment">// 如果没有正在执行同步，那么在后台开一个线程执行同步</span></span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</span><br><span class="line">        <span class="comment">// 更新最近一次执行同步的时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2-AOF文件重写"><a href="#2-2-AOF文件重写" class="headerlink" title="2.2 AOF文件重写"></a>2.2 AOF文件重写</h3><p>为了解决AOF文件体积膨胀的问题，Redis 提供了AOF文件重写（rewrite）功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件。</p>
<p>新文件有以下特性：</p>
<ul>
<li>进程内已经超时的数据不在写入文件。</li>
<li>无效命令不在写入文件。</li>
<li>多条写的命令合并成一个。</li>
</ul>
<p><strong>触发机制</strong></p>
<ul>
<li>手动触发：<code>BGREWRITEAOF</code> 命令。</li>
<li>自动触发：根据<code>redis.conf</code>的两个参数确定触发的时机。<ul>
<li>auto-aof-rewrite-percentage。<br>100：当前AOF的文件空间<code>（aof_current_size）</code>和上一次重写后AOF文件空间<code>（aof_base_size）</code>的比值。</li>
<li>auto-aof-rewrite-min-size 64mb：表示运行AOF重写时文件最小的体积。</li>
<li>自动触发时机 &#x3D; (aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp; (aof_current_size - aof_base_size) &#x2F; aof_base_size &gt;&#x3D; auto-aof-rewrite-percentage)。</li>
</ul>
</li>
</ul>
<p><strong>重写的实现</strong></p>
<p>AOF重写操作可能会进行大量的写入操作，可能造成长时间阻塞,这时候服务器将无法处理客户端发来的命令请求。</p>
<p>所以Redis决定<code>fork()</code>一个子进程在后台执行。这样做可以达到两个目的：</p>
<ul>
<li>子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li>
</ul>
<p>不过， 使用子进程也有一个问题需要解决： 因为子进程在进行 AOF 重写期间， 主进程还需要继续处理命令， 而新的命令可能对现有的数据进行修改， 这会让当前数据库的数据和重写后的 AOF 文件中的数据不一致。</p>
<p>为了解决这个问题， Redis 增加了一个 AOF 重写缓存， 这个缓存在 fork 出子进程之后开始启用， Redis 主进程在接到新的写命令之后， 除了会将这个写命令的协议内容追加到现有的 AOF 文件之外， 还会追加到这个缓存中：</p>
<p><img src="https://img-blog.csdnimg.cn/49187a5cd71c4098836858d9939a4b92.png" alt="在这里插入图片描述"></p>
<p>接下来我们来看源码实现：</p>
<p>首先是AOF重写缓冲区的结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AOF缓冲区大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AOF_RW_BUF_BLOCK_SIZE (1024*1024*10)    <span class="comment">/* 10 MB per block */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AOF块缓冲区结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aofrwblock</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前已经使用的和可用的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used, <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[AOF_RW_BUF_BLOCK_SIZE];</span><br><span class="line">&#125; aofrwblock;</span><br></pre></td></tr></table></figure>
<p>重写缓冲区并不是一个大块的内存空间，而是一些内存块的链表，每个内存块的大小为10MB，这样就组成了一个重写缓冲区。</p>
<p>因此当客户端发来命令时，会执行以下操作：</p>
<ol>
<li>执行客户端的命令。</li>
<li>将执行后的写命令追加到AOF缓冲区<code>（server.aof_buf）</code>中。</li>
<li>将执行后的写命令追加到AOF重写缓冲区<code>（server.aof_rewrite_buf_blocks）</code>中。</li>
</ol>
<p>后台执行重写的操作源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是BGREWRITEAOF的工作步骤</span></span><br><span class="line"><span class="comment">// 1. 用户调用BGREWRITEAOF</span></span><br><span class="line"><span class="comment">// 2. Redis调用这个函数，它执行fork()</span></span><br><span class="line"><span class="comment">//      2.1 子进程在临时文件中执行重写操作</span></span><br><span class="line"><span class="comment">//      2.2 父进程将累计的差异数据追加到server.aof_rewrite_buf中</span></span><br><span class="line"><span class="comment">// 3. 当子进程完成2.1</span></span><br><span class="line"><span class="comment">// 4. 父进程会捕捉到子进程的退出码，如果是OK，那么追加累计的差异数据到临时文件，并且对临时文件rename，用它代替旧的AOF文件，然后就完成AOF的重写。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> childpid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在进行重写或正在进行RDB持久化操作，则返回C_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 创建父子进程间通信的管道</span></span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="comment">// 记录fork()开始时间</span></span><br><span class="line">    start = ustime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="comment">// 关闭监听的套接字</span></span><br><span class="line">        closeListeningSockets(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置进程名字</span></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-aof-rewrite&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建临时文件</span></span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-bg-%d.aof&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">        <span class="comment">// 对临时文件进行AOF重写</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            <span class="comment">// 获取子进程使用的内存空间大小</span></span><br><span class="line">            <span class="type">size_t</span> private_dirty = zmalloc_get_private_dirty();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">&quot;AOF rewrite: %zu MB of memory used by copy-on-write&quot;</span>,</span><br><span class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 成功退出子进程</span></span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异常退出子进程</span></span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父进程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="comment">// 设置fork()函数消耗的时间</span></span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        <span class="comment">// 计算fork的速率，GB/每秒</span></span><br><span class="line">        server.stat_fork_rate = (<span class="type">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></span><br><span class="line">        <span class="comment">// 将&quot;fork&quot;和fork消耗的时间关联到延迟诊断字典中</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">&quot;fork&quot;</span>,server.stat_fork_time/<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">&quot;Can&#x27;t rewrite append only file in background: fork: %s&quot;</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">&quot;Background append only file rewriting started by pid %d&quot;</span>,childpid);</span><br><span class="line">        <span class="comment">// 将AOF日程标志清零</span></span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// AOF开始的时间</span></span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 设置AOF重写的子进程pid</span></span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        <span class="comment">// 在AOF或RDB期间，不能对哈希表进行resize操作</span></span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        <span class="comment">// 将aof_selected_db设置为-1，强制让feedAppendOnlyFile函数执行时，执行一个select命令</span></span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 清空脚本缓存</span></span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>服务器主进程执行了<code>fork</code>操作生成一个子进程执行<code>rewriteAppendOnlyFile()</code>函数进行对临时文件的重写操作。</p>
<p><code>rewriteAppendOnlyFile()</code>函数源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写一系列的命令，用来完全重建数据集到filename文件中，被 REWRITEAOF and BGREWRITEAOF调用</span></span><br><span class="line"><span class="comment">// 为了使重建数据集的命令数量最小，Redis会使用 可变参的命令，例如RPUSH, SADD 和 ZADD。</span></span><br><span class="line"><span class="comment">// 然而每次单个命令的元素数量不能超过AOF_REWRITE_ITEMS_PER_CMD</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rewriteAppendOnlyFile</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    rio aof;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="type">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> now = mstime();</span><br><span class="line">    <span class="type">char</span> byte;</span><br><span class="line">    <span class="type">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建临时文件的名字保存到tmpfile中</span></span><br><span class="line">    <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">&quot;temp-rewriteaof-%d.aof&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">    <span class="comment">// 打开文件</span></span><br><span class="line">    fp = fopen(tmpfile,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;Opening the temp file for AOF rewrite in rewriteAppendOnlyFile(): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置一个空sds给 保存子进程AOF时差异累计数据的sds</span></span><br><span class="line">    server.aof_child_diff = sdsempty();</span><br><span class="line">    <span class="comment">// 初始化rio为文件io对象</span></span><br><span class="line">    rioInitWithFile(&amp;aof,fp);</span><br><span class="line">    <span class="comment">// 如果开启了增量时同步，防止在缓存中累计太多命令，造成写入时IO阻塞时间过长</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_rewrite_incremental_fsync)</span><br><span class="line">        <span class="comment">// 设置自动同步的字节数限制为AOF_AUTOSYNC_BYTES = 32MB</span></span><br><span class="line">        rioSetAutoSync(&amp;aof,AOF_AUTOSYNC_BYTES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        <span class="comment">// 按照格式构建 SELECT 命令内容</span></span><br><span class="line">        <span class="type">char</span> selectcmd[] = <span class="string">&quot;*2\r\n$6\r\nSELECT\r\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 当前数据库指针</span></span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        <span class="comment">// 数据库的键值对字典</span></span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="comment">// 如果数据库中没有键值对则跳过当前数据库</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 创建一个安全的字典迭代器</span></span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line">        <span class="keyword">if</span> (!di) &#123;</span><br><span class="line">            <span class="comment">// 创建失败返回C_ERR</span></span><br><span class="line">            fclose(fp);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将SELECT 命令写入AOF文件，确保后面的命令能正确载入到数据库</span></span><br><span class="line">        <span class="keyword">if</span> (rioWrite(&amp;aof,selectcmd,<span class="keyword">sizeof</span>(selectcmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="comment">// 将数据库的ID吸入AOF文件</span></span><br><span class="line">        <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,j) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历保存当前数据的键值对的字典</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sds keystr;</span><br><span class="line">            robj key, *o;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> expiretime;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前节点保存的键值</span></span><br><span class="line">            keystr = dictGetKey(de);</span><br><span class="line">            <span class="comment">// 当前节点保存的值对象</span></span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">            <span class="comment">// 初始化一个在栈中分配的键对象</span></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取该键值对的过期时间</span></span><br><span class="line">            expiretime = getExpire(db,&amp;key);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前键已经过期，则跳过该键</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据值的对象类型，将键值对写到AOF文件中</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 值为字符串类型对象</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type == OBJ_STRING) &#123;</span><br><span class="line">                <span class="type">char</span> cmd[]=<span class="string">&quot;*3\r\n$3\r\nSET\r\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 按格式写入SET命令</span></span><br><span class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="comment">/* Key and value */</span></span><br><span class="line">                <span class="comment">// 按格式写入键值对对象</span></span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为列表类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">                <span class="comment">// 重建一个列表对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteListObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为集合类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">                <span class="comment">// 重建一个集合对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为有序集合类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">                <span class="comment">// 重建一个有序集合对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteSortedSetObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            <span class="comment">// 值为哈希类型对象</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH) &#123;</span><br><span class="line">                <span class="comment">// 重建一个哈希对象命令，将键值对按格式写入</span></span><br><span class="line">                <span class="keyword">if</span> (rewriteHashObject(&amp;aof,&amp;key,o) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;Unknown object type&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果该键有过期时间，且没过期，写入过期时间</span></span><br><span class="line">            <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> cmd[]=<span class="string">&quot;*3\r\n$9\r\nPEXPIREAT\r\n&quot;</span>;</span><br><span class="line">                <span class="comment">// 将过期键时间全都以Unix时间写入</span></span><br><span class="line">                <span class="keyword">if</span> (rioWrite(&amp;aof,cmd,<span class="keyword">sizeof</span>(cmd)<span class="number">-1</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkObject(&amp;aof,&amp;key) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">                <span class="keyword">if</span> (rioWriteBulkLongLong(&amp;aof,expiretime) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在rio的缓存中每次写了10M，就从父进程读累计的差异，保存到子进程的aof_child_diff中</span></span><br><span class="line">            <span class="keyword">if</span> (aof.processed_bytes &gt; processed+<span class="number">1024</span>*<span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新已写的字节数</span></span><br><span class="line">                processed = aof.processed_bytes;</span><br><span class="line">                <span class="comment">// 从父进程读累计写入的缓冲区的差异，在重写结束时链接到文件的结尾</span></span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);    <span class="comment">//释放字典迭代器</span></span><br><span class="line">        di = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当父进程仍然在发送数据时，先执行一个缓慢的同步，以便下一次最中的同步更快</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次从父进程读取几次数据，以获得更多的数据，我们无法一直读取，因为服务器从client接受的数据总是比发送给子进程要快，所以当数据来临的时候，我们尝试从在循环中多次读取。</span></span><br><span class="line">    <span class="comment">// 如果在20ms之内没有新的数据到来，那么我们终止读取</span></span><br><span class="line">    <span class="type">int</span> nodata = <span class="number">0</span>;</span><br><span class="line">    <span class="type">mstime_t</span> start = mstime();  <span class="comment">//读取的开始时间</span></span><br><span class="line">    <span class="comment">// 在20ms之内等待数据到来</span></span><br><span class="line">    <span class="keyword">while</span>(mstime()-start &lt; <span class="number">1000</span> &amp;&amp; nodata &lt; <span class="number">20</span>) &#123;</span><br><span class="line">        <span class="comment">// 在1ms之内，查看从父进程读数据的fd是否变成可读的，若不可读则aeWait()函数返回0</span></span><br><span class="line">        <span class="keyword">if</span> (aeWait(server.aof_pipe_read_data_from_parent, AE_READABLE, <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nodata++;   <span class="comment">//更新新数据到来的时间，超过20ms则退出while循环</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当管道的读端可读时，清零nodata</span></span><br><span class="line">        nodata = <span class="number">0</span>; <span class="comment">/* Start counting from zero, we stop on N *contiguous* timeouts. */</span></span><br><span class="line">        <span class="comment">// 从父进程读累计写入的缓冲区的差异，在重写结束时链接到文件的结尾</span></span><br><span class="line">        aofReadDiffFromParent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求父进程停止发送累计差异数据</span></span><br><span class="line">    <span class="keyword">if</span> (write(server.aof_pipe_write_ack_to_parent,<span class="string">&quot;!&quot;</span>,<span class="number">1</span>) != <span class="number">1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 将从父进程读ack的fd设置为非阻塞模式</span></span><br><span class="line">    <span class="keyword">if</span> (anetNonBlock(<span class="literal">NULL</span>,server.aof_pipe_read_ack_from_parent) != ANET_OK)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 在5000ms之内，从fd读1个字节的数据保存在byte中，查看byte是否是&#x27;!&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (syncRead(server.aof_pipe_read_ack_from_parent,&amp;byte,<span class="number">1</span>,<span class="number">5000</span>) != <span class="number">1</span> ||</span><br><span class="line">        byte != <span class="string">&#x27;!&#x27;</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="comment">// 如果收到的是父进程发来的&#x27;!&#x27;，则打印日志</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Parent agreed to stop sending diffs. Finalizing AOF...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次从父进程读累计写入的缓冲区的差异</span></span><br><span class="line">    aofReadDiffFromParent();</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">&quot;Concatenating %.2f MB of AOF diff received from parent.&quot;</span>,</span><br><span class="line">        (<span class="type">double</span>) sdslen(server.aof_child_diff) / (<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">    <span class="comment">// 将子进程aof_child_diff中保存的差异数据写到AOF文件中</span></span><br><span class="line">    <span class="keyword">if</span> (rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次冲洗文件缓冲区，执行同步操作</span></span><br><span class="line">    <span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;   <span class="comment">//关闭文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子性的将临时文件的名字，改成appendonly.aof</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error moving temp append only file on the final destination: %s&quot;</span>, strerror(errno));</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印日志</span></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;SYNC append only file rewrite performed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写错误处理</span></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Write error writing append only file on disk: %s&quot;</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>我们可以看到在关闭文件之前，多次执行了从重写缓冲区做读操作的<code>aofReadDiffFromParent()</code>。</p>
<p>在最后执行了<code>rioWrite(&amp;aof,server.aof_child_diff,sdslen(server.aof_child_diff)</code>操作，这就是把AOF重写缓冲区保存服务器主进程新命令追加写到AOF文件中，以此保证了AOF文件的数据状态和数据库的状态一致。</p>
<p><strong>父子进程之间的通信</strong></p>
<p>整个重写的过程中，父子进行通信的地方只有一个，那就是最后父进程在子进程做重写操作完成时，把子进程重写操作期间所执行的新命令发送给子进程的重写缓冲区，子进程然后将重写缓冲区的数据追加到AOF文件中。</p>
<p>而父进程是如何将差异数据发送给子进程呢？Redis中使用的是管道技术。</p>
<h3 id="2-3-AOF文件载入"><a href="#2-3-AOF文件载入" class="headerlink" title="2.3 AOF文件载入"></a>2.3 AOF文件载入</h3><p>因为Redis命令总是在一个客户端中执行，因此，为了载入AOF文件，需要创建一个关闭监听套接字的伪客户端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行AOF文件中的命令</span></span><br><span class="line"><span class="comment">// 成功返回C_OK，出现非致命错误返回C_ERR，例如AOF文件长度为0，出现致命错误打印日志退出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadAppendOnlyFile</span><span class="params">(<span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> *<span class="title">fakeClient</span>;</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">&quot;r&quot;</span>); <span class="comment">//以读打开AOF文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="type">int</span> old_aof_state = server.aof_state;   <span class="comment">//备份当前AOF的状态</span></span><br><span class="line">    <span class="type">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="type">off_t</span> valid_up_to = <span class="number">0</span>; <span class="comment">/* Offset of the latest well-formed command loaded. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件打开，但是大小为0，则返回C_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果文件打开失败，打印日志，退出</span></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Fatal error: can&#x27;t open the append log file for reading: %s&quot;</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily disable AOF, to prevent EXEC from feeding a MULTI</span></span><br><span class="line"><span class="comment">     * to the same file we&#x27;re about to read. */</span></span><br><span class="line">    <span class="comment">// 暂时关闭AOF，防止在执行MULTI时，EXEC命令被传播到AOF文件中</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成一个伪client</span></span><br><span class="line">    fakeClient = createFakeClient();</span><br><span class="line">    <span class="comment">// 设置载入的状态信息</span></span><br><span class="line">    startLoading(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> argc, j;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Serve the clients from time to time */</span></span><br><span class="line">        <span class="comment">// 间隔性的处理client请求</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            <span class="comment">// ftello(fp)返回当前文件载入的偏移量</span></span><br><span class="line">            <span class="comment">// 设置载入时server的状态信息，更新当前载入的进度</span></span><br><span class="line">            loadingProgress(ftello(fp));</span><br><span class="line">            <span class="comment">// 在服务器被阻塞的状态下，仍然能处理请求</span></span><br><span class="line">            <span class="comment">// 因为当前处于载入状态，当client的请求到来时，总是返回loading的状态错误</span></span><br><span class="line">            processEventsWhileBlocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一行文件内容读到buf中，遇到&quot;\r\n&quot;停止</span></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(fp))   <span class="comment">//如果文件已经读完了或数据库为空，则跳出while循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查文件格式 &quot;*&lt;argc&gt;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        <span class="comment">// 取出命令参数个数</span></span><br><span class="line">        argc = atoi(buf+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;  <span class="comment">//至少一个参数，就是当前命令</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配参数列表空间</span></span><br><span class="line">        argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        <span class="comment">// 设置伪client的参数列表</span></span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历参数列表</span></span><br><span class="line">        <span class="comment">// &quot;$&lt;command_len&gt;\r\n&lt;command&gt;\r\n&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="comment">// 读一行内容到buf中，遇到&quot;\r\n&quot;停止</span></span><br><span class="line">            <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查格式</span></span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">            <span class="comment">// 读出参数的长度len</span></span><br><span class="line">            len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            <span class="comment">// 初始化一个len长度的sds</span></span><br><span class="line">            argsds = sdsnewlen(<span class="literal">NULL</span>,len);</span><br><span class="line">            <span class="comment">// 从文件中读出一个len字节长度，将值保存到argsds中</span></span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                sdsfree(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 创建一个字符串对象保存读出的参数argsds</span></span><br><span class="line">            argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line">            <span class="comment">// 读两个字节，跳过&quot;\r\n&quot;</span></span><br><span class="line">            <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr; <span class="comment">/* discard CRLF */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Command lookup */</span></span><br><span class="line">        <span class="comment">// 查找命令</span></span><br><span class="line">        cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">&quot;Unknown command &#x27;%s&#x27; reading the append only file&quot;</span>, (<span class="type">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Run the command in the context of a fake client */</span></span><br><span class="line">        <span class="comment">// 调用伪client执行命令</span></span><br><span class="line">        cmd-&gt;proc(fakeClient);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The fake client should not have a reply */</span></span><br><span class="line">        <span class="comment">// 伪client不应该有回复</span></span><br><span class="line">        serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* The fake client should never get blocked */</span></span><br><span class="line">        <span class="comment">// 伪client不应该是阻塞的</span></span><br><span class="line">        serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Clean up. Command code may have changed argv/argc so we use the</span></span><br><span class="line"><span class="comment">         * argv/argc of the client instead of the local variables. */</span></span><br><span class="line">        <span class="comment">// 释放伪client的参数列表</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        <span class="comment">// 更新已载入且命令合法的当前文件的偏移量</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This point can only be reached when EOF is reached without errors.</span></span><br><span class="line"><span class="comment">     * If the client is in the middle of a MULTI/EXEC, log error and quit. */</span></span><br><span class="line">    <span class="comment">// 执行到这里，说明AOF文件的所有内容都被正确的读取</span></span><br><span class="line">    <span class="comment">// 如果伪client处于 MULTI/EXEC 的环境中，还有检测文件是否包含正确事物的结束，调到uxeof</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) <span class="keyword">goto</span> uxeof;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 载入成功</span></span><br><span class="line">loaded_ok: <span class="comment">/* DB loaded, cleanup and return C_OK to the caller. */</span></span><br><span class="line">    fclose(fp); <span class="comment">//关闭文件</span></span><br><span class="line">    freeFakeClient(fakeClient); <span class="comment">//释放伪client</span></span><br><span class="line">    server.aof_state = old_aof_state;   <span class="comment">//还原AOF状态</span></span><br><span class="line">    stopLoading();  <span class="comment">//设置载入完成的状态</span></span><br><span class="line">    aofUpdateCurrentSize(); <span class="comment">//更新服务器状态，当前AOF文件的大小</span></span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size; <span class="comment">//更新重写的大小</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 载入时读错误，如果feof(fp)为真，则直接执行 uxeof</span></span><br><span class="line">readerr: <span class="comment">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="comment">// 退出前释放伪client的空间</span></span><br><span class="line">        <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unrecoverable error reading the append only file: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不被预期的AOF文件结束格式</span></span><br><span class="line">uxeof: <span class="comment">/* Unexpected AOF end of file. */</span></span><br><span class="line">    <span class="comment">// 如果发现末尾结束格式不完整则自动截掉,成功加载前面正确的数据。</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Warning: short read while loading the AOF file !!!&quot;</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;!!! Truncating the AOF at offset %llu !!!&quot;</span>,</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) valid_up_to);</span><br><span class="line">        <span class="comment">// 截断文件到正确加载的位置</span></span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || truncate(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Last valid command offset is invalid&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Error truncating the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure the AOF file descriptor points to the end of the</span></span><br><span class="line"><span class="comment">             * file after the truncate call. */</span></span><br><span class="line">            <span class="comment">// 确保截断后的文件指针指向文件的末尾</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; lseek(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Can&#x27;t seek the end of the AOF file: %s&quot;</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;AOF loaded anyway because aof-load-truncated is enabled&quot;</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok; <span class="comment">//跳转到loaded_ok，表截断成功，成功加载前面正确的数据。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出前释放伪client的空间</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &#x27;aof-load-truncated&#x27; configuration option to yes and restart the server.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式错误</span></span><br><span class="line">fmterr: <span class="comment">/* Format error. */</span></span><br><span class="line">    <span class="comment">// 退出前释放伪client的空间</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 2.链表</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%202.%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表. 当一个列表键包含了数量比较多的元素，又或者列表键中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现（短的话用压缩列表）.</p>
<p>除了链表键之外，发布与订阅、慢查询、监视器等功能也用到了链表，Redis 服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区（outputbuffer）.</p>
<p>在redis中，链表结构被实现为双端链表，因此，在头部和尾部进行的操作就会非常快.</p>
<h2 id="2-链表的实现"><a href="#2-链表的实现" class="headerlink" title="2. 链表的实现"></a>2. 链表的实现</h2><p>Redis的链表结构被定义在<code>adlist.h</code>和<code>adlist.c</code>中.</p>
<h3 id="2-1-链表节点的实现"><a href="#2-1-链表节点的实现" class="headerlink" title="2.1 链表节点的实现"></a>2.1 链表节点的实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">	<span class="comment">// 前驱节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 万能指针，用于保存节点的值</span></span><br><span class="line">    <span class="type">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure>

<p>多个listNode可以通过prev和next指针组成双端链表，好处是可以让获取某个节点的前驱节点和后继节点的复杂度为<code>O(1)</code>.</p>
<p><img src="https://img-blog.csdnimg.cn/cc86969364be4589b91e5c21c44ec518.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-表头的实现"><a href="#2-2-表头的实现" class="headerlink" title="2.2 表头的实现"></a>2.2 表头的实现</h3><p>Redis还为双端链表提供了一个表头，用于存放链表的信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">	<span class="comment">// 链表头结点指针</span></span><br><span class="line">    listNode *head;   </span><br><span class="line">    <span class="comment">// 链表尾结点指针      </span></span><br><span class="line">    listNode *tail;         </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的三个函数指针就像类中的成员函数一样</span></span><br><span class="line">    <span class="comment">// 复制链表节点保存的值</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);   </span><br><span class="line">    <span class="comment">// 释放链表节点保存的值 </span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 比较链表节点所保存的节点值和另一个输入的值是否相等   </span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key); </span><br><span class="line">    <span class="comment">// 链表长度计数器</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>下图是一个由表头和三个节点组成的链表：</p>
<p><img src="https://img-blog.csdnimg.cn/24168a557b54487e9807d282e1a029dd.png" alt="在这里插入图片描述"></p>
<h2 id="3-双端链表的优点"><a href="#3-双端链表的优点" class="headerlink" title="3. 双端链表的优点"></a>3. 双端链表的优点</h2><p><strong>1. 双端</strong></p>
<p>链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是<code>O(1)</code>. </p>
<p><strong>2. 无环</strong></p>
<p>表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点. </p>
<p><strong>3. 带表头指针和表尾指针</strong></p>
<p>通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为<code>O(1)</code>.</p>
<p><strong>4. 带链表长度计数器</strong></p>
<p>程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为<code>O(1)</code>.</p>
<p><strong>5. 多态</strong></p>
<p>链表节点使用<code>void*</code>指针来保存节点值，并且可以通过list结构的<code>dup</code>、<code>free</code>、<code>match</code>三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值.</p>
<h2 id="4-部分源码剖析"><a href="#4-部分源码剖析" class="headerlink" title="4. 部分源码剖析"></a>4. 部分源码剖析</h2><h3 id="4-1-迭代器"><a href="#4-1-迭代器" class="headerlink" title="4.1 迭代器"></a>4.1 迭代器</h3><p>Redis为双端链表封装了一个迭代器，可以使用迭代器对链表执行遍历操作.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正向迭代</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_HEAD 0</span></span><br><span class="line"><span class="comment">// 反向迭代    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AL_START_TAIL 1     </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">	<span class="comment">// 迭代器当前指向的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="comment">// 迭代方向，可以取以下两个值：AL_START_HEAD 和 AL_START_TAIL</span></span><br><span class="line">    <span class="type">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为list创建一个迭代器iterator</span></span><br><span class="line">listIter *<span class="title function_">listGetIterator</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">int</span> direction)</span> &#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">	<span class="comment">// 为迭代器申请空间</span></span><br><span class="line">    <span class="keyword">if</span> ((iter = zmalloc(<span class="keyword">sizeof</span>(*iter))) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置迭代指针的起始位置</span></span><br><span class="line">    <span class="keyword">if</span> (direction == AL_START_HEAD)     </span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter-&gt;next = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">    <span class="comment">// 设置迭代方向</span></span><br><span class="line">    iter-&gt;direction = direction;        </span><br><span class="line">    <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁迭代器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listReleaseIterator</span><span class="params">(listIter *iter)</span> &#123;</span><br><span class="line">    zfree(iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将迭代器li重置为list的头结点并且设置为正向迭代</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewind</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">	<span class="comment">// 设置迭代指针的起始位置</span></span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 设置迭代方向从头到尾           </span></span><br><span class="line">    li-&gt;direction = AL_START_HEAD;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将迭代器li重置为list的尾结点并且设置为反向迭代</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRewindTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listIter *li)</span> &#123;</span><br><span class="line">	<span class="comment">// 设置迭代指针的起始位置</span></span><br><span class="line">    li-&gt;next = <span class="built_in">list</span>-&gt;tail;        </span><br><span class="line">    <span class="comment">// 设置迭代方向从尾到头      </span></span><br><span class="line">    li-&gt;direction = AL_START_TAIL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回迭代器iter指向的当前节点并更新iter</span></span><br><span class="line">listNode *<span class="title function_">listNext</span><span class="params">(listIter *iter)</span> &#123;</span><br><span class="line">	<span class="comment">// 备份当前迭代器指向的节点</span></span><br><span class="line">    listNode *current = iter-&gt;next; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    <span class="comment">// 根据迭代方向更新迭代指针</span></span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)   </span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回备份的当前节点地址</span></span><br><span class="line">    <span class="keyword">return</span> current;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-链表的创建和销毁"><a href="#4-2-链表的创建和销毁" class="headerlink" title="4.2 链表的创建和销毁"></a>4.2 链表的创建和销毁</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个表头</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listCreate</span><span class="params">(<span class="type">void</span>)</span>  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为表头分配内存</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">list</span> = zmalloc(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 初始化表头</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;dup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">free</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;match = <span class="literal">NULL</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 返回表头</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁list表头和链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listRelease</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    listNode *current, *next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 备份头节点地址</span></span><br><span class="line">    current = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="comment">// 备份链表元素个数，使用备份操作防止更改原有信息</span></span><br><span class="line">    len = <span class="built_in">list</span>-&gt;len;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(len--) &#123;          </span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        <span class="comment">// 如果设置了list结构的释放函数，则调用该函数释放节点值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(current-&gt;value);</span><br><span class="line">        zfree(current);</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后释放表头</span></span><br><span class="line">    zfree(<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-头插和尾插"><a href="#4-3-头插和尾插" class="headerlink" title="4.3 头插和尾插"></a>4.3 头插和尾插</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将value添加到list链表的头部</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeHead</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span> &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新节点分配空间</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置node的value值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将node头插到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 将node头插到非空链表</span></span><br><span class="line">        node-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;prev = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 链表元素计数器加1</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将value添加到list链表的尾部</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listAddNodeTail</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *value)</span> &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新节点分配空间</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置node的value值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="comment">// 将node尾插到空链表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        node-&gt;prev = node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// 将node头插到非空链表</span></span><br><span class="line">        node-&gt;prev = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = node;</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新链表节点计数器</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-4-根据某个节点的位置插入一个值"><a href="#4-4-根据某个节点的位置插入一个值" class="headerlink" title="4.4 根据某个节点的位置插入一个值"></a>4.4 根据某个节点的位置插入一个值</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在list中，根据after在old_node节点前后插入值为value的节点</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listInsertNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *old_node, <span class="type">void</span> *value, <span class="type">int</span> after)</span> &#123;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为新节点分配空间</span></span><br><span class="line">    <span class="keyword">if</span> ((node = zmalloc(<span class="keyword">sizeof</span>(*node))) == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 设置node的value值</span></span><br><span class="line">    node-&gt;value = value;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// after 非零，则将节点插入到old_node的后面</span></span><br><span class="line">    <span class="keyword">if</span> (after) &#123;    </span><br><span class="line">        node-&gt;prev = old_node;</span><br><span class="line">        node-&gt;next = old_node-&gt;next;</span><br><span class="line">        <span class="comment">// 目标节点如果是链表的尾节点，更新list的tail指针</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail == old_node) &#123;   </span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// after 为零，则将节点插入到old_node的前面</span></span><br><span class="line">        node-&gt;next = old_node;</span><br><span class="line">        node-&gt;prev = old_node-&gt;prev;</span><br><span class="line">        <span class="comment">// 如果节点如果是链表的头节点，更新list的head指针</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == old_node) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有，则更新node的前驱节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev != <span class="literal">NULL</span>) &#123;   </span><br><span class="line">        node-&gt;prev-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有，则更新node的后继节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        node-&gt;next-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新链表节点计数器</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-5-删除节点"><a href="#4-5-删除节点" class="headerlink" title="4.5 删除节点"></a>4.5 删除节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">listDelNode</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, listNode *node)</span> &#123;</span><br><span class="line">	<span class="comment">// 更新node的前驱节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;prev) </span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;head = node-&gt;next;</span><br><span class="line">    <span class="comment">// 更新node的后继节点的指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;next) </span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;tail = node-&gt;prev;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果设置了list结构的释放函数，则调用该函数释放节点值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;<span class="built_in">free</span>) <span class="built_in">list</span>-&gt;<span class="built_in">free</span>(node-&gt;value);</span><br><span class="line">    <span class="comment">// 释放节点</span></span><br><span class="line">    zfree(node);</span><br><span class="line">    <span class="comment">// 更新链表节点计数器</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-查找节点"><a href="#4-6-查找节点" class="headerlink" title="4.6 查找节点"></a>4.6 查找节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在list中查找value为key的节点并返回</span></span><br><span class="line">listNode *<span class="title function_">listSearchKey</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">void</span> *key)</span></span><br><span class="line">&#123;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建迭代器</span></span><br><span class="line">    iter = listGetIterator(<span class="built_in">list</span>, AL_START_HEAD);</span><br><span class="line">    <span class="comment">// 迭代整个链表</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	<span class="comment">// 如果设置list结构中的match方法，则用该方法比较</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match) &#123;                          </span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;match(node-&gt;value, key)) &#123;</span><br><span class="line">	            <span class="comment">// 如果找到，释放迭代器返回node地址</span></span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;value) &#123;</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回下标为index的节点地址</span></span><br><span class="line">listNode *<span class="title function_">listIndex</span><span class="params">(<span class="built_in">list</span> *<span class="built_in">list</span>, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">    listNode *n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 如果下标为负数，从链表尾部开始</span></span><br><span class="line">        index = (-index)<span class="number">-1</span>;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;tail;</span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        n = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">        <span class="comment">// 如果下标为正数，从链表头部开始</span></span><br><span class="line">        <span class="keyword">while</span>(index-- &amp;&amp; n) n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-拷贝链表"><a href="#4-7-拷贝链表" class="headerlink" title="4.7 拷贝链表"></a>4.7 拷贝链表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝表头为orig的链表并返回</span></span><br><span class="line"><span class="built_in">list</span> *<span class="title function_">listDup</span><span class="params">(<span class="built_in">list</span> *orig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span> *copy;</span><br><span class="line">    listIter *iter;</span><br><span class="line">    listNode *node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个表头</span></span><br><span class="line">    <span class="keyword">if</span> ((copy = listCreate()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新建表头的处理函数</span></span><br><span class="line">    copy-&gt;dup = orig-&gt;dup;</span><br><span class="line">    copy-&gt;<span class="built_in">free</span> = orig-&gt;<span class="built_in">free</span>;</span><br><span class="line">    copy-&gt;match = orig-&gt;match;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 迭代整个orig的链表</span></span><br><span class="line">    <span class="comment">// 为orig定义一个迭代器并设置迭代方向</span></span><br><span class="line">    iter = listGetIterator(orig, AL_START_HEAD);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 迭代器根据迭代方向不停迭代</span></span><br><span class="line">    <span class="keyword">while</span>((node = listNext(iter)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">void</span> *value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制节点值到新节点</span></span><br><span class="line">        <span class="keyword">if</span> (copy-&gt;dup) &#123;</span><br><span class="line">	        <span class="comment">// 如果定义了list结构中的dup指针，则使用该方法拷贝节点值</span></span><br><span class="line">            value = copy-&gt;dup(node-&gt;value); </span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                listRelease(copy);</span><br><span class="line">                listReleaseIterator(iter);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">	        <span class="comment">// 获得当前node的value值</span></span><br><span class="line">            value = node-&gt;value;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将node节点尾插到copy表头的链表中</span></span><br><span class="line">        <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            listRelease(copy);</span><br><span class="line">            listReleaseIterator(iter);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自行释放迭代器</span></span><br><span class="line">    listReleaseIterator(iter);</span><br><span class="line">    <span class="comment">// 返回拷贝副本</span></span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 18.Redis网络连接库分析</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%2018.Redis%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E5%BA%93%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="1-Redis网络连接库介绍"><a href="#1-Redis网络连接库介绍" class="headerlink" title="1. Redis网络连接库介绍"></a>1. Redis网络连接库介绍</h2><p>Redis网络连接库对应的文件是<code>networking.c</code>，这个文件主要负责：</p>
<ul>
<li>客户端的创建与释放.</li>
<li>命令接收与命令回复.</li>
<li>Redis通信协议分析.</li>
<li>CLIENT 命令的实现.</li>
</ul>
<h2 id="2-客户端的创建与释放"><a href="#2-客户端的创建与释放" class="headerlink" title="2. 客户端的创建与释放"></a>2. 客户端的创建与释放</h2><h3 id="2-1-客户端的创建"><a href="#2-1-客户端的创建" class="headerlink" title="2.1 客户端的创建"></a>2.1 客户端的创建</h3><p>Redis服务器是一个同时与多个客户端建立连接的程序. 当客户端连接上服务器时，服务器会建立一个<code>server.h/client</code>结构来保存客户端的状态信息.<br><code>server.h/client</code>结构如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// client独一无二的ID</span></span><br><span class="line">    <span class="type">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    <span class="comment">// client的套接字</span></span><br><span class="line">    <span class="type">int</span> fd;                 <span class="comment">/* Client socket. */</span></span><br><span class="line">    <span class="comment">// 指向当前的数据库</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line">    <span class="comment">// 保存指向数据库的ID</span></span><br><span class="line">    <span class="type">int</span> dictid;             <span class="comment">/* ID of the currently SELECTed DB. */</span></span><br><span class="line">    <span class="comment">// client的名字</span></span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME. */</span></span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="comment">// 输入缓存的峰值</span></span><br><span class="line">    <span class="type">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size. */</span></span><br><span class="line">    <span class="comment">// client输入命令时，参数的数量</span></span><br><span class="line">    <span class="type">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    <span class="comment">// client输入命令的参数列表</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="comment">// 保存客户端执行命令的历史记录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    <span class="comment">// 请求协议类型，内联或者多条命令</span></span><br><span class="line">    <span class="type">int</span> reqtype;            <span class="comment">/* Request protocol type: PROTO_REQ_* */</span></span><br><span class="line">    <span class="comment">// 参数列表中未读取命令参数的数量，读取一个，该值减1</span></span><br><span class="line">    <span class="type">int</span> multibulklen;       <span class="comment">/* Number of multi bulk arguments left to read. */</span></span><br><span class="line">    <span class="comment">// 命令内容的长度</span></span><br><span class="line">    <span class="type">long</span> bulklen;           <span class="comment">/* Length of bulk argument in multi bulk request. */</span></span><br><span class="line">    <span class="comment">// 回复缓存列表，用于发送大于固定回复缓冲区的回复</span></span><br><span class="line">    <span class="built_in">list</span> *reply;            <span class="comment">/* List of reply objects to send to the client. */</span></span><br><span class="line">    <span class="comment">// 回复缓存列表对象的总字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list. */</span></span><br><span class="line">    <span class="comment">// 已发送的字节数或对象的字节数</span></span><br><span class="line">    <span class="type">size_t</span> sentlen;         <span class="comment">/* Amount of bytes already sent in the current</span></span><br><span class="line"><span class="comment">                               buffer or object being sent. */</span></span><br><span class="line">    <span class="comment">// client创建所需时间</span></span><br><span class="line">    <span class="type">time_t</span> ctime;           <span class="comment">/* Client creation time. */</span></span><br><span class="line">    <span class="comment">// 最后一次和服务器交互的时间</span></span><br><span class="line">    <span class="type">time_t</span> lastinteraction; <span class="comment">/* Time of the last interaction, used for timeout */</span></span><br><span class="line">    <span class="comment">// 客户端的输出缓冲区超过软性限制的时间，记录输出缓冲区第一次到达软性限制的时间</span></span><br><span class="line">    <span class="type">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="comment">// client状态的标志</span></span><br><span class="line">    <span class="type">int</span> flags;              <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line">    <span class="comment">// 认证标志，0表示未认证，1表示已认证</span></span><br><span class="line">    <span class="type">int</span> authenticated;      <span class="comment">/* When requirepass is non-NULL. */</span></span><br><span class="line">    <span class="comment">// 从节点的复制状态</span></span><br><span class="line">    <span class="type">int</span> replstate;          <span class="comment">/* Replication state if this is a slave. */</span></span><br><span class="line">    <span class="comment">// 在ack上设置从节点的写处理器，是否在slave向master发送ack，</span></span><br><span class="line">    <span class="type">int</span> repl_put_online_on_ack; <span class="comment">/* Install slave write handler on ACK. */</span></span><br><span class="line">    <span class="comment">// 保存主服务器传来的RDB文件的文件描述符</span></span><br><span class="line">    <span class="type">int</span> repldbfd;           <span class="comment">/* Replication DB file descriptor. */</span></span><br><span class="line">    <span class="comment">// 读取主服务器传来的RDB文件的偏移量</span></span><br><span class="line">    <span class="type">off_t</span> repldboff;        <span class="comment">/* Replication DB file offset. */</span></span><br><span class="line">    <span class="comment">// 主服务器传来的RDB文件的大小</span></span><br><span class="line">    <span class="type">off_t</span> repldbsize;       <span class="comment">/* Replication DB file size. */</span></span><br><span class="line">    <span class="comment">// 主服务器传来的RDB文件的大小，符合协议的字符串形式</span></span><br><span class="line">    sds replpreamble;       <span class="comment">/* Replication DB preamble. */</span></span><br><span class="line">    <span class="comment">// replication复制的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> reploff;      <span class="comment">/* Replication offset if this is our master. */</span></span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_off; <span class="comment">/* Replication ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量所用的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> repl_ack_time;<span class="comment">/* Replication ack time, if this is a slave. */</span></span><br><span class="line">    <span class="comment">// FULLRESYNC回复给从节点的offset</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> psync_initial_offset; <span class="comment">/* FULLRESYNC reply offset other slaves</span></span><br><span class="line"><span class="comment">                                       copying this slave output buffer</span></span><br><span class="line"><span class="comment">                                       should use. */</span></span><br><span class="line">    <span class="type">char</span> replrunid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* Master run id if is a master. */</span></span><br><span class="line">    <span class="comment">// 从节点的端口号</span></span><br><span class="line">    <span class="type">int</span> slave_listening_port; <span class="comment">/* As configured with: REPLCONF listening-port */</span></span><br><span class="line">    <span class="comment">// 从节点IP地址</span></span><br><span class="line">    <span class="type">char</span> slave_ip[NET_IP_STR_LEN]; <span class="comment">/* Optionally given by REPLCONF ip-address */</span></span><br><span class="line">    <span class="comment">// 从节点的功能</span></span><br><span class="line">    <span class="type">int</span> slave_capa;         <span class="comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事物状态</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    <span class="type">int</span> btype;              <span class="comment">/* Type of blocking op if CLIENT_BLOCKED. */</span></span><br><span class="line">    <span class="comment">// 阻塞的状态</span></span><br><span class="line">    blockingState bpop;     <span class="comment">/* blocking state */</span></span><br><span class="line">    <span class="comment">// 最近一个写全局的复制偏移量</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> woff;         <span class="comment">/* Last write global replication offset. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控列表</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="comment">// 订阅频道</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    <span class="comment">// 订阅的模式</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    <span class="comment">// 被缓存的ID</span></span><br><span class="line">    sds peerid;             <span class="comment">/* Cached peer ID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Response buffer */</span></span><br><span class="line">    <span class="comment">// 回复固定缓冲区的偏移量</span></span><br><span class="line">    <span class="type">int</span> bufpos;</span><br><span class="line">    <span class="comment">// 回复固定缓冲区</span></span><br><span class="line">    <span class="type">char</span> buf[PROTO_REPLY_CHUNK_BYTES];</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>

<p>创建客户端的源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的client</span></span><br><span class="line">client *<span class="title function_">createClient</span><span class="params">(<span class="type">int</span> fd)</span> &#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));    <span class="comment">//分配空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果fd为-1，表示创建的是一个无网络连接的伪客户端，用于执行lua脚本的时候</span></span><br><span class="line">    <span class="comment">// 如果fd不等于-1，表示创建一个有网络连接的客户端</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置fd为非阻塞模式</span></span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 禁止使用 Nagle 算法，client向内核递交的每个数据包都会立即发送给server出去，TCP_NODELAY</span></span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 如果开启了tcpkeepalive，则设置 SO_KEEPALIVE</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            <span class="comment">// 设置tcp连接的keep alive选项</span></span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 创建一个文件事件状态el，且监听读事件，开始接受命令的输入</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认选0号数据库</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 设置client的ID</span></span><br><span class="line">    c-&gt;id = server.next_client_id++;</span><br><span class="line">    <span class="comment">// client的套接字</span></span><br><span class="line">    c-&gt;fd = fd;</span><br><span class="line">    <span class="comment">// client的名字</span></span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 回复固定(静态)缓冲区的偏移量</span></span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输入缓存区</span></span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    <span class="comment">// 输入缓存区的峰值</span></span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 请求协议类型，内联或者多条命令，初始化为0</span></span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 参数个数</span></span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 参数列表</span></span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 当前执行的命令和最近一次执行的命令</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查询缓冲区剩余未读取命令的数量</span></span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读入参数的长度</span></span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 已发的字节数</span></span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// client的状态</span></span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置创建client的时间和最后一次互动的时间</span></span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 认证状态</span></span><br><span class="line">    c-&gt;authenticated = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// replication复制的状态，初始为无</span></span><br><span class="line">    c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">    <span class="comment">// 设置从节点的写处理器为ack，是否在slave向master发送ack</span></span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// replication复制的偏移量</span></span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量</span></span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过ack命令接收到的偏移量所用的时间</span></span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从节点的端口号</span></span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从节点IP地址</span></span><br><span class="line">    c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 从节点的功能</span></span><br><span class="line">    c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line">    <span class="comment">// 回复链表</span></span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    <span class="comment">// 回复链表的字节数</span></span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复缓冲区的内存大小软限制</span></span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复链表的释放和复制方法</span></span><br><span class="line">    listSetFreeMethod(c-&gt;reply,decrRefCountVoid);</span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    <span class="comment">// 阻塞超过时间</span></span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 造成阻塞的键字典</span></span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 存储解除阻塞的键，用于保存PUSH入元素的键，也就是dstkey</span></span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 阻塞状态</span></span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 要达到的复制偏移量</span></span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 全局的复制偏移量</span></span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 监控的键</span></span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    <span class="comment">// 订阅频道</span></span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 订阅模式</span></span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    <span class="comment">// 被缓存的peerid，peerid就是 ip:port</span></span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 订阅发布模式的释放和比较方法</span></span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line">    <span class="comment">// 将真正的client放在服务器的客户端链表中</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients,c);</span><br><span class="line">    <span class="comment">// 初始化client的事物状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据创建的文件描述符<code>fd</code>，可以创建用于不同场景下的<code>client</code>. 这个<code>fd</code>就是服务器接收客户端<code>connect</code>后所返回的文件描述符.</p>
<ul>
<li><code>fd == -1</code>，表示创建一个无网络连接的客户端。主要用于执行 lua 脚本时.</li>
<li><code>fd != -1</code>，表示接收到一个正常的客户端连接，则会创建一个有网络连接的客户端，也就是创建一个文件事件，来监听这个fd是否可读，当客户端发送数据，则事件被触发.</li>
</ul>
<p>创建客户端的过程，会将<code>server.h/client</code>结构的所有成员初始化，接下里会介绍部分重点的成员.</p>
<p><code>int id</code>：服务器对于每一个连接进来的都会创建一个ID，客户端的ID从1开始。每次重启服务器会刷新.<br><code>int fd</code>：当前客户端状态描述符。分为无网络连接的客户端和有网络连接的客户端.<br><code>int flags</code>：客户端状态的标志.<br><code>robj *name</code>：默认创建的客户端是没有名字的，可以通过<code>CLIENT SETNAME</code>命令设置名字. 后面会介绍该命令的实现.<br><code>int reqtype</code>：请求协议的类型. 因为Redis服务器支持<code>Telnet</code>的连接，因此Telnet命令请求协议类型是<code>PROTO_REQ_INLINE</code>，而<code>redis-cli</code>命令请求的协议类型是<code>PROTO_REQ_MULTIBULK</code>.</p>
<p>用于保存服务器接受客户端命令的成员：</p>
<p><code>sds querybuf</code>：保存客户端发来命令请求的输入缓冲区. 以Redis通信协议的方式保存.<br><code>size_t querybuf_peak</code>：保存输入缓冲区的峰值.<br><code>int argc</code>：命令参数个数.<br><code>robj *argv</code>：命令参数列表.</p>
<p>用于保存服务器给客户端回复的成员：</p>
<p><code>char buf[16*1024]</code>：保存执行完命令所得命令回复信息的静态缓冲区，它的大小是固定的，所以主要保存的是一些比较短的回复. 分配<code>client</code>结构空间时，就会分配一个<code>16K</code>的大小.<br><code>int bufpos</code>：记录静态缓冲区的偏移量，也就是buf数组已经使用的字节数.<br><code>list *reply</code>：保存命令回复的链表. 因为静态缓冲区大小固定，主要保存固定长度的命令回复，当处理一些返回大量回复的命令，则会将命令回复以链表的形式连接起来.<br><code>unsigned long long reply_bytes</code>：保存回复链表的字节数.<br><code>size_t sentlen</code>：已发送回复的字节数.</p>
<h3 id="2-2-客户端的释放"><a href="#2-2-客户端的释放" class="headerlink" title="2.2 客户端的释放"></a>2.2 客户端的释放</h3><p>客户端释放的函数是<code>freeClient()</code>，主要就是释放各种数据结构和清空一些缓冲区等操作，这里就不再列出源码.</p>
<p>我们可以重点关注一下异步释放客户端，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异步释放client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeClientAsync</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是已经即将关闭或者是lua脚本的伪client，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP || c-&gt;flags &amp; CLIENT_LUA) <span class="keyword">return</span>;</span><br><span class="line">    c-&gt;flags |= CLIENT_CLOSE_ASAP;</span><br><span class="line">    <span class="comment">// 将client加入到即将关闭的client链表中</span></span><br><span class="line">    <span class="comment">// server.clients_to_close 中保存着服务器中所有待关闭的链表</span></span><br><span class="line">    listAddNodeTail(server.clients_to_close,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置异步释放客户端的目的主要是：防止底层函数正在向客户端的输出缓冲区写数据的时候，关闭客户端，这样是不安全的. Redis会安排客户端在<code>serverCron()</code>函数的安全时间释放它.</p>
<p>当然也可以取消异步释放，那么就会调用<code>freeClient()</code>函数立即释放，源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取消设置异步释放的client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeClientsInAsyncFreeQueue</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历所有即将关闭的client</span></span><br><span class="line">    <span class="keyword">while</span> (listLength(server.clients_to_close)) &#123;</span><br><span class="line">        listNode *ln = listFirst(server.clients_to_close);</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消立即关闭的标志</span></span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_CLOSE_ASAP;</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="comment">// 从即将关闭的client链表中删除</span></span><br><span class="line">        listDelNode(server.clients_to_close,ln);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-命令接收与命令回复"><a href="#3-命令接收与命令回复" class="headerlink" title="3. 命令接收与命令回复"></a>3. 命令接收与命令回复</h2><h3 id="3-1-命令接收"><a href="#3-1-命令接收" class="headerlink" title="3.1 命令接收"></a>3.1 命令接收</h3><p>当客户端连接上Redis服务器后，服务器会得到一个文件描述符<code>fd</code>，而且服务器会监听该文件描述符的读事件，这些在<code>createClient()</code>函数中. 那么当客户端发送了命令，触发了<code>AE_READABLE</code>事件，那么就会调用回调函数<code>readQueryFromClient()</code>来从文件描述符fd中读发来的命令，并保存在输入缓冲区<code>querybuf</code>中. 而这个回调函数就是我们在Redis事件处理一文中所提到的指向回调函数的指针<code>rfileProc</code>和<code>wfileProc</code>. 那么，我们先来分析<code>readQueryFromClient</code>函数. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取client的输入缓冲区的内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    client *c = (client*) privdata;</span><br><span class="line">    <span class="type">int</span> nread, readlen;</span><br><span class="line">    <span class="type">size_t</span> qblen;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读入的长度，默认16MB</span></span><br><span class="line">    readlen = PROTO_IOBUF_LEN;</span><br><span class="line">    <span class="comment">// 如果是多条请求，根据请求的大小，设置读入的长度readlen</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK &amp;&amp; c-&gt;multibulklen &amp;&amp; c-&gt;bulklen != <span class="number">-1</span></span><br><span class="line">        &amp;&amp; c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> remaining = (<span class="type">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)-sdslen(c-&gt;querybuf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; readlen) readlen = remaining;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓冲区的长度</span></span><br><span class="line">    qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">    <span class="comment">// 更新缓冲区的峰值</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;querybuf_peak &lt; qblen) c-&gt;querybuf_peak = qblen;</span><br><span class="line">    <span class="comment">// 扩展缓冲区的大小</span></span><br><span class="line">    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);</span><br><span class="line">    <span class="comment">// 将client发来的命令，读入到输入缓冲区中</span></span><br><span class="line">    nread = read(fd, c-&gt;querybuf+qblen, readlen);</span><br><span class="line">    <span class="comment">// 读操作出错</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE, <span class="string">&quot;Reading from client: %s&quot;</span>,strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 读操作完成</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_VERBOSE, <span class="string">&quot;Client closed connection&quot;</span>);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新输入缓冲区的已用大小和未用大小。</span></span><br><span class="line">    sdsIncrLen(c-&gt;querybuf,nread);</span><br><span class="line">    <span class="comment">// 设置最后一次服务器和client交互的时间</span></span><br><span class="line">    c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 如果是主节点，则更新复制操作的偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) c-&gt;reploff += nread;</span><br><span class="line">    <span class="comment">// 更新从网络输入的字节数</span></span><br><span class="line">    server.stat_net_input_bytes += nread;</span><br><span class="line">    <span class="comment">// 如果输入缓冲区长度超过服务器设置的最大缓冲区长度</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; server.client_max_querybuf_len) &#123;</span><br><span class="line">        <span class="comment">// 将client信息转换为sds</span></span><br><span class="line">        sds ci = catClientInfoString(sdsempty(),c), bytes = sdsempty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输入缓冲区保存在bytes中</span></span><br><span class="line">        bytes = sdscatrepr(bytes,c-&gt;querybuf,<span class="number">64</span>);</span><br><span class="line">        <span class="comment">// 打印到日志</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Closing client that reached max query buffer length: %s (qbuf initial bytes: %s)&quot;</span>, ci, bytes);</span><br><span class="line">        <span class="comment">// 释放空间</span></span><br><span class="line">        sdsfree(ci);</span><br><span class="line">        sdsfree(bytes);</span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理client输入的命令内容</span></span><br><span class="line">    processInputBuffer(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，这个<code>readQueryFromClient()</code>函数是read函数的封装，从文件描述符<code>fd</code>中读出数据到输入缓冲区<code>querybuf</code>中，并更新输入缓冲区的峰值<code>querybuf_peak</code>，而且会检查读的长度，如果大于了<code>server.client_max_querybuf_len</code>则会退出，而这个阀值在服务器初始化为<code>PROTO_MAX_QUERYBUF_LEN (1024*1024*1024)</code>也就是<code>1G</code>大小.</p>
<p>回忆之前的各种命令实现，都是通过client的argv和argc这两个成员来处理的. 因此，服务器还需要将输入缓冲区<code>querybuf</code>中的数据，处理成参数列表的对象，也就是上面的<code>processInputBuffer()</code>函数. 源码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理client输入的命令内容</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">processInputBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    server.current_client = c;</span><br><span class="line">    <span class="comment">// 一直读输入缓冲区的内容</span></span><br><span class="line">    <span class="keyword">while</span>(sdslen(c-&gt;querybuf)) &#123;</span><br><span class="line">        <span class="comment">// 如果处于暂停状态，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; clientsArePaused()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果client处于被阻塞状态，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_BLOCKED) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果client处于关闭状态，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是未知的请求类型，则判定请求类型</span></span><br><span class="line">        <span class="keyword">if</span> (!c-&gt;reqtype) &#123;</span><br><span class="line">            <span class="comment">// 如果是&quot;*&quot;开头，则是多条请求，是client发来的</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;querybuf[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_MULTIBULK;</span><br><span class="line">            <span class="comment">// 否则就是内联请求，是Telnet发来的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;reqtype = PROTO_REQ_INLINE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是内联请求</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_INLINE) &#123;</span><br><span class="line">            <span class="comment">// 处理Telnet发来的内联命令，并创建成对象，保存在client的参数列表中</span></span><br><span class="line">            <span class="keyword">if</span> (processInlineBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果是多条请求</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;reqtype == PROTO_REQ_MULTIBULK) &#123;</span><br><span class="line">            <span class="comment">// 将client的querybuf中的协议内容转换为client的参数列表中的对象</span></span><br><span class="line">            <span class="keyword">if</span> (processMultibulkBuffer(c) != C_OK) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">&quot;Unknown request type&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果参数为0，则重置client</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">0</span>) &#123;</span><br><span class="line">            resetClient(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Only reset the client when the command was executed. */</span></span><br><span class="line">            <span class="comment">// 执行命令成功后重置client</span></span><br><span class="line">            <span class="keyword">if</span> (processCommand(c) == C_OK)</span><br><span class="line">                resetClient(c);</span><br><span class="line">            <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行成功，则将用于崩溃报告的client设置为NULL</span></span><br><span class="line">    server.current_client = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>redis-cli</code>命令请求的协议类型是<code>PROTO_REQ_MULTIBULK</code>，进而调用<code>processMultibulkBuffer()</code>函数来处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将client的querybuf中的协议内容转换为client的参数列表中的对象</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">processMultibulkBuffer</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *newline = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> pos = <span class="number">0</span>, ok;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数列表中命令数量为0，因此先分配空间</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* The client should have been reset */</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;argc == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Multi bulk length cannot be read without a \r\n */</span></span><br><span class="line">        <span class="comment">// 查询第一个换行符</span></span><br><span class="line">        newline = <span class="built_in">strchr</span>(c-&gt;querybuf,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">        <span class="comment">// 没有找到\r\n，表示不符合协议，返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; PROTO_INLINE_MAX_SIZE) &#123;</span><br><span class="line">                addReplyError(c,<span class="string">&quot;Protocol error: too big mbulk count string&quot;</span>);</span><br><span class="line">                setProtocolError(c,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Buffer should also contain \n */</span></span><br><span class="line">        <span class="comment">// 检查格式</span></span><br><span class="line">        <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="type">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We know for sure there is a whole line since newline != NULL,</span></span><br><span class="line"><span class="comment">         * so go ahead and find out the multi bulk length. */</span></span><br><span class="line">        <span class="comment">// 保证第一个字符为&#x27;*&#x27;</span></span><br><span class="line">        serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;querybuf[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        <span class="comment">// 将&#x27;*&#x27;之后的数字转换为整数。*3\r\n</span></span><br><span class="line">        ok = string2ll(c-&gt;querybuf+<span class="number">1</span>,newline-(c-&gt;querybuf+<span class="number">1</span>),&amp;ll);</span><br><span class="line">        <span class="keyword">if</span> (!ok || ll &gt; <span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">&quot;Protocol error: invalid multibulk length&quot;</span>);</span><br><span class="line">            setProtocolError(c,pos);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指向&quot;*3\r\n&quot;的&quot;\r\n&quot;之后的位置</span></span><br><span class="line">        pos = (newline-c-&gt;querybuf)+<span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 空白命令，则将之前的删除，保留未阅读的部分</span></span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数数量</span></span><br><span class="line">        c-&gt;multibulklen = ll;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setup argv array on client structure */</span></span><br><span class="line">        <span class="comment">// 分配client参数列表的空间</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argv) zfree(c-&gt;argv);</span><br><span class="line">        c-&gt;argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*c-&gt;multibulklen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;multibulklen &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 读入multibulklen个参数，并创建对象保存在参数列表中</span></span><br><span class="line">    <span class="keyword">while</span>(c-&gt;multibulklen) &#123;</span><br><span class="line">        <span class="comment">/* Read bulk length if unknown */</span></span><br><span class="line">        <span class="comment">// 读入参数的长度</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bulklen == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到换行符，确保&quot;\r\n&quot;存在</span></span><br><span class="line">            newline = <span class="built_in">strchr</span>(c-&gt;querybuf+pos,<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (newline == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sdslen(c-&gt;querybuf) &gt; PROTO_INLINE_MAX_SIZE) &#123;</span><br><span class="line">                    addReplyError(c,</span><br><span class="line">                        <span class="string">&quot;Protocol error: too big bulk count string&quot;</span>);</span><br><span class="line">                    setProtocolError(c,<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> C_ERR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Buffer should also contain \n */</span></span><br><span class="line">            <span class="comment">// 检查格式</span></span><br><span class="line">            <span class="keyword">if</span> (newline-(c-&gt;querybuf) &gt; ((<span class="type">signed</span>)sdslen(c-&gt;querybuf)<span class="number">-2</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// $3\r\nSET\r\n...，确保是&#x27;$&#x27;字符，保证格式</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;querybuf[pos] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">                addReplyErrorFormat(c,</span><br><span class="line">                    <span class="string">&quot;Protocol error: expected &#x27;$&#x27;, got &#x27;%c&#x27;&quot;</span>,</span><br><span class="line">                    c-&gt;querybuf[pos]);</span><br><span class="line">                setProtocolError(c,pos);</span><br><span class="line">                <span class="keyword">return</span> C_ERR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将参数长度保存到ll。</span></span><br><span class="line">            ok = string2ll(c-&gt;querybuf+pos+<span class="number">1</span>,newline-(c-&gt;querybuf+pos+<span class="number">1</span>),&amp;ll);</span><br><span class="line">            <span class="keyword">if</span> (!ok || ll &lt; <span class="number">0</span> || ll &gt; <span class="number">512</span>*<span class="number">1024</span>*<span class="number">1024</span>) &#123;</span><br><span class="line">                addReplyError(c,<span class="string">&quot;Protocol error: invalid bulk length&quot;</span>);</span><br><span class="line">                setProtocolError(c,pos);</span><br><span class="line">                <span class="keyword">return</span> C_ERR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定位第一个参数的位置，也就是SET的S</span></span><br><span class="line">            pos += newline-(c-&gt;querybuf+pos)+<span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 参数长度太长，进行优化</span></span><br><span class="line">            <span class="keyword">if</span> (ll &gt;= PROTO_MBULK_BIG_ARG) &#123;</span><br><span class="line">                <span class="type">size_t</span> qblen;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* If we are going to read a large object from network</span></span><br><span class="line"><span class="comment">                 * try to make it likely that it will start at c-&gt;querybuf</span></span><br><span class="line"><span class="comment">                 * boundary so that we can optimize object creation</span></span><br><span class="line"><span class="comment">                 * avoiding a large copy of data. */</span></span><br><span class="line">                <span class="comment">// 如果我们要从网络中读取一个大的对象，尝试使它可能从c-&gt; querybuf边界开始，以便我们可以优化对象创建，避免大量的数据副本</span></span><br><span class="line">                <span class="comment">// 保存未读取的部分</span></span><br><span class="line">                sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// 重置偏移量</span></span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 获取querybuf中已使用的长度</span></span><br><span class="line">                qblen = sdslen(c-&gt;querybuf);</span><br><span class="line">                <span class="comment">/* Hint the sds library about the amount of bytes this string is</span></span><br><span class="line"><span class="comment">                 * going to contain. */</span></span><br><span class="line">                <span class="comment">// 扩展querybuf的大小</span></span><br><span class="line">                <span class="keyword">if</span> (qblen &lt; (<span class="type">size_t</span>)ll+<span class="number">2</span>)</span><br><span class="line">                    c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf,ll+<span class="number">2</span>-qblen);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存参数的长度</span></span><br><span class="line">            c-&gt;bulklen = ll;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read bulk argument */</span></span><br><span class="line">        <span class="comment">// 因为只读了multibulklen字节的数据，读到的数据不够，则直接跳出循环，执行processInputBuffer()函数循环读取</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(c-&gt;querybuf)-pos &lt; (<span class="type">unsigned</span>)(c-&gt;bulklen+<span class="number">2</span>)) &#123;</span><br><span class="line">            <span class="comment">/* Not enough data (+2 == trailing \r\n) */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 为参数创建了对象</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Optimization: if the buffer contains JUST our bulk element</span></span><br><span class="line"><span class="comment">             * instead of creating a new object by *copying* the sds we</span></span><br><span class="line"><span class="comment">             * just use the current sds string. */</span></span><br><span class="line">            <span class="comment">// 如果读入的长度大于32k</span></span><br><span class="line">            <span class="keyword">if</span> (pos == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                c-&gt;bulklen &gt;= PROTO_MBULK_BIG_ARG &amp;&amp;</span><br><span class="line">                (<span class="type">signed</span>) sdslen(c-&gt;querybuf) == c-&gt;bulklen+<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c-&gt;argv[c-&gt;argc++] = createObject(OBJ_STRING,c-&gt;querybuf);</span><br><span class="line">                <span class="comment">// 跳过换行</span></span><br><span class="line">                sdsIncrLen(c-&gt;querybuf,<span class="number">-2</span>); <span class="comment">/* remove CRLF */</span></span><br><span class="line">                <span class="comment">/* Assume that if we saw a fat argument we&#x27;ll see another one</span></span><br><span class="line"><span class="comment">                 * likely... */</span></span><br><span class="line">                <span class="comment">// 设置一个新长度</span></span><br><span class="line">                c-&gt;querybuf = sdsnewlen(<span class="literal">NULL</span>,c-&gt;bulklen+<span class="number">2</span>);</span><br><span class="line">                sdsclear(c-&gt;querybuf);</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 创建对象保存在client的参数列表中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                c-&gt;argv[c-&gt;argc++] =</span><br><span class="line">                    createStringObject(c-&gt;querybuf+pos,c-&gt;bulklen);</span><br><span class="line">                pos += c-&gt;bulklen+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 清空命令内容的长度</span></span><br><span class="line">            c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 未读取命令参数的数量，读取一个，该值减1</span></span><br><span class="line">            c-&gt;multibulklen--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trim to pos */</span></span><br><span class="line">    <span class="comment">// 删除已经读取的，保留未读取的</span></span><br><span class="line">    <span class="keyword">if</span> (pos) sdsrange(c-&gt;querybuf,pos,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We&#x27;re done when c-&gt;multibulk == 0 */</span></span><br><span class="line">    <span class="comment">// 命令的参数全部被读取完</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;multibulklen == <span class="number">0</span>) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Still not read to process the command */</span></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们结合一个多条批量回复进行分析。一个多条批量回复以 <code>*&lt;argc&gt;\r\n</code>为前缀，后跟多条不同的批量回复，其中 <code>argc</code>为这些批量回复的数量. 那么<code>SET nmykey nmyvalue</code>命令转换为Redis协议内容如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;*3<span class="subst">\r</span><span class="subst">\n</span>$3<span class="subst">\r</span><span class="subst">\n</span>SET<span class="subst">\r</span><span class="subst">\n</span>$5<span class="subst">\r</span><span class="subst">\n</span>mykey<span class="subst">\r</span><span class="subst">\n</span>$7<span class="subst">\r</span><span class="subst">\n</span>myvalue<span class="subst">\r</span><span class="subst">\n</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>当进入<code>processMultibulkBuffer()</code>函数之后，如果是第一次执行该函数，那么<code>argv</code>中未读取的命令数量为0，也就是说参数列表为空，那么会执行<code>if (c-&gt;multibulklen == 0)</code>的代码，这里的代码会解析<code>*3\r\n</code>，将<code>3</code>保存到<code>multibulklen</code>中，表示后面的参数个数，然后根据参数个数，为<code>argv</code>分配空间.</p>
<p>接着，执行<code>multibulklen</code>次while循环，每次读一个参数，例如<code>$3\r\nSET\r\n</code>，也是先读出参数长度，保存在<code>bulklen</code>中，然后将参数<code>SET</code>保存构建成对象保存到参数列表中. 每次读一个参数，<code>multibulklen</code>就会减1，当等于0时，就表示命令的参数全部读取到参数列表完毕.</p>
<p>于是命令接收的整个过程完成.</p>
<h3 id="3-2-命令回复"><a href="#3-2-命令回复" class="headerlink" title="3.2 命令回复"></a>3.2 命令回复</h3><p>命令回复的函数，也是事件处理程序的回调函数之一. 当服务器的client的回复缓冲区有数据，那么就会调用<code>aeCreateFileEvent(server.el, c-&gt;fd, AE_WRITABLE,sendReplyToClient, c)</code>函数，将<code>文件描述符fd</code>和<code>AE_WRITABLE</code>事件关联起来，当客户端可写时，就会触发事件，调用<code>sendReplyToClient()</code>函数，执行写事件. 我们重点看这个函数的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写事件处理程序，只是发送回复给client</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sendReplyToClient</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    <span class="comment">// 发送完数据会删除fd的可读事件</span></span><br><span class="line">    writeToClient(fd,privdata,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数直接调用了<code>writeToClient()</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将输出缓冲区的数据写给client，如果client被释放则返回C_ERR，没被释放则返回C_OK</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeToClient</span><span class="params">(<span class="type">int</span> fd, client *c, <span class="type">int</span> handler_installed)</span> &#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> objlen;</span><br><span class="line">    <span class="type">size_t</span> objmem;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果指定的client的回复缓冲区中还有数据，则返回真，表示可以写socket</span></span><br><span class="line">    <span class="keyword">while</span>(clientHasPendingReplies(c)) &#123;</span><br><span class="line">        <span class="comment">// 固定缓冲区发送未完成</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将缓冲区的数据写到fd中</span></span><br><span class="line">            nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</span><br><span class="line">            <span class="comment">// 写失败跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 更新发送的数据计数器</span></span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果发送的数据等于buf的偏移量，表示发送完成</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>)c-&gt;sentlen == c-&gt;bufpos) &#123;</span><br><span class="line">                <span class="comment">// 则将其重置</span></span><br><span class="line">                c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 固定缓冲区发送完成，发送回复链表的内容</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 回复链表的第一条回复对象，和对象值的长度和所占的内存</span></span><br><span class="line">            o = listNodeValue(listFirst(c-&gt;reply));</span><br><span class="line">            objlen = sdslen(o-&gt;ptr);</span><br><span class="line">            objmem = getStringObjectSdsUsedMemory(o);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过空对象，并删除这个对象</span></span><br><span class="line">            <span class="keyword">if</span> (objlen == <span class="number">0</span>) &#123;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                c-&gt;reply_bytes -= objmem;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将当前节点的值写到fd中</span></span><br><span class="line">            nwritten = write(fd, ((<span class="type">char</span>*)o-&gt;ptr)+c-&gt;sentlen,objlen-c-&gt;sentlen);</span><br><span class="line">            <span class="comment">// 写失败跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 更新发送的数据计数器</span></span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送完成，则删除该节点，重置发送的数据长度，更新回复链表的总字节数</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">                c-&gt;reply_bytes -= objmem;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新写到网络的字节数</span></span><br><span class="line">        server.stat_net_output_bytes += totwritten;</span><br><span class="line">        <span class="comment">// 如果这次写的总量大于NET_MAX_WRITES_PER_EVENT的限制，则会中断本次的写操作，将处理时间让给其他的client，以免一个非常的回复独占服务器，剩余的数据下次继续在写</span></span><br><span class="line">        <span class="comment">// 但是，如果当服务器的内存数已经超过maxmemory，即使超过最大写NET_MAX_WRITES_PER_EVENT的限制，也会继续执行写入操作，是为了尽快写入给客户端</span></span><br><span class="line">        <span class="keyword">if</span> (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span><br><span class="line">            (server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">             zmalloc_used_memory() &lt; server.maxmemory)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理写入失败</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            nwritten = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE,</span><br><span class="line">                <span class="string">&quot;Error writing to client: %s&quot;</span>, strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不是主节点服务器，则更新最近和服务器交互的时间</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果指定的client的回复缓冲区中已经没有数据，发送完成</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c)) &#123;</span><br><span class="line">        c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 删除当前client的可读事件的监听</span></span><br><span class="line">        <span class="keyword">if</span> (handler_installed) aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Close connection after entire reply has been sent. */</span></span><br><span class="line">        <span class="comment">// 如果指定了写入按成之后立即关闭的标志，则释放client</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) &#123;</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数实际上是对<code>write()</code>函数的封装，将静态回复缓冲区<code>buf</code>或回复链表<code>reply</code>中的数据循环写到文件描述符<code>fd</code>中. 如果写完了，则将当前客户端的<code>AE_WRITABLE</code>事件删除.</p>
<h2 id="4-CLIENT命令的实现"><a href="#4-CLIENT命令的实现" class="headerlink" title="4. CLIENT命令的实现"></a>4. CLIENT命令的实现</h2><p><code>CLIENT</code>相关的命令大致有6条：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CLIENT</span> KILL [ip:port] [ID client-<span class="type">id</span>] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [<span class="built_in">SKIPME</span> yes/no] </span><br><span class="line"><span class="built_in">CLIENT</span> GETNAME</span><br><span class="line"><span class="built_in">CLIENT</span> LIST</span><br><span class="line"><span class="built_in">CLIENT</span> PAUSE timeout </span><br><span class="line"><span class="built_in">CLIENT</span> REPLY ON|OFF|<span class="built_in">SKIP</span> </span><br><span class="line"><span class="built_in">CLIENT</span> SETNAME connection-name </span><br></pre></td></tr></table></figure>

<p>下面是<code>client</code>命令的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// client 命令的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clientCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    client *client;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  CLIENT LIST 的实现</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;list&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* CLIENT LIST */</span></span><br><span class="line">        <span class="comment">// 获取所有的client信息</span></span><br><span class="line">        sds o = getAllClientsInfoString();</span><br><span class="line">        <span class="comment">// 添加到到输入缓冲区中</span></span><br><span class="line">        addReplyBulkCBuffer(c,o,sdslen(o));</span><br><span class="line">        sdsfree(o);</span><br><span class="line">    <span class="comment">// CLIENT REPLY ON|OFF|SKIP 命令实现</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;reply&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">/* CLIENT REPLY ON|OFF|SKIP */</span></span><br><span class="line">        <span class="comment">// 如果是 ON</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 取消 off 和 skip 的标志</span></span><br><span class="line">            c-&gt;flags &amp;= ~(CLIENT_REPLY_SKIP|CLIENT_REPLY_OFF);</span><br><span class="line">            <span class="comment">// 回复 +OK</span></span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">        <span class="comment">// 如果是 OFF</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;off&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 打开 OFF标志</span></span><br><span class="line">            c-&gt;flags |= CLIENT_REPLY_OFF;</span><br><span class="line">        <span class="comment">// 如果是 SKIP</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;skip&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 没有设置 OFF 则设置 SKIP 标志</span></span><br><span class="line">            <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_REPLY_OFF))</span><br><span class="line">                c-&gt;flags |= CLIENT_REPLY_SKIP_NEXT;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//  CLIENT KILL [ip:port] [ID client-id] [TYPE normal | master | slave | pubsub] [ADDR ip:port] [SKIPME yes / no]</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;kill&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* CLIENT KILL &lt;ip:port&gt;</span></span><br><span class="line"><span class="comment">         * CLIENT KILL &lt;option&gt; [value] ... &lt;option&gt; [value] */</span></span><br><span class="line">        <span class="type">char</span> *addr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> type = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">uint64_t</span> id = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> skipme = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> killed = <span class="number">0</span>, close_this_client = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CLIENT KILL addr:port只能通过地址杀死client，旧版本兼容</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">/* Old style syntax: CLIENT KILL &lt;addr&gt; */</span></span><br><span class="line">            addr = c-&gt;argv[<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">            skipme = <span class="number">0</span>; <span class="comment">/* With the old form, you can kill yourself. */</span></span><br><span class="line">        <span class="comment">// 新版本可以根据[ID client-id] [master|normal|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]杀死client</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> i = <span class="number">2</span>; <span class="comment">/* Next option index. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* New style syntax: parse options. */</span></span><br><span class="line">            <span class="comment">// 解析语法</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; c-&gt;argc) &#123;</span><br><span class="line">                <span class="type">int</span> moreargs = c-&gt;argc &gt; i+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// CLIENT KILL [ID client-id]</span></span><br><span class="line">                <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;id&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> tmp;</span><br><span class="line">                    <span class="comment">// 获取client的ID</span></span><br><span class="line">                    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[i+<span class="number">1</span>],&amp;tmp,<span class="literal">NULL</span>)</span><br><span class="line">                        != C_OK) <span class="keyword">return</span>;</span><br><span class="line">                    id = tmp;</span><br><span class="line">                <span class="comment">// CLIENT KILL TYPE type, 这里的 type 可以是 [master|normal|slave|pubsub]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;type&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="comment">// 获取client的类型，[master|normal|slave|pubsub]四种之一</span></span><br><span class="line">                    type = getClientTypeByName(c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr);</span><br><span class="line">                    <span class="keyword">if</span> (type == <span class="number">-1</span>) &#123;</span><br><span class="line">                        addReplyErrorFormat(c,<span class="string">&quot;Unknown client type &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                            (<span class="type">char</span>*) c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">// CLIENT KILL [ADDR ip:port]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;addr&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="comment">// 获取ip:port</span></span><br><span class="line">                    addr = c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">                <span class="comment">// CLIENT KILL [SKIPME yes/no]</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr,<span class="string">&quot;skipme&quot;</span>) &amp;&amp; moreargs) &#123;</span><br><span class="line">                    <span class="comment">// 如果是yes，设置设置skipme，调用该命令的客户端将不会被杀死</span></span><br><span class="line">                    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;yes&quot;</span>)) &#123;</span><br><span class="line">                        skipme = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 设置为no会影响到还会杀死调用该命令的客户端。</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;no&quot;</span>)) &#123;</span><br><span class="line">                        skipme = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        addReply(c,shared.syntaxerr);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    addReply(c,shared.syntaxerr);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate clients killing all the matching clients. */</span></span><br><span class="line">        listRewind(server.clients,&amp;li);</span><br><span class="line">        <span class="comment">// 迭代所有的client节点</span></span><br><span class="line">        <span class="keyword">while</span> ((ln = listNext(&amp;li)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            client = listNodeValue(ln);</span><br><span class="line">            <span class="comment">// 比较当前client和这四类信息，如果有一个不符合就跳过本层循环，否则就比较下一个信息</span></span><br><span class="line">            <span class="keyword">if</span> (addr &amp;&amp; <span class="built_in">strcmp</span>(getClientPeerId(client),addr) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (type != <span class="number">-1</span> &amp;&amp; getClientType(client) != type) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (id != <span class="number">0</span> &amp;&amp; client-&gt;id != id) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == client &amp;&amp; skipme) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Kill it. */</span></span><br><span class="line">            <span class="comment">// 杀死当前的client</span></span><br><span class="line">            <span class="keyword">if</span> (c == client) &#123;</span><br><span class="line">                close_this_client = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                freeClient(client);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算杀死client的个数</span></span><br><span class="line">            killed++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Reply according to old/new format. */</span></span><br><span class="line">        <span class="comment">// 回复client信息</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// 没找到符合信息的</span></span><br><span class="line">            <span class="keyword">if</span> (killed == <span class="number">0</span>)</span><br><span class="line">                addReplyError(c,<span class="string">&quot;No such client&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                addReply(c,shared.ok);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 发送杀死的个数</span></span><br><span class="line">            addReplyLongLong(c,killed);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this client has to be closed, flag it as CLOSE_AFTER_REPLY</span></span><br><span class="line"><span class="comment">         * only after we queued the reply to its output buffers. */</span></span><br><span class="line">        <span class="keyword">if</span> (close_this_client) c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">    <span class="comment">//  CLIENT SETNAME connection-name</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;setname&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">int</span> j, len = sdslen(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">        <span class="type">char</span> *p = c-&gt;argv[<span class="number">2</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setting the client name to an empty string actually removes</span></span><br><span class="line"><span class="comment">         * the current name. */</span></span><br><span class="line">        <span class="comment">// 设置名字为空</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先释放掉原来的名字</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;name) decrRefCount(c-&gt;name);</span><br><span class="line">            c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Otherwise check if the charset is ok. We need to do this otherwise</span></span><br><span class="line"><span class="comment">         * CLIENT LIST format will break. You should always be able to</span></span><br><span class="line"><span class="comment">         * split by space to get the different fields. */</span></span><br><span class="line">        <span class="comment">// 检查名字格式是否正确</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j] &lt; <span class="string">&#x27;!&#x27;</span> || p[j] &gt; <span class="string">&#x27;~&#x27;</span>) &#123; <span class="comment">/* ASCII is assumed. */</span></span><br><span class="line">                addReplyError(c,</span><br><span class="line">                    <span class="string">&quot;Client names cannot contain spaces, &quot;</span></span><br><span class="line">                    <span class="string">&quot;newlines or special characters.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放原来的名字</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;name) decrRefCount(c-&gt;name);</span><br><span class="line">        <span class="comment">// 设置新名字</span></span><br><span class="line">        c-&gt;name = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        incrRefCount(c-&gt;name);</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    <span class="comment">//  CLIENT GETNAME</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;getname&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 回复名字</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;name)</span><br><span class="line">            addReplyBulk(c,c-&gt;name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">    <span class="comment">//  CLIENT PAUSE timeout</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;pause&quot;</span>) &amp;&amp; c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> duration;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以毫秒为单位将等待时间保存在duration中</span></span><br><span class="line">        <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;duration,UNIT_MILLISECONDS)</span><br><span class="line">                                        != C_OK) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 暂停client</span></span><br><span class="line">        pauseClients(duration);</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyError(c, <span class="string">&quot;Syntax error, try CLIENT (LIST | KILL | GETNAME | SETNAME | PAUSE | REPLY)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 4.跳跃表</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%204.%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><code>跳跃表（skiplist）</code>是一种有序的数据结构，它通过建立多层<code>&quot;索引&quot;</code>，从而达到快速访问节点的目的. 跳跃表支持平均<code>O(logN)</code>、最坏<code>O(N)</code>复杂度的节点查找，还可以通过顺序性操作来批量处理节点. </p>
<p>如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员(member)是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现.</p>
<h2 id="2-跳跃表的实现"><a href="#2-跳跃表的实现" class="headerlink" title="2. 跳跃表的实现"></a>2. 跳跃表的实现</h2><p>在<code>redis-3.2.0</code>之前，关于跳跃表的定义在<code>redis.h</code>文件中，而在<code>redis-3.2.0</code>之后（包括该版本），关于跳跃表的定义在<code>server.h</code>文件中.</p>
<p>其中<code>zskiplistNode</code>结构用于表示跳跃表节点，而<code>zskiplist</code>结构用于保存跳跃表的表头信息.</p>
<p><strong>跳跃表节点 zskiplistNode</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">	<span class="comment">//	保存成员对象的地址</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层级，柔型数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">	    <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>


<p><strong>跳跃表表头 zskiplist</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">	<span class="comment">// header 指向跳跃表的表头节点</span></span><br><span class="line">	<span class="comment">// tail 指向跳跃表的表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 跳跃表的长度或跳跃表节点数量计数器，除去第一个节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 跳跃表中节点的最大层数，除了第一个节点</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>


<p>下图是一个带有三个节点的跳跃表示意图：</p>
<p><img src="https://img-blog.csdnimg.cn/2cb43c5a15b9423899552f5b414e3615.png" alt="在这里插入图片描述"><br>这种画法的层级可能不太好理解，下图的画法更加明朗：</p>
<p><img src="https://img-blog.csdnimg.cn/6354e3dddab3422db83e0574dedcd8bc.png" alt="在这里插入图片描述"><code>层（level）</code>其实就是跳跃表的索引，Redis的跳表最多可以建立32层索引.<br>那新插入的节点该建立多少层索引呢？Redis会通过随机算法来计算得到一个随机值，叫做<code>幂次定律</code>.</p>
<h2 id="3-幂次定律"><a href="#3-幂次定律" class="headerlink" title="3. 幂次定律"></a>3. 幂次定律</h2><p>Redis会为新插入的值返回一个<code>随机层数值</code>. 随机算法使用的是<code>幂次定律</code>.</p>
<p>幂次定律的含义就是：<code>如果某件事的发生频率和它的某个属性成幂关系，那么这个频率就可以称之为符合幂次定律</code>.</p>
<p>特点是：少数几个事件的发生频率占了整个发生频率的大部分， 而其余的大多数事件只占整个发生频率的一个小部分.</p>
<p>映射到Redis中的生成层数就是：一个新插入的节点，生成小数值层数的概率很大，而生成大数值层数的概率很小.</p>
<p>Redis中的这个随机算法在<code>t_zset.c</code>文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ZSKIPLIST_MAXLEVEL 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZSKIPLIST_P 0.25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个随机层数值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回一个1到32的数字</span></span><br><span class="line">    <span class="keyword">return</span> (level &lt; ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>概率计算：</p>
<p><code>p = 0.25</code></p>
<ul>
<li>层数恰好为1的概率（不执行while）为<code>1 - p</code>.</li>
<li>层数恰好为2的概率（执行 1 次while）为<code>p * (1 - p)</code>.</li>
<li>层数恰好为3的概率（执行 2 次while）为<code>p ^ 2 * (1 - p)</code>.</li>
<li>层数恰好为4的概率（执行 3 次while）为<code>p ^ 3 * (1 - p)</code>.</li>
<li>层数恰好为k（k &lt;&#x3D; 32）的概率（执行 k - 1 次while）为<code>p ^ (k - 1) * (1 - p)</code>.</li>
</ul>
<p>可以发现生成越高层数的概率会越来越小，而且和上一次呈幂关系递减.</p>
<h2 id="4-部分源码剖析"><a href="#4-部分源码剖析" class="headerlink" title="4. 部分源码剖析"></a>4. 部分源码剖析</h2><h3 id="4-1-创建跳跃表"><a href="#4-1-创建跳跃表" class="headerlink" title="4.1 创建跳跃表"></a>4.1 创建跳跃表</h3><p><strong>创建节点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个层数为level，分数为score，对象为obj的跳跃表节点</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslCreateNode</span><span class="params">(<span class="type">int</span> level, <span class="type">double</span> score, robj *obj)</span> &#123;</span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">    zskiplistNode *zn = zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> zskiplistLevel));</span><br><span class="line">    <span class="comment">// 设置分数</span></span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    <span class="comment">// 设置对象</span></span><br><span class="line">    zn-&gt;obj = obj;</span><br><span class="line">    <span class="comment">// 返回节点地址</span></span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建表头</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建返回一个跳跃表 表头zskiplist</span></span><br><span class="line">zskiplist *<span class="title function_">zslCreate</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    <span class="comment">// 设置默认层数</span></span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置跳跃表长度</span></span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//创建哨兵节点：层数为32，分数为0，没有obj</span></span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//跳跃表头节点初始化</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">    	<span class="comment">// 将跳跃表头节点的所有前进指针forward设置为NULL</span></span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 将跳跃表头节点的所有跨度span设置为0</span></span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳跃表头节点的后退指针backward置为NULL</span></span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 表头指向跳跃表尾节点的指针置为NULL</span></span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-销毁跳跃表"><a href="#4-2-销毁跳跃表" class="headerlink" title="4.2 销毁跳跃表"></a>4.2 销毁跳跃表</h3><p><strong>销毁一个节点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zslFreeNode</span><span class="params">(zskiplistNode *node)</span> &#123;</span><br><span class="line">	<span class="comment">// 该节点对象的引用计数减1</span></span><br><span class="line">    decrRefCount(node-&gt;obj);</span><br><span class="line">    <span class="comment">// 释放该该节点空间</span></span><br><span class="line">    zfree(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>销毁表头</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 释放跳跃表表头zsl，以及跳跃表节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zslFree</span><span class="params">(zskiplist *zsl)</span> &#123;</span><br><span class="line">    zskiplistNode *node = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward, *next;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 释放跳跃表的头节点</span></span><br><span class="line">    zfree(zsl-&gt;header);</span><br><span class="line">    <span class="comment">// 释放其他节点</span></span><br><span class="line">    <span class="keyword">while</span>(node) &#123;</span><br><span class="line">    	<span class="comment">// 备份下一个节点地址</span></span><br><span class="line">        next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        <span class="comment">// 释放节点空间</span></span><br><span class="line">        zslFreeNode(node);</span><br><span class="line">        <span class="comment">// 指向下一个节点</span></span><br><span class="line">        node = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放表头</span></span><br><span class="line">    zfree(zsl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-插入节点"><a href="#4-3-插入节点" class="headerlink" title="4.3 插入节点"></a>4.3 插入节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点，分数为score，对象为obj，插入到zsl表头管理的跳跃表中，并返回新节点的地址</span></span><br><span class="line">zskiplistNode *<span class="title function_">zslInsert</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *obj)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="comment">// 记录每一层遍历的时候跨越的节点数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="type">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">// 获取跳跃表头结点地址，从头节点开始一层一层遍历</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 遍历头节点的每个level，从下标最大层减1到0</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		<span class="comment">// 更新rank[i]为i+1所跨越的节点数，但是最外一层为0</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 这个while循环是查找的过程，沿着x指针遍历跳跃表，满足以下条件则要继续在当前层往前走</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;   <span class="comment">// 当前层的前进指针不为空且</span></span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score || <span class="comment">// 当前的要插入的score大于当前层的score或</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp; <span class="comment">// 当前score等于要插入的score且</span></span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,obj) &lt; <span class="number">0</span>))) &#123; <span class="comment">//当前层的对象与要插入的obj不等</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span; <span class="comment">// 记录该层一共跨越了多少节点 加上 上一层遍历所跨越的节点数</span></span><br><span class="line">            x = x-&gt;level[i].forward; <span class="comment">// 指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while循环跳出时，用update[i]记录第i层所遍历到的最后一个节点，遍历到i=0时，就要在该节点后要插入节点</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上述的while中已经确保了同分值且同成员的元素不会出现，所以这里不需要进一步进行检查，可以直接创建新元素</span></span><br><span class="line">    <span class="comment">// 获得一个随机的层数</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="comment">// 如果大于当前所有节点最大的层数时</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">        	<span class="comment">// 将大于等于原来zsl-&gt;level层以上的rank[]设置为0</span></span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 将大于等于原来zsl-&gt;level层以上update[i]指向头结点（因为这时候的最后一个节点就是头节点）</span></span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            <span class="comment">// update[i]已经指向头结点，将第i层的跨度设置为length</span></span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新表中的最大层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个节点</span></span><br><span class="line">    x = zslCreateNode(level,score,obj);</span><br><span class="line">    <span class="comment">// 遍历每一层</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">    	<span class="comment">// 设置新节点的前进指针为查找时（while循环）每一层最后一个节点的的前进指针</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">// 再把查找时每层的最后一个节点的前进指针设置为新创建的节点地址</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新插入节点的跨度值</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        <span class="comment">// 更新插入节点前一个节点的跨度值</span></span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果插入节点的level小于原来的zsl-&gt;level才会执行</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    	<span class="comment">//因为高度没有达到这些层，所以只需将查找时每层最后一个节点的值的跨度加1</span></span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置插入节点的后退指针，就是查找时最下层的最后一个节点，该节点的地址记录在update[0]中</span></span><br><span class="line">    <span class="comment">// 如果插入在第二个节点，也就是头结点后的位置就将后退指针设置为NULL</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 如果x节点不是最尾部的节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">    	<span class="comment">// 就将x节点后面的节点的后退节点设置成为x地址</span></span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">// 否则更新表头的tail指针，指向最尾部的节点x</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    <span class="comment">// 跳跃表节点计数器加1</span></span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="comment">// 返回x地址</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-删除节点"><a href="#4-4-删除节点" class="headerlink" title="4.4 删除节点"></a>4.4 删除节点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zslDeleteNode</span><span class="params">(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 设置前进指针和跨度</span></span><br><span class="line">    <span class="comment">// 遍历下标为0到跳跃表最大层数-1的层</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">    	<span class="comment">// 如果找到该节点</span></span><br><span class="line">        <span class="keyword">if</span> (update[i]-&gt;level[i].forward == x) &#123;</span><br><span class="line">        	<span class="comment">// 将前一个节点的跨度减1</span></span><br><span class="line">            update[i]-&gt;level[i].span += x-&gt;level[i].span - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 前一个节点的前进指针指向被删除的节点的后一个节点，跳过该节点</span></span><br><span class="line">            update[i]-&gt;level[i].forward = x-&gt;level[i].forward;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 在第i层没找到，只将该层的最后一个节点的跨度减1</span></span><br><span class="line">            update[i]-&gt;level[i].span -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//设置后退指针</span></span><br><span class="line">     <span class="comment">// 如果被删除的前进节点不为空，后面还有节点</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward) &#123;  </span><br><span class="line">    	<span class="comment">// 就将后面节点的后退指针指向被删除节点x的回退指针</span></span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x-&gt;backward;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 否则直接将被删除的x节点的后退节点设置为表头的tail指针</span></span><br><span class="line">        zsl-&gt;tail = x-&gt;backward;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新跳跃表最大层数</span></span><br><span class="line">    <span class="keyword">while</span>(zsl-&gt;level &gt; <span class="number">1</span> &amp;&amp; zsl-&gt;header-&gt;level[zsl-&gt;level<span class="number">-1</span>].forward == <span class="literal">NULL</span>)</span><br><span class="line">        zsl-&gt;level--;</span><br><span class="line">    <span class="comment">//节点计数器减1</span></span><br><span class="line">    zsl-&gt;length--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-获取节点的排位"><a href="#4-5-获取节点的排位" class="headerlink" title="4.5 获取节点的排位"></a>4.5 获取节点的排位</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找score和o对象在跳跃表中的排位</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="type">double</span> score, robj *o)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历头结点的每一层</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score || <span class="comment">//只要分值还小于给定的score或者</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp; <span class="comment">// 分值相等但是对象小于给定对象o</span></span><br><span class="line">                compareStringObjects(x-&gt;level[i].forward-&gt;obj,o) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span; <span class="comment">// 更新排位值</span></span><br><span class="line">            x = x-&gt;level[i].forward; <span class="comment">// 指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 确保在第i层找到分值相同，且对象相同时才会返回排位值</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;obj &amp;&amp; equalStringObjects(x-&gt;obj,o)) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-6-范围操作"><a href="#4-6-范围操作" class="headerlink" title="4.6 范围操作"></a>4.6 范围操作</h3><p><strong>返回一个zset是否有一部分在range的范围内</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">zslIsInLexRange</span><span class="params">(zskiplist *zsl, zlexrangespec *range)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试range的范围是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (compareStringObjectsForLexRange(range-&gt;min,range-&gt;max) &gt; <span class="number">1</span> ||</span><br><span class="line">            (compareStringObjects(range-&gt;min,range-&gt;max) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (range-&gt;minex || range-&gt;maxex)))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    x = zsl-&gt;tail;</span><br><span class="line">    <span class="comment">// 查看跳跃表的尾节点的对象是否比range的最小值还大，</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslLexValueGteMin(x-&gt;obj,range))</span><br><span class="line">    	<span class="comment">// 说明zset没有一部分在range范围</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    x = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="comment">// 查看跳跃表的头节点的对象是否比range的最大值还小，</span></span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span> || !zslLexValueLteMax(x-&gt;obj,range))</span><br><span class="line">    	<span class="comment">// 说明zset没有一部分在range范围</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>返回第一个包含在range范围内的节点的地址</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">zskiplistNode *<span class="title function_">zslFirstInLexRange</span><span class="params">(zskiplist *zsl, zlexrangespec *range)</span> &#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zsl是否有一部分包含在range内，没有则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!zslIsInLexRange(zsl,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历每一层</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 一直前进寻找，当某一个节点比range的最小值大时，停止寻找</span></span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; !zslLexValueGteMin(x-&gt;level[i].forward-&gt;obj,range))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存当前节点地址</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前节点是否超过最大值，超过则返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (!zslLexValueLteMax(x-&gt;obj,range)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 3.字典</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%203.%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>字典还有一个更为通俗的名字：<code>map（映射）</code>，是一种用于保存<code>键值对</code>的抽象数据结构. 很多语言都内置了字典这种数据结构，像C++中的<code>unordered_map</code>、Java中的<code>HashMap</code>、Golang中的<code>map</code>等等.</p>
<p>但是C语言中却没有内置这种数据结构，因此Redis构建了自己的字典实现. 字典在Redis中的应用相当广泛，比如哈希对象在满足条件的情况下会使用字典作为底层实现，以及Redis中的数据库也是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的.</p>
<h2 id="2-字典的实现"><a href="#2-字典的实现" class="headerlink" title="2. 字典的实现"></a>2. 字典的实现</h2><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对.</p>
<p>关于字典的源码在源码根目录的<code>dict.h</code>和<code>dict.c</code>中.</p>
<h3 id="2-1-哈希表"><a href="#2-1-哈希表" class="headerlink" title="2.1 哈希表"></a>2.1 哈希表</h3><p>Redis字典所使用的哈希表由dictht结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">	<span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 哈希表已有节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>table是一个数组，数组中的每个元素都是一个指向哈希表节点的指针：</p>
<p><img src="https://img-blog.csdnimg.cn/ac4d66fd6ffc4cb799e0eae8d2340295.png" alt="在这里插入图片描述"></p>
<h3 id="2-2-哈希表节点"><a href="#2-2-哈希表节点" class="headerlink" title="2.2 哈希表节点"></a>2.2 哈希表节点</h3><p>哈希表的table指向的数组存放着<code>dictEntry</code>类型的地址.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">	<span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下一个hash节点，形成链表，用来解决hash键冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<ul>
<li>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个<code>uint64_t</code>整数，又或者是一个<code>int64_t</code>整数.</li>
<li>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键冲突( collision )的问题.</li>
</ul>
<p>如下图所示，next指针将两个索引值相同的键k1和k0连接在了一起：</p>
<p><img src="https://img-blog.csdnimg.cn/3ed70a5acdc34983998cf73bb2ff72e3.png" alt="在这里插入图片描述"></p>
<h3 id="2-3-字典"><a href="#2-3-字典" class="headerlink" title="2.3 字典"></a>2.3 字典</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">	<span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 两张哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash的标记，rehashidx==-1，表示没在进行rehash</span></span><br><span class="line">    <span class="type">long</span> rehashidx;</span><br><span class="line">    <span class="comment">// 正在迭代的迭代器数量</span></span><br><span class="line">    <span class="type">int</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p><code>type</code>属性和<code>privdata</code>属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li>type属性是一个指向<code>dictType</code>结构的指针，每个<code>dictType</code>结构保存了一组用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同的类型特定函数.</li>
<li>而<code>privdata</code>属性则保存了需要传给那些类型特定函数的可选参数.</li>
</ul>
<p><code>dictType</code>类型保存着 操作字典不同类型key和value的函数指针.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">	<span class="comment">// 计算hash值的函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;</span><br><span class="line">    <span class="comment">// 复制key的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制value的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);</span><br><span class="line">    <span class="comment">// 比较key的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁key的析构函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁value的析构函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ht</code>属性是一个包含两个项的数组，数组中的每个项都是一个<code>dictht</code>哈希表，一般情况字典只使用<code>ht[0]</code>哈希表，<code>ht[1]</code>哈希表只会在对<code>ht[0]</code>哈希表进行<code>rehash</code>时使用.</li>
<li>除了<code>ht[1]</code>之外，另一个和<code>rehash</code>有关的属性就是<code>rehashidx</code>，它记录了<br><code>rehash</code>目前的进度，如果目前没有在进行<code>rehash</code>，那么它的值为-1.</li>
</ul>
<p>下图是一个没有在进行rehash的字典：</p>
<p><img src="https://img-blog.csdnimg.cn/14d9a317443c43dba1f041cab3b9aa6c.png" alt="在这里插入图片描述"></p>
<h2 id="3-哈希算法"><a href="#3-哈希算法" class="headerlink" title="3. 哈希算法"></a>3. 哈希算法</h2><p>当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面. </p>
<p>Redis的字典计算哈希值有两个步骤：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算key的哈希值</span></span><br><span class="line">hash = dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">// 使用sizemask属性和哈希值，计算出索引值</span></span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p>当字典被用作数据库的底层实现，或者哈希对象的底层实现时，Redis使用<code>MurmurHash2</code>算法来计算键的哈希值. </p>
<h3 id="3-1-用于计算int型哈希值的函数"><a href="#3-1-用于计算int型哈希值的函数" class="headerlink" title="3.1 用于计算int型哈希值的函数"></a>3.1 用于计算int型哈希值的函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于计算int整型哈希值的哈希函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictIntHashFunction</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">10</span>);</span><br><span class="line">    key +=  (key &lt;&lt; <span class="number">3</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">6</span>);</span><br><span class="line">    key += ~(key &lt;&lt; <span class="number">11</span>);</span><br><span class="line">    key ^=  (key &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-MurmurHash2-算法"><a href="#3-2-MurmurHash2-算法" class="headerlink" title="3.2 MurmurHash2 算法"></a>3.2 MurmurHash2 算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于计算字符串的哈希值的哈希函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">dictGenHashFunction</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key, <span class="type">int</span> len)</span> &#123;    </span><br><span class="line">    <span class="comment">// m和r这两个值用于计算哈希值，只是因为效果好</span></span><br><span class="line">    <span class="type">uint32_t</span> seed = dict_hash_function_seed;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint32_t</span> m = <span class="number">0x5bd1e995</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> r = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">uint32_t</span> h = seed ^ len;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一次将 4 个字节混合到哈希中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *data = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串key每四个一组看成uint32_t类型，进行运算的到h</span></span><br><span class="line">    <span class="keyword">while</span>(len &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> k = *(<span class="type">uint32_t</span>*)data;</span><br><span class="line"></span><br><span class="line">        k *= m;</span><br><span class="line">        k ^= k &gt;&gt; r;</span><br><span class="line">        k *= m;</span><br><span class="line"></span><br><span class="line">        h *= m;</span><br><span class="line">        h ^= k;</span><br><span class="line"></span><br><span class="line">        data += <span class="number">4</span>;</span><br><span class="line">        len -= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输入数组的最后几个字节</span></span><br><span class="line">    <span class="keyword">switch</span>(len) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: h ^= data[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: h ^= data[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: h ^= data[<span class="number">0</span>]; h *= m;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保最后几个字节被更好的合并</span></span><br><span class="line">    h ^= h &gt;&gt; <span class="number">13</span>;</span><br><span class="line">    h *= m;</span><br><span class="line">    h ^= h &gt;&gt; <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-rehash"><a href="#4-rehash" class="headerlink" title="4. rehash"></a>4. rehash</h2><p>随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的<code>负载因子</code>维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩. </p>
<p>扩展和收缩哈希表的工作可以通过执行<code>rehash （重新散列）</code>操作来完成，Redis 对字典的哈希表执行rehash的步骤如下：</p>
<ol>
<li><p>为字典的<code>ht[1]</code>哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及<code>ht[0]</code>当前包含的键值对数量（也即是<code>ht[0].used</code>属性的值）：</p>
<p>  (1)  扩容操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used * 2</code>的<code>2 ^ n</code>.<br>  (2)  收缩操作：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used</code>的<code>2 ^ n</code>.</p>
</li>
<li><p>将保存在<code>ht[0]</code>中的所有键值对<code>rehash</code>到<code>ht[1]</code>上面：rehash 指的是重新计算键的哈希值和索引值，然后将键值对放置到<code>ht[1]</code>哈希表的指定位置上.</p>
</li>
<li><p>当<code>ht[0]</code>包含的所有键值对都迁移到了<code>ht[1]</code>之后（ht[0]变为空表），释放<br><code>ht[0]</code>，将<code>ht[1]</code>设置为<code>ht[0]</code>，并在<code>ht[1]</code>新创建一个空白哈希表，为下一次<code>rehash</code>做准备.</p>
</li>
</ol>
<h3 id="4-1-哈希表扩容与收缩的规则"><a href="#4-1-哈希表扩容与收缩的规则" class="headerlink" title="4.1 哈希表扩容与收缩的规则"></a>4.1 哈希表扩容与收缩的规则</h3><p><strong>扩容</strong></p>
<p>当以下条件中的任意一个被满足时，程序会自动开始对哈希表执行扩展操作：</p>
<ul>
<li>服务器目前没有在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子大于等于<code>1</code>.</li>
<li>服务器目前正在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且哈希表的负载因子大于等于<code>5</code>.</li>
</ul>
<p>负载因子计算公式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 负载因子 = 哈希表已保存的节点数量 / 哈希表大小</span></span><br><span class="line">load_factor = ht[<span class="number">0</span>].used / ht[<span class="number">0</span>].size</span><br></pre></td></tr></table></figure>

<p>扩容源码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回字典d是否正在rehash</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示字典是否启用rehash，dictEnableResize()和dictDisableResize()可以修改该变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> dict_can_resize = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 强制进行rehash的比例 used/size 如果大于dict_force_resize_ratio就会强制触发rehash进行扩大哈希表的操作</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> dict_force_resize_ratio = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展d字典，并初始化</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d) &#123;</span><br><span class="line">	<span class="comment">// 正在进行rehash，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果字典（的 0 号哈希表）为空，那么创建并返回初始化大小的 0 号哈希表</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字典已使用节点数和字典大小之间的比率接近 1：1</span></span><br><span class="line">	<span class="comment">// 能够扩展的标志为真 或者 已使用节点数和字典大小之间的比率超过 dict_force_resize_ratio（默认为5）</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp; (dict_can_resize || d-&gt;ht[<span class="number">0</span>].used / d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio)) </span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">// 扩展为节点个数的2倍</span></span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容或者收缩的操作都靠下面这个函数来执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据size调整或创建字典d的哈希表</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictExpand</span><span class="params">(dict *d, <span class="type">unsigned</span> <span class="type">long</span> size)</span> &#123;</span><br><span class="line">	<span class="comment">// 新的hash表</span></span><br><span class="line">    dictht n;</span><br><span class="line">    <span class="comment">// 获得一个最接近2的倍数的realsize</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在rehash或size不够大返回出错标志</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果新的realsize和原本的size一样则返回出错标志</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的哈希表并将所有指针初始化为 NULL</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 如果ht[0]哈希表为空，则将新的哈希表n设置为ht[0]</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为重新散列准备第二个散列表</span></span><br><span class="line">    <span class="comment">// 如果ht[0]非空，则需要rehash</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;    </span><br><span class="line">	<span class="comment">// 设置rehash标志位为0，开始渐进式rehash（incremental rehashing）       </span></span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的函数用于计算hash表扩容或者收缩后的大小：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __LONG_MAX__是long_int类型的最大值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LONG_MAX  __LONG_MAX__</span></span><br><span class="line"><span class="comment">// 初始化的哈希表大小为4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DICT_HT_INITIAL_SIZE     4      </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算第一个大于等于 size 的 2 ^ N ，用作哈希表的值</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> _dictNextPower(<span class="type">unsigned</span> <span class="type">long</span> size) &#123;</span><br><span class="line">	<span class="comment">// 先让i等于hash的初始大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// size最大为LONG_MAX</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= LONG_MAX) <span class="keyword">return</span> LONG_MAX;</span><br><span class="line">    <span class="comment">// 返回大于等于第一个大于哈希表初始大小的2的n次幂</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        i *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>收缩</strong></p>
<p>当哈希表的负载因子小于<code>0.1</code>时，程序自动开始对哈希表执行收缩操作.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缩小字典d</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果dict_can_resize被设置成0，表示不能进行rehash，或正在进行rehash，返回出错标志DICT_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得已经有的节点数量作为最小限度minimal</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 但是minimal不能小于最低值DICT_HT_INITIAL_SIZE（4）</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line">    <span class="comment">// 用minimal调整字典d的大小</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="5-渐进式rehash"><a href="#5-渐进式rehash" class="headerlink" title="5. 渐进式rehash"></a>5. 渐进式rehash</h2><p>为了避免<code>rehash</code>对服务器性能造成影响，服务器不是一次性将<code>ht[0]</code>里面的所有键值对全部<code>rehash</code>到<code>ht[1]</code>，而是分多次、渐进式地将<code>ht[0]</code>里面的键值对慢慢地<code>rehash</code>到<code>ht[1]</code>.</p>
<p>下面是哈希表渐进式<code>rehash</code>的步骤：</p>
<ol>
<li>为<code>ht[1]</code>分配空间，让字典同时持有<code>ht[0]</code>和<code>ht[1]</code>两个哈希表.</li>
<li>在字典中维持一个索引计数器变量<code>rehashidx</code>，并将它的值设置为0，表示<code>rehash</code>工作正式开始.</li>
<li>在<code>rehash</code>进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将<code>ht[0]</code>哈希表在<code>rehashidx</code>索引上的所有键值对<code>rehash</code>到<code>ht[1]</code>，当<code>rehash</code>工作完成之后，程序将<code>rehashidx</code>属性的值增一.</li>
<li>随着字典操作的不断执行，最终在某个时间点上，<code>ht[0]</code>的所有键值对都会被<code>rehash</code>至<code>ht[1]</code>，这时程序将<code>rehashidx</code>属性的值设为<code>-1</code>，表示<code>rehash</code>操作已完成.</li>
</ol>
<p><strong>渐进式rehash执行期间的哈希表操作</strong></p>
<p>渐进式rehash期间，如果要在字典里面查找一个键，程序会先在<code>ht[0]</code>里面进行查找，如果没有找到，就会在<code>ht[1]</code>里面进行查找.</p>
<p>另外，新添加到字典的键值对会被直接保存到<code>ht[1]</code>里面.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// n步进行渐进式rehash</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictRehash</span><span class="params">(dict *d, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">	<span class="comment">// rehashidx每次增加的上限</span></span><br><span class="line">    <span class="type">int</span> empty_visits = n * <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 只有rehashidx不等于-1时，才表示正在进行rehash，否则返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分n步，而且ht[0]上还有没有移动的节点</span></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 确保rehashidx没有越界，因为rehashidx是从-1开始，0表示已经移动1个节点，它总是小于hash表的size</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="type">unsigned</span> <span class="type">long</span>)d-&gt;rehashidx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个循环用来更新 rehashidx 的值，因为有些桶为空，所以 rehashidx并非每次都比原来前进一个位置，而是有可能前进几个位置，但最多不超过 10。</span></span><br><span class="line">        <span class="comment">// 将rehashidx移动到ht[0]有节点的下标，也就是table[d-&gt;rehashidx]非空</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ht[0]下标为rehashidx有节点，得到该节点的地址</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第二个循环用来将ht[0]表中每次找到的非空桶中的链表（或者就是单个节点）拷贝到ht[1]中</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> h;</span><br><span class="line">						</span><br><span class="line">			<span class="comment">// 备份下一个节点的地址</span></span><br><span class="line">            nextde = de-&gt;next;  </span><br><span class="line">					</span><br><span class="line">			<span class="comment">// 获得计算哈希值并得到哈希表中的下标h</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;    </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将该节点插入到下标为h的位置</span></span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新两个表节点数目计数器</span></span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将de指向以一个处理的节点</span></span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迁移过后将该下标的指针置为空</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 更新rehashidx</span></span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否已经将整张表rehash</span></span><br><span class="line">    <span class="comment">// ht[0]上已经没有节点了，说明已经迁移完成</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="comment">// 释放hash表内存</span></span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);          </span><br><span class="line">        <span class="comment">// 将迁移过的1号哈希表设置为0号哈希表</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 重置ht[1]哈希表</span></span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// rehash标志关闭</span></span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 表示已完成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 表示还有节点等待迁移</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 5.整数集合</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%205.%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>整数集合<code>（intset）</code>是集合键的底层实现之一，当一个集合<code>只包含整数值元素</code>，并且这个集合的<code>元素数量不多</code>时，Redis就会使用整数集合作为集合键的底层实现.</p>
<p><code>intset</code>可以保存类型为<code>int16_ t</code>、<code>int32_ t</code>或者<code>int64_ t</code>的整数值，并且保证集合中不会出现重复元素.</p>
<h2 id="2-整数集合的实现"><a href="#2-整数集合的实现" class="headerlink" title="2. 整数集合的实现"></a>2. 整数集合的实现</h2><p>Redis中<code>inset</code>结构定义在<code>intset.h</code>和<code>intset.c</code>中. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 16位，2个字节，表示范围-32,768~32,767</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="comment">// 32位，4个字节，表示范围-2,147,483,648~2,147,483,647</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="comment">// 64位，8个字节，表示范围-9,223,372,036,854,775,808~9,223,372,036,854,775,807</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数集合</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">	<span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合元素数量</span></span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组，元素类型并不一定是ini8_t类型</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>encoding</code>属性表示<code>contents</code>数组储存元素的类型，虽然intset结构把contents属性声明为<code>int8_t</code>类型的数组，但是可以看源码中的宏定义，其实<code>contents</code>并不保存<code>int8_t</code>类型的元素. 只保存范围更大的三种类型. </li>
<li><code>length</code>属性记录的是<code>contents</code>数组的长度.</li>
<li><code>contents</code>数组保存实际的元素，各个元素从小到大有序地排列.</li>
</ul>
<p>如下图，分别是一个储存<code>INTSET_ENC_INT16</code>类型和一个储存<code>INTSET_ENC_INT64</code>类型的整数集合：</p>
<p><img src="https://img-blog.csdnimg.cn/8622b78094b24b39b2288279bf50449c.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8e1f4516d80144988544f3f5f3d11c0b.png" alt="在这里插入图片描述"></p>
<h2 id="3-升级"><a href="#3-升级" class="headerlink" title="3. 升级"></a>3. 升级</h2><p>每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面.</p>
<h3 id="3-1-升级步骤"><a href="#3-1-升级步骤" class="headerlink" title="3.1 升级步骤"></a>3.1 升级步骤</h3><p><strong>升级三步骤</strong></p>
<ol>
<li><p>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间.</p>
</li>
<li><p>将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变.</p>
</li>
<li><p>将新元素添加到底层数组里面.</p>
</li>
</ol>
<p>比如现在要向一个储存<code>int16_t</code>类型的整数集合中添加一个<code>int32_t</code>类型的元素：</p>
<p><img src="https://img-blog.csdnimg.cn/e203db3a50054542b4adeb340fd581b4.png" alt="在这里插入图片描述"><br>每个元素占用<code>16</code>位，一共是<code>3 * 16 = 48位</code>，下图是每个元素在这48位里的位置：</p>
<p><img src="https://img-blog.csdnimg.cn/9f0b8ad56f594bd2ac35612c96f04edf.png" alt="在这里插入图片描述"><br>现在我们要插入一个整数值<code>65535</code>，它是<code>int32_t</code>类型的，所以程序需要对整数集合进行升级.</p>
<p>第一步是扩展整数集合底层数组的空间大小，并为新元素分配空间，<code>int32_t</code>类型的元素占<code>32</code>位空间，所以新数组一共占<code>4 * 32 = 128位</code>空间，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/22ee0f491a384668bd626d027132fd0d.png" alt="在这里插入图片描述"><br>第二步是将原来数组中的元素转换成<code>int32_t</code>类型，然后将转换后的元素放到正确的位上面：</p>
<p><img src="https://img-blog.csdnimg.cn/571dabdc70e941d1b77eac82243451c4.png" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/ad107e7f64fc4c86b4837745c9a83932.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e72cbe17b1144db2a59bcabdcd6aa656.png" alt="在这里插入图片描述"><br>第三步是将新元素添加到底层数组里面：</p>
<p><img src="https://img-blog.csdnimg.cn/1ddd0bdebd764d7682dfc43a58f33e4a.png" alt="在这里插入图片描述"><br>最后将整数集合的<code>encoding</code>属性的值从<code>INTSET_ENC_INT16</code>改为<code>INTSET_ENC_INT32</code>，然后将<code>length</code>属性的值从3改为4.</p>
<p>设置完之后的整数集合如图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/38a6de3623d14ef9915a34cb6e834d50.png" alt="在这里插入图片描述"></p>
<h3 id="3-2-升级的优点"><a href="#3-2-升级的优点" class="headerlink" title="3.2 升级的优点"></a>3.2 升级的优点</h3><h4 id="3-2-1-提升灵活性"><a href="#3-2-1-提升灵活性" class="headerlink" title="3.2.1 提升灵活性"></a>3.2.1 提升灵活性</h4><p>因为C语言是静态类型语言，为了避免类型错误，我们通常不会将两种不同类型的值放在同一个数据结构里面.<br>但是，因为整数集合可以通过自动升级底层数组来适应新元素，所以我们可以随意地将<code>int16_ t</code>、<code>int32_t</code>或者<code>int64_t</code>类型的整数添加到集合中，而不必担心出现类型错误，这种做法非常灵活.</p>
<h4 id="3-2-2-节约内存"><a href="#3-2-2-节约内存" class="headerlink" title="3.2.2 节约内存"></a>3.2.2 节约内存</h4><p>整数集合既可以让集合能同时保存三种不同类型的值，又可以确保升级操作只会在有需要的时候（添加更大类型的值）进行，这可以尽量节省内存.</p>
<h3 id="3-3-升级源码"><a href="#3-3-升级源码" class="headerlink" title="3.3 升级源码"></a>3.3 升级源码</h3><p><strong>获取新元素的编码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下述宏定义在stdint.h文件中</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT16_MAX            INT16_C(32767)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INT16_MIN          (-INT16_C(32767)-1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MAX           INT32_C(2147483647)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INT32_MIN         (-INT32_C(2147483647)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回合适v的编码方式</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> _intsetValueEncoding(<span class="type">int64_t</span> v) &#123;</span><br><span class="line">	<span class="comment">// 如果超出32位所能表示数值的范围则返回 INTSET_ENC_INT64</span></span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="comment">// 如果超出16位所能表示数值的范围则返回 INTSET_ENC_INT32</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重新分配内存空间</strong></p>
<p><code>intrev32ifbe()</code>函数定义在<code>endianconv.h</code>文件中，目的是将大端字节序转换为小端字节序，使得使用大端字节序的机器也能正常使用Redis.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调整集合的内存空间大小</span></span><br><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetResize</span><span class="params">(intset *is, <span class="type">uint32_t</span> len)</span> &#123; </span><br><span class="line">	<span class="comment">// 计算数组的大小</span></span><br><span class="line">    <span class="type">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取指定下标的值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据编码方式enc，返回在集合is中下标为pos的元素</span></span><br><span class="line"><span class="type">static</span> <span class="type">int64_t</span> _intsetGetEncoded(intset *is, <span class="type">int</span> pos, <span class="type">uint8_t</span> enc) &#123;</span><br><span class="line">    <span class="type">int64_t</span> v64;</span><br><span class="line">    <span class="type">int32_t</span> v32;</span><br><span class="line">    <span class="type">int16_t</span> v16;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == INTSET_ENC_INT64) &#123;</span><br><span class="line">    	<span class="comment">// 从下标pos开始的内存空间拷贝64bit的数据到v64</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v64,((<span class="type">int64_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v64));</span><br><span class="line">        memrev64ifbe(&amp;v64);</span><br><span class="line">        <span class="keyword">return</span> v64;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == INTSET_ENC_INT32) &#123;</span><br><span class="line">    	<span class="comment">// 从下标pos开始的内存空间拷贝32bit的数据到v32</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v32,((<span class="type">int32_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v32));</span><br><span class="line">        memrev32ifbe(&amp;v32);</span><br><span class="line">        <span class="keyword">return</span> v32;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//16位编码</span></span><br><span class="line">    	<span class="comment">// 从下标pos开始的内存空间拷贝16bit的数据到v16</span></span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;v16,((<span class="type">int16_t</span>*)is-&gt;contents)+pos,<span class="keyword">sizeof</span>(v16));</span><br><span class="line">        memrev16ifbe(&amp;v16);</span><br><span class="line">        <span class="keyword">return</span> v16;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设置下标pos的值为value</strong></p>
<p>这个函数实际上就是把原来的元素转换成新的编码类型，然后将转换后的元素放到正确的位上面. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据集合is设置的编码方式，设置下标为pos的值为value</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> _intsetSet(intset *is, <span class="type">int</span> pos, <span class="type">int64_t</span> value) &#123;</span><br><span class="line">	<span class="comment">// 获取集合设置的编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">    	<span class="comment">// 设置下标pos的值为value</span></span><br><span class="line">    	<span class="comment">// 这里contents数组已经被 (int64_t*) 强制转化成了新的编码类型，做赋值的时候，value也会被转化成对应的类型</span></span><br><span class="line">        ((<span class="type">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        <span class="comment">// 转换大小端</span></span><br><span class="line">        memrev64ifbe(((<span class="type">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="type">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="type">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="type">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="type">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>升级</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据value的编码方式，对整数集合is的编码格式升级</span></span><br><span class="line"><span class="type">static</span> intset *<span class="title function_">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123; </span><br><span class="line">	<span class="comment">// 当前集合的编码方式</span></span><br><span class="line">    <span class="type">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="comment">// 得到value合适的编码方式</span></span><br><span class="line">    <span class="type">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="comment">// 集合元素数量</span></span><br><span class="line">    <span class="type">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="comment">// 如果value小于0，则要将value添加到数组最前端，因此为移动1个编码长度</span></span><br><span class="line">    <span class="type">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新集合is的编码方式</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    <span class="comment">// 根据新的编码方式重新设置内存空间大小</span></span><br><span class="line">    is = intsetResize(is, intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从后往前开始升级，可以使值不会被覆盖</span></span><br><span class="line">    <span class="comment">//_intsetGetEncoded() 得到下标为length的值</span></span><br><span class="line">    <span class="comment">//_intsetSet() 把原来的元素转换成新的编码类型，然后将转换后的元素放到正确的位上面</span></span><br><span class="line">    <span class="comment">// 如果是负数，prepend就等于1，原来的元素刚好都向后移动一个位置</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在开头或者结尾放置新值</span></span><br><span class="line">    <span class="comment">// value是负数，要放在最前端</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">    	<span class="comment">// 设置下标为0的值为value</span></span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    	<span class="comment">// value为正数，设置最末尾+1的值为value</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">     <span class="comment">// 数组元素加1</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-降级"><a href="#4-降级" class="headerlink" title="4. 降级"></a>4. 降级</h2><p>整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态.</p>
<h2 id="5-部分源码剖析"><a href="#5-部分源码剖析" class="headerlink" title="5. 部分源码剖析"></a>5. 部分源码剖析</h2><h3 id="5-1-创建一个空集合"><a href="#5-1-创建一个空集合" class="headerlink" title="5.1 创建一个空集合"></a>5.1 创建一个空集合</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空集合</span></span><br><span class="line">intset *<span class="title function_">intsetNew</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">    intset *is = zmalloc(<span class="keyword">sizeof</span>(intset));</span><br><span class="line">    <span class="comment">// 设置编码方式，默认为 INTSET_ENC_INT16</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(INTSET_ENC_INT16);</span><br><span class="line">    <span class="comment">// 集合为空</span></span><br><span class="line">    is-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-查找元素"><a href="#5-2-查找元素" class="headerlink" title="5.2 查找元素"></a>5.2 查找元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回1表示value是集合中的元素，否则返回0</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">intsetFind</span><span class="params">(intset *is, <span class="type">int64_t</span> value)</span> &#123;  </span><br><span class="line">	<span class="comment">// 获得value适合的编码类型   </span></span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="comment">// 如果value的编码格式小于集合的编码格式且value在集合中已存在，返回1，其中任何一个不成立返回0</span></span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到is集合中值为value的下标，返回1，并保存在pos中，没有找到返回0，并将pos设置为value可以插入到数组的位置</span></span><br><span class="line"><span class="comment">// 因为集合是有序的，所以使用的是二分查找</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">intsetSearch</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint32_t</span> *pos)</span> &#123;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line">		</span><br><span class="line">	<span class="comment">// 空集合返回0</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value不在数组区间中的情况</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// value大于数组中的最大值</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,intrev32ifbe(is-&gt;length)<span class="number">-1</span>)) &#123;</span><br><span class="line">        	<span class="comment">// 将pos设置为数组末尾</span></span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// value小于数组的最小值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">         	<span class="comment">// pos可以是下标为0的位置</span></span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有序集合中进行二分查找</span></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">    	<span class="comment">// (min + max) / 2，找到中间数的下标</span></span><br><span class="line">        mid = ((<span class="type">unsigned</span> <span class="type">int</span>)min + (<span class="type">unsigned</span> <span class="type">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 获得下标为mid的值cur</span></span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		<span class="comment">// 找到这个值</span></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">    	<span class="comment">// 设置pos为找到的位置，返回1</span></span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	 <span class="comment">// 此时min和max相等，所以pos可以设置为min或max，返回0</span></span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-移动元素"><a href="#5-3-移动元素" class="headerlink" title="5.3 移动元素"></a>5.3 移动元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向前或向后移动指定下标范围内的数组元素</span></span><br><span class="line"><span class="comment">// 插入或者删除元素会使用这个API</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">intsetMoveTail</span><span class="params">(intset *is, <span class="type">uint32_t</span> from, <span class="type">uint32_t</span> to)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *src, *dst;</span><br><span class="line">    <span class="comment">// 获得要移动的元素的个数</span></span><br><span class="line">    <span class="type">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="comment">// 获得集合is的默认编码方式</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断不同的编码格式</span></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">    	<span class="comment">// 获得要被移动范围的起始地址</span></span><br><span class="line">        src = (<span class="type">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        <span class="comment">// 获得要被移动到的目的地址</span></span><br><span class="line">        dst = (<span class="type">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        <span class="comment">// 计算要移动多少个字节</span></span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="type">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        src = (<span class="type">int32_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="type">int32_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="type">int32_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        src = (<span class="type">int16_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="type">int16_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="type">int16_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从src开始移动bytes个字节到dst</span></span><br><span class="line">    <span class="comment">// C语言库函数</span></span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="5-4-添加元素"><a href="#5-4-添加元素" class="headerlink" title="5.4 添加元素"></a>5.4 添加元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将value添加到is集合中，如果成功success被设置为1否则为0</span></span><br><span class="line">intset *<span class="title function_">intsetAdd</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">uint8_t</span> *success)</span> &#123;</span><br><span class="line">	<span class="comment">// 获得value适合的编码类型</span></span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">uint32_t</span> pos;</span><br><span class="line">    <span class="comment">// 设置success默认为1</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果value的编码类型大于集合的编码类型</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">  		<span class="comment">// 升级集合，并且将value加入集合，该步骤必定成功</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 查找value，若果value已经存在，intsetSearch返回1,如果不存在，pos保存value可以插入的位置</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">        	<span class="comment">// value存在，success设置为0</span></span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//value在集合中不存在，且pos保存可以插入的位置</span></span><br><span class="line">        <span class="comment">// 调整集合大小</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 如果pos不是在数组末尾则要移动调整集合</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置pos下标的值为value</span></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    <span class="comment">// 集合节点数量加1</span></span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-删除元素"><a href="#5-5-删除元素" class="headerlink" title="5.5 删除元素"></a>5.5 删除元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从集合中删除value，删除成功success设置为1，失败为0</span></span><br><span class="line">intset *<span class="title function_">intsetRemove</span><span class="params">(intset *is, <span class="type">int64_t</span> value, <span class="type">int</span> *success)</span> &#123;</span><br><span class="line">	<span class="comment">// 获得value适合的编码类型</span></span><br><span class="line">    <span class="type">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="type">uint32_t</span> pos;</span><br><span class="line">    <span class="comment">// 设置success默认为0</span></span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果value的编码格式小于集合的编码格式且value在集合中已存在，pos保存着下标</span></span><br><span class="line">    <span class="keyword">if</span> (valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">    	<span class="comment">// 备份当前集合元素数量</span></span><br><span class="line">        <span class="type">uint32_t</span> len = intrev32ifbe(is-&gt;length);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 删除成功，设置success为1</span></span><br><span class="line">        <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果不是最后一个元素，则移动元素覆盖掉被删除的元素</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; (len<span class="number">-1</span>)) intsetMoveTail(is,pos+<span class="number">1</span>,pos);</span><br><span class="line">       	<span class="comment">// 缩小大小</span></span><br><span class="line">        is = intsetResize(is,len<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 更新集合元素个数</span></span><br><span class="line">        is-&gt;length = intrev32ifbe(len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 6.压缩列表</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%206.%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><code>压缩列表（ziplist）</code>是列表键和哈希键的底层实现之一. 当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串,那么Redis就会使用压缩列表来做列表键的底层实现.<br>当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现.</p>
<p>压缩列表是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构. 一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值.</p>
<h2 id="2-压缩列表的实现"><a href="#2-压缩列表的实现" class="headerlink" title="2. 压缩列表的实现"></a>2. 压缩列表的实现</h2><h3 id="2-1-压缩列表结构"><a href="#2-1-压缩列表结构" class="headerlink" title="2.1 压缩列表结构"></a>2.1 压缩列表结构</h3><p>下图展示了压缩列表的各个组成部分：</p>
<p><img src="https://img-blog.csdnimg.cn/be67d1c0691a460cbbbd82c75c0433ad.png" alt="在这里插入图片描述"><br>下表是上图中各个部分的作用：</p>
<p><img src="https://img-blog.csdnimg.cn/8b0f78946f47421493e4f7675d819eaa.png" alt="在这里插入图片描述"></p>
<p>其中关于压缩列表的源码在<code>ziplist.h</code>和<code>ziplist.c</code>文件中.</p>
<p>Redis没有提供一个结构体来保存压缩列表的信息，而是提供了一组宏来定位每个成员的地址.</p>
<p>由于压缩列表对数据的信息访问都是以字节为单位的，所以参数<code>zl</code>的类型是<code>char *</code>类型的，因此对<code>zl</code>指针进行系列的强制类型转换， 以便对不同长度成员的访问：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将zl定位到前4个字节的bytes成员，记录这整个压缩列表的内存字节数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将zl定位到4字节到8字节的offset成员，记录着压缩列表尾节点距离列表的起始地址的偏移字节量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将zl定位到8字节到10字节的length成员，记录着压缩列表的节点数量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_LENGTH(zl)      (*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩列表表头（以上三个属性）的大小10个字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回压缩列表首节点的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_HEAD(zl)  ((zl)+ZIPLIST_HEADER_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回压缩列表尾节点的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_TAIL(zl)  ((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回end成员的地址，一个字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIPLIST_ENTRY_END(zl)   ((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩列表的末尾end成员的值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_END 255</span></span><br><span class="line"><span class="comment">// 压缩列表的最多节点数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_BIGLEN 254</span></span><br></pre></td></tr></table></figure>


<p><strong>创建一个空的压缩列表</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建并返回一个新的压缩列表</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">ziplistNew</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ZIPLIST_HEADER_SIZE是压缩列表的表头大小，1字节是末端的end大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bytes = ZIPLIST_HEADER_SIZE+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为表头和表尾end成员分配空间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl = zmalloc(bytes);</span><br><span class="line">    <span class="comment">// 将zlbytes属性设置为小端字节</span></span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    <span class="comment">// 将zltail属性设置为小端字节</span></span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    <span class="comment">// 空列表的节点数量为0</span></span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将表尾end成员设置成默认的255</span></span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-2-压缩列表节点"><a href="#2-2-压缩列表节点" class="headerlink" title="2.2 压缩列表节点"></a>2.2 压缩列表节点</h3><p><code>ziplist.c</code>文件中定义了如下所示的压缩列表节点结构体，但实际上Redis并不使用这个结构体来储存压缩列表节点的数据.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* We use this function to receive information about a ziplist entry.</span></span><br><span class="line"><span class="comment"> * Note that this is not how the data is actually encoded, is just what we</span></span><br><span class="line"><span class="comment"> * get filled by a function in order to operate more easily. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize; <span class="comment">/* Bytes used to encode the previous entry len*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlen;     <span class="comment">/* Previous entry len. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize;        <span class="comment">/* Bytes used to encode this entry type/len.</span></span><br><span class="line"><span class="comment">                                    For example strings have a 1, 2 or 5 bytes</span></span><br><span class="line"><span class="comment">                                    header. Integers always use a single byte.*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;            <span class="comment">/* Bytes used to represent the actual entry.</span></span><br><span class="line"><span class="comment">                                    For strings this is just the string length</span></span><br><span class="line"><span class="comment">                                    while for integers it is 1, 2, 3, 4, 8 or</span></span><br><span class="line"><span class="comment">                                    0 (for 4 bit immediate) depending on the</span></span><br><span class="line"><span class="comment">                                    number range. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;     <span class="comment">/* prevrawlensize + lensize. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;      <span class="comment">/* Set to ZIP_STR_* or ZIP_INT_* depending on</span></span><br><span class="line"><span class="comment">                                    the entry encoding. However for 4 bits</span></span><br><span class="line"><span class="comment">                                    immediate integers this can assume a range</span></span><br><span class="line"><span class="comment">                                    of values and must be range-checked. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;            <span class="comment">/* Pointer to the very start of the entry, that</span></span><br><span class="line"><span class="comment">                                    is, this points to prev-entry-len field. */</span></span><br><span class="line">&#125; zlentry;</span><br></pre></td></tr></table></figure>


<p>压缩列表节点的真实结构是这样的：</p>
<p><img src="https://img-blog.csdnimg.cn/5f3d7ce2446149bd89ab9816f7c46ee0.png" alt="在这里插入图片描述"></p>
<ul>
<li><p><code>previous_entry_length</code>属性以字节为单位，记录了压缩列表中前一个节点的长度，该属性的长度可以是<code>1</code>字节或者<code>5</code>字节. 根据这个属性，我们可以直接通过指针运算得到前一个节点的起始地址.</p>
<ul>
<li><p>如果前一节点的长度小于<code>254</code>字节，那么<code>previous_entry_length</code>属性的长度为1字节，前一节点的长度就保存在这一个字节里面.</p>
</li>
<li><p>如果前一节点的长度大于等于254字节，那么<code>previous_entry_length</code>属性的长度为5字节，其中属性的第一字节会被设置为<code>0xFE (十进制值254 )</code>，而之后的四个字节则用于保存前一节点的长度.</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对p指向的当前节点的前驱节点的长度len成员进行编码，并写入p中，如果p为空，则仅仅返回编码len所需要的字节数</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">zipPrevEncodeLength</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *p, <span class="type">unsigned</span> <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    	<span class="comment">// 如果前驱节点的长度len字节小于254则返回1个字节，否则返回5个</span></span><br><span class="line">        <span class="keyword">return</span> (len &lt; ZIP_BIGLEN) ? <span class="number">1</span> : <span class="keyword">sizeof</span>(len)+<span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		<span class="comment">// 如果前驱节点的长度len字节小于254</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; ZIP_BIGLEN) &#123;</span><br><span class="line">      	    <span class="comment">// 将len保存在p[0]中</span></span><br><span class="line">            p[<span class="number">0</span>] = len;</span><br><span class="line">            <span class="comment">// 返回所需的编码数1字节</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       		<span class="comment">// 前驱节点的长度len大于254字节</span></span><br><span class="line">       		<span class="comment">// 添加5字节的标示，0xFE（254）</span></span><br><span class="line">            p[<span class="number">0</span>] = ZIP_BIGLEN;</span><br><span class="line">            <span class="comment">// 从p+1的起始地址开始拷贝len</span></span><br><span class="line">            <span class="built_in">memcpy</span>(p+<span class="number">1</span>,&amp;len,<span class="keyword">sizeof</span>(len));</span><br><span class="line">            memrev32ifbe(p+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 返回所需的编码数5字节</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+<span class="keyword">sizeof</span>(len); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>encoding</code>属性记录了节点的<code>content</code>属性所保存数据的类型以及长度：</p>
<ul>
<li><p><code>1</code>、<code>2</code>或者<code>5</code>字节长值的最高位为<code>00</code>、<code>01</code>或者<code>10</code>的是字节数组编码，这种编码表示节点的<code>content</code>属性保存着<code>字节数组</code>，数组的长度由编码除去最高两位之后的其他位记录.</p>
</li>
<li><p><code>1</code>字节长，值的最高位以<code>11</code>开头的是<code>整数编码</code>，这种编码表示节点的<code>content</code>属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录.</p>
<p>  相关宏定义：</p>
</li>
</ul>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字节数组</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_MASK 0xc0               <span class="comment">//1100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_06B (0 &lt;&lt; 6)            <span class="comment">//0000 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_14B (1 &lt;&lt; 6)            <span class="comment">//0100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_STR_32B (2 &lt;&lt; 6)            <span class="comment">//1000 0000</span></span></span><br><span class="line">			</span><br><span class="line"><span class="comment">// 整数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_MASK 0x30               <span class="comment">//0011 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_16B (0xc0 | 0&lt;&lt;4)       <span class="comment">//1100 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_32B (0xc0 | 1&lt;&lt;4)       <span class="comment">//1101 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_64B (0xc0 | 2&lt;&lt;4)       <span class="comment">//1110 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_24B (0xc0 | 3&lt;&lt;4)       <span class="comment">//1111 0000</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZIP_INT_8B 0xfe                 <span class="comment">//1111 1110</span></span></span><br></pre></td></tr></table></figure>

</li>
<li><p><code>content</code>属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的<code>encoding</code>属性决定.</p>
<ul>
<li><p>每个压缩列表节点可以保存一个字节数组或者一个整数值：</p>
<ul>
<li><p>字节数组：</p>
<ul>
<li>长度小于等于<code>63 * (2 ^ 6 - 1)</code>字节的字节数组</li>
<li>长度小于等于<code>16383 * (2 ^ 14 - 1)</code>字节的字节数组</li>
<li>长度小于等于<code>4 294 967 295 * (2 ^ 32 - 1)</code>字节的字节数组</li>
</ul>
</li>
<li><p>整数</p>
<ul>
<li>4位长，介于0至12之间的无符号整数</li>
<li>1字节长的有符号整数</li>
<li>3字节长的有符号整数</li>
<li><code>int16_t</code>类型整数</li>
<li><code>int32_t</code>类型整数</li>
<li><code>int64_t</code>类型整数</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-连锁更新"><a href="#3-连锁更新" class="headerlink" title="3. 连锁更新"></a>3. 连锁更新</h2><p>前面说过，每个节点的<code>previous_entry_length</code>属性都记录了前一个节点的长度：</p>
<ul>
<li>如果前一节点的长度小于<code>254</code>字节，那么<code>previous_entry_length</code>属性的长度为1字节，前一节点的长度就保存在这一个字节里面.</li>
<li>如果前一节点的长度大于等于254字节，那么<code>previous_entry_length</code>属性的长度为5字节，其中属性的第一字节会被设置为<code>0xFE (十进制值254 )</code>，而之后的四个字节则用于保存前一节点的长度.</li>
</ul>
<p>现在，考虑这样一种情况：在一个压缩列表中，有多个连续的、长度介于<code>250</code>字节到<code>253</code>字节之间的节点<code>e1</code>至<code>eN</code>，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/ca3420bfdc6a4840aec7d723765acf62.png" alt="在这里插入图片描述"></p>
<p>因为<code>e1</code>至<code>eN</code>的所有节点的长度都小于<code>254</code>字节，所以记录这些节点的长度只需要<code>1</code>字节长的<code>previous_entry_length</code>属性. </p>
<p>这时，如果我们将一个长度大于等于<code>254</code>字节的新节点<code>new</code>设置为压缩列表的表头节点，那么<code>new</code>将成为<code>el</code>的前置节点，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/27dd916104b3499cbddd227e6c4750cc.png" alt="在这里插入图片描述"></p>
<p>因为<code>e1</code>的<code>previous_entry_length</code>属性仅长<code>1</code>字节，它没办法保存新节点new的长度，所以程序将对压缩列表执行空间重分配操作，并将<code>e1</code>节点的<code>previous_entry_length</code>属性从原来的<code>1</code>字节长扩展为<code>5</code>字节长.</p>
<p>接着程序会不断的对压缩列表执行空间重分配操作，直到<code>eN</code>为止.</p>
<p>Redis将这种在特殊情况下产生的连续多次空间扩展操作称之为<code>&quot;连锁更新&quot;</code>. 出了添加节点可能引发连锁更新以外，删除节点也可能引发连锁更新.</p>
<p>因为连锁更新在最坏情况下需要对压缩列表执行<code>N</code>次空间重分配操作，而每次空间重分配的最坏复杂度为<code>O(N)</code>，所以连锁更新的最坏复杂度为<code>O(N)</code>.</p>
<p>但其实我们可以不用担心连锁更新的问题，因为连锁更新在Redis中发生的概率比较低：</p>
<ul>
<li><p>首先，压缩列表里要恰好有多个连续的、长度介于<code>250</code>字节至<code>253</code>字节之间的节点，连锁更新才有可能被引发，在实际中，这种情况并不多见.</p>
</li>
<li><p>其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如说，对三五个节点进行连锁更新是绝对不会影响性能的.（一旦存储的数据量变大，Redis一般就不会使用压缩列表了）.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 9.字符串对象</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%209.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="1-字符串对象的结构"><a href="#1-字符串对象的结构" class="headerlink" title="1. 字符串对象的结构"></a>1. 字符串对象的结构</h2><p>下图展示了字符串对象的结构，首先是一个<code>redisObject</code>表头，表头中规定了对象类型以及对象所使用的编码，<code>ptr</code>指针则指向了一个<code>sdshdr</code>表头，<code>sdshdr</code>结构中的<code>buf</code>数组保存着实际的字符串.</p>
<p><img src="https://img-blog.csdnimg.cn/d2cbdf38c7864f2f90fb035830b6db61.png" alt="在这里插入图片描述"></p>
<h2 id="2-字符串对象编码"><a href="#2-字符串对象编码" class="headerlink" title="2. 字符串对象编码"></a>2. 字符串对象编码</h2><h3 id="2-1-编码使用规则"><a href="#2-1-编码使用规则" class="headerlink" title="2.1 编码使用规则"></a>2.1 编码使用规则</h3><p>前面我们说到，Redis中的一种对象有着多种底层数据结构的实现. 而String对象的编码有三种，见下表：</p>
<table>
<thead>
<tr>
<th>encoding</th>
<th>ptr</th>
</tr>
</thead>
<tbody><tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
</tbody></table>
<p>各种编码的使用规则是这样的：</p>
<ul>
<li>字符串保存的值是整数，并且该整数可以用<code>long</code>类型表示，使用<code>OBJ_ENCODING_INT</code>编码.</li>
<li>字符串保存的对象是一个字符串值，并且字符串的长度小于44字节，使用<code>OBJ_ENCODING_EMBSTR</code>编码. （redis使用jemalloc内存分配器，且jemalloc会分配8，16，32，64等字节的内存，一个embstr固定的大小为16+3+1 &#x3D; 20个字节，因此一个最大的embstr字符串为64-20 &#x3D; 44字节.）</li>
<li>字符串保存的对象是一个字符串值，并且字符串的大于44字节，使用<code>OBJ_ENCODING_RAW</code>编码.</li>
</ul>
<h3 id="2-2-编码转换"><a href="#2-2-编码转换" class="headerlink" title="2.2 编码转换"></a>2.2 编码转换</h3><p><code>int</code>和<code>embstr</code>编码的字符串对象满足一定的条件，会被转化为<code>raw </code>编码的字符串对象.</p>
<ul>
<li>对<code>int</code>和<code>embstr</code>字符串对象使用<code>APPEND</code>命令，对象会变成<code>raw</code>编码.</li>
<li><code>int</code>编码的整数字符串超出<code>long</code>能表示的范围，或者<code>embstr</code>编码的字符串超过<code>44</code>字节，都会变成<code>raw</code>编码.</li>
</ul>
<p>需要说明的是，<code>embstr</code>编码是专门用于保存短字符串的一种优化编码方式，这种编码和<code>raw</code>编码是一样的，但<code>raw</code>编码会调用两次内存分配函数来分别创建<code>redisObject</code>结构和<code>sdshdr</code>结构，而<code>embstr</code>编码则通过调用一次内存分配函数来分配一块连续的空间，这一块空间中直接就包含了上面的两个部分，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/21b674b7020a4311a068bad25fa93a02.png" alt="在这里插入图片描述"></p>
<p>使用<code>embstr</code>编码的字符串对象来保存短字符串有以下好处：</p>
<ul>
<li><code>embstr</code>编码将创建字符串对象所需的内存分配次数从<code>raw</code>编码的两次降低为一次.</li>
<li>释放<code>embstr</code>编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数.</li>
<li>因为<code>embstr</code>编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起<code>raw</code>编码的字符串对象能够更好地利用缓存带来的优势.</li>
</ul>
<p>其次，Redis没有为<code>embstr</code>编码的字符串编写任何相应的修改程序，所以<code>embstr</code>编码的字符串实际上是可读的，任何对它进行修改的操作，都会让它变为<code>raw</code>编码.</p>
<h2 id="3-字符串对象命令介绍"><a href="#3-字符串对象命令介绍" class="headerlink" title="3. 字符串对象命令介绍"></a>3. 字符串对象命令介绍</h2><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>GETSET key value</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值（old value）</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位（bit）</td>
</tr>
<tr>
<td>MGET key1 [key2..]</td>
<td>获取所有（一个或多个）给定 key 的值</td>
</tr>
<tr>
<td>SETBIT key offset value</td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位（bit）</td>
</tr>
<tr>
<td>SETEX key seconds value</td>
<td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds （以秒为单位）</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td>MSET key value [key value …]</td>
<td>同时设置一个或多个 key-value 对</td>
</tr>
<tr>
<td>MSETNX key value [key value …]</td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</td>
</tr>
<tr>
<td>PSETEX key milliseconds value</td>
<td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>INCRBY key increment将 key</td>
<td>所储存的值加上给定的增量值（increment）</td>
</tr>
<tr>
<td>INCRBYFLOAT key increment</td>
<td>将 key 所储存的值加上给定的浮点增量值（increment）</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一</td>
</tr>
<tr>
<td>DECRBY key decrementkey</td>
<td>所储存的值减去给定的减量值（decrement）</td>
</tr>
<tr>
<td>APPEND key value</td>
<td>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾</td>
</tr>
</tbody></table>
<h2 id="4-字符串对象命令的实现"><a href="#4-字符串对象命令的实现" class="headerlink" title="4. 字符串对象命令的实现"></a>4. 字符串对象命令的实现</h2><p>字符串对象命令的实现代码在<code>t_string.c</code>源文件中.</p>
<h3 id="4-1-SET命令"><a href="#4-1-SET命令" class="headerlink" title="4.1 SET命令"></a>4.1 SET命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET_NO_FLAGS 0</span></span><br><span class="line"><span class="comment">// 在key不存在的情况下才会设置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET_NX (1&lt;&lt;0)</span></span><br><span class="line"><span class="comment">// 在key存在的情况下才会设置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET_XX (1&lt;&lt;1)</span></span><br><span class="line"><span class="comment">// 以秒(s)为单位设置键的key过期时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET_EX (1&lt;&lt;2)</span></span><br><span class="line"><span class="comment">// 以毫秒(ms)为单位设置键的key过期时间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET_PX (1&lt;&lt;3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// setGenericCommand() 函数是以下命令: SET, SETEX, PSETEX, SETNX 的最底层实现</span></span><br><span class="line"><span class="comment">// flags 可以是NX或XX，由上面的宏提供</span></span><br><span class="line"><span class="comment">// expire 定义key的过期时间，格式由unit指定</span></span><br><span class="line"><span class="comment">// ok_reply和abort_reply保存着回复client的内容，NX和XX也会改变回复</span></span><br><span class="line"><span class="comment">// 如果ok_reply为空，则使用 &quot;+OK&quot;</span></span><br><span class="line"><span class="comment">// 如果abort_reply为空，则使用 &quot;$-1&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setGenericCommand</span><span class="params">(client *c, <span class="type">int</span> flags, robj *key, robj *val, robj *expire, <span class="type">int</span> unit, robj *ok_reply, robj *abort_reply)</span> &#123;</span><br><span class="line">	<span class="comment">// 初始化，避免错误</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> milliseconds = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果定义了key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        <span class="comment">// 从expire对象中取出值，保存在milliseconds中，如果出错发送默认的信息给client</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果过期时间小于等于0，则发送错误信息给client</span></span><br><span class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">&quot;invalid expire time in %s&quot;</span>,c-&gt;cmd-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果unit的单位是秒，则需要转换为毫秒保存</span></span><br><span class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookupKeyWrite函数是为执行写操作而取出key的值对象</span></span><br><span class="line">    <span class="comment">// 如果设置了NX(不存在)，但是在数据库中 可以找到 该key</span></span><br><span class="line">    <span class="comment">// 或者设置了XX(存在)，但是在数据库中 不可以找到 该key</span></span><br><span class="line">    <span class="comment">// 回复abort_reply给client</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</span><br><span class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// db.c文件中的函数，在当前db设置键为key的值为val</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据库为脏(dirty)，服务器每次修改一个key后，都会对脏键(dirty)增1</span></span><br><span class="line">    server.dirty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置key的过期时间</span></span><br><span class="line">    <span class="comment">// mstime()返回毫秒为单位的格林威治时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送&quot;set&quot;事件的通知，用于发布订阅模式，通知客户端接受发生的事件</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送&quot;expire&quot;事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">        <span class="string">&quot;expire&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置成功，则向客户端发送ok_reply</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-GET命令"><a href="#4-2-GET命令" class="headerlink" title="4.2 GET命令"></a>4.2 GET命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GET 命令的底层实现</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getGenericCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lookupKeyReadOrReply函数是为执行读操作而返回key的值对象，找到返回该对象，找不到会发送信息给client</span></span><br><span class="line">    <span class="comment">// 如果key不存在直接，返回0表示GET命令执行成功</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果key的值的编码类型不是字符串对象</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != OBJ_STRING) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);    <span class="comment">//返回类型错误的信息给client，返回-1表示GET命令执行失败</span></span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,o);  <span class="comment">//返回之前找到的对象作为回复给client，返回0表示GET命令执行成功</span></span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-DECR-和-INCR-命令"><a href="#4-3-DECR-和-INCR-命令" class="headerlink" title="4.3 DECR 和 INCR 命令"></a>4.3 DECR 和 INCR 命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DECR key 将 key 中储存的数字值减一</span></span><br><span class="line"><span class="comment">// INCR key 将 key 中储存的数字值增一</span></span><br><span class="line"><span class="comment">//INCR和DECR命令的底层实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrDecrCommand</span><span class="params">(client *c, <span class="type">long</span> <span class="type">long</span> incr)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> value, oldvalue;</span><br><span class="line">    robj *o, *new;</span><br><span class="line"></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);   <span class="comment">//以写操作获取key的value对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到了value对象但是value对象不是字符串类型，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串类型的value转换为long long类型保存在value中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != C_OK) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 备份旧的value</span></span><br><span class="line">    oldvalue = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果incr超出long long类型所能表示的范围，发送错误信息</span></span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; oldvalue &lt; <span class="number">0</span> &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</span><br><span class="line">        (incr &gt; <span class="number">0</span> &amp;&amp; oldvalue &gt; <span class="number">0</span> &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;increment or decrement would overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    value += incr;  <span class="comment">//计算新的value值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// value对象目前非共享，编码为整型类型，且新value值不在共享范围，且value处于long类型所表示的范围内</span></span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp; o-&gt;refcount == <span class="number">1</span> &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</span><br><span class="line">        (value &lt; <span class="number">0</span> || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</span><br><span class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        new = o;</span><br><span class="line">        <span class="comment">// 设置vlaue对象的值</span></span><br><span class="line">        o-&gt;ptr = (<span class="type">void</span>*)((<span class="type">long</span>)value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当不满足以上任意条件，则新创建一个字符串对象</span></span><br><span class="line">        new = createStringObjectFromLongLong(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前的value对象存在</span></span><br><span class="line">        <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        	<span class="comment">// 用new对象去重写key的值</span></span><br><span class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],new);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 如果之前的value不存在，将key和new组成新的key-value对</span></span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],new);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数据库的键被改动，则会调用该函数发送信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送&quot;incrby&quot;事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;incrby&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 设置脏键</span></span><br><span class="line">    server.dirty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复信息给client</span></span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,new);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-4-APPEND-命令"><a href="#4-4-APPEND-命令" class="headerlink" title="4.4 APPEND 命令"></a>4.4 APPEND 命令</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// APPEND key value 追加字符串</span></span><br><span class="line"><span class="comment">// APPEND命令的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">appendCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> totlen;</span><br><span class="line">    robj *o, *append;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以写操作获取key的value对象</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有获取到vlaue，则要创建一个</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">// 对参数value进行优化编码</span></span><br><span class="line">        c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// 将key和value组成新的key-value对</span></span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]); </span><br><span class="line">        <span class="comment">// 增加value的引用计数</span></span><br><span class="line">        incrRefCount(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">// 返回vlaue的长度</span></span><br><span class="line">        totlen = stringObjectLen(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">		<span class="comment">// 获取到value</span></span><br><span class="line">		<span class="comment">// 如果value不是字符串类型的对象直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,OBJ_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* &quot;append&quot; is an argument, so always an sds */</span></span><br><span class="line">        <span class="comment">// 获得追加的值对象</span></span><br><span class="line">        append = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 计算追加后的长度</span></span><br><span class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</span><br><span class="line">        <span class="comment">// 如果追加后的长度超出范围，则返回</span></span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,totlen) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为要根据value修改key的值，因此如果key原来的值是共享的，需要解除共享，新创建一个值对象与key组对</span></span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        <span class="comment">// 将vlaue对象的值后面追加上append的值</span></span><br><span class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</span><br><span class="line">        <span class="comment">// 计算出追加后值的长度</span></span><br><span class="line">        totlen = sdslen(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当数据库的键被改动，则会调用该函数发送信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送&quot;append&quot;事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">&quot;append&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 设置脏键</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">// 发送追加后value的长度给client</span></span><br><span class="line">    addReplyLongLong(c,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 8.对象系统</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%208.%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在前面的章节中，我们介绍了Redis中用到的所有底层数据结构，包括：<code>SDS</code>、<code>双端链表</code>、<code>字典</code>、<code>跳表</code>、<code>压缩列表</code>、<code>整数集合</code>、<code>快速列表</code>.</p>
<p>Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统，这个系统包含<code>字符串对象</code>、<code>列表对象</code>、<code>哈希对象</code>、<code>集合对象</code>和<code>有序集合对象</code>这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构.</p>
<p><strong>使用对象系统的优点：</strong></p>
<ul>
<li>Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令.</li>
<li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率.</li>
</ul>
<p>除此之外，对象系统还实现了一些比较实用的机制：</p>
<p><strong>内存回收机制：</strong></p>
<p>基于引用计数技术，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放.</p>
<p><strong>对象共享机制</strong></p>
<p>Redis同样通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存.</p>
<p><strong>过期键自动删除</strong></p>
<p>Redis的对象带有访问时间记录信息，该信息可以用于计算数据库键的空转时长，在服务器启用了<code>maxmemory</code>功能的情况下，空转时长较大的那些键可能会优先被服务器删除.</p>
<h2 id="2-对象的结构"><a href="#2-对象的结构" class="headerlink" title="2. 对象的结构"></a>2. 对象的结构</h2><p>我们在Redis数据库中新创建一个键值对的时候，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）. 其中键对象固定是一个字符串对象，而值对象则是由<code>redisObject</code>结构保存的数据，该结构中和保存数据有关的三个属性分别是：<code>type</code>属性、<code>encoding</code>属性和<code>ptr</code>属性. 而<code>lru</code>和<code>refcount</code>分别是用于对象删除和对象引用的字段，我们后面再解释.</p>
<p>Redis对象相关的源码在<code>server.h</code>和<code>object.c</code>文件中.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 对象的数据类型，占4bits，共5种类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 对象的编码，占4bits，共10种类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实用LRU算法计算相对server.lruclock的LRU时间</span></span><br><span class="line">    <span class="type">unsigned</span> lru:LRU_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向底层数据实现的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-对象类型"><a href="#2-1-对象类型" class="headerlink" title="2.1 对象类型"></a>2.1 对象类型</h3><p>对象的<code>type</code>属性记录了对象的类型，Redis一共有5个对象类型，见下表：</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody></table>
<p>当我们对一个数据库键执行<code>TYPE KEY</code>命令时，命令会返回该数据库键对应的<code>值对象的类型</code>，下表列出了<code>TYPE KEY</code>命令在面对不同类型的值对象所产生的输出：</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>对象 type 属性的值</th>
<th>TYPE 命令的输出</th>
</tr>
</thead>
<tbody><tr>
<td>字符串对象</td>
<td>REDIS_STRING</td>
<td>“string”</td>
</tr>
<tr>
<td>列表对象</td>
<td>REDIS_LIST</td>
<td>“list”</td>
</tr>
<tr>
<td>哈希对象</td>
<td>REDIS_HASH</td>
<td>“hash”</td>
</tr>
<tr>
<td>集合对象</td>
<td>REDIS_SET</td>
<td>“set”</td>
</tr>
<tr>
<td>有序集合对象</td>
<td>REDIS_ZSET</td>
<td>“zset”</td>
</tr>
</tbody></table>
<p><code>type</code>属性会被设置为对应类型的宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串对象</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_STRING 0</span></span><br><span class="line"><span class="comment">// 列表对象</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_LIST 1</span></span><br><span class="line"><span class="comment">// 集合对象</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SET 2</span></span><br><span class="line"><span class="comment">// 有序集合对象</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ZSET 3</span></span><br><span class="line"><span class="comment">// 哈希对象</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_HASH 4</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-对象编码和底层类型"><a href="#2-2-对象编码和底层类型" class="headerlink" title="2.2 对象编码和底层类型"></a>2.2 对象编码和底层类型</h3><p>一种对象在保存不同大小数据的时候，可能使用不同的编码类型，而编码类型由<code>encoding</code>属性来记录. 使用命令<code>OBJECT ENCODING KEY</code>可以得到该数据库键对应值所使用的编码.</p>
<p>下表记录了每种对象会使用的编码类型：</p>
<table>
<thead>
<tr>
<th>encoding</th>
<th>ptr</th>
</tr>
</thead>
<tbody><tr>
<td>OBJ_ENCODING_INT</td>
<td>整数值实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_RAW</td>
<td>简单动态字符串实现的字符串对象</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>快速列表实现的列表对象</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_INTSET</td>
<td>整数集合实现的集合对象</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的哈希对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_HT</td>
<td>字典实现的哈希对象</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>跳跃表和字典实现的有序集合对象</td>
</tr>
<tr>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>压缩列表实现的有序集合对象</td>
</tr>
</tbody></table>
<p>下面是<code>enconding</code>属性会用到的宏：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="comment">// redis 5.0添加，用于消息队列的数据类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-指向底层类型的指针"><a href="#2-3-指向底层类型的指针" class="headerlink" title="2.3 指向底层类型的指针"></a>2.3 指向底层类型的指针</h3><p><code>ptr</code>是一个万能指针，它会指向对象的底层实现数据类型. 我们后面会逐一介绍这些类型.</p>
<h2 id="3-对象系统的重要操作"><a href="#3-对象系统的重要操作" class="headerlink" title="3. 对象系统的重要操作"></a>3. 对象系统的重要操作</h2><p>Redis为对象系统定义了丰富的API，以下函数定义在<code>server.h</code>头文件中，实现在<code>server.c</code>源文件中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Redis object implementation */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrRefCount</span><span class="params">(robj *o)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">decrRefCountVoid</span><span class="params">(<span class="type">void</span> *o)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">incrRefCount</span><span class="params">(robj *o)</span>;</span><br><span class="line">robj *<span class="title function_">resetRefCount</span><span class="params">(robj *obj)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStringObject</span><span class="params">(robj *o)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeListObject</span><span class="params">(robj *o)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeSetObject</span><span class="params">(robj *o)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeZsetObject</span><span class="params">(robj *o)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">freeHashObject</span><span class="params">(robj *o)</span>;</span><br><span class="line"></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span>;</span><br><span class="line">robj *<span class="title function_">createStringObject</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span>;</span><br><span class="line">robj *<span class="title function_">createRawStringObject</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span>;</span><br><span class="line">robj *<span class="title function_">createEmbeddedStringObject</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span>;</span><br><span class="line">robj *<span class="title function_">dupStringObject</span><span class="params">(robj *o)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">isObjectRepresentableAsLongLong</span><span class="params">(robj *o, <span class="type">long</span> <span class="type">long</span> *llongval)</span>;</span><br><span class="line">robj *<span class="title function_">tryObjectEncoding</span><span class="params">(robj *o)</span>;</span><br><span class="line">robj *<span class="title function_">getDecodedObject</span><span class="params">(robj *o)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">stringObjectLen</span><span class="params">(robj *o)</span>;</span><br><span class="line">robj *<span class="title function_">createStringObjectFromLongLong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span>;</span><br><span class="line">robj *<span class="title function_">createStringObjectFromLongDouble</span><span class="params">(<span class="type">long</span> <span class="type">double</span> value, <span class="type">int</span> humanfriendly)</span>;</span><br><span class="line">robj *<span class="title function_">createQuicklistObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createZiplistObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createSetObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createIntsetObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createHashObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">robj *<span class="title function_">createZsetZiplistObject</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLongFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="type">long</span> *target, <span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">checkType</span><span class="params">(client *c, robj *o, <span class="type">int</span> type)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getLongLongFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="type">long</span> <span class="type">long</span> *target, <span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getDoubleFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="type">double</span> *target, <span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getLongLongFromObject</span><span class="params">(robj *o, <span class="type">long</span> <span class="type">long</span> *target)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getLongDoubleFromObject</span><span class="params">(robj *o, <span class="type">long</span> <span class="type">double</span> *target)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getLongDoubleFromObjectOrReply</span><span class="params">(client *c, robj *o, <span class="type">long</span> <span class="type">double</span> *target, <span class="type">const</span> <span class="type">char</span> *msg)</span>;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">strEncoding</span><span class="params">(<span class="type">int</span> encoding)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">compareStringObjects</span><span class="params">(robj *a, robj *b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">collateStringObjects</span><span class="params">(robj *a, robj *b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">equalStringObjects</span><span class="params">(robj *a, robj *b)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">estimateObjectIdleTime</span><span class="params">(robj *o)</span>;</span><br></pre></td></tr></table></figure>

<p>我们挑选几个进行研究.</p>
<h3 id="3-1-创建字符串对象"><a href="#3-1-创建字符串对象" class="headerlink" title="3.1 创建字符串对象"></a>3.1 创建字符串对象</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个默认的对象</span></span><br><span class="line">robj *<span class="title function_">createObject</span><span class="params">(<span class="type">int</span> type, <span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    <span class="comment">// 设置对象类型</span></span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    <span class="comment">// 设置默认的编码方式</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    <span class="comment">// 设置对象</span></span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    <span class="comment">// 引用计数为1</span></span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution). */</span></span><br><span class="line">    <span class="comment">// 计算设置当前LRU时间</span></span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>创建一个编码为 OBJ_ENCODING_RAW 的字符串对象</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个字符串对象，编码默认为 OBJ_ENCODING_RAW，指向的数据为一个sds</span></span><br><span class="line">robj *<span class="title function_">createRawStringObject</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createObject(OBJ_STRING,sdsnewlen(ptr,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建一个编码为 OBJ_ENCODING_EMBSTR 的字符串对象</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个embstr编码的字符串对象</span></span><br><span class="line">robj *<span class="title function_">createEmbeddedStringObject</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">	<span class="comment">// 分配空间</span></span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sdshdr8)+len+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// o+1刚好就是struct sdshdr8的地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr8</span> *<span class="title">sh</span> =</span> (<span class="type">void</span>*)(o+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 类型为字符串对象</span></span><br><span class="line">    o-&gt;type = OBJ_STRING;</span><br><span class="line">    <span class="comment">// 设置编码类型</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_EMBSTR;</span><br><span class="line">    <span class="comment">// 指向分配的sds对象，分配的len+1的空间首地址</span></span><br><span class="line">    o-&gt;ptr = sh+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置引用计数</span></span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算设置当前LRU时间</span></span><br><span class="line">    o-&gt;lru = LRU_CLOCK();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置字符串长度</span></span><br><span class="line">    sh-&gt;len = len;</span><br><span class="line">    <span class="comment">// 设置最大容量</span></span><br><span class="line">    sh-&gt;alloc = len;</span><br><span class="line">    <span class="comment">// 设置sds的类型</span></span><br><span class="line">    sh-&gt;flags = SDS_TYPE_8;</span><br><span class="line">    <span class="comment">// 如果传了字符串参数</span></span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">   		<span class="comment">// 将传进来的ptr保存到对象中</span></span><br><span class="line">        <span class="built_in">memcpy</span>(sh-&gt;buf,ptr,len);</span><br><span class="line">        <span class="comment">// 结束符标志</span></span><br><span class="line">        sh-&gt;buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 否则将对象的空间初始化为0</span></span><br><span class="line">        <span class="built_in">memset</span>(sh-&gt;buf,<span class="number">0</span>,len+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>创建一个编码为 OBJ_ENCODING_INT 的字符串对象</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串对象，根据整数值</span></span><br><span class="line">robj *<span class="title function_">createStringObjectFromLongLong</span><span class="params">(<span class="type">long</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redis中[0, 10000)内的整数是共享的</span></span><br><span class="line">    <span class="comment">// 如果value属于redis共享整数的范围</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; OBJ_SHARED_INTEGERS) &#123;</span><br><span class="line">    	<span class="comment">// 引用计数加1</span></span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        <span class="comment">// 返回一个编码类型为OBJ_ENCODING_INT的字符串对象</span></span><br><span class="line">        o = shared.integers[value];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不在共享整数的范围</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// value在long类型所表示的范围内</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">        	<span class="comment">// 创建对象</span></span><br><span class="line">            o = createObject(OBJ_STRING, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 编码类型为OBJ_ENCODING_INT</span></span><br><span class="line">            o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">            <span class="comment">// 指向这个value值</span></span><br><span class="line">            o-&gt;ptr = (<span class="type">void</span>*)((<span class="type">long</span>)value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// value不在long类型所表示的范围内，将long long类型的整数转换为字符串</span></span><br><span class="line">            <span class="comment">// 编码类型为OBJ_ENCODING_RAW</span></span><br><span class="line">            o = createObject(OBJ_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>根据不同的长度使用不同的编码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sdshdr8的大小为3个字节，加上1个结束符共4个字节</span></span><br><span class="line"><span class="comment">// redisObject的大小为16个字节</span></span><br><span class="line"><span class="comment">// redis使用jemalloc内存分配器，且jemalloc会分配8，16，32，64等字节的内存</span></span><br><span class="line"><span class="comment">// 一个embstr固定的大小为16+3+1 = 20个字节，因此一个最大的embstr字符串为64-20 = 44字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建字符串对象，根据长度使用不同的编码类型</span></span><br><span class="line"><span class="comment">// createRawStringObject和createEmbeddedStringObject的区别是：</span></span><br><span class="line"><span class="comment">// createRawStringObject是当字符串长度大于44字节时，robj结构和sdshdr结构在内存上是分开的</span></span><br><span class="line"><span class="comment">// createEmbeddedStringObject是当字符串长度小于等于44字节时，robj结构和sdshdr结构在内存上是连续的</span></span><br><span class="line">robj *<span class="title function_">createStringObject</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ptr, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-2-复制字符串对象"><a href="#3-2-复制字符串对象" class="headerlink" title="3.2 复制字符串对象"></a>3.2 复制字符串对象</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 复制的o对象的副本的地址，且创建的对象非共享</span></span><br><span class="line">robj *<span class="title function_">dupStringObject</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">    robj *d;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一定是OBJ_STRING类型</span></span><br><span class="line">    serverAssert(o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据不同的编码类型</span></span><br><span class="line">    <span class="keyword">switch</span>(o-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJ_ENCODING_RAW:</span><br><span class="line">    	<span class="comment">// 创建的对象非共享</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));        </span><br><span class="line">    <span class="keyword">case</span> OBJ_ENCODING_EMBSTR:</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">    <span class="keyword">case</span> OBJ_ENCODING_INT:</span><br><span class="line">    	<span class="comment">// 即使是共享整数范围内的整数，创建的对象也是非共享的</span></span><br><span class="line">        d = createObject(OBJ_STRING, <span class="literal">NULL</span>);</span><br><span class="line">        d-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">        d-&gt;ptr = o-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        serverPanic(<span class="string">&quot;Wrong encoding.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-销毁字符串对象"><a href="#3-3-销毁字符串对象" class="headerlink" title="3.3 销毁字符串对象"></a>3.3 销毁字符串对象</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁字符串对象ptr指向的对象</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeStringObject</span><span class="params">(robj *o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) &#123;</span><br><span class="line">        sdsfree(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Redis源码与设计剖析 -- 7.快速列表</title>
    <url>/2022/10/31/Redis/Redis%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%89%96%E6%9E%90%20--%207.%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>之前我们介绍了链表结构和压缩列表结构，它们是列表键的底层实现方式，但是链表的附加空间有点高，因为<code>prev</code>和<code>next</code>指针会占掉一部分的空间（64位系统占用<code>8 + 8 = 16</code>字节）.而且链表的每个节点都是单独分配内存，会加剧内存的碎片化.</p>
<p>所以在<code>redis-3.2</code>版本开始，Redis使用<code>quicklist</code>作为列表键的底层实现.</p>
<h2 id="2-quicklist实现"><a href="#2-quicklist实现" class="headerlink" title="2. quicklist实现"></a>2. quicklist实现</h2><p><code>quicklist</code>实际上是<code>zipList</code>和<code>linkedList</code>的混合体，它把<code>zipList</code>放在<code>linkedList</code>的每个结点中，实现紧凑存储.</p>
<p><img src="https://img-blog.csdnimg.cn/9ae84bac1a294c05a416b93d71f0d70b.png" alt="在这里插入图片描述"></p>
<h3 id="2-1-quicklist表头结构"><a href="#2-1-quicklist表头结构" class="headerlink" title="2.1 quicklist表头结构"></a>2.1 quicklist表头结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向头部(最左边)quicklist节点的指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向尾部(最右边)quicklist节点的指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ziplist节点计数器</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// quicklist节点计数器</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存ziplist的大小，配置文件设定，占16bits</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点压缩程度，配置文件设定，占16bits，0表示不压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>;</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>

<p>其中<code>fill</code>和<code>compress</code>属性是可以配置的，在<code>redis.conf</code>文件中.</p>
<ul>
<li><code>fill</code>属性对应的配置：<code>list-max-ziplist-size -2</code><ul>
<li>当数字为负数时，表示下列含义：<ul>
<li><code>-1</code>表示每个quicklistNode节点的ziplist字节大小不能超过<code>4kb</code>.</li>
<li><code>-2</code>表示每个quicklistNode节点的ziplist字节大小不能超过<code>8kb</code>（默认）.</li>
<li><code>-3</code>表示每个quicklistNode节点的ziplist字节大小不能超过<code>16kb</code>.</li>
<li><code>-4</code>表示每个quicklistNode节点的ziplist字节大小不能超过<code>32kb</code>.</li>
<li><code>-5</code>表示每个quicklistNode节点的ziplist字节大小不能超过<code>64kb</code>.</li>
</ul>
</li>
<li>当数字为正数时，表示下列含义：<ul>
<li>表示ziplist结构能包含的<code>entry</code>的最大个数，最大值为<code>2 ^ 15</code>.</li>
</ul>
</li>
<li><code>compress</code>属性对应的配置：<code>list-compress-depth 0</code></li>
<li><code>0</code>表示不压缩（默认）.</li>
<li><code>1</code>表示quicklist列表的两端各有<code>1</code>个节点不压缩，中间的节点压缩.</li>
<li><code>2</code>表示quicklist列表的两端各有<code>2</code>个节点不压缩，中间的节点压缩.</li>
<li><code>3</code>表示quicklist列表的两端各有<code>3</code>个节点不压缩，中间的节点压缩.</li>
<li>最大值为<code>2 ^ 16</code>.</li>
</ul>
</li>
</ul>
<h3 id="2-2-quicklist节点结构"><a href="#2-2-quicklist节点结构" class="headerlink" title="2.2 quicklist节点结构"></a>2.2 quicklist节点结构</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>     <span class="comment">//前驱节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>     <span class="comment">//后继节点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不设置压缩数据参数时指向一个ziplist结构，设置压缩数据参数指向quicklistLZF结构</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 压缩列表ziplist的总长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ziplist中的节点数，占16 bits长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示是否采用LZF压缩算法压缩quicklist节点，1表示不采用，2表示采用，占2 bits长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示一个quicklistNode节点是否采用ziplist结构保存数据，2表示采用，1表示不采用，默认是2，占2bits长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记quicklist是否压缩过，占1bit长度</span></span><br><span class="line">    <span class="comment">// 如果recompress为1，则等待被再次压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试时使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 额外扩展位，占10bits长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>;</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-被压缩过的ziplist"><a href="#2-3-被压缩过的ziplist" class="headerlink" title="2.3 被压缩过的ziplist"></a>2.3 被压缩过的ziplist</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表示被LZF算法压缩后的ziplist的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存压缩后的ziplist的数组，柔性数组</span></span><br><span class="line">    <span class="type">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-quicklistEntry"><a href="#2-4-quicklistEntry" class="headerlink" title="2.4 quicklistEntry"></a>2.4 quicklistEntry</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 管理quicklist中quicklistNode节点中ziplist信息的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span></span><br><span class="line">	<span class="comment">// 指向所属的quicklist的指针</span></span><br><span class="line">    <span class="type">const</span> quicklist *quicklist;</span><br><span class="line">    <span class="comment">// 指向所属的quicklistNode节点的指针</span></span><br><span class="line">    quicklistNode *node;</span><br><span class="line">    <span class="comment">// 指向当前ziplist结构的指针  </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zi;</span><br><span class="line">     <span class="comment">// 指向当前ziplist结构的字符串vlaue成员      </span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *value;</span><br><span class="line">    <span class="comment">// 指向当前ziplist结构的整数value成员   </span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> longval;            </span><br><span class="line">    <span class="comment">// 保存当前ziplist结构的字节数大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="comment">// 保存相对ziplist的偏移量</span></span><br><span class="line">    <span class="type">int</span> offset;</span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure>

<h2 id="3-常用操作"><a href="#3-常用操作" class="headerlink" title="3. 常用操作"></a>3. 常用操作</h2><h3 id="3-1-插入"><a href="#3-1-插入" class="headerlink" title="3.1 插入"></a>3.1 插入</h3><p>quicklist可以选择在头部或者尾部进行插入，对应的API是<code>quicklistPushHead</code>和<code>quicklistPushTail</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushHead</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">	<span class="comment">// 备份头结点地址</span></span><br><span class="line">    quicklistNode *orig_head = quicklist-&gt;head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果ziplist可以插入entry节点</span></span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;head, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;head-&gt;zl =</span><br><span class="line">        	<span class="comment">// 将节点push到头部</span></span><br><span class="line">            ziplistPush(quicklist-&gt;head-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line">        <span class="comment">// 更新quicklistNode记录ziplist大小的sz</span></span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;head);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果不能插入entry节点到ziplist</span></span><br><span class="line">    	<span class="comment">// 新创建一个quicklistNode节点</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将entry节点push到新创建的quicklistNode节点中</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新ziplist的大小sz</span></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新创建的节点插入到头节点前</span></span><br><span class="line">        _quicklistInsertNodeBefore(quicklist, quicklist-&gt;head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新quicklistNode计数器</span></span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    <span class="comment">// 更新entry计数器</span></span><br><span class="line">    quicklist-&gt;head-&gt;count++;</span><br><span class="line">    <span class="comment">// 如果改变头节点指针则返回1，否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> (orig_head != quicklist-&gt;head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">quicklistPushTail</span><span class="params">(quicklist *quicklist, <span class="type">void</span> *value, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">    quicklistNode *orig_tail = quicklist-&gt;tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果ziplist可以插入entry节点</span></span><br><span class="line">    <span class="keyword">if</span> (likely(</span><br><span class="line">            _quicklistNodeAllowInsert(quicklist-&gt;tail, quicklist-&gt;fill, sz))) &#123;</span><br><span class="line">        quicklist-&gt;tail-&gt;zl =</span><br><span class="line">       		<span class="comment">// 将节点push到尾部</span></span><br><span class="line">            ziplistPush(quicklist-&gt;tail-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        <span class="comment">// 更新quicklistNode记录ziplist大小的sz</span></span><br><span class="line">        quicklistNodeUpdateSz(quicklist-&gt;tail);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 新创建一个quicklistNode节点</span></span><br><span class="line">        quicklistNode *node = quicklistCreateNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将entry节点push到新创建的quicklistNode节点中</span></span><br><span class="line">        node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新ziplist的大小sz</span></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        <span class="comment">// 将新创建的节点插入到尾节点后</span></span><br><span class="line">        _quicklistInsertNodeAfter(quicklist, quicklist-&gt;tail, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新quicklistNode计数器</span></span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">    <span class="comment">// 更新entry计数器</span></span><br><span class="line">    quicklist-&gt;tail-&gt;count++;</span><br><span class="line">    <span class="comment">// 如果改变尾节点指针则返回1，否则返回0</span></span><br><span class="line">    <span class="keyword">return</span> (orig_tail != quicklist-&gt;tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>一、Redis的安装与配置</title>
    <url>/2022/09/09/Redis/%E4%B8%80%E3%80%81Redis%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="下载到本地"><a href="#下载到本地" class="headerlink" title="下载到本地"></a>下载到本地</h2><p>我使用的Redis版本是6.2.6，下载地址：<br><a href="https://download.redis.io/releases/redis-6.2.6.tar.gz">https://download.redis.io/releases/redis-6.2.6.tar.gz</a>。</p>
<p>使用的是<code>centos7</code>系统。</p>
<p>直接下载到本地，然后使用xftp传输到centos系统中。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>解压软件包到opt目录</strong></p>
<p>将安装包解压到到<code>opt</code>目录下，opt目录一般用来存放附加软件包。然后进入<code>cd</code>进<code>redis-6.2.6</code>目录中。</p>
<p><strong>安装GCC和redis</strong></p>
<p>1.安装GCC环境：</p>
<p>执行命令<code>yum install gcc-c++</code>。<br>然后使用<code>gcc -v</code>查看是否安装成功。</p>
<p>2.执行编译：</p>
<p>cd切换到redis解压目录下，执行编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>3.安装：</p>
<p>安装并指定安装目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install PREFIX=/opt/module/redis6</span><br></pre></td></tr></table></figure>

<p>安装完成会得到一个bin目录，里面有<code>redis-server</code>、<code>redis-cli</code>等可执行文件。</p>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>配置文件是<code>redis.conf</code>，可以再创建一个目录：<code>tmpconfig</code>，然后把redis.conf文件拷贝到该文件夹，以后使用这个拷贝的配置文件来启动redis，原来的配置文件就用来做备份。</p>
<p>执行<code>mkdir tmpconfig</code>创建目录，然后执行<code>cp redis.conf tmpconfig/</code>拷贝配置文件。接着<code>cd tmpconfig</code>进入目录，编辑配置文件<code>vi redis.conf</code>，我主要修改了以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置为后台启动</span><br><span class="line">daemonize yes</span><br><span class="line"></span><br><span class="line"># 将pid文件的生成目录改到redis6/run目录下</span><br><span class="line">pidfile /opt/module/redis6/run/redis_[端口号].pid</span><br><span class="line"></span><br><span class="line"># 将端口号改为****</span><br><span class="line">port [端口号]</span><br></pre></td></tr></table></figure>

<h2 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到bin目录中</span></span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动redis服务</span></span><br><span class="line">./redis-server ../tmpconfig/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用客户端连接redis服务</span></span><br><span class="line">./redis-cli -p [端口号]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看redis进程是否开启</span></span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<h2 id="关闭redis服务"><a href="#关闭redis服务" class="headerlink" title="关闭redis服务"></a>关闭redis服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 先退出客户端连接</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭linux服务</span></span><br><span class="line">./redis-cli -p [端口号] shutdown</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="将redis配置到Linux系统服务"><a href="#将redis配置到Linux系统服务" class="headerlink" title="将redis配置到Linux系统服务"></a>将redis配置到Linux系统服务</h2><p>1.首先进入redis的配置文件<code>redis.conf</code>，将<code>daemonize</code>属性改为<code>yes</code>:</p>
<p>可以在阅读模式下使用:</p>
<p><code>:/daemonize</code></p>
<p>查找到这个属性项。</p>
<p>2.将<code>redis.conf</code>文件复制到<code>/etc/redis/</code>目录下并改名为<code>[端口号].conf</code>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis.conf /etc/redis/[端口号].conf</span><br></pre></td></tr></table></figure>

<p>3.将utils目录下的<code>redis_init_script</code>文件复制到<code>/etc/init.d/</code>目录下，并命名为redis：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span>  utils/redis_init_script    /etc/init.d/redis</span><br></pre></td></tr></table></figure>

<p>4.编辑上一步的redis文件，并按实际修改文件的前几行：</p>
<p>比如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">REDISPORT=[端口号]</span><br><span class="line">AUTH=&quot;密码&quot;</span><br><span class="line">EXEC=/opt/module/redis6/bin/redis-server</span><br><span class="line">CLIEXEC=/opt/module/redis6/bin/redis-cli</span><br><span class="line"></span><br><span class="line">PIDFILE=/opt/module/redis6/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line">CONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;</span><br></pre></td></tr></table></figure>


<p>5.设置文件执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 /etc/init.d/redis</span><br></pre></td></tr></table></figure>

<p>6.设置开机自启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开机启动</span></span><br><span class="line">chkconfig redis on</span><br><span class="line"><span class="comment"># 开机关闭</span></span><br><span class="line">chkconfig redis off</span><br></pre></td></tr></table></figure>

<p>7.将&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;redis脚本添加到服务： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到/etc/rc.d/init.d/目录下</span></span><br><span class="line"><span class="built_in">cd</span> /etc/rc.d/init.d/</span><br><span class="line"><span class="comment"># 添加到系统服务</span></span><br><span class="line">chkconfig --add redis</span><br></pre></td></tr></table></figure>

<p>8.测试命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动redis服务</span></span><br><span class="line">service redis start</span><br><span class="line"><span class="comment"># 关闭redis服务</span></span><br><span class="line">service redis stop</span><br><span class="line"><span class="comment"># 连接服务端</span></span><br><span class="line">./redis-cli -p [端口号]</span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">auth [password]</span><br></pre></td></tr></table></figure>

<p>9.错误处理：</p>
<p>如果出现以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/var/run/redis_6379.pid does not exist, process is not running</span><br></pre></td></tr></table></figure>
<p>就将<code>/var/run/</code>目录下的<code>redis_6379.pid</code>文件删除再启动redis服务。</p>
<h2 id="redis开启远程服务并设置密码"><a href="#redis开启远程服务并设置密码" class="headerlink" title="redis开启远程服务并设置密码"></a>redis开启远程服务并设置密码</h2><p>redis默认只支持本机访问，如果要远程访问，需要在配置文件中配置：</p>
<ol>
<li>将redis.conf 里的<code>redis.conf</code>中的<code>bind127.0.0.1</code>这一行注释掉，这样任意IP都可以访问；</li>
<li>找到 <code>protected-mode yes</code> 改为 <code>protected-mode no</code>；</li>
<li>为redis的连接加上密码：在<code>protected-mode</code>的下一行加上 <code>requirepass [password]</code>;</li>
<li>关闭redis: <code>pkill redis</code>;</li>
<li>重启redis；</li>
</ol>
<h2 id="重新编辑redis的脚本"><a href="#重新编辑redis的脚本" class="headerlink" title="重新编辑redis的脚本"></a>重新编辑redis的脚本</h2><p>由于我们设置了密码，所以redis的脚本需要修改一下，编辑<code>/etc/init.d/redis</code>文件，以下作为参考：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">REDISPORT=[端口]</span><br><span class="line">AUTH=&quot;密码&quot;</span><br><span class="line">EXEC=/opt/module/redis6/bin/redis-server</span><br><span class="line">CLIEXEC=/opt/module/redis6/bin/redis-cli</span><br><span class="line"></span><br><span class="line">PIDFILE=/opt/module/redis6/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line">CONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        if [ -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE exists, process is already running or crashed&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;Starting Redis server...&quot;</span><br><span class="line">                $EXEC $CONF</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        if [ ! -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE does not exist, process is not running&quot;</span><br><span class="line">        else</span><br><span class="line">                PID=$(cat $PIDFILE)</span><br><span class="line">                echo &quot;Stopping ...&quot;</span><br><span class="line">                $CLIEXEC -p $REDISPORT -a $AUTH shutdown</span><br><span class="line">                while [ -x /proc/$&#123;PID&#125; ]</span><br><span class="line">                do</span><br><span class="line">                    echo &quot;Waiting for Redis to shutdown ...&quot;</span><br><span class="line">                    sleep 1</span><br><span class="line">                done</span><br><span class="line">                echo &quot;Redis stopped&quot;</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    status)</span><br><span class="line">        PID=$(cat $PIDFILE)</span><br><span class="line">        if [ ! -x /proc/$&#123;PID&#125; ]</span><br><span class="line">        then</span><br><span class="line">            echo &#x27;Redis is not running&#x27;</span><br><span class="line">        else</span><br><span class="line">            echo &quot;Redis is running ($PID)&quot;</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    restart)</span><br><span class="line">        $0 stop</span><br><span class="line">        $0 start</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Please use start, stop,restart or status as first argument&quot;</span><br><span class="line">        ;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="基础知识补充"><a href="#基础知识补充" class="headerlink" title="基础知识补充"></a>基础知识补充</h2><p>redis默认有16个数据库，配置文件redis.conf 中database项&#x3D;16<br><code>select</code> 数据库索引 ：切换数据库<br><code>dbsize</code>：查看数据库存储数<br>使用<code>redis-cli</code> 连接其他redis服务.\redis-cli.exe -h 192.168.0.113 -p 6379 win10默认不用当前目录命令，因此前面添加.\。<br><code>flushdb</code>：清空当前库<br><code>flushall</code>：清空所有库<br>redis 为什么快？<br>redis是单线程的，官方表示，redis是基于内存操作，CPU不是性能瓶颈，机器的内存和网络带宽才是性能瓶颈，既然可以使用单线程来实现，就用了。为什么单线程还这么快？单线程并且基于内存，单线程没有多线程的切换开销，因此最快。并且redis内部采用IO多路复用技术实现， 减少IO的重复操作。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>三、Redis事务和锁机制</title>
    <url>/2022/09/09/Redis/%E4%B8%89%E3%80%81Redis%20%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><p>Redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。</p>
<p><strong>Redis事务三特性</strong></p>
<ol>
<li><p>单独的隔离操作 ：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>没有隔离级别的概念 ：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>
</li>
<li><p>不保证原子性 ：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚 。</p>
</li>
</ol>
<h2 id="事务基本指令"><a href="#事务基本指令" class="headerlink" title="事务基本指令"></a>事务基本指令</h2><ul>
<li><code>multi</code>：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li>
<li><code>exec</code>：设定事务的结束位置，同时执行事务，与multi成对使用</li>
</ul>
<p><strong>redis事务执行流程</strong></p>
<ol>
<li><code>multi</code>（开启事务）</li>
<li>命令入队</li>
<li><code>exec</code> （执行事务）或<code>discard</code>（放弃事务）</li>
</ol>
<h2 id="事务的执行案例"><a href="#事务的执行案例" class="headerlink" title="事务的执行案例"></a>事务的执行案例</h2><h3 id="正常执行事务"><a href="#正常执行事务" class="headerlink" title="正常执行事务"></a>正常执行事务</h3><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; exec</span><br><span class="line"><span class="number">1</span>) OK</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">4</span>) OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; </span><br></pre></td></tr></table></figure>



<h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; discard</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;k3&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;k2&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;k1&quot;</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; </span><br></pre></td></tr></table></figure>




<h3 id="编译时异常（代码有问题，命令有问题）"><a href="#编译时异常（代码有问题，命令有问题）" class="headerlink" title="编译时异常（代码有问题，命令有问题）"></a>编译时异常（代码有问题，命令有问题）</h3><p>事务中所有命令都不会被执行。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k1 v1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; getset k3</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;getset&#x27; command</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k4 v4</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; get k1</span><br><span class="line">(nil)</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; </span><br></pre></td></tr></table></figure>



<h3 id="运行时异常（逻辑错误，错误使用命令）"><a href="#运行时异常（逻辑错误，错误使用命令）" class="headerlink" title="运行时异常（逻辑错误，错误使用命令）"></a>运行时异常（逻辑错误，错误使用命令）</h3><p>事务中正确的部分会被执行，错误的部分则不会被执行。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; incr k1</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; exec</span><br><span class="line"><span class="number">1</span>) (error) ERR value is not an integer or out of range #虽然第一条命令报错，但是依旧正常执行</span><br><span class="line"><span class="number">2</span>) OK</span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; </span><br></pre></td></tr></table></figure>




<h2 id="Redis-锁机制"><a href="#Redis-锁机制" class="headerlink" title="Redis 锁机制"></a>Redis 锁机制</h2><p><strong>悲观锁</strong></p>
<p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>比较适合写入操作比较频繁的场景，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</p>
<p><strong>乐观锁</strong></p>
<p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis 就是利用这种<code>check-and-set</code>机制实现事务的。</p>
<p>比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</p>
<p><strong>watch和unwatch</strong></p>
<p>Redis中可以使用<code>watch</code>和<code>unwatch</code>实现锁机制。</p>
<p>在执行<code>multi</code>之前，先执行<code>watch key1 [key2]</code>，可以监视一个 (或多个) key ，如果在事务执行之前这个 (或这些) key 被其他命令所改动，那么事务将被打断。</p>
<p><code>unwatch</code>可以取消<code>watch</code>命令对所有key的监视。如果在执行<code>watch</code>命令之后，<code>exec</code>命令或<code>discard</code>命令先被执行了的话，那么就不需要再执行 <code>unwatch</code>了。</p>
<p><strong>乐观锁案例</strong></p>
<p>下面是一个多线程修改值的案例，我们使用<code>watch</code>来实现乐观锁。</p>
<p><code>money</code>和<code>out</code>都是一个String类型的值，表示已有的钱和花出去的钱，初始时分别设置为100和0.</p>
<p>首先开启一个客户端，开启一个事务，将money减去10，接着将out加上10，但是不提交事务。</p>
<p>这个时候，再次开启一个客户端模拟第二个线程，第二个线程将money直接设置成1000。</p>
<p>然后我们再返回第一个客户端使用exec提交事务，这个时候会发现执行的结果是<code>(nil)</code>，没有执行成功。实现了一个乐观锁的效果。</p>
<p><img src="https://img-blog.csdnimg.cn/0ae8a9a67a4f494aa29012a11b74007d.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/4785826eb7d54e62bcfeba4ccfdbb268.png" alt="在这里插入图片描述"><br>执行失败之后可以先使用<code>unwatch</code>放弃监视，然后接着进行后续的操作。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"># 如果事务执行失败，先解锁</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; unwatch</span><br><span class="line">OK</span><br><span class="line"># 获取最新值，再次监视 </span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; watch money</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; decrby money <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; incrby money <span class="number">1</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0.0.1:6379</span>(TX)&gt; exec </span><br><span class="line"># 对比监视值是否发送变化，如果没有变化可以执行，变化则执行失败</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">999</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">1000</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>心跳机制与可选项配置</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/10%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="服务注册发现的原理"><a href="#服务注册发现的原理" class="headerlink" title="服务注册发现的原理"></a>服务注册发现的原理</h2><p>让我们再回顾一下服务注册与发现的原理：服务注册发现是将所有的服务注册到注册组件中心，各服务在进行互相调用功能时，先通过查询方法获取到要调用的服务的状态信息和地址，然后向对应的微服务模块发起调用。我们学习过consul的工作原理和环境搭建，consul的工作原理图如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/f39d58823f7e4d93b9b994f0ef7cb836.png" alt="在这里插入图片描述"></p>
<h2 id="未发现服务错误"><a href="#未发现服务错误" class="headerlink" title="未发现服务错误"></a>未发现服务错误</h2><p>回顾完了服务注册发现的原理，我们就可以知道，如果请求发起端程序不能在服务组件中发现对应的服务，则会产生错误。接下来我们利用程序演示错误。</p>
<p>首先，通过终端命令启动consul节点服务，以方便服务注册：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure>

<h5 id="指定服务程序注册到consul"><a href="#指定服务程序注册到consul" class="headerlink" title="指定服务程序注册到consul"></a>指定服务程序注册到consul</h5><p>我们利用已经学习过的服务注册可选项指定注册到consul组件，详细命令如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> --registry=consul</span><br></pre></td></tr></table></figure>

<p>通过该命令，可以成功将服务注册到consul组件，并启动服务开始运行。</p>
<h5 id="运行客户端服务"><a href="#运行客户端服务" class="headerlink" title="运行客户端服务"></a>运行客户端服务</h5><p>由于服务端程序已经注册到consul,因此客户端程序在执行时也需要到consul中查询才能正确执行。运行客户端并注册到consul组件的命令是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run client.<span class="keyword">go</span> --registry=consul</span><br></pre></td></tr></table></figure>

<p>通过以上命令，程序可以正确得到执行，并输出正确结果。</p>
<h5 id="未发现服务错误-1"><a href="#未发现服务错误-1" class="headerlink" title="未发现服务错误"></a>未发现服务错误</h5><p>我们可以主动让程序发生错误，来验证未发现的错误，以此来验证我们所学习的服务注册与发现的原理。在执行客户端程序时，我们不指定–registry选项，默认使用mdns，则命令为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run client.<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>我们执行上述命令，运行客户端程序。由于我们的客户端程序会连接对应的服务的方法，但是对应的服务并没有注册到mdns中，因此，程序会发生错误。本案例中，客户端程序执行错误如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="string">&quot;go.micro.client&quot;</span><span class="punctuation">,</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">500</span><span class="punctuation">,</span><span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span><span class="string">&quot;error selecting student_service node: not found&quot;</span><span class="punctuation">,</span><span class="attr">&quot;status&quot;</span><span class="punctuation">:</span><span class="string">&quot;Internal Server Error&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，程序返回了错误信息，提示我们服务未找到。</p>
<p>通过这个主动错误的示范，我们能更加深刻的理解go-micro与consul的插件式协同工作和微服务内部的原理。</p>
<h2 id="弊端与解决方法"><a href="#弊端与解决方法" class="headerlink" title="弊端与解决方法"></a>弊端与解决方法</h2><p>服务实例与发现组件的工作机制是：当服务开启时，将自己的相关信息注册到发现组件中，当服务关闭时，发送卸载或者移除请求。在实际生产环境中，服务可能会出现很多异常情况，发生宕机或者其他等情况，往往服务进程会被销毁，或者网络出现故障也会导致通信链路发生问题，在这些情况下，服务实例会在服务发现组件中被移除。</p>
<h5 id="TTL和间隔时间"><a href="#TTL和间隔时间" class="headerlink" title="TTL和间隔时间"></a>TTL和间隔时间</h5><p>为了解决这个问题，go-micro框架提供了TTL机制和间隔时间注册机制。TTL是Time-To-Live的缩写，指定一次注册在注册组件中的有效期，过期后便会删除。而间隔时间注册则表示定时向注册组件中重新注册以确保服务在线。</p>
<ul>
<li><p>指令方式<br>这两种注册方式都可以通过可选项指令来实现配置，具体的命令如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> --registry=consul --register_ttl=<span class="number">10</span> --register_interval=<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>该命令表示我们每间隔5秒钟向服务注册组件注册一次，每次有效期限是10秒。</p>
</li>
<li><p>编码方式<br>除了使用指令的方式以外，还可以在代码中实现这两种参数的设定，在微服务创建时通过配置来完成。具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">service := micro.NewService(</span><br><span class="line">	micro.Name(<span class="string">&quot;student_service&quot;</span>),</span><br><span class="line">	micro.Version(<span class="string">&quot;v1.0.0&quot;</span>),</span><br><span class="line">	micro.RegisterTTL(<span class="number">10</span>*time.Second),</span><br><span class="line">	micro.RegisterInterval(<span class="number">5</span>*time.Second),</span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>分别通过micro.RegisterTTL和micro.RegisterInterval来实现两个选项的设置。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>二、Redis常用命令以及数据类型</title>
    <url>/2022/09/09/Redis/%E4%BA%8C%E3%80%81Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p> Redis 通用命令是一些可以作用在常用数据结构上的常用命令和一些基础的命令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key</li>
<li>DEL：删除一个指定的key</li>
<li>EXISTS：判断key是否存在</li>
<li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li>
<li>TTL：查看一个KEY的剩余有效期</li>
</ul>
<p>通过<code>help [command]</code>可以查看一个命令的具体用法，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看keys命令的帮助信息：</span></span><br><span class="line">127.0.0.1:6379&gt; help keys</span><br><span class="line"></span><br><span class="line">KEYS pattern</span><br><span class="line">summary: Find all keys matching the given pattern</span><br><span class="line">since: 1.0.0</span><br><span class="line">group: generic</span><br></pre></td></tr></table></figure>

<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。</p>
<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.</p>
<p><strong>String类型的常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td>GETRANGE key start end</td>
<td>返回 key 中字符串值的子字符</td>
</tr>
<tr>
<td>GETSET key value</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值（old value）</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>对 key 所储存的字符串值，获取指定偏移量上的位（bit）</td>
</tr>
<tr>
<td>MGET key1 [key2..]</td>
<td>获取所有（一个或多个）给定 key 的值</td>
</tr>
<tr>
<td>SETBIT key offset value</td>
<td>对 key 所储存的字符串值，设置或清除指定偏移量上的位（bit）</td>
</tr>
<tr>
<td>SETEX key seconds value</td>
<td>将值 value 关联到 key ，并将 key 的过期时间设为 seconds （以秒为单位）</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>SETRANGE key offset value</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td>MSET key value [key value …]</td>
<td>同时设置一个或多个 key-value 对</td>
</tr>
<tr>
<td>MSETNX key value [key value …]</td>
<td>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在</td>
</tr>
<tr>
<td>PSETEX key milliseconds value</td>
<td>这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>INCRBY key increment将 key</td>
<td>所储存的值加上给定的增量值（increment）</td>
</tr>
<tr>
<td>INCRBYFLOAT key increment</td>
<td>将 key 所储存的值加上给定的浮点增量值（increment）</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一</td>
</tr>
<tr>
<td>DECRBY key decrementkey</td>
<td>所储存的值减去给定的减量值（decrement）</td>
</tr>
<tr>
<td>APPEND key value</td>
<td>如果 key 已经存在并且是一个字符串， APPEND 命令将 value 追加到 key 原来的值的末尾</td>
</tr>
</tbody></table>
<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p>
<p>特征也与LinkedList类似：</p>
<ul>
<li>有序</li>
<li>元素可以重复</li>
<li>插入和删除快</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p>
<p><strong>List类型的常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BLPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>BRPOP key1 [key2 ] timeout</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>BRPOPLPUSH source destination timeout</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它；如但果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止</td>
</tr>
<tr>
<td>LINDEX key index</td>
<td>通过索引获取列表中的元素</td>
</tr>
<tr>
<td>LINSERT key BEFORE[AFTER] pivot value</td>
<td>在列表的元素前或者后插入元素</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移出并获取列表的第一个元素</td>
</tr>
<tr>
<td>LPUSH key value1 [value2]</td>
<td>将一个或多个值插入到列表头部</td>
</tr>
<tr>
<td>LPUSHX key value</td>
<td>将一个或多个值插入到已存在的列表头部</td>
</tr>
<tr>
<td>LRANGE key start stop</td>
<td>获取列表指定范围内的元素</td>
</tr>
<tr>
<td>LREM key count value</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>通过索引设置列表元素的值</td>
</tr>
<tr>
<td>LTRIM key start stop</td>
<td>对一个列表进行修剪（trim），就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH key value1 [value2]</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX key value</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody></table>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p>
<ul>
<li><p>无序</p>
</li>
<li><p>元素不可重复</p>
</li>
<li><p>查找快</p>
</li>
<li><p>支持交集、并集、差集等功能</p>
</li>
</ul>
<p><strong>Set类型的常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SADD key member1 [member2]</td>
<td>将一个或多个成员添加到集合</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取集合中的成员数</td>
</tr>
<tr>
<td>SDIFF key1 [key2]</td>
<td>减去多个集合</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 [key2]</td>
<td>减去多个集并将结果集存储在键中</td>
</tr>
<tr>
<td>SINTER key1 [key2]</td>
<td>相交多个集合</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 [key2]</td>
<td>交叉多个集合并将结果集存储在键中</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断确定给定值是否是集合的成员</td>
</tr>
<tr>
<td>SMOVE source destination member</td>
<td>将成员从一个集合移动到另一个集合</td>
</tr>
<tr>
<td>SPOP key</td>
<td>从集合中删除并返回随机成员</td>
</tr>
<tr>
<td>SRANDMEMBER key [count]</td>
<td>从集合中获取一个或多个随机成员</td>
</tr>
<tr>
<td>SREM key member1 [member2]</td>
<td>从集合中删除一个或多个成员</td>
</tr>
<tr>
<td>SUNION key1 [key2]</td>
<td>添加多个集合</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 [key2]</td>
<td>添加多个集并将结果集存储在键中</td>
</tr>
<tr>
<td>SSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>递增地迭代集合中的元素</td>
</tr>
</tbody></table>
<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>
<p>SortedSet具备下列特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p>
<p><strong>SortedSet类型的常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ZADD key score1 member1 [score2 member2]</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>ZCARD key</td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td>ZCOUNT key min max</td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>ZINCRBY key increment member</td>
<td>有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td>ZLEXCOUNT key min max</td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>ZRANGE key start stop [WITHSCORES]</td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td>ZRANGEBYLEX key min max [LIMIT offset count]</td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>ZRANK key member</td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>ZREM key member [member …]</td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX key min max</td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK key start stop</td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE key min max</td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>ZREVRANGE key start stop [WITHSCORES]</td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE key max min [WITHSCORES]</td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key [key …]</td>
<td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>ZSCAN key cursor [MATCH pattern] [COUNT count]</td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。</p>
<p><strong>Hash类型的常用命令</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>HDEL key field2 [field2]</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看哈希表 key 中，指定的字段是否存在</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment</td>
</tr>
<tr>
<td>HINCRBYFLOAT key field increment</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
</tr>
<tr>
<td>HKEYS key</td>
<td>获取所有哈希表中的字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td>HMGET key field1 [field2]</td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 [field2 value2 ]</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
</tr>
<tr>
<td>HSET key field value</td>
<td>将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值</td>
</tr>
<tr>
<td>HVALS key</td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td>HSCAN key cursor [MATCH pattern][COUNT count]</td>
<td>迭代哈希表中的键值对</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>四、Redis持久化</title>
    <url>/2022/09/09/Redis/%E5%9B%9B%E3%80%81Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>Redis有两种持久化方案：</p>
<ul>
<li>RDB持久化</li>
<li>AOF持久化</li>
</ul>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB全称<code>Redis Database Backup file（Redis数据备份文件）</code>，也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<h3 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h3><p>RDB持久化在四种情况下会执行：</p>
<ul>
<li>执行save命令</li>
<li>执行bgsave命令</li>
<li>Redis停机时</li>
<li>触发RDB条件时</li>
</ul>
<p><strong>1）save命令</strong></p>
<p>执行下面的命令，可以立即执行一次RDB：</p>
<p><img src="https://img-blog.csdnimg.cn/e68aa164f7424a1e8204a27861e8b3da.png" alt="在这里插入图片描述"></p>
<p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p>
<p><strong>2）bgsave命令</strong></p>
<p>下面的命令可以异步执行RDB：</p>
<p><img src="https://img-blog.csdnimg.cn/66e8f5cd14374b0db854f1f56cd1d080.png" alt="在这里插入图片描述"></p>
<p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>3）停机时</strong></p>
<p>Redis停机时会执行一次save命令，实现RDB持久化。</p>
<p><strong>4）触发RDB条件</strong></p>
<p>Redis内部有触发RDB的机制，可以在<code>redis.conf</code>文件中找到，格式如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save &quot;&quot; 则表示禁用RDB</span></span><br><span class="line"><span class="attr">save</span> <span class="string">900 1  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">300 10  </span></span><br><span class="line"><span class="attr">save</span> <span class="string">60 10000 </span></span><br></pre></td></tr></table></figure>



<p>RDB的其它配置也可以在<code>redis.conf</code>文件中设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否压缩 ,建议不开启，压缩也会消耗cpu，而磁盘不值钱</span></span><br><span class="line"><span class="attr">rdbcompression</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># RDB文件名称</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump.rdb  </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 文件保存的路径目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">./ </span></span><br></pre></td></tr></table></figure>



<h3 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h3><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是<code>copy-on-write</code>技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/032201de536b446da345ea29399f6e73.png" alt="在这里插入图片描述"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>RDB方式bgsave的基本流程：</p>
<ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新RDB文件替换旧的RDB文件</li>
</ul>
<p>RDB会在什么时候执行？save 60 1000代表什么含义？</p>
<ul>
<li>默认是服务停止时</li>
<li>代表60秒内至少执行1000次修改则触发RDB</li>
</ul>
<p>RDB的缺点？</p>
<ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写出RDB文件都比较耗时</li>
</ul>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF原理"><a href="#AOF原理" class="headerlink" title="AOF原理"></a>AOF原理</h3><p>AOF全称为<code>Append Only File（追加文件）</code>。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<p><img src="https://img-blog.csdnimg.cn/54bcb0556c2e40c38c0be038142425ad.png" alt="在这里插入图片描述"></p>
<h3 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h3><p>AOF默认是关闭的，需要修改<code>redis.conf</code>配置文件来开启AOF：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开启AOF功能，默认是no</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># AOF文件的名称</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br></pre></td></tr></table></figure>

<p>AOF的命令记录的频率也可以通过<code>redis.conf</code>文件来配：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">always </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">everysec </span></span><br><span class="line"><span class="comment"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line"><span class="attr">appendfsync</span> <span class="string">no</span></span><br></pre></td></tr></table></figure>


<p>三种策略对比：</p>
<p><img src="https://img-blog.csdnimg.cn/5124818ed8e142cbacdf502a3f967791.png" alt="在这里插入图片描述"></p>
<h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<p><img src="https://img-blog.csdnimg.cn/7ab3bad8617f47af9c2abbe6d38a578d.png" alt="在这里插入图片描述"></p>
<p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在<code>redis.conf</code>中配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line"><span class="attr">auto-aof-rewrite-percentage</span> <span class="string">100</span></span><br><span class="line"><span class="comment"># AOF文件体积最小多大以上才触发重写 </span></span><br><span class="line"><span class="attr">auto-aof-rewrite-min-size</span> <span class="string">64mb </span></span><br></pre></td></tr></table></figure>

<h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>
<p><img src="https://img-blog.csdnimg.cn/1cc7d2009c7b42d0a2a7462fdc5b531d.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
  </entry>
  <entry>
    <title>Micro负载均衡组件--Selector</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/12Micro%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%BB%84%E4%BB%B6--Selector/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Go-micro中的介绍课程中，我们说过go-micro具备负载均衡功能。所谓负载均衡，英文为Load Balance，其意思是将负载进行平衡、分摊到多个操作单元上进行执行。例如Web服务器，应用服务器，微服务程序服务器等，以此来完成达到高并发的目的。</p>
<p>当只有一台服务部署程序时，是不存在负载均衡问题的，此时所有的请求都由同一台服务器进行处理。随着业务复杂度的增加和功能迭代，单一的服务器无法满足业务增长需求，需要靠分布式来提高系统的扩展性，随着而来的就是负载均衡的问题。因此需要加入负载均衡组件或者功能，两者的区别和负载均衡的作用如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/cb06efb2acf14969a12f2b56bb666b14.png" alt="在这里插入图片描述"></p>
<p>从图中可以看到，用户先访问负载均衡器，再由负载均衡器对请求进行处理，进而分发到不同的服务器上的服务程序进行处理。</p>
<p>负载均衡器主要处理四种请求，分别是：HTTP、HTTPS、TCP、UDP。</p>
<h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>负载均衡器的作用既然是负责接收请求，并实现请求的分发，因此需要按照一定的规则进行转发处理。负载均衡器可以按照不同的规则实现请求的转发，其遵循的转发规则称之为负载均衡算法。常用的负载均衡算法有以下几个：</p>
<ul>
<li><p>Round Robin（轮询算法）：所谓轮询算法，其含义很简单，就是按照一定的顺序进行依次排队分发。当有请求队列需要转发时，为第一个请求选择可用服务列表中的第一个服务器，为下一个请求选择服务列表中的第二个服务器。按照此规则依次向下进行选择分发，直到选择到服务器列表的最后一个。当第一次列表转发完毕后，重新选择第一个服务器进行分发，此为轮询。</p>
</li>
<li><p>Least Connections（最小连接）：因为分布式系统中有多台服务器程序在运行，每台服务器在某一个时刻处理的连接请求数量是不一样的。因此，当有新的请求需要转发时，按照最小连接数原则，负载均衡器会有限选择当前连接数最小的服务器，以此来作为转发的规则。</p>
</li>
<li><p>Source（源）：还有一种常见的方式是将请求的IP进行hash计算，根据结算结果来匹配要转发的服务器，然后进行转发。这种方式可以一定程度上保证特定用户能够连接到相同的服务器。</p>
</li>
</ul>
<h2 id="Mico的Selector"><a href="#Mico的Selector" class="headerlink" title="Mico的Selector"></a>Mico的Selector</h2><p>Selector的英文是选择器的意思，在Micro中实现了Selector组件，运行在客户端实现负载均衡功能。当客户端需要调用服务端方法时，客户端会根据其内部的selector组件中指定的负载均衡策略选择服务注册中的一个服务实例。Go-micro中的Selector是基于Register模块构建的，提供负载均衡策略，同时还提供过滤、缓存和黑名单等功能。</p>
<h2 id="Selector定义"><a href="#Selector定义" class="headerlink" title="Selector定义"></a>Selector定义</h2><p>首先，让我们来看一下Selector的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Selector <span class="keyword">interface</span> &#123;</span><br><span class="line">	Init(opts ...Option) <span class="type">error</span></span><br><span class="line">	Options() Options</span><br><span class="line">	<span class="comment">// Select returns a function which should return the next node</span></span><br><span class="line">	Select(service <span class="type">string</span>, opts ...SelectOption) (Next, <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Mark sets the success/error against a node</span></span><br><span class="line">	Mark(service <span class="type">string</span>, node *registry.Node, err <span class="type">error</span>)</span><br><span class="line">	<span class="comment">// Reset returns state back to zero for a service</span></span><br><span class="line">	Reset(service <span class="type">string</span>)</span><br><span class="line">	<span class="comment">// Close renders the selector unusable</span></span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line">	<span class="comment">// Name of the selector</span></span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上是go-micro框架中的Selector的定义，Selector接口定义中包含Init、Options、Mark、Reset、Close、String方法。其中Select是核心方法，可以实现自定义的负载均衡策略，Mark方法用于标记服务节点的状态,String方法返回自定义负载均衡器的名称。</p>
<h2 id="DefaultSelector"><a href="#DefaultSelector" class="headerlink" title="DefaultSelector"></a>DefaultSelector</h2><p>在selector包下，除Selector接口定义外，还包含DefaultSelector的定义，作为go-micro默认的负载均衡器而被使用。DefaultSelector是通过NewSelector函数创建生成的。NewSelector函数实现如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSelector</span><span class="params">(opts ...Option)</span></span> Selector &#123;</span><br><span class="line">	sopts := Options&#123;</span><br><span class="line">		Strategy: Random,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, opt := <span class="keyword">range</span> opts &#123;</span><br><span class="line">		opt(&amp;sopts)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> sopts.Registry == <span class="literal">nil</span> &#123;</span><br><span class="line">		sopts.Registry = registry.DefaultRegistry</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s := &amp;registrySelector&#123;</span><br><span class="line">		so: sopts,</span><br><span class="line">	&#125;</span><br><span class="line">	s.rc = s.newCache()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在NewSelector中，实例化了registrySelector对象并进行了返回,在实例化的过程中，配置了Selector的Options选项，默认的配置是Random。我们进一步查看会发现Random是一个func，定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Random</span><span class="params">(services []*registry.Service)</span></span> Next &#123;</span><br><span class="line">	<span class="keyword">var</span> nodes []*registry.Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		nodes = <span class="built_in">append</span>(nodes, service.Nodes...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*registry.Node, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ErrNoneAvailable</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		i := rand.Int() % <span class="built_in">len</span>(nodes)</span><br><span class="line">		<span class="keyword">return</span> nodes[i], <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法是go-micro中默认的负载均衡器，会随机选择一个服务节点进行分发；除了Random算法外，还可以看到RoundRobin算法，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RoundRobin</span><span class="params">(services []*registry.Service)</span></span> Next &#123;</span><br><span class="line">	<span class="keyword">var</span> nodes []*registry.Node</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, service := <span class="keyword">range</span> services &#123;</span><br><span class="line">		nodes = <span class="built_in">append</span>(nodes, service.Nodes...)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> i = rand.Int()</span><br><span class="line">	<span class="keyword">var</span> mtx sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (*registry.Node, <span class="type">error</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(nodes) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ErrNoneAvailable</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mtx.Lock()</span><br><span class="line">		node := nodes[i%<span class="built_in">len</span>(nodes)]</span><br><span class="line">		i++</span><br><span class="line">		mtx.Unlock()</span><br><span class="line">		<span class="keyword">return</span> node, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="registrySelector"><a href="#registrySelector" class="headerlink" title="registrySelector"></a>registrySelector</h2><p>registrySelector是selector包下default.go文件中的结构体定义，具体定义如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> registrySelector <span class="keyword">struct</span> &#123;</span><br><span class="line">	so Options</span><br><span class="line">	rc cache.Cache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缓存Cache"><a href="#缓存Cache" class="headerlink" title="缓存Cache"></a>缓存Cache</h3><p>目前已经有了负载均衡器，我们可以看到在Selector的定义中，还包含一个cache.Cache结构体类型，这是什么作用呢？</p>
<p>有了Selector以后，我们每次请求负载均衡器都要去Register组件中查询一次，这样无形之中就增加了成本，降低了效率，没有办法达到高可用。为了解决以上这种问题，在设计Selector的时候设计一个缓存，Selector将自己查询到的服务列表数据缓存到本地Cache中。当需要处理转发时，先到缓存中查找，如果能找到即分发；如果缓存当中没有，会执行请求服务发现注册组件，然后缓存到本地。<br>具体的实现机制如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cache <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// embed the registry interface</span></span><br><span class="line">	registry.Registry</span><br><span class="line">	<span class="comment">// stop the cache watcher</span></span><br><span class="line">	Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cache)</span></span> watch(w registry.Watcher) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// used to stop the watch</span></span><br><span class="line">	stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// manage this loop</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> w.Stop()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// wait for exit</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-c.exit:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="comment">// we&#x27;ve been stopped</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-stop:</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		res, err := w.Next()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">close</span>(stop)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		c.update(res)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过watch实现缓存的更新、创建、移除等操作。</p>
<h3 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h3><p>在了解完了缓存后，我们再看看Selector中其他的方法。在Selector接口的定义中，还可以看到有Mark和Resetf昂发的声明。具体声明如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mark sets the success/error against a node</span></span><br><span class="line">Mark(service <span class="type">string</span>, node *registry.Node, err <span class="type">error</span>)</span><br><span class="line"><span class="comment">// Reset returns state back to zero for a service</span></span><br><span class="line">Reset(service <span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>Mark方法可以用于标记服务注册和发现组件中的某一个节点的状态，这是因为在某些情况下，负载均衡器跟踪请求的执行情况。如果请求被转发到某天服务节点上，多次执行失败，就意味着该节点状态不正常，此时可以通过Mark方法设置节点变成黑名单，以过滤掉掉状态不正常的节点。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>事件驱动机制</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/11%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>之前我们已经学习了使用go-micro创建微服务，并实现了服务的调用。我们具体的实现是实例化了client对象，并调用了对应服务的相关方法。这种方式可以实现系统功能，但有比较大的缺点。</p>
<p>我们通过举例来说明：在某个系统中存在用户服务（user service)、产品服务（product service)和消息服务（message service）。如果用户服务中要调用消息服务中的功能方法，则具体的实现方式可用下图所示方法表示：</p>
<p><img src="https://img-blog.csdnimg.cn/240b3065a8074a559adf7bf3329d5f40.png" alt="在这里插入图片描述"></p>
<p>按照正常的实现是在user service模块的程序中实例化message service的一个client，然后进行RPC调用，调用sendMessage来实现发送消息。</p>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>这种实现方式代码耦合度高，用户服务的模块中出现了消息服务模块的代码，不利于系统的扩展和功能的迭代开发。</p>
<h3 id="发布-x2F-订阅机制"><a href="#发布-x2F-订阅机制" class="headerlink" title="发布&#x2F;订阅机制"></a>发布&#x2F;订阅机制</h3><h5 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h5><p>依然是上述的案例，用户服务在用户操作的过程中，需要调用消息服务的某个方法，假设为发送验证码消息的一个方法。为了使系统代码能够实现解耦，用户服务并不直接调用消息服务的具体的方法，而是将用户信息等相关数据发送到一个中间组件，该组件负责存储消息，而消息服务会按照特定的频率访问中间的消息存储组件，并取出其中的消息,然后执行发送验证码等操作。具体的示意图如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/61b39106fc7c4560b2f933aa96bae3a3.png" alt="在这里插入图片描述"></p>
<p>在上述的架构图中，我们可以看到，相较于之前的实现，多了一个中间的消息组件系统。</p>
<h5 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h5><p>只有当用户服务中的某个功能执行时，才会触发相应的事件，并将对应的用户数据等消息发送到消息队列组件中，这个过程我们称之为事件发布。</p>
<h5 id="事件订阅"><a href="#事件订阅" class="headerlink" title="事件订阅"></a>事件订阅</h5><p>与事件发布对应的是事件订阅。我们增加消息队列组件的目的是实现模块程序的解耦，原来是程序调用端主动进行程序调用，现在需要由另外一方模块的程序到消息队列组件中主动获取需要相关数据并进行相关功能调用。这个主动获取的过程称之为订阅。</p>
<p>基于消息发布&#x2F;订阅的消息系统有很多种框架的实现，常见的有：Kafka、RabbitMQ、ActiveMQ、Kestrel、NSQ等。</p>
<h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>在我们介绍go-micro的时已经提到过，go-micro整个框架都是插件式的设计。没错，这里的发布&#x2F;订阅也是通过接口设计来实现的。</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Broker <span class="keyword">interface</span> &#123;</span><br><span class="line">	Init(...Option) <span class="type">error</span></span><br><span class="line">	Options() Options</span><br><span class="line">	Address() <span class="type">string</span></span><br><span class="line">	Connect() <span class="type">error</span></span><br><span class="line">	Disconnect() <span class="type">error</span></span><br><span class="line">	Publish(topic <span class="type">string</span>, m *Message, opts ...PublishOption) <span class="type">error</span></span><br><span class="line">	Subscribe(topic <span class="type">string</span>, h Handler, opts ...SubscribeOption) (Subscriber, <span class="type">error</span>)</span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要具体实现事件的发布和订阅功能，只需要安装对应支持的go-plugins插件实现就可以了。go-plugins里支持的消息队列方式有：kafka、nsq、rabbitmq、redis等。同时，go-micro本身支持三种broker，分别是http、nats、memory，默认的broker是http，在实际使用过程中往往使用第三方的插件来进行消息发布&#x2F;订阅的实现。</p>
<p>在本课程中，我们演示RabbitMQ插件实现的事件订阅和发布机制。</p>
<h2 id="安装go-plugins"><a href="#安装go-plugins" class="headerlink" title="安装go-plugins"></a>安装go-plugins</h2><p>在go-micro框架的学习过程中，需要频繁的用到相关的插件。因此，首先安装go-plugins插件库，在go-plugins插件库中，封装提供了go-micro框架中的插件机制的实现方案。</p>
<h5 id="源码库"><a href="#源码库" class="headerlink" title="源码库"></a>源码库</h5><p>在github网站上能够找到对应的go-plugins插件库的源码，源码地址是：<a href="https://github.com/micro/go-plugins">https://github.com/micro/go-plugins</a></p>
<h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/micro/<span class="keyword">go</span>-plugins</span><br></pre></td></tr></table></figure>

<p>可以通过上述的命令安装micro的插件库。</p>
<h5 id="Broker实现"><a href="#Broker实现" class="headerlink" title="Broker实现"></a>Broker实现</h5><p>在已经安装和下载的go-plugins插件库中,我们可以看到有一个broker目录，其中就封装了go-micro框架的broker机制支持的解决方案。</p>
<p>我们在本案例中，以mqtt进行讲解。</p>
<h2 id="kafka介绍及环境搭建"><a href="#kafka介绍及环境搭建" class="headerlink" title="kafka介绍及环境搭建"></a>kafka介绍及环境搭建</h2><h5 id="Kafka简介"><a href="#Kafka简介" class="headerlink" title="Kafka简介"></a>Kafka简介</h5><p> Kafka最先由LinkedIn公司开发，之后成为Apache的顶级项目。Kafka是一个分布式的、分区化、可复制提交的日志服务。使用Kafka作为传统的消息系统实现标准的队列和消息的发布—订阅，例如搜索和内容提要（Content Feed）。比起大多数的消息系统来说，Kafka有更好的吞吐量，内置的分区，冗余及容错性，这让Kafka成为了一个很好的大规模消息处理应用的解决方案</p>
<h5 id="Kafka安装"><a href="#Kafka安装" class="headerlink" title="Kafka安装"></a>Kafka安装</h5><p>我们的举例在win10环境下进行，所以这里只列举win10环境kafka的安装：</p>
<p><a href="https://blog.csdn.net/qq_49723651/article/details/120802095">win10环境部署kafka</a></p>
<h5 id="运行kafka"><a href="#运行kafka" class="headerlink" title="运行kafka"></a>运行kafka</h5><p>其实高版本的kafka内置了zookeeper，按理我们可以直接使用kafka内置的zookeeper，但是高版本的kafka对win10的文件系统支持并不好，kafka内置的zookeeper总是启动失败，所以我另外下载了一个zookeeper。</p>
<p>使用时首先启动zookeeper，然后启动kafka即可：</p>
<p><a href="https://blog.csdn.net/qq_49723651/article/details/121087747">kafka的简单使用</a></p>
<h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><p>接下来进行订阅和发布机制的编程的实现。</p>
<h5 id="消息组件初始化"><a href="#消息组件初始化" class="headerlink" title="消息组件初始化"></a>消息组件初始化</h5><p>如果要想使用消息组件完成消息的发布和订阅，首先应该让消息组件正常工作。因此，需要先对消息组件进行初始化。我们可以在服务创建时，对消息组件进行初始化，并进行可选项配置,设置使用kafka作为消息组件。代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">BrokerURLs := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="number">0</span>: <span class="string">&quot;127.0.0.1:9093&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">&quot;student.client&quot;</span>),</span><br><span class="line">		micro.Broker(kafka.NewBroker(<span class="function"><span class="keyword">func</span><span class="params">(o *broker.Options)</span></span> &#123;</span><br><span class="line">			o.Addrs = BrokerURLs</span><br><span class="line">		&#125;)),</span><br><span class="line">	)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以使用micro.Broker来指定特定的消息组件，并通过kafka.NewBroker初始化一个kafka实例对象,作为broker参数。需要注意的是，在我的机器中，kafka的默认监听端口我改成了9093。</p>
<h5 id="消息订阅"><a href="#消息订阅" class="headerlink" title="消息订阅"></a>消息订阅</h5><p>因为是时间驱动机制，消息的发送方随时可能发布相关事件。因此需要消息的接收方先进行订阅操作，避免遗漏消息。go-micro框架中可以通过broker.Subscribe实现消息订阅。编程代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 消息订阅</span></span><br><span class="line">	_, err := pubSub.Subscribe(<span class="string">&quot;go.micro.srv.message&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(event broker.Event)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> req *message.StudentRequest</span><br><span class="line">		fmt.Println(<span class="type">string</span>(event.Message().Body))</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := json.Unmarshal(event.Message().Body, &amp;req); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot; 接收到信息：&quot;</span>, req)</span><br><span class="line">		<span class="comment">//去执行其他操作</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="消息发布"><a href="#消息发布" class="headerlink" title="消息发布"></a>消息发布</h5><p>完成了消息的订阅，我们再来实现消息的发布。在客户端实现消息的发布。在go-micro框架中，可以使用broker.Publish来进行消息的发布,具体的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">	brok := service.Server().Options().Broker</span><br><span class="line">	<span class="keyword">if</span> err := brok.Connect(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot; broker connection failed, error : &quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//student := &amp;message.Student&#123;Name: &quot;davie&quot;, Classes: &quot;软件工程专业&quot;, Grade: 80, Phone: &quot;12345678901&quot;&#125;</span></span><br><span class="line">	student := &amp;message.Student&#123;Name: <span class="string">&quot;tony&quot;</span>, Classes: <span class="string">&quot;网络工程专业&quot;</span>, Grade: <span class="number">95</span>, Phone: <span class="string">&quot;12345678902&quot;</span>&#125;</span><br><span class="line">	msgBody, err := json.Marshal(student)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msg := &amp;broker.Message&#123;</span><br><span class="line">		Header: <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span>: student.Name,</span><br><span class="line">		&#125;,</span><br><span class="line">		Body: msgBody,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 发布消息</span></span><br><span class="line">	err = brok.Publish(<span class="string">&quot;go.micro.srv.message&quot;</span>, msg)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot; 消息发布失败：%s\n&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		log.Print(<span class="string">&quot;消息发布成功&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><h5 id="启动kafka"><a href="#启动kafka" class="headerlink" title="启动kafka"></a>启动kafka</h5><p>kafka会在9093端口监听。</p>
<h5 id="启动server程序"><a href="#启动server程序" class="headerlink" title="启动server程序"></a>启动server程序</h5><p>首先运行server端程序的main.go文件中的main函数。</p>
<h5 id="启动client程序"><a href="#启动client程序" class="headerlink" title="启动client程序"></a>启动client程序</h5><p>server程序启动后，启动客户端程序client.go，可以输出正确日志：</p>
<p>服务端日志：<br><img src="https://img-blog.csdnimg.cn/bf3629676fb44c7f87c6b9a804896794.png" alt="在这里插入图片描述">客户端日志：<br><img src="https://img-blog.csdnimg.cn/2060b056a1694873b9d65cbfa6ee6099.png" alt="在这里插入图片描述"></p>
<br>

<p>然后我们可以查看kafka的日志文件：</p>
<p><img src="https://img-blog.csdnimg.cn/fd3f5a9bfb8e49078b4e4c5e3061858d.png" alt="在这里插入图片描述"><br>发现了这两条消费记录。</p>
<h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>在服务端通过fmt.println日志，可以输出event.Message().Body)数据，其格式为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;davie&quot;</span><span class="punctuation">,</span><span class="attr">&quot;classes&quot;</span><span class="punctuation">:</span><span class="string">&quot;软件工程专业&quot;</span><span class="punctuation">,</span><span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span><span class="number">80</span><span class="punctuation">,</span><span class="attr">&quot;phone&quot;</span><span class="punctuation">:</span><span class="string">&quot;12345678901&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到在服务实例之间传输的数据格式是json格式。根据之前学习proto知识可以知道，在进行消息通信时，采用JSON格式进行数据传输，其效率比较低。</p>
<p>因此，这意味着，当我们在使用第三方消息组件进行消息发布&#x2F;订阅时，会失去对protobuf的使用。这对追求高消息的开发者而言，是需要解决和改进的问题。因为使用protobuf可以直接在多个服务之间使用二进制流数据进行传输，要比json格式高效的多。</p>
<h2 id="googlepubsub"><a href="#googlepubsub" class="headerlink" title="googlepubsub"></a>googlepubsub</h2><p>在go-micro框架中内置的Broker插件中，有google提供的googlepubsub插件实现，位于代理层之上，同时还省略了使用第三方代理消息组件（如mqtt)。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>Protobuf</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/1Protobuf/</url>
    <content><![CDATA[<h2 id="Protobuf"><a href="#Protobuf" class="headerlink" title="Protobuf"></a>Protobuf</h2><p>Google Protocol Buffer( 简称 Protobuf)是Google公司内部的混合语言数据标准，他们主要用于RPC系统和持续数据存储系统。</p>
<h2 id="Protobuf应用场景"><a href="#Protobuf应用场景" class="headerlink" title="Protobuf应用场景"></a>Protobuf应用场景</h2><p>Protocol Buffers可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC数据交换格式。它的优点在于以高效的二进制方式存储，比XML小3到10倍，快20到100倍。</p>
<h2 id="Protobuf在go语言中的编程实现"><a href="#Protobuf在go语言中的编程实现" class="headerlink" title="Protobuf在go语言中的编程实现"></a>Protobuf在go语言中的编程实现</h2><hr>

<p>Go语言中有对应的实现Protobuf协议的库，Github地址：<a href="https://github.com/golang/protobuf">https://github.com/golang/protobuf</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用Go语言的Protobuf库之前，需要相应的环境准备：</p>
<p><strong>1.安装protobuf编译器</strong></p>
<p>可以在如下地址：<a href="https://github.com/protocolbuffers/protobuf/releases">https://github.com/protocolbuffers/protobuf/releases</a>选择适合自己系统的Proto编译器程序进行下载并解压。</p>
<p><strong>2.配置环境变量</strong></p>
<p>windows系统下可以直接在Path目录中进行添加：</p>
<p><img src="https://img-blog.csdnimg.cn/56119b2eeec94478b35ba2c9ad23afec.png" alt="在这里插入图片描述"></p>
<h3 id="Protobuf-协议语法"><a href="#Protobuf-协议语法" class="headerlink" title="Protobuf 协议语法"></a>Protobuf 协议语法</h3><p><strong>Protobuf 协议的格式</strong></p>
<p>Protobuf协议规定：使用该协议进行数据序列化和反序列化操作时，首先定义传输数据的格式，并命名为以**”.proto”**为扩展名的消息定义文件。</p>
<p><strong>message 定义一个消息</strong></p>
<p>先来看一个非常简单的例子。假设想定义一个“订单”的消息格式，每一个“订单”都含有一个订单号ID、订单金额Num、订单时间TimeStamp字段。可以采用如下的方式来定义消息类型的.proto文件：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">Order</span>&#123;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">string</span> order_id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">required</span> <span class="type">int64</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> timestamp = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可以看到在结构体字段类型的前面，还存在着三种关键字：</p>
<ul>
<li>1、required：该规则规定，消息体中该字段的值是必须要设置的。</li>
<li>2、optional：消息体中该规则的字段的值可以存在，也可以为空，optional的字段可以根据defalut设置默认值。</li>
<li>3、repeated：消息体中该规则字段可以存在多个（包括0个），该规则对应java的数组或者go语言的slice。</li>
</ul>
<p>注意：使用required弊多于利；在实际开发中更应该使用optional和repeated而不是required。</p>
<p>但是在protobuf 3中，直接去掉了 required 和 optional 修饰符，所有字段都是 optional 的，使用上更加简便。</p>
<h3 id="使用Protobuf的步骤"><a href="#使用Protobuf的步骤" class="headerlink" title="使用Protobuf的步骤"></a>使用Protobuf的步骤</h3><p><strong>1、创建扩展名为 .proto的文件 ，并编写代码。比如创建person.proto文件，内容如下：</strong></p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">syntax</span> <span class="operator">=</span> <span class="string">&quot;proto3&quot;</span><span class="comment">;</span></span><br><span class="line">package example<span class="comment">;</span></span><br><span class="line">// 表示生成到当前目录下，然后当前的这个proto文件属于example包</span><br><span class="line">option go_package <span class="operator">=</span> <span class="string">&quot;./;example&quot;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    required string Name <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    required int32 Age <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    required string From <span class="operator">=</span> <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、编译.proto文件，生成Go语言文件。执行如下命令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc ./test.proto --go_out=./</span><br></pre></td></tr></table></figure>

<p>然后会生成对应的 person.pb.go 文件。</p>
<p><strong>3、在程序中使用Protobuf 在程序中有如下代码：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;ProtocDemo/example&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/golang/protobuf/proto&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	msg_test := &amp;example.Person&#123;</span><br><span class="line">		Name: proto.String(<span class="string">&quot;Davie&quot;</span>),</span><br><span class="line">		Age:  proto.Int(<span class="number">18</span>),</span><br><span class="line">		From: proto.String(<span class="string">&quot;China&quot;</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//序列化</span></span><br><span class="line">	msgDataEncoding, err := proto.Marshal(msg_test)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	msgEntity := example.Person&#123;&#125;</span><br><span class="line">	err = proto.Unmarshal(msgDataEncoding, &amp;msgEntity)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fmt.Printf(<span class="string">&quot;姓名：%s\n\n&quot;</span>, msgEntity.GetName())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;年龄：%d\n\n&quot;</span>, msgEntity.GetAge())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;国籍：%s\n\n&quot;</span>, msgEntity.GetFrom())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Protobuf序列化原理"><a href="#Protobuf序列化原理" class="headerlink" title="Protobuf序列化原理"></a>Protobuf序列化原理</h2><p>之前已经做过描述，Protobuf的message中有很多字段，每个字段的格式为：<code>修饰符 字段类型 字段名 = 域号; </code></p>
<p><strong>Varint</strong></p>
<p>Varint是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。</p>
<p>Varint中的每个byte的最高位bit有特殊的含义，如果该位为1，表示后续的byte也是该数字的一部分，如果该位为0，则结束。其他的7个bit都用来表示数字。因此小于128的数字都可以用一个byte表示。大于128的数字，比如300，会用两个字节来表示：1010 1100 0000 0010。下图演示了 Google Protocol Buffer 如何解析两个bytes。注意到最终计算前将两个byte的位置相互交换过一次，这是因为 Google Protocol Buffer 字节序采用little-endian的方式。</p>
<p><img src="https://img-blog.csdnimg.cn/a948ce11598f4c6dabcb8838a4bd3107.png" alt="在这里插入图片描述"></p>
<p>在序列化时，Protobuf按照TLV的格式序列化每一个字段，T即Tag，也叫Key；V是该字段对应的值value；L是Value的长度，如果一个字段是整形，这个L部分会省略。</p>
<p>序列化后的Value是按原样保存到字符串或者文件中，Key按照一定的转换条件保存起来，序列化后的结果就是 KeyValueKeyValue…依次类推的样式，示意图如下所示： </p>
<p><img src="https://img-blog.csdnimg.cn/ba1919d7d3e14fb0a96baa1646c84ec2.png" alt="在这里插入图片描述"></p>
<p>采用这种Key-Pair结构无需使用分隔符来分割不同的Field。对于可选的Field，如果消息中不存在该field，那么在最终的Message Buffer中就没有该field，这些特性都有助于节约消息本身的大小。比如，我们有消息order1:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">Order.id</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line"><span class="attr">Order.desc</span> = <span class="string">&quot;bill&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>则最终的 Message Buffer 中有两个Key-Value对，一个对应消息中的id；另一个对应desc。Key用来标识具体的field，在解包的时候，Protocol Buffer根据Key就可以知道相应的Value应该对应于消息中的哪一个field。</p>
<p>Key 的定义如下：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line">(field_number &lt;&lt; <span class="number">3</span>) | wire_<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<p>可以看到 Key 由两部分组成。第一部分是 field_number，比如消息lm.helloworld中field id 的field_number为1。第二部分为wire_type。表示 Value的传输类型。而wire_type有以下几种类型：</p>
<p><img src="https://img-blog.csdnimg.cn/ee75c0c16b3c49e4a504309d1936d56f.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>RESTful API设计标准和实践</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/13RESTful%20API%E8%AE%BE%E8%AE%A1%E6%A0%87%E5%87%86%E5%92%8C%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前面已经介绍了go-micro的一些核心功能和核心机制。实现的都是着重于微服务之间。在实际的开发过程中，需要微服务仅仅是作为后台程序进行部署，需要整体向web前端用户端产品提供交互和数据。因此，我们来看看如何微服务如何与web进行交互。</p>
<h2 id="划分调用范围"><a href="#划分调用范围" class="headerlink" title="划分调用范围"></a>划分调用范围</h2><p>在整体的系统架构中，我们会将系统分为前台和后台。前台负责与用户交互，展示数据，执行操作。后台负责业务逻辑处理，数据持久化等操作。在系统运行过程中，前台和后台，后台和后台都可能发生功能调用：</p>
<ul>
<li><p>内部调用：后台各个微服务之间的互相调用，属于系统后台内部的调用,称之为内部调用。</p>
</li>
<li><p>外部调用：前台与后台的接口请求调用，通常被称之为外部调用。</p>
</li>
</ul>
<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>在开发实践中，我们对于外部调用和内部调用所采用的技术方案会有所不同。</p>
<ul>
<li><p>RPC调用：后台各个服务之间内部的互相调用，为了实现高效率的服务的交互，通常采用RPC的方式进行实现。</p>
</li>
<li><p>REST：对于前端客户端通过HTTP接口，与后台交互的场景。因为涉及到对不同资源的管理和操作，因此往往采用RESTful标准进行实现。</p>
</li>
</ul>
<h2 id="Go-Micro-API网关"><a href="#Go-Micro-API网关" class="headerlink" title="Go-Micro API网关"></a>Go-Micro API网关</h2><p>Micro框架中有API网关的功能。API网关的作用是为微服务做代理，负责将微服务的RPC方法代理成支持HTTP协议的web请求，同时将用户端使用的URL进行暴露。</p>
<h3 id="安装Micro工具"><a href="#安装Micro工具" class="headerlink" title="安装Micro工具"></a>安装Micro工具</h3><p>要想使用go-micro 的api网关功能。需要下载Micro源码并安装Mico。</p>
<h4 id="安装Micro"><a href="#安装Micro" class="headerlink" title="安装Micro"></a>安装Micro</h4><p>可以直接通过go get命令下载并安装,具体命令为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/micro/micro</span><br></pre></td></tr></table></figure>
<p>在使用go get命令下载源码和相应依赖时，国内由于网络环境的问题，可能会导致下载失败的错误。</p>
<p>如果在安装的过程中出现连接超时的错误，可以通过手动的方式下载相应的依赖库，然后再进行手动安装。因此，解决方案分为两步：</p>
<h5 id="安装golang的net、crypt、text等库"><a href="#安装golang的net、crypt、text等库" class="headerlink" title="安装golang的net、crypt、text等库"></a>安装golang的net、crypt、text等库</h5><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/grpc/g</span>rpc-go.git <span class="variable">$GOPATH</span><span class="regexp">/src/g</span>oogle.golang.org/grpc  </span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/golang/</span>net.git <span class="variable">$GOPATH</span><span class="regexp">/src/g</span>olang.org<span class="regexp">/x/</span>net  </span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/golang/</span>text.git <span class="variable">$GOPATH</span><span class="regexp">/src/g</span>olang.org<span class="regexp">/x/</span>text  </span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/golang/</span>crypto.git <span class="variable">$GOPATH</span><span class="regexp">/src/g</span>olang.org<span class="regexp">/x/</span>crypto</span><br></pre></td></tr></table></figure>
<p>使用git clone命令将所需要的代码库进行下载。</p>
<h5 id="安装micro"><a href="#安装micro" class="headerlink" title="安装micro"></a>安装micro</h5><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">go install github.com<span class="regexp">/micro/mi</span>cro</span><br></pre></td></tr></table></figure>
<p> 使用go install命令安装micro框架，等待命令执行结束。</p>
<h4 id="检验Micro安装成功"><a href="#检验Micro安装成功" class="headerlink" title="检验Micro安装成功"></a>检验Micro安装成功</h4><p>micro系列工具安装成功后，可以通过命令检验查看。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">micro --version</span><br><span class="line">micro version <span class="number">1.9</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>如上，输出了micro version 1.9.1即表示micro安装成功。</p>
<h2 id="Micro-API工作原理"><a href="#Micro-API工作原理" class="headerlink" title="Micro API工作原理"></a>Micro API工作原理</h2><p>micro工具提供了构建api网关服务的功能，并基于go-micro框架进行编程实现，核心作用是把RPC形式的服务代理成为支持HTTP协议的WEB API请求。</p>
<h2 id="运行Micro-api服务"><a href="#运行Micro-api服务" class="headerlink" title="运行Micro api服务"></a>运行Micro api服务</h2><p>可以通过如下命令启动micro api：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">micro api</span><br></pre></td></tr></table></figure>


<h3 id="反向代理的API服务启动"><a href="#反向代理的API服务启动" class="headerlink" title="反向代理的API服务启动"></a>反向代理的API服务启动</h3><p>在Micro api功能中,支持多种处理请求路由的方式，我们称之为Handler。包括：API Handler、RPC Handler、反向代理、Event Handler，RPC等五种方式。在本案例中，我们使用反向代理来进行演示。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><ul>
<li>格式：&#x2F;[service]</li>
<li>请求&#x2F;响应：HTTP方式</li>
<li>micro api启动时通过–handler&#x3D;proxy设置</li>
</ul>
<p>因此，反向代理形式的micro api网关服务启动命令为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">micro api --handler=http</span><br></pre></td></tr></table></figure>

<p>在本案例中，我们将micro api的反向代理和REST代表的HTTP WEB请求结合起来一起使用。</p>
<h2 id="安装go-restful"><a href="#安装go-restful" class="headerlink" title="安装go-restful"></a>安装go-restful</h2><p>可以通过安装go-restful库来实现RESTful风格的路径映射，从而实现HTTP的WEB API服务。安装go-restful的命令如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/emicklei/<span class="keyword">go</span>-restful</span><br></pre></td></tr></table></figure>


<blockquote>
<p>我们使用一个获取某个学生信息的服务为例，进行讲解micro api的编程实现。</p>
</blockquote>
<h2 id="服务定义和编译"><a href="#服务定义和编译" class="headerlink" title="服务定义和编译"></a>服务定义和编译</h2><p>定义学生消息体proto文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &#x27;proto3&#x27;;</span><br><span class="line">package proto;</span><br><span class="line">option go_package=&quot;./;proto&quot;;</span><br><span class="line">message Student &#123;</span><br><span class="line">    string id = 1;</span><br><span class="line">    string name = 2;</span><br><span class="line">    int32 grade = 3;</span><br><span class="line">    string classes = 4;</span><br><span class="line">&#125;</span><br><span class="line">message Request &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">&#125;</span><br><span class="line">service StudentService &#123;</span><br><span class="line">    rpc GetStudent (Request) returns (Student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在proto文件中定义了Student、Request消息体和rpc服务。使用micro api网关功能，编译proto文件，需要生成micro文件。编译生成该文件需要使用到一个新的protoc-gen-micro库，安装protoc-gen-micro库命令如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/micro/protoc-gen-micro</span><br></pre></td></tr></table></figure>
<p>再次编译proto文件，需要指定两个参数，分别是：go_out和micro_out，详细命令如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">protoc --go_out=. --micro_out=. student.proto</span><br></pre></td></tr></table></figure>
<p>上述命令执行成功后，会自动生成两个go语言文件：student.pb.go和student.micro.go。</p>
<p>micro.go文件中生成的内容包含服务的实例化，和相应的服务方法的底层实现。</p>
<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>我们都知道正常的Web服务，是通过路由处理http的请求的。在此处也是一样的，我们可以通过路由处理来解析HTTP请求的接口，service对象中包含路由处理方法。详细代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">type</span> StudentServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ss *StudentServiceImpl)</span></span> GetStudent(ctx context.Context, request *proto.Request, resp *proto.Student) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//tom</span></span><br><span class="line">	studentMap := <span class="keyword">map</span>[<span class="type">string</span>]proto.Student&#123;</span><br><span class="line">		<span class="string">&quot;davie&quot;</span>:  proto.Student&#123;Name: <span class="string">&quot;davie&quot;</span>, Classes: <span class="string">&quot;软件工程专业&quot;</span>, Grade: <span class="number">80</span>&#125;,</span><br><span class="line">		<span class="string">&quot;steven&quot;</span>: proto.Student&#123;Name: <span class="string">&quot;steven&quot;</span>, Classes: <span class="string">&quot;计算机科学与技术&quot;</span>, Grade: <span class="number">90</span>&#125;,</span><br><span class="line">		<span class="string">&quot;tony&quot;</span>:   proto.Student&#123;Name: <span class="string">&quot;tony&quot;</span>, Classes: <span class="string">&quot;计算机网络工程&quot;</span>, Grade: <span class="number">85</span>&#125;,</span><br><span class="line">		<span class="string">&quot;jack&quot;</span>:   proto.Student&#123;Name: <span class="string">&quot;jack&quot;</span>, Classes: <span class="string">&quot;工商管理&quot;</span>, Grade: <span class="number">96</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> request.Name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot; 请求参数错误,请重新请求。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取对应的student</span></span><br><span class="line">	student := studentMap[request.Name]</span><br><span class="line">	<span class="keyword">if</span> student.Name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		fmt.Println(student.Name, student.Classes, student.Grade)</span><br><span class="line">		*resp = student</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot; 未查询当相关学生信息 &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">&quot;go.micro.srv.student&quot;</span>),</span><br><span class="line">	)</span><br><span class="line">	service.Init()</span><br><span class="line">    proto.RegisterStudentServiceHandler(service.Server(), <span class="built_in">new</span>(StudentServiceImpl))</span><br><span class="line">	<span class="keyword">if</span> err := service.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>server程序进行服务的实现和服务的运行。</p>
<h2 id="REST-映射"><a href="#REST-映射" class="headerlink" title="REST 映射"></a>REST 映射</h2><p>现在，RPC服务已经编写完成。我们需要编程实现API的代理功能，用于处理HTTP形式的请求。<br>在rest.go文件中，实现rest的映射，详细代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	cli proto.StudentService</span><br><span class="line">)</span><br><span class="line"><span class="comment">// http请求处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span></span> GetStudent(req *restful.Request, rsp *restful.Response) &#123;</span><br><span class="line">	name := req.PathParameter(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">	<span class="comment">// 核心代码</span></span><br><span class="line">	<span class="comment">// 使用cli调用RPC函数，从而达到将RPC形式的服务代理成为支持HTTP协议的WEB API请求。</span></span><br><span class="line">	response, err := cli.GetStudent(context.TODO(), &amp;proto.Request&#123;</span><br><span class="line">		Name: name,</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">		rsp.WriteError(<span class="number">500</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	rsp.WriteEntity(response)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意这里创建了一个web服务</span></span><br><span class="line">	service := web.NewService(</span><br><span class="line">		web.Name(<span class="string">&quot;go.micro.api.student&quot;</span>),</span><br><span class="line">	)</span><br><span class="line">	service.Init()</span><br><span class="line">	<span class="comment">// 实例化cli对象</span></span><br><span class="line">	cli = proto.NewStudentService(<span class="string">&quot;go.micro.srv.student&quot;</span>, client.DefaultClient)</span><br><span class="line">	student := <span class="built_in">new</span>(Student)</span><br><span class="line">	ws := <span class="built_in">new</span>(restful.WebService)</span><br><span class="line">	ws.Path(<span class="string">&quot;/student&quot;</span>)</span><br><span class="line">	ws.Consumes(restful.MIME_XML, restful.MIME_JSON)</span><br><span class="line">	ws.Produces(restful.MIME_JSON, restful.MIME_XML)</span><br><span class="line">	ws.Route(ws.GET(<span class="string">&quot;/&#123;name&#125;&quot;</span>).To(student.GetStudent))</span><br><span class="line">	wc := restful.NewContainer()</span><br><span class="line">	wc.Add(ws)</span><br><span class="line">	service.Handle(<span class="string">&quot;/&quot;</span>, wc)</span><br><span class="line">	<span class="keyword">if</span> err := service.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>RPC简介及原理介绍</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/3RPC%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="RPC简介"><a href="#RPC简介" class="headerlink" title="RPC简介"></a>RPC简介</h2><p>RPC是Remote Procedure Call Protocol单词首字母的缩写，简称为：RPC，翻译成中文叫远程过程调用协议，指的是调用远端服务器上的程序的方法整个过程。</p>
<h2 id="RPC设计组成"><a href="#RPC设计组成" class="headerlink" title="RPC设计组成"></a>RPC设计组成</h2><p>RPC技术在架构设计上有四部分组成，分别是：<strong>客户端、客户端存根、服务端、服务端存根。</strong></p>
<ul>
<li><p><code>客户端(Client)</code>：服务调用发起方，也称为服务消费者。</p>
</li>
<li><p><code>客户端存根(Client Stub)</code>：该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。</p>
</li>
<li><p><code>服务端(Server)</code>：远端的计算机机器上运行的程序，其中有客户端要调用的方法。</p>
</li>
<li><p><code>服务端存根(Server Stub)</code>：接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序。</p>
</li>
</ul>
<h2 id="RPC原理及调用步骤"><a href="#RPC原理及调用步骤" class="headerlink" title="RPC原理及调用步骤"></a>RPC原理及调用步骤</h2><p>RPC具体的调用步骤图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/ec584debdb814d6da4aed4a068513b7b.png" alt="在这里插入图片描述">上述RPC调用过程具体描述为：</p>
<ul>
<li><p>1、客户端想要发起一个远程过程调用，首先通过调用本地客户端Stub程序的方式调用想要使用的功能方法名；</p>
</li>
<li><p>2、客户端Stub程序接收到了客户端的功能调用请求，<strong>将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。</strong></p>
</li>
<li><p>3、客户端Stub查找到远程服务器程序的IP地址，调用Socket通信协议，通过网络发送给服务端。</p>
</li>
<li><p>4、服务端Stub程序接收到客户端发送的数据包信息，并<strong>通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。</strong></p>
</li>
<li><p>5、服务端Stub程序准备相关数据，<strong>调用本地Server对应的功能方法进行，并传入相应的参数，进行业务处理。</strong></p>
</li>
<li><p>6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序。</p>
</li>
<li><p>7、服务端Stub程序<strong>将程序调用结果按照约定的协议进行序列化，</strong>并通过网络发送回客户端Stub程序。</p>
</li>
<li><p>8、客户端Stub程序接收到服务端Stub发送的返回数据，<strong>对数据进行反序列化操作，</strong>并将调用返回的数据传递给客户端请求发起者。</p>
</li>
<li><p>9、客户端请求发起者得到调用结果，整个RPC调用过程结束。</p>
</li>
</ul>
<h2 id="RPC涉及到的相关技术"><a href="#RPC涉及到的相关技术" class="headerlink" title="RPC涉及到的相关技术"></a>RPC涉及到的相关技术</h2><p>我们来对上述RPC调用中涉及到的技术做一个总结和分析：</p>
<p><strong>1、动态代理技术：</strong> 上文中我们提到的Client Stub和Sever Stub程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。</p>
<p><strong>2、序列化和反序列化：</strong> 在RPC调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。</p>
<ul>
<li><p><code>序列化</code>：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。</p>
</li>
<li><p><code>反序列化</code>：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。</p>
</li>
</ul>
<p>上节学习过的Protobuf协议就可以对数据做序列化和反序列化编码操作，其在RPC框架中使用很广泛。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>解决protobuf文件报错protoc-gen-go unable to determine Go import path for “person.proto“</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/2%E8%A7%A3%E5%86%B3protobuf%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99protoc-gen-go%20unable%20to%20determine%20Go%20import%20path%20for%20%E2%80%9Cperson.proto%E2%80%9C/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用命令<code>rotoc --go_out=. person.proto</code>指定proto文件编译输出路径时，遇到了标题中的错误。网上说需要在proto文件中加上：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span> go_package = &quot;path;name&quot;;</span><br><span class="line"> </span><br><span class="line"><span class="type">path</span> 表示生成的go文件的存放地址，会自动生成目录的。</span><br><span class="line"><span class="type">name</span> 表示生成的go文件所属的包名</span><br><span class="line"></span><br><span class="line">比如proto文件在当前目录下，它被声明在example包中，就加上：</span><br><span class="line"><span class="keyword">option</span> go_package = &quot;./;example&quot;</span><br></pre></td></tr></table></figure>

<p>但是加上以后还是会报错：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Built-<span class="keyword">in</span> <span class="keyword">option</span> <span class="string">&#x27;go_package&#x27;</span> <span class="keyword">not</span> <span class="built_in">found</span></span><br></pre></td></tr></table></figure>





<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>goland 2021.2版本新建项目没有go modules可选， go modules已经集成进了go 里面。</p>
<p>这个版本创建proto文件会出现error, 解决办法如下图，不管是用protobuf 或者protubuf support 插件，解决办法都一样。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p><img src="https://img-blog.csdnimg.cn/33a73e158dc842c1b6a09e580ad77a8b.png" alt="在这里插入图片描述"></p>
<p>加上proto文件的查询路径然后重启goland即可。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言实现RPC编程</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/4go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RPC%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="RPC官方库"><a href="#RPC官方库" class="headerlink" title="RPC官方库"></a>RPC官方库</h2><p>在Go语言官方网站的pkg说明中，提供了官方支持的rpc包，具体链接如下：<a href="https://golang.org/pkg/net/rpc/">https://golang.org/pkg/net/rpc/</a>。官方提供的rpc包完整的包名是：<strong>net&#x2F;rpc</strong>。</p>
<h2 id="net-x2F-rpc库实现RPC调用编程"><a href="#net-x2F-rpc库实现RPC调用编程" class="headerlink" title="net&#x2F;rpc库实现RPC调用编程"></a>net&#x2F;rpc库实现RPC调用编程</h2><p>rpc调用有两个参与者，分别是：<strong>客户端（client）和服务器（server）</strong>。</p>
<p>首先是提供方法暴露的一方: <code>服务器</code>。</p>
<h3 id="一、服务定义及暴露"><a href="#一、服务定义及暴露" class="headerlink" title="一、服务定义及暴露"></a>一、服务定义及暴露</h3><p>在编程实现过程中，服务器端需要<code>注册结构体对象，然后通过对象所属的方法暴露给调用者</code>，从而提供服务，该方法称之为<strong>输出方法</strong>，此输出方法可以被远程调用。当然，在定义输出方法时，能够被远程调用的方法需要遵循一定的规则。我们通过代码进行讲解：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span></span> MethodName(request T1,response *T2) <span class="type">error</span></span><br></pre></td></tr></table></figure>

<p>上述代码是go语言官方给出的对外暴露的服务方法的定义标准，其中包含了主要的几条规则，分别是：</p>
<ul>
<li>1、对外暴露的方法有且只能有两个参数，这个两个参数只能是输出类型或内建类型，两种类型中的一种。</li>
<li>2、方法的第二个参数必须是指针类型。</li>
<li>3、方法的返回类型为error。</li>
<li>4、方法的类型是可输出的。</li>
<li>5、方法本身也是可输出的。</li>
</ul>
<p>我们举例说明：假设目前我们有一个需求，给出一个float类型变量，作为圆形的半径，要求通过RPC调用，返回对应的圆形面积。具体的编程实现思路如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MathUtil <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法向外暴露：提供计算圆形面积的服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mu *MathUtil)</span></span> CalculateCircleArea(req <span class="type">float32</span>, resp *<span class="type">float32</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*resp = math.Pi * req * req <span class="comment">//圆形的面积 s = π * r * r</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//返回类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述的案例中，我们可以看到：</p>
<ul>
<li>1、Calculate方法是服务对象MathUtil向外提供的服务方法，该方法用于接收传入的圆形半径数据，计算圆形面积并返回。</li>
<li>2、第一个参数req代表的是调用者（client）传递提供的参数。</li>
<li>3、第二个参数resp代表要返回给调用者的计算结果，必须是指针类型。</li>
<li>4、正常情况下，方法的返回值为是error，为nil。如果遇到异常或特殊情况，则error将作为一个字符串返回给调用者，此时，resp参数就不会再返回给调用者。</li>
</ul>
<p>至此为止，已经实现了服务端的功能定义，接下来就是让服务代码生效，需要将服务进行注册，并启动请求处理。</p>
<h5 id="二、注册服务及监听请求"><a href="#二、注册服务及监听请求" class="headerlink" title="二、注册服务及监听请求"></a>二、注册服务及监听请求</h5><p><strong>net&#x2F;rpc包</strong>为我们提供了注册服务和处理请求的一系列方法,结合本案例实现注册及处理逻辑，如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、初始化指针数据类型</span></span><br><span class="line">mathUtil := <span class="built_in">new</span>(MathUtil) <span class="comment">//初始化指针数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、调用net/rpc包的功能将服务对象进行注册</span></span><br><span class="line">err := rpc.Register(mathUtil)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过该函数把mathUtil中提供的服务注册到HTTP协议上，方便调用者可以利用http的方式进行数据传递</span></span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、在特定的端口进行监听</span></span><br><span class="line">listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8081&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(listen, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>经过服务注册和监听处理，RPC调用过程中的服务端实现就已经完成了。接下来需要实现的是客户端请求代码的实现。</p>
<h3 id="三、客户端调用"><a href="#三、客户端调用" class="headerlink" title="三、客户端调用"></a>三、客户端调用</h3><p>在服务端是通过Http的端口监听方式等待连接的，因此在客户端就需要通过http连接，首先与服务端实现连接。</p>
<ul>
<li><p>客户端连接服务端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8081&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>远端方法调用<br>客户端成功连接服务端以后，就可以通过方法调用调用服务端的方法，具体调用方法如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> req <span class="type">float32</span> <span class="comment">//请求值</span></span><br><span class="line">req = <span class="number">3</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> resp *<span class="type">float32</span> <span class="comment">//返回值</span></span><br><span class="line">err = client.Call(<span class="string">&quot;MathUtil.CalculateCircleArea&quot;</span>, req, &amp;resp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(*resp)</span><br></pre></td></tr></table></figure>

<p>  上述的调用方法核心在于client.Call方法的调用，该方法有三个参数，第一个参数表示要调用的远端服务的方法名，第二个参数是调用时要传入的参数，第三个参数是调用要接收的返回值。<br>  上述的Call方法调用实现的方式是同步的调用，除此之外，还有一种异步的方式可以实现调用。异步调用代码实现如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> respSync *<span class="type">float32</span></span><br><span class="line"><span class="comment">//异步的调用方式</span></span><br><span class="line">syncCall := client.Go(<span class="string">&quot;MathUtil.CalculateCircleArea&quot;</span>, req, &amp;respSync, <span class="literal">nil</span>)</span><br><span class="line">replayDone := &lt;-syncCall.Done</span><br><span class="line">fmt.Println(replayDone)</span><br><span class="line">fmt.Println(*respSync)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="多参数的请求调用参数传递"><a href="#多参数的请求调用参数传递" class="headerlink" title="多参数的请求调用参数传递"></a>多参数的请求调用参数传递</h5><p>上述内容演示了单个参数下的RPC调用，对于多参数下的请求该如何实现。我们通过另外一个案例进行演示。</p>
<p>假设现在需要实现另外一个需求：通过RPC调用实现计算两个数字相加功能并返回计算结果。此时，就需要传递两个参数，具体实现如下：</p>
<p>将参数定义在一个新的结构体中，存放在param包中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> AddParma <span class="keyword">struct</span> &#123;</span><br><span class="line">	Args1 <span class="type">float32</span> <span class="comment">//第一个参数</span></span><br><span class="line">	Args2 <span class="type">float32</span> <span class="comment">//第二个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在server.go文件中，实现两数相加的功能，并实现服务注册的逻辑：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mu *MathUtil)</span></span> Add(param param.AddParma, resp *<span class="type">float32</span>) <span class="type">error</span> &#123;</span><br><span class="line">	*resp = param.Args1 + param.Args2 <span class="comment">//实现两数相加的功能</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">mathUtil := <span class="built_in">new</span>(MathUtil)</span><br><span class="line"></span><br><span class="line">	err := rpc.RegisterName(<span class="string">&quot;MathUtil&quot;</span>, mathUtil)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8082&quot;</span>)</span><br><span class="line">	http.Serve(listen, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure>

<p>在本案例中，我们通过新的注册方法rpc.RegisterName实现了服务的注册和调用。</p>
<p>至此，我们已经完成了net&#x2F;rpc包的最基础的使用。</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>RPC与Protobuf结合使用</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/5RPC%E4%B8%8EProtobuf%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>这里我们利用一个需求场景来学习相关的知识点：</p>
<p>假设在一个系统中，有订单模块（Order），其他模块想要实现RPC的远程工程调用，根据订单ID和时间戳可以获取订单信息。如果获取成功就返回相应的订单信息；如果查询不到返回失败信息。现在，我们来进行需求的编程实现。</p>
<h2 id="传输数据格式定义"><a href="#传输数据格式定义" class="headerlink" title="传输数据格式定义"></a>传输数据格式定义</h2><p><strong>数据定义</strong></p>
<p>根据需求，定义message.proto文件，详细定义如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">syntax</span> <span class="operator">=</span> <span class="string">&quot;proto3&quot;</span><span class="comment">;</span></span><br><span class="line">package message<span class="comment">;</span></span><br><span class="line">option go_package<span class="operator">=</span><span class="string">&quot;./;message&quot;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">//订单请求参数</span><br><span class="line">message OrderRequest &#123;</span><br><span class="line">    string orderId <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    int64 timeStamp <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//订单信息</span><br><span class="line">message OrderInfo &#123;</span><br><span class="line">    string OrderId <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br><span class="line">    string OrderName <span class="operator">=</span> <span class="number">2</span><span class="comment">;</span></span><br><span class="line">    string OrderStatus <span class="operator">=</span> <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在上述文件中，定义了客户端发起RPC调用时的请求数据结构OrderRequest和服务端查询后返回的数据结构OrderInfo。数据定义采用proto3语法实现，整个数据定义被定义在message包下。</p>
<ul>
<li><p><strong>编译proto文件</strong></p>
<p>通过proto编译命令对.proto文件进行编译，自动生成对应结构体的Go语言文件。编译命令如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">protoc ./message.proto --go_out=./</span><br></pre></td></tr></table></figure>

<p>执行上述命令是在message包下。编译命令结束后，会在message包下生成message.pb.go文件，其中自动生成了OrderRequest和OrderInfo在Go语言中结构体的定义和相关的方法。</p>
</li>
</ul>
<h3 id="Protobufg格式数据与RPC结合"><a href="#Protobufg格式数据与RPC结合" class="headerlink" title="Protobufg格式数据与RPC结合"></a>Protobufg格式数据与RPC结合</h3><ul>
<li><p><strong>服务的定义</strong><br>进行RPC远程过程调用，实现调用远程服务器的方法，首先要有服务。在本案例中，定义提供订单查询功能的服务，取名为OrderService，同时提供订单信息查询方法供远程调用。详细的服务和方法定义如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单服务</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(os *OrderService)</span></span> GetOrderInfo(request message.OrderRequest, response *message.OrderInfo) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">//201907310003</span></span><br><span class="line">	orderMap := <span class="keyword">map</span>[<span class="type">string</span>]message.OrderInfo&#123;</span><br><span class="line">		<span class="string">&quot;201907300001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907300001&quot;</span>, OrderName: <span class="string">&quot;衣服&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;201907310001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310001&quot;</span>, OrderName: <span class="string">&quot;零食&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;201907310002&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310002&quot;</span>, OrderName: <span class="string">&quot;食品&quot;</span>, OrderStatus: <span class="string">&quot;未付款&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"> current := time.Now().Unix()</span><br><span class="line"> <span class="keyword">if</span> (request.TimeStamp &gt; current) &#123;</span><br><span class="line"> *response = message.OrderInfo&#123;OrderId: <span class="string">&quot;0&quot;</span>, OrderName: <span class="string">&quot;&quot;</span>, OrderStatus: <span class="string">&quot;订单信息异常&quot;</span>&#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> result := orderMap[request.OrderId]<span class="comment">//201907310003</span></span><br><span class="line"> <span class="keyword">if</span> result.OrderId != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"> *response = orderMap[request.OrderId]</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> errors.New(<span class="string">&quot;server error&quot;</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在服务的方法定义中，使用orderMap模拟初始订单数据库，方便案例查询展示。GetOrderInfo方法有两个参数，第一个是message.OrderRequest，作为调用者传递的参数，第二个是message.OrderInfo，作为调用返回的参数，通过此处的两个参数，将上文通过.proto定义并自动生成的Go语言结构体数据结合起来。</p>
</li>
<li><p><strong>服务的注册和处理</strong><br>服务定义好以后，需要将服务注册到RPC框架，并开启http请求监听处理。这部分代码与之前的RPC服务端实现逻辑一致，具体实现如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	orderService := <span class="built_in">new</span>(OrderService)</span><br><span class="line"></span><br><span class="line">	rpc.Register(orderService)</span><br><span class="line"></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8081&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	http.Serve(listen, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>RPC客户端调用实现</strong><br>在客户端，除了客户端正常访问远程服务器的逻辑外，还需要准备客户端需要传递的请求数据message.OrderInfo。具体实现如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:8081&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timeStamp := time.Now().Unix()</span><br><span class="line">	request := message.OrderRequest&#123;OrderId: <span class="string">&quot;201907310001&quot;</span>, TimeStamp: timeStamp&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> response *message.OrderInfo</span><br><span class="line">	err = client.Call(<span class="string">&quot;OrderService.GetOrderInfo&quot;</span>, request, &amp;response)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(*response)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>gRPC安装和使用</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/6gRPC%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、什么是gRPC"><a href="#一、什么是gRPC" class="headerlink" title="一、什么是gRPC"></a>一、什么是gRPC</h2><h3 id="gRPC介绍"><a href="#gRPC介绍" class="headerlink" title="gRPC介绍"></a>gRPC介绍</h3><p>gRPC是由Google公司开源的一款高性能的远程过程调用(RPC)框架，可以在任何环境下运行。该框架提供了负载均衡，跟踪，智能监控，身份验证等功能，可以实现系统间的高效连接。</p>
<h3 id="gRPC官方网站"><a href="#gRPC官方网站" class="headerlink" title="gRPC官方网站"></a>gRPC官方网站</h3><p>gRPC官方网站：<a href="https://grpc.io/">https://grpc.io/</a>。</p>
<h3 id="gRPC源码"><a href="#gRPC源码" class="headerlink" title="gRPC源码"></a>gRPC源码</h3><p>gRPC的官方源码库存放于github网站，可以公开访问。gRPC源码库主页链接如下：<a href="https://github.com/grpc/grpc">https://github.com/grpc/grpc</a></p>
<p>gRPC开源库支持诸如：C++，C#，Dart，Go，Java，Node，Objective-C，PHP，Python，Ruby，WebJS等多种语言，开发者可以自行在gRPC的github主页库选择查看对应语言的实现。</p>
<h3 id="gRPC调用执行过程"><a href="#gRPC调用执行过程" class="headerlink" title="gRPC调用执行过程"></a>gRPC调用执行过程</h3><p>因为gRPC支持多种语言的实现，因此gRPC支持客户端与服务器在多种语言环境中部署运行和互相调用。多语言环境交互示例如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/838f2fd053fb4378be65ce959e819410.png" alt="在这里插入图片描述"></p>
<p>其中gRPC中默认采用的数据格式化方式是protocol buffers。</p>
<h2 id="二、grpc-go介绍"><a href="#二、grpc-go介绍" class="headerlink" title="二、grpc-go介绍"></a>二、grpc-go介绍</h2><h3 id="grpc-go是什么"><a href="#grpc-go是什么" class="headerlink" title="grpc-go是什么"></a>grpc-go是什么</h3><p>grpc-go库是gRPC库的Golang语言实现版本。可以通过github主页访问grpc-go库的源码并下载。grpc-go主页的Github地址如下：<a href="https://github.com/grpc/grpc-go">https://github.com/grpc/grpc-go</a></p>
<h3 id="grpc-go安装"><a href="#grpc-go安装" class="headerlink" title="grpc-go安装"></a>grpc-go安装</h3><h4 id="go-get命令安装"><a href="#go-get命令安装" class="headerlink" title="go get命令安装"></a>go get命令安装</h4><p>在网络环境通畅的情况下，可以使用go get命令安装grpc-go库：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure>

<p>需要注意，很多开发者在使用上述的命令进行安装grpc-go库时，往往会遇到网络环境的问题导致下载失败，链接超时报错。经常遇到的错误是：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> google.golang.org/grpc: unrecognized <span class="keyword">import</span> path <span class="string">&quot;google.golang.org/grpc&quot;</span> (https fetch: Get https:<span class="comment">//google.golang.org/grpc?go-get=1: dial tcp 216.239.37.1:443: i/o timeout)</span></span><br></pre></td></tr></table></figure>

<p>如果遇到类似上文中的timeout的链接服务器超时的错误，说明是网络环境问题，此时可以通过第二种方案进行安装。</p>
<h4 id="下载方式安装"><a href="#下载方式安装" class="headerlink" title="下载方式安装"></a>下载方式安装</h4><p>可以使用git工具中的git clone命令，将代码从github上下载到本地。clone命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc</span></span><br></pre></td></tr></table></figure>

<p>上述命令后半部分<code>$GOPATH/src/google.golang.org/grpc</code>是指定将grpc-go代码库下载到特定目录。</p>
<h4 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h4><p>如果采用2.2.2中的clone方式下载安装，因为grpc-go库中调用了其他外部库内容，因此，需要额外准备相关的代码库环境。需要准备的库主要是golang.org包下的一些库。golang.org包下的库也可以从github上下载，然后放到对应的golang.org目录下。</p>
<h2 id="三、定义服务"><a href="#三、定义服务" class="headerlink" title="三、定义服务"></a>三、定义服务</h2><h3 id="编写protobuf文件"><a href="#编写protobuf文件" class="headerlink" title="编写protobuf文件"></a>编写protobuf文件</h3><p>我们想要实现的是通过gRPC框架进行远程服务调用，首先第一步应该是要有服务。利用之前所掌握的内容，gRPC框架支持对服务的定义和生成。<br>gRPC框架默认使用protocol buffers作为接口定义语言，用于描述网络传输消息结构。除此之外，还可以使用protobuf定义服务接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">package message;</span><br><span class="line">option go_package=&quot;./;message&quot;;</span><br><span class="line"></span><br><span class="line">//订单请求参数</span><br><span class="line">message OrderRequest &#123;</span><br><span class="line">    string orderId = 1;</span><br><span class="line">    int64 timeStamp = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//订单信息</span><br><span class="line">message OrderInfo &#123;</span><br><span class="line">    string OrderId = 1;</span><br><span class="line">    string OrderName = 2;</span><br><span class="line">    string OrderStatus = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//订单服务service定义</span><br><span class="line">service OrderService&#123;</span><br><span class="line">    rpc GetOrderInfo(OrderRequest) returns (OrderInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过proto文件定义了数据结构的同时，还定义了要实现的服务接口，GetOrderInfo即是具体服务接口的定义，在GetOrderInfo接口定义中，OrderRequest表示是请求传递的参数，OrderInfo表示处理结果返回数据参数。</p>
<h2 id="四、编译-proto文件"><a href="#四、编译-proto文件" class="headerlink" title="四、编译.proto文件"></a>四、编译.proto文件</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>定义的proto文件需要通过编译，生成go语言代码文件，供客户端程序和服务端程序使用。可以安装go语言环境中的关于proto的插件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -a github.com/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure>

<p>-a 参数标示下载好后直接做 <code>go install</code></p>
<h3 id="gRPC编译支持"><a href="#gRPC编译支持" class="headerlink" title="gRPC编译支持"></a>gRPC编译支持</h3><p>如果定义的.proto文件，如本案例中所示，定义中包含了服务接口的定义，而我们想要使用gRPC框架实现RPC调用。开发者可以采用protocol-gen-go库提供的插件编译功能，生成兼容gRPC框架的golang语言代码。只需要在基本编译命令的基础上，指定插件的参数，告知protoc编译器即可。具体的编译生成兼容gRPC框架的服务代码的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:. *.proto</span><br></pre></td></tr></table></figure>

<h2 id="gRPC实现RPC编程"><a href="#gRPC实现RPC编程" class="headerlink" title="gRPC实现RPC编程"></a>gRPC实现RPC编程</h2><h4 id="服务接口实现"><a href="#服务接口实现" class="headerlink" title="服务接口实现"></a>服务接口实现</h4><p>在.proto定义好服务接口并生成对应的go语言文件后，需要对服务接口做具体的实现。定义服务接口具体由OrderServiceImpl进行实现，并实现GetOrderInfo详细内容，服务实现逻辑与前文所述内容相同。不同点是服务接口参数的变化。详细代码实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体的方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(os *OrderServiceImpl)</span></span> GetOrderInfo(ctx context.Context, request *message.OrderRequest) (*message.OrderInfo, <span class="type">error</span>) &#123;</span><br><span class="line">	orderMap := <span class="keyword">map</span>[<span class="type">string</span>]message.OrderInfo&#123;</span><br><span class="line">		<span class="string">&quot;201907300001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907300001&quot;</span>, OrderName: <span class="string">&quot;衣服&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;201907310001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310001&quot;</span>, OrderName: <span class="string">&quot;零食&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;201907310002&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310002&quot;</span>, OrderName: <span class="string">&quot;食品&quot;</span>, OrderStatus: <span class="string">&quot;未付款&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> response *message.OrderInfo</span><br><span class="line">	current := time.Now().Unix()</span><br><span class="line">	<span class="keyword">if</span> (request.TimeStamp &gt; current) &#123;</span><br><span class="line">		*response = message.OrderInfo&#123;OrderId: <span class="string">&quot;0&quot;</span>, OrderName: <span class="string">&quot;&quot;</span>, OrderStatus: <span class="string">&quot;订单信息异常&quot;</span>&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		result := orderMap[request.OrderId]</span><br><span class="line">		<span class="keyword">if</span> result.OrderId != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			fmt.Println(result)</span><br><span class="line">			<span class="keyword">return</span> &amp;result, <span class="literal">nil</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;server error&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gRPC实现服务端"><a href="#gRPC实现服务端" class="headerlink" title="gRPC实现服务端"></a>gRPC实现服务端</h4><p>使用gRPC框架，首先实现服务端的程序。既然使用gRPC框架来实现，就需要调用gRPC进行服务方法的注册以及监听的处理。服务注册和监听处理实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个空的server对象</span></span><br><span class="line">	server := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将OrderServiceImpl对象注册到server中</span></span><br><span class="line">	message.RegisterOrderServiceServer(server, <span class="built_in">new</span>(OrderServiceImpl))</span><br><span class="line"></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提供RPC服务</span></span><br><span class="line">	server.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="gRPC实现客户端"><a href="#gRPC实现客户端" class="headerlink" title="gRPC实现客户端"></a>gRPC实现客户端</h4><p>实现完服务端以后，实现客户端程序。和服务端程序关系对应，调用gRPC框架的方法获取相应的客户端程序，并实现服务的调用，具体编程实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、Dail连接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:8090&quot;</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	orderServiceClient := message.NewOrderServiceClient(conn)</span><br><span class="line">	<span class="comment">// 创建一个请求对象</span></span><br><span class="line">	orderRequest := &amp;message.OrderRequest&#123;OrderId: <span class="string">&quot;201907300001&quot;</span>, TimeStamp: time.Now().Unix()&#125;</span><br><span class="line">	<span class="comment">// 使用orderServiceClient调用RPC服务</span></span><br><span class="line">	orderInfo, err := orderServiceClient.GetOrderInfo(context.Background(), orderRequest)</span><br><span class="line">	<span class="keyword">if</span> orderInfo != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(orderInfo.GetOrderId())</span><br><span class="line">		fmt.Println(orderInfo.GetOrderName())</span><br><span class="line">		fmt.Println(orderInfo.GetOrderStatus())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>gRPC调用</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/7gRPC%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<p>在gRPC框架中，诸如上一节我们学习的在客户端与服务端之间通过消息结构体定义的方式来传递数据，我们称之为“单项RPC”，也称之为简单模式。除此之外，gRPC中还有数据流模式的RPC调用实现，这正是我们本节课要学习的内容。</p>
<h2 id="一-服务端流-RPC"><a href="#一-服务端流-RPC" class="headerlink" title="一 服务端流 RPC"></a>一 服务端流 RPC</h2><p>在服务端流模式的RPC实现中，服务端得到客户端请求后，<code>处理结束返回一个数据应答流</code>。在发送完所有的客户端请求的应答数据后，服务端的状态详情和可选的跟踪元数据发送给客户端。服务端流RPC实现案例如下：</p>
<h3 id="1-1-服务接口定义"><a href="#1-1-服务接口定义" class="headerlink" title="1.1 服务接口定义"></a>1.1 服务接口定义</h3><p>在.proto文件中定义服务接口,使用服务端流模式定义服务接口,如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">//订单服务service定义</span><br><span class="line">service OrderService &#123;</span><br><span class="line">    rpc GetOrderInfos (OrderRequest) returns (stream OrderInfo) &#123;&#125;; //服务端流模式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到与之前简单模式下的数据作为服务接口的参数和返回值不同的是，此处服务接口的返回值使用了stream进行修饰。通过stream修饰的方式表示该接口调用时，服务端会以数据流的形式将数据返回给客户端。</p>
<h3 id="1-2-编译-proto文件，生成pb-go文件"><a href="#1-2-编译-proto文件，生成pb-go文件" class="headerlink" title="1.2 编译.proto文件，生成pb.go文件"></a>1.2 编译.proto文件，生成pb.go文件</h3><p>使用gRPC插件编译命令编译.proto文件，编译命令如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">protoc --go_out=plugins=grpc:. message.proto</span><br></pre></td></tr></table></figure>

<h3 id="1-3-自动生成文件的变化"><a href="#1-3-自动生成文件的变化" class="headerlink" title="1.3 自动生成文件的变化"></a>1.3 自动生成文件的变化</h3><p>与数据结构体发送携带数据实现不同的时，流模式下的数据发送和接收使用新的功能方法完成。在自动生成的go代码程序当中，每一个流模式对应的服务接口，都会自动生成对应的单独的client和server程序，以及对应的结构体实现。具体编程如下图所示：</p>
<h4 id="1-3-1-服务端自动生成"><a href="#1-3-1-服务端自动生成" class="headerlink" title="1.3.1 服务端自动生成"></a>1.3.1 服务端自动生成</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderService_GetOrderInfosServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*OrderInfo) <span class="type">error</span></span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> orderServiceGetOrderInfosServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceGetOrderInfosServer)</span></span> Send(m *OrderInfo) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x.ServerStream.SendMsg(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流模式下，服务接口的服务端提供Send方法，将数据以流的形式进行发送</p>
<h4 id="1-3-2-客户端自动生成"><a href="#1-3-2-客户端自动生成" class="headerlink" title="1.3.2 客户端自动生成"></a>1.3.2 客户端自动生成</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderService_GetOrderInfosClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Recv() (*OrderInfo, <span class="type">error</span>)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> orderServiceGetOrderInfosClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceGetOrderInfosClient)</span></span> Recv() (*OrderInfo, <span class="type">error</span>) &#123;</span><br><span class="line">	m := <span class="built_in">new</span>(OrderInfo)</span><br><span class="line">	<span class="keyword">if</span> err := x.ClientStream.RecvMsg(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流模式下，服务接口的客户端提供Recv()方法接收服务端发送的流数据。</p>
<h3 id="1-4-服务编码实现"><a href="#1-4-服务编码实现" class="headerlink" title="1.4 服务编码实现"></a>1.4 服务编码实现</h3><p>定义好服务接口并编译生成代码文件后，即可根据规则对定义的服务进行编码实现。具体的服务编码实现如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单服务实现</span></span><br><span class="line"><span class="keyword">type</span> OrderServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取订单信息s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(os *OrderServiceImpl)</span></span> GetOrderInfos(request *message.OrderRequest, stream message.OrderService_GetOrderInfosServer) <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot; 服务端流 RPC 模式&quot;</span>)</span><br><span class="line"></span><br><span class="line">	orderMap := <span class="keyword">map</span>[<span class="type">string</span>]message.OrderInfo&#123;</span><br><span class="line">		<span class="string">&quot;201907300001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907300001&quot;</span>, OrderName: <span class="string">&quot;衣服&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;201907310001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310001&quot;</span>, OrderName: <span class="string">&quot;零食&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;201907310002&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310002&quot;</span>, OrderName: <span class="string">&quot;食品&quot;</span>, OrderStatus: <span class="string">&quot;未付款&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> id, info := <span class="keyword">range</span> orderMap &#123;</span><br><span class="line">		<span class="keyword">if</span> (time.Now().Unix() &gt;= request.TimeStamp) &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;订单序列号ID：&quot;</span>, id)</span><br><span class="line">			fmt.Println(<span class="string">&quot;订单详情：&quot;</span>, info)</span><br><span class="line">			<span class="comment">//通过流模式发送给客户端</span></span><br><span class="line">			stream.Send(&amp;info)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetOrderInfos方法就是服务接口的具体实现，因为是流模式开发，服务端将数据以流的形式进行发送,因此，该方法的第二个参数类型为OrderService_GetOrderInfosServer，该参数类型是一个接口，其中包含Send方法，允许发送流数据。Send方法的具体实现在编译好的pb.go文件中，进一步调用grpc.SeverStream.SendMsg方法。</p>
<h3 id="1-5-服务的注册和监听的处理"><a href="#1-5-服务的注册和监听的处理" class="headerlink" title="1.5 服务的注册和监听的处理"></a>1.5 服务的注册和监听的处理</h3><p>服务的监听与处理与前文所学内容没有区别，依然是相同的步骤:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := grpc.NewServer()</span><br><span class="line">	<span class="comment">//注册</span></span><br><span class="line">	message.RegisterOrderServiceServer(server, <span class="built_in">new</span>(OrderServiceImpl))</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	server.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-客户端数据接收"><a href="#1-6-客户端数据接收" class="headerlink" title="1.6 客户端数据接收"></a>1.6 客户端数据接收</h3><p>服务端使用Send方法将数据以流的形式进行发送，客户端可以使用Recv()方法接收流数据,因为数据流失源源不断的，因此使用for无限循环实现数据流的读取，当读取到io.EOF时，表示流数据结束。客户端数据读取实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">		orderInfo, err := orderInfoClient.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;读取结束&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;读取到的信息：&quot;</span>, orderInfo)</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="1-7-运行结果"><a href="#1-7-运行结果" class="headerlink" title="1.7 运行结果"></a>1.7 运行结果</h3><p>按照先后顺序，依次运行server.go文件和client.go文件，可以得到运行结果。</p>
<h4 id="1-7-1-服务端运行结果"><a href="#1-7-1-服务端运行结果" class="headerlink" title="1.7.1 服务端运行结果"></a>1.7.1 服务端运行结果</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> 服务端流 RPC 模式</span><br><span class="line">订单序列号ID： <span class="number">201907300001</span></span><br><span class="line">订单详情： &#123;<span class="number">201907300001</span> 衣服 已付款 &#123;&#125; [] <span class="number">0</span>&#125;</span><br><span class="line">订单序列号ID： <span class="number">201907310001</span></span><br><span class="line">订单详情： &#123;<span class="number">201907310001</span> 零食 已付款 &#123;&#125; [] <span class="number">0</span>&#125;</span><br><span class="line">订单序列号ID： <span class="number">201907310002</span></span><br><span class="line">订单详情： &#123;<span class="number">201907310002</span> 食品 未付款 &#123;&#125; [] <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-7-2-客户端运行结果"><a href="#1-7-2-客户端运行结果" class="headerlink" title="1.7.2 客户端运行结果"></a>1.7.2 客户端运行结果</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">客户端请求RPC调用：服务端流模式</span><br><span class="line">读取到的信息： OrderId:<span class="string">&quot;201907310001&quot;</span> OrderName:<span class="string">&quot;\351\233\266\351\243\237&quot;</span> OrderStatus:<span class="string">&quot;\345\267\262\344\273\230\346\254\276&quot;</span> </span><br><span class="line">读取到的信息： OrderId:<span class="string">&quot;201907310002&quot;</span> OrderName:<span class="string">&quot;\351\243\237\345\223\201&quot;</span> OrderStatus:<span class="string">&quot;\346\234\252\344\273\230\346\254\276&quot;</span> </span><br><span class="line">读取到的信息： OrderId:<span class="string">&quot;201907300001&quot;</span> OrderName:<span class="string">&quot;\350\241\243\346\234\215&quot;</span> OrderStatus:<span class="string">&quot;\345\267\262\344\273\230\346\254\276&quot;</span> </span><br><span class="line">读取结束</span><br></pre></td></tr></table></figure>

<h2 id="二-客户端流模式"><a href="#二-客户端流模式" class="headerlink" title="二 客户端流模式"></a>二 客户端流模式</h2><p>上文演示的是服务端以数据流的形式返回数据的形式。对应的，也存在客户端以流的形式发送请求数据的形式。</p>
<h3 id="2-1-服务接口的定义"><a href="#2-1-服务接口的定义" class="headerlink" title="2.1 服务接口的定义"></a>2.1 服务接口的定义</h3><p>与服务端同理,客户端流模式的RPC服务声明格式，就是使用stream修饰服务接口的接收参数,具体如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">//订单服务service定义</span><br><span class="line">service OrderService &#123;</span><br><span class="line">    rpc AddOrderList (stream OrderRequest) returns (OrderInfo) &#123;&#125;; //客户端流模式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-编译-proto文件"><a href="#2-2-编译-proto文件" class="headerlink" title="2.2  编译.proto文件"></a>2.2  编译.proto文件</h3><p>使用编译命令编译.protow文件。客户端流模式中也会自动生成服务接口的接口。</p>
<h4 id="2-2-1-自动生成的服务流接口实现"><a href="#2-2-1-自动生成的服务流接口实现" class="headerlink" title="2.2.1 自动生成的服务流接口实现"></a>2.2.1 自动生成的服务流接口实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderService_AddOrderListServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	SendAndClose(*OrderInfo) <span class="type">error</span></span><br><span class="line">	Recv() (*OrderRequest, <span class="type">error</span>)</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> orderServiceAddOrderListServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceAddOrderListServer)</span></span> SendAndClose(m *OrderInfo) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x.ServerStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceAddOrderListServer)</span></span> Recv() (*OrderRequest, <span class="type">error</span>) &#123;</span><br><span class="line">	m := <span class="built_in">new</span>(OrderRequest)</span><br><span class="line">	<span class="keyword">if</span> err := x.ServerStream.RecvMsg(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SendAndClose和Recv方法是客户端流模式下的服务端对象所拥有的方法。</p>
<h4 id="2-2-2-自动生成的客户端流接口实现"><a href="#2-2-2-自动生成的客户端流接口实现" class="headerlink" title="2.2.2 自动生成的客户端流接口实现"></a>2.2.2 自动生成的客户端流接口实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderService_AddOrderListClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*OrderRequest) <span class="type">error</span></span><br><span class="line">	CloseAndRecv() (*OrderInfo, <span class="type">error</span>)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> orderServiceAddOrderListClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceAddOrderListClient)</span></span> Send(m *OrderRequest) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x.ClientStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceAddOrderListClient)</span></span> CloseAndRecv() (*OrderInfo, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> err := x.ClientStream.CloseSend(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	m := <span class="built_in">new</span>(OrderInfo)</span><br><span class="line">	<span class="keyword">if</span> err := x.ClientStream.RecvMsg(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Send和CloseAndRecv是客户端流模式下的客户端对象所拥有的方法。</p>
<h3 id="2-3-服务的实现"><a href="#2-3-服务的实现" class="headerlink" title="2.3 服务的实现"></a>2.3 服务的实现</h3><p>客户端流模式的服务接口具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单服务实现</span></span><br><span class="line"><span class="keyword">type</span> OrderServiceImpl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加订单信息服务实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(os *OrderServiceImpl)</span></span> AddOrderList(stream message.OrderService_AddOrderListServer) <span class="type">error</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot; 客户端流 RPC 模式&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">//从流中读取数据信息</span></span><br><span class="line">		orderRequest, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot; 读取数据结束 &quot;</span>)</span><br><span class="line">			result := message.OrderInfo&#123;OrderStatus: <span class="string">&quot; 读取数据结束 &quot;</span>&#125;</span><br><span class="line">			<span class="keyword">return</span> stream.SendAndClose(&amp;result)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//打印接收到的数据</span></span><br><span class="line">		fmt.Println(orderRequest)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-服务的注册和监听处理"><a href="#2-4-服务的注册和监听处理" class="headerlink" title="2.4 服务的注册和监听处理"></a>2.4 服务的注册和监听处理</h3><p>依然是采用相同的服务注册和监听处理方式对服务进行注册和监听处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	server := grpc.NewServer()</span><br><span class="line">	<span class="comment">//注册</span></span><br><span class="line">	message.RegisterOrderServiceServer(server, <span class="built_in">new</span>(OrderServiceImpl))</span><br><span class="line"></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	server.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-客户端实现"><a href="#2-5-客户端实现" class="headerlink" title="2.5 客户端实现"></a>2.5 客户端实现</h3><p>客户端调用send方法流数据到服务端，具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//调用服务方法</span></span><br><span class="line">	addOrderListClient, err := orderServiceClient.AddOrderList(context.Background())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//调用方法发送流数据</span></span><br><span class="line">	<span class="keyword">for</span> _, info := <span class="keyword">range</span> orderMap &#123;</span><br><span class="line">		err = addOrderListClient.Send(&amp;info)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		orderInfo, err := addOrderListClient.CloseAndRecv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot; 读取数据结束了 &quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(orderInfo.GetOrderStatus())</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-程序运行"><a href="#2-6-程序运行" class="headerlink" title="2.6 程序运行"></a>2.6 程序运行</h3><h4 id="2-6-1-服务端"><a href="#2-6-1-服务端" class="headerlink" title="2.6.1 服务端"></a>2.6.1 服务端</h4><p>运行案例，程序输出如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> 客户端流 RPC 模式</span><br><span class="line"><span class="number">201907300001</span> 衣服 已付款</span><br><span class="line"><span class="number">201907310001</span> 零食 已付款</span><br><span class="line"><span class="number">201907310002</span> 食品 未付款</span><br><span class="line"> 读取数据结束 </span><br><span class="line"> 客户端流 RPC 模式</span><br><span class="line"><span class="number">201907300001</span> 衣服 已付款</span><br><span class="line"><span class="number">201907310001</span> 零食 已付款</span><br><span class="line"><span class="number">201907310002</span> 食品 未付款</span><br><span class="line"> 读取数据结束 </span><br></pre></td></tr></table></figure>

<h4 id="2-6-2-客户端"><a href="#2-6-2-客户端" class="headerlink" title="2.6.2 客户端"></a>2.6.2 客户端</h4><p>客户端运行程序输出如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">客户端请求RPC调用：客户端流模式</span><br><span class="line"> 读取数据结束 </span><br><span class="line"> 读取数据结束了 </span><br></pre></td></tr></table></figure>

<h2 id="三-双向流模式"><a href="#三-双向流模式" class="headerlink" title="三 双向流模式"></a>三 双向流模式</h2><p>上文已经讲过了服务端流模式和客户端流模式。如果将客户端和服务端两种流模式结合起来,就是第三种模式，双向流模式。即客户端发送数据的时候以流数据发送，服务端返回数据也以流的形式进行发送，因此称之为双向流模式。</p>
<h3 id="3-1-双向流服务的定义"><a href="#3-1-双向流服务的定义" class="headerlink" title="3.1 双向流服务的定义"></a>3.1 双向流服务的定义</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//订单服务service定义</span></span><br><span class="line">service OrderService &#123;</span><br><span class="line">    rpc GetOrderInfos (stream OrderRequest) returns (stream OrderInfo) &#123;&#125;; <span class="comment">//双向流模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-编译-proto文件"><a href="#3-2-编译-proto文件" class="headerlink" title="3.2 编译.proto文件"></a>3.2 编译.proto文件</h3><h4 id="3-2-1-服务端接口实现"><a href="#3-2-1-服务端接口实现" class="headerlink" title="3.2.1 服务端接口实现"></a>3.2.1 服务端接口实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderService_GetOrderInfosServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*OrderInfo) <span class="type">error</span></span><br><span class="line">	Recv() (*OrderRequest, <span class="type">error</span>)</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> orderServiceGetOrderInfosServer <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ServerStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceGetOrderInfosServer)</span></span> Send(m *OrderInfo) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x.ServerStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceGetOrderInfosServer)</span></span> Recv() (*OrderRequest, <span class="type">error</span>) &#123;</span><br><span class="line">	m := <span class="built_in">new</span>(OrderRequest)</span><br><span class="line">	<span class="keyword">if</span> err := x.ServerStream.RecvMsg(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-客户端接口实现"><a href="#3-2-2-客户端接口实现" class="headerlink" title="3.2.2 客户端接口实现"></a>3.2.2 客户端接口实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> OrderService_GetOrderInfosClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	Send(*OrderRequest) <span class="type">error</span></span><br><span class="line">	Recv() (*OrderInfo, <span class="type">error</span>)</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> orderServiceGetOrderInfosClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	grpc.ClientStream</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceGetOrderInfosClient)</span></span> Send(m *OrderRequest) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> x.ClientStream.SendMsg(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *orderServiceGetOrderInfosClient)</span></span> Recv() (*OrderInfo, <span class="type">error</span>) &#123;</span><br><span class="line">	m := <span class="built_in">new</span>(OrderInfo)</span><br><span class="line">	<span class="keyword">if</span> err := x.ClientStream.RecvMsg(m); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-服务实现"><a href="#3-3-服务实现" class="headerlink" title="3.3 服务实现"></a>3.3 服务实现</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现grpc双向流模式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(os *OrderServiceImpl)</span></span> GetOrderInfos(stream message.OrderService_GetOrderInfosServer) <span class="type">error</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		orderRequest, err := stream.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot; 数据读取结束 &quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fmt.Println(orderRequest.GetOrderId())</span><br><span class="line">		orderMap := <span class="keyword">map</span>[<span class="type">string</span>]message.OrderInfo&#123;</span><br><span class="line">			<span class="string">&quot;201907300001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907300001&quot;</span>, OrderName: <span class="string">&quot;衣服&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">			<span class="string">&quot;201907310001&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310001&quot;</span>, OrderName: <span class="string">&quot;零食&quot;</span>, OrderStatus: <span class="string">&quot;已付款&quot;</span>&#125;,</span><br><span class="line">			<span class="string">&quot;201907310002&quot;</span>: message.OrderInfo&#123;OrderId: <span class="string">&quot;201907310002&quot;</span>, OrderName: <span class="string">&quot;食品&quot;</span>, OrderStatus: <span class="string">&quot;未付款&quot;</span>&#125;,</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		result := orderMap[orderRequest.GetOrderId()]</span><br><span class="line">		<span class="comment">//发送数据</span></span><br><span class="line">		err = stream.Send(&amp;result)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err.Error())</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-服务端及客户端的编程实现"><a href="#3-4-服务端及客户端的编程实现" class="headerlink" title="3.4 服务端及客户端的编程实现"></a>3.4 服务端及客户端的编程实现</h3><h4 id="3-4-1-服务端实现"><a href="#3-4-1-服务端实现" class="headerlink" title="3.4.1 服务端实现"></a>3.4.1 服务端实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	server := grpc.NewServer()</span><br><span class="line">	<span class="comment">//注册</span></span><br><span class="line">	message.RegisterOrderServiceServer(server, <span class="built_in">new</span>(OrderServiceImpl))</span><br><span class="line"></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8092&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	server.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-2-客户端实现"><a href="#3-4-2-客户端实现" class="headerlink" title="3.4.2 客户端实现"></a>3.4.2 客户端实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1、Dail连接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:8092&quot;</span>, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	orderServiceClient := message.NewOrderServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">&quot;客户端请求RPC调用：双向流模式&quot;</span>)</span><br><span class="line">	orderIDs := []<span class="type">string</span>&#123;<span class="string">&quot;201907300001&quot;</span>, <span class="string">&quot;201907310001&quot;</span>, <span class="string">&quot;201907310002&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">	orderInfoClient, err := orderServiceClient.GetOrderInfos(context.Background())</span><br><span class="line">	<span class="keyword">for</span> _, orderID := <span class="keyword">range</span> orderIDs &#123;</span><br><span class="line">		orderRequest := message.OrderRequest&#123;OrderId: orderID&#125;</span><br><span class="line">		err := orderInfoClient.Send(&amp;orderRequest)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="built_in">panic</span>(err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//关闭</span></span><br><span class="line">	orderInfoClient.CloseSend()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		orderInfo, err := orderInfoClient.Recv()</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;读取结束&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">&quot;读取到的信息：&quot;</span>, orderInfo)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL索引的使用</title>
    <url>/2022/11/02/MySQL/10mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p>
<h3 id="验证索引提升查询效率"><a href="#验证索引提升查询效率" class="headerlink" title="验证索引提升查询效率"></a>验证索引提升查询效率</h3><p>在我们准备的表结构tb_item 中， 一共存储了 300 万记录；</p>
<p>A. 根据ID查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1999</span>\G;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/f05812e124dc40b89cc6b9e4b6a586a5.png" alt="在这里插入图片描述"></p>
<p>查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；</p>
<p><img src="https://img-blog.csdnimg.cn/c3a25dee32114517874be08776c762e9.png" alt="在这里插入图片描述"></p>
<p>2). 根据 title 进行精确查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;iphoneX 移动3G 32G941&#x27;</span>\G; </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/6974e1f0be534863b29a4586f8c64744.png" alt="在这里插入图片描述"></p>
<p>查看SQL语句的执行计划 ：</p>
<p>处理方案 ， 针对title字段， 创建索引 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_item_title <span class="keyword">on</span> tb_item(title);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/b7db522e1ae14c8a86edfc31d2f7cf69.png" alt="在这里插入图片描述"></p>
<p>索引创建完成之后，再次进行查询 ：</p>
<p><img src="https://img-blog.csdnimg.cn/c103876f87bf44deacd08f0f4dfb87d2.png" alt="在这里插入图片描述"></p>
<p>通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引</p>
<p><img src="https://img-blog.csdnimg.cn/89b80b6809cd4ad2b42835b40a85d8be.png" alt="在这里插入图片描述"></p>
<h3 id="索引的使用-1"><a href="#索引的使用-1" class="headerlink" title="索引的使用"></a>索引的使用</h3><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_seller` (</span><br><span class="line">	`sellerid` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">	`name` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">	`nickname` <span class="type">varchar</span> (<span class="number">50</span>),</span><br><span class="line">	`password` <span class="type">varchar</span> (<span class="number">60</span>),</span><br><span class="line">	`status` <span class="type">varchar</span> (<span class="number">1</span>),</span><br><span class="line">	`address` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">	`createtime` datetime,</span><br><span class="line">    <span class="keyword">primary</span> key(`sellerid`)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;alibaba&#x27;</span>,<span class="string">&#x27;阿里巴巴&#x27;</span>,<span class="string">&#x27;阿里小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;baidu&#x27;</span>,<span class="string">&#x27;百度科技有限公司&#x27;</span>,<span class="string">&#x27;百度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;huawei&#x27;</span>,<span class="string">&#x27;华为科技有限公司&#x27;</span>,<span class="string">&#x27;华为小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;luoji&#x27;</span>,<span class="string">&#x27;罗技科技有限公司&#x27;</span>,<span class="string">&#x27;罗技小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;ourpalm&#x27;</span>,<span class="string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="string">&#x27;掌趣小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;qiandu&#x27;</span>,<span class="string">&#x27;千度科技&#x27;</span>,<span class="string">&#x27;千度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;sina&#x27;</span>,<span class="string">&#x27;新浪科技有限公司&#x27;</span>,<span class="string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;小米科技&#x27;</span>,<span class="string">&#x27;小米官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;西安市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;yijia&#x27;</span>,<span class="string">&#x27;宜家家居&#x27;</span>,<span class="string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(name,status,address);</span><br></pre></td></tr></table></figure>

<h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><p>1). <code>全值匹配 ，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/3efadc0d81dc4cff8c442b0d5aae412d.png" alt="在这里插入图片描述"></p>
<p>2). 最左前缀法则</p>
<p><code>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</code>(想象爬楼梯)</p>
<p>匹配最左前缀法则，走索引：</p>
<p><img src="https://img-blog.csdnimg.cn/67c86c663ba84c7d9cb54c5f518a4170.png" alt="在这里插入图片描述"></p>
<p>违法最左前缀法则 ， 索引失效：</p>
<p><img src="https://img-blog.csdnimg.cn/3801af2744644df68f8ea76b8bf592b1.png" alt="在这里插入图片描述"></p>
<p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p>
<p><img src="https://img-blog.csdnimg.cn/1b01ac22360f401d972546526d14cecc.png" alt="在这里插入图片描述"></p>
<p>3). <code>范围查询右边的列，不能使用索引 。范围查询条件之后的字段，索引失效</code></p>
<p><img src="https://img-blog.csdnimg.cn/0343191d276d4b5d8c245904012a193d.png" alt="在这里插入图片描述"></p>
<p>根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p>
<p>4). <code>不要在索引列上进行运算操作， 索引将失效。</code><br><img src="https://img-blog.csdnimg.cn/5aa3c99d0aeb40f384b128b29378b0dd.png" alt="在这里插入图片描述"></p>
<p>5). <code>字符串不加单引号，造成索引失效。</code></p>
<p><img src="https://img-blog.csdnimg.cn/0da47d48dd004a8da9c2e3c6514e5383.png" alt="在这里插入图片描述"></p>
<p>由于，在查询是，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p>
<p>6). <code>尽量使用覆盖索引，避免select *</code></p>
<p><code>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</code></p>
<p><img src="https://img-blog.csdnimg.cn/ba0bc22a3ffa4a4a83c4dd790052c972.png" alt="在这里插入图片描述"></p>
<p>如果查询列，超出索引列，也会降低性能。(索引列没有password，所以需要回表查询)</p>
<p><img src="https://img-blog.csdnimg.cn/194aeb3ba20b4132a58fcd3f1f1c2296.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TIP : </span><br><span class="line">	</span><br><span class="line"><span class="keyword">using</span> index ：使用覆盖索引的时候就会出现</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">where</span>：在查找使用索引的情况下，需要回表去查询所需的数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> index <span class="keyword">condition</span>：查找使用了索引，但是需要回表查询数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> index ; <span class="keyword">using</span> <span class="keyword">where</span>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</span><br></pre></td></tr></table></figure>

<p>7). <code>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</code></p>
<p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;黑马程序员&#x27;</span> <span class="keyword">or</span> createtime <span class="operator">=</span> <span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>\G;	</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/b6bc511bc2ec4230bca06ee6cc38c0bd.png" alt="在这里插入图片描述"></p>
<p>8). <code>以%开头的Like模糊查询，索引失效。</code></p>
<p><code>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</code></p>
<p><img src="https://img-blog.csdnimg.cn/ee716b9f8227450480810127fdc61b0b.png" alt="在这里插入图片描述"></p>
<p><strong>解决方案 ：通过覆盖索引来解决</strong></p>
<p><img src="https://img-blog.csdnimg.cn/30edba5a206b4aeda51425829b7e3111.png" alt="在这里插入图片描述"></p>
<p>9). <code>如果MySQL评估使用索引比全表更慢，则不使用索引。</code></p>
<p><img src="https://img-blog.csdnimg.cn/80bbe93c14a748dca32ab7bc24d29ba9.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>明明单独创建了address索引，但是explain查看没有使用索引，这种情况跟表中数据有关，查看表数据知道，12条数据，11条是’北京市’，使用索引查找效率不如直接全表扫描来的快，所以在执行SQL语句的时候，MySQL放弃使用索引，而使用全表扫描。</p>
</blockquote>
<p>10). is NULL ， is NOT NULL <code>有时</code>索引失效。</p>
<p><img src="https://img-blog.csdnimg.cn/baad2c511f454a4dad6496634acb9067.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>MySQL底层会自动判断，如果全表扫描快，则直接使用全表扫描，不走索引。如果表中该索引列数据绝大多数是非空值，则使用is not null的时候走索引，使用is null的时候不走索引（还不如全表扫描快），全表扫描；反之亦然。</p>
</blockquote>
<p>11). <code>in 走索引， not in 索引失效。</code></p>
<p><img src="https://img-blog.csdnimg.cn/e927e8c98a4a4fdcbef794fd17d1a6c6.png" alt="在这里插入图片描述"></p>
<p>12). <code>单列索引和复合索引。</code></p>
<p><code>尽量使用复合索引，而少使用单列索引 。</code></p>
<p>创建复合索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_name_sta_address <span class="keyword">on</span> tb_seller(name, status, address);</span><br><span class="line"></span><br><span class="line">就相当于创建了三个索引 ： </span><br><span class="line">	name</span><br><span class="line">	name <span class="operator">+</span> status</span><br><span class="line">	name <span class="operator">+</span> status <span class="operator">+</span> address</span><br></pre></td></tr></table></figure>

<p>创建单列索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name <span class="keyword">on</span> tb_seller(name);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_status <span class="keyword">on</span> tb_seller(status);</span><br><span class="line"><span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用单列索引的时候，数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p>
</blockquote>
<h3 id="查看索引使用情况"><a href="#查看索引使用情况" class="headerlink" title="查看索引使用情况"></a>查看索引使用情况</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;	 <span class="comment">-- 查看当前会话索引使用情况</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Handler_read%&#x27;</span>;	<span class="comment">-- 查看全局索引使用情况</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/510ae43773764ea185e731d8ece2919f.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。</span><br><span class="line"></span><br><span class="line">Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。</span><br><span class="line"></span><br><span class="line">Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</span><br><span class="line"></span><br><span class="line">Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化<span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">DESC</span>。</span><br><span class="line"></span><br><span class="line">Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。</span><br><span class="line"></span><br><span class="line">Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL存储引擎</title>
    <url>/2022/11/02/MySQL/11mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h3 id="存储引擎特性"><a href="#存储引擎特性" class="headerlink" title="存储引擎特性"></a>存储引擎特性</h3><p> 和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。</p>
<p><code>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。</code></p>
<p> Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</p>
<p> MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。</p>
<p>可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ：</p>
<p><img src="https://img-blog.csdnimg.cn/5f76dde7b5da4e5fae4ad44f2182804d.png" alt="在这里插入图片描述"></p>
<p>创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。</p>
<p>查看Mysql数据库默认的存储引擎 ， 指令 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span> ；</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/038fe689d71b47fab7df6fa5c263997f.png" alt="在这里插入图片描述"></p>
<h3 id="各种储存引擎特性"><a href="#各种储存引擎特性" class="headerlink" title="各种储存引擎特性"></a>各种储存引擎特性</h3><p>下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ：</p>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>MEMORY</th>
<th>MERGE</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td><code>支持</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td><code>行锁(适合高并发)</code></td>
<td><code>表锁</code></td>
<td>表锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据索引</td>
<td>支持</td>
<td></td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N&#x2F;A</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td><code>支持</code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。</p>
<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p> InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
<p>InnoDB存储引擎不同于其他存储引擎的特点 ：</p>
<p><strong>事务控制</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_innodb(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>innodb <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_innodb(id,name)<span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Meta20&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/d0af26c064a845f389a812c105da4374.png" alt="在这里插入图片描述"></p>
<p>测试，发现在InnoDB中是存在事务的 ；</p>
<p><strong>外键约束</strong></p>
<p> MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p>
<p> 下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> country_innodb(</span><br><span class="line">	country_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    country_name <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(country_id)</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> city_innodb(</span><br><span class="line">	city_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    city_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    country_id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(city_id),</span><br><span class="line">    key idx_fk_country_id(country_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> `fk_city_country` <span class="keyword">FOREIGN</span> KEY(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line">)ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ON DELETE RESTRICT:删除主表，如果有关联记录，不删除</span></span><br><span class="line"><span class="comment">-- ON UPDATE CASCADE:更新主表，如果子表有关联记录，更新子表记录</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> country_innodb <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;China&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;America&#x27;</span>),(<span class="keyword">null</span>,<span class="string">&#x27;Japan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> city_innodb <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Xian&#x27;</span>,<span class="number">1</span>),(<span class="keyword">null</span>,<span class="string">&#x27;NewYork&#x27;</span>,<span class="number">2</span>),(<span class="keyword">null</span>,<span class="string">&#x27;BeiJing&#x27;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>


<p>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。</p>
<p>RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；</p>
<p>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；</p>
<p>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</p>
<p>针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</p>
<p>表中数据如下图所示 ：</p>
<p><img src="https://img-blog.csdnimg.cn/7f773bca935c4977938b9a8e445c62e4.png" alt="在这里插入图片描述"></p>
<p>外键信息可以使用如下两种方式查看 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> city_innodb ;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/bde8189c2c834c85acad7901f56b82db.png" alt="在这里插入图片描述"><br>删除country_id为1 的country数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> country_innodb <span class="keyword">where</span> country_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/6022a234cae34487b3af38161d185f3b.png" alt="在这里插入图片描述"><br>更新主表country表的字段 country_id :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> country_innodb <span class="keyword">set</span> country_id <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> country_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/e923f594f5604b4e94255c4486ccd34c.png" alt="在这里插入图片描述"><br>更新后， 子表的数据信息为 ：</p>
<p><img src="https://img-blog.csdnimg.cn/c1f0b2d942a840cbb6f76e4cd23d08ed.png" alt="在这里插入图片描述"></p>
<p><strong>存储方式</strong></p>
<p>InnoDB 存储表和索引有以下两种方式 ：</p>
<p>①. 使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</p>
<p>②. 使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。</p>
<p><img src="https://img-blog.csdnimg.cn/2e5a6095cf254bdda236dd74b45bd2f3.png" alt="在这里插入图片描述"></p>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><blockquote>
<p>MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点：</p>
</blockquote>
<p><strong>不支持事务</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_myisam(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">primary</span> key(id)</span><br><span class="line">)ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/7269d7c06073478ba9b3af8506eed0a0.png" alt="在这里插入图片描述"></p>
<p>通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ；</p>
<p><strong>文件存储方式</strong></p>
<blockquote>
<p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ：</p>
<p>.frm (存储表定义)；</p>
<p>.MYD(MYData , 存储数据)；</p>
<p>.MYI(MYIndex , 存储索引)；</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/5512c2791bc645f4bdb263257b3f6775.png" alt="在这里插入图片描述"></p>
<h4 id="MEMORY"><a href="#MEMORY" class="headerlink" title="MEMORY"></a>MEMORY</h4><blockquote>
<p>Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p>
</blockquote>
<h4 id="MERGE"><a href="#MERGE" class="headerlink" title="MERGE"></a>MERGE</h4><blockquote>
<p>MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p>
</blockquote>
<p> 对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。</p>
<p> 可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。</p>
<p><img src="https://img-blog.csdnimg.cn/a815ccb496b34951ac0421d75c605000.png" alt="在这里插入图片描述"><br>下面是一个创建和使用MERGE表的示例 ：</p>
<p>1）创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_1990(</span><br><span class="line">	order_id <span class="type">int</span> ,</span><br><span class="line">	order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">	<span class="keyword">primary</span> key (order_id)</span><br><span class="line">)engine <span class="operator">=</span> myisam <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_1991(</span><br><span class="line">	order_id <span class="type">int</span> ,</span><br><span class="line">	order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">	<span class="keyword">primary</span> key (order_id)</span><br><span class="line">)engine <span class="operator">=</span> myisam <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_all(</span><br><span class="line">	order_id <span class="type">int</span> ,</span><br><span class="line">	order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">	<span class="keyword">primary</span> key (order_id)</span><br><span class="line">)engine <span class="operator">=</span> <span class="keyword">merge</span> <span class="keyword">union</span> <span class="operator">=</span> (order_1990,order_1991) INSERT_METHOD<span class="operator">=</span><span class="keyword">LAST</span> <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<p>2）分别向两张表中插入记录</p>
<p>order_1990中的数据 ：</p>
<p><img src="https://img-blog.csdnimg.cn/da89c5bc21354edfadb52c95aed567d2.png" alt="在这里插入图片描述"><br>order_1991中的数据 ：</p>
<p><img src="https://img-blog.csdnimg.cn/14f35a0cf1fa4e5f94ecf58c987bbd67.png" alt="在这里插入图片描述"><br>order_all中的数据 ：</p>
<p><img src="https://img-blog.csdnimg.cn/51e6025dfa034a5a9661b46dfbb00308.png" alt="在这里插入图片描述"></p>
<p>4）往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_all <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">10000.0</span>,<span class="string">&#x27;西安&#x27;</span>)；</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/008681d2e57e4cf99804ca4fae0a16ce.png" alt="在这里插入图片描述"></p>
<h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><p> 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p>
<ul>
<li>InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li>
<li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li>
<li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>TLS验证、Token认证和拦截器</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/8TLS%E9%AA%8C%E8%AF%81%E3%80%81Token%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、授权认证"><a href="#一、授权认证" class="headerlink" title="一、授权认证"></a>一、授权认证</h2><p>gRPC中默认支持两种授权方式,分别是：SSL&#x2F;TLS认证方式、基于Token的认证方式。</p>
<h3 id="1-1-SSL-x2F-TLS认证方式"><a href="#1-1-SSL-x2F-TLS认证方式" class="headerlink" title="1.1 SSL&#x2F;TLS认证方式"></a>1.1 SSL&#x2F;TLS认证方式</h3><p>SSL全称是Secure Sockets Layer，又被称之为安全套接字层，是一种标准安全协议，用于在通信过程中建立客户端与服务器之间的加密链接。<br>TLS的全称是Transport Layer Security，TLS是SSL的升级版。在使用的过程中，往往习惯于将SSL和TLS组合在一起写作SSL&#x2F;TLS。<br>简而言之，SSL&#x2F;TLS是一种用于网络通信中加密的安全协议。</p>
<h4 id="1-1-1-SSL-x2F-TLS工作原理"><a href="#1-1-1-SSL-x2F-TLS工作原理" class="headerlink" title="1.1.1 SSL&#x2F;TLS工作原理"></a>1.1.1 SSL&#x2F;TLS工作原理</h4><p>使用SSL&#x2F;TLS协议对通信连接进行安全加密，是通过非对称加密的方式来实现的。所谓非对称加密方式又称之为公钥加密，密钥对由公钥和私钥两种密钥组成。私钥和公钥成对存在，先生成私钥，通过私钥生成对应的公钥。公钥可以公开，私钥进行妥善保存。</p>
<p>在加密过程中：客户端想要向服务器发起链接，首先会先向服务端请求要加密的公钥。获取到公钥后客户端使用公钥将信息进行加密，服务端接收到加密信息，使用私钥对信息进行解密并进行其他后续处理，完成整个信道加密并实现数据传输的过程。</p>
<h4 id="1-1-2-制作证书"><a href="#1-1-2-制作证书" class="headerlink" title="1.1.2 制作证书"></a>1.1.2 制作证书</h4><p>可以自己在本机计算机上安装openssl，并生成相应的证书。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl ecparam -genkey -name secp384r1 -out server.key</span><br><span class="line">openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-编程实现服务端"><a href="#1-1-3-编程实现服务端" class="headerlink" title="1.1.3 编程实现服务端"></a>1.1.3 编程实现服务端</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MathManager <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mm *MathManager)</span></span> AddMethod(ctx context.Context, request *message.RequestArgs) (response *message.Response, err <span class="type">error</span>) &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot; 服务端 Add方法 &quot;</span>)</span><br><span class="line">	result := request.Args1 + request.Args2</span><br><span class="line">	fmt.Println(<span class="string">&quot; 计算结果是：&quot;</span>, result)</span><br><span class="line">	response = <span class="built_in">new</span>(message.Response)</span><br><span class="line">	response.Code = <span class="number">1</span>;</span><br><span class="line">	response.Message = <span class="string">&quot;执行成功&quot;</span></span><br><span class="line">	<span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//TLS认证</span></span><br><span class="line">	creds, err := credentials.NewServerTLSFromFile(<span class="string">&quot;./keys/server.pem&quot;</span>, <span class="string">&quot;./keys/server.key&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatal(<span class="string">&quot;加载证书文件失败&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//实例化grpc server, 开启TLS认证</span></span><br><span class="line">	server := grpc.NewServer(grpc.Creds(creds))</span><br><span class="line"></span><br><span class="line">	message.RegisterMathServiceServer(server, <span class="built_in">new</span>(MathManager))</span><br><span class="line"></span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8092&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	server.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-编程实现客户端"><a href="#1-1-3-编程实现客户端" class="headerlink" title="1.1.3 编程实现客户端"></a>1.1.3 编程实现客户端</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//TLS连接</span></span><br><span class="line">	creds, err := credentials.NewClientTLSFromFile(<span class="string">&quot;./keys/server.pem&quot;</span>, <span class="string">&quot;go-grpc-example&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1、Dail连接</span></span><br><span class="line">	conn, err := grpc.Dial(<span class="string">&quot;localhost:8092&quot;</span>, grpc.WithTransportCredentials(creds))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	serviceClient := message.NewMathServiceClient(conn)</span><br><span class="line"></span><br><span class="line">	addArgs := message.RequestArgs&#123;Args1: <span class="number">3</span>, Args2: <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">	response, err := serviceClient.AddMethod(context.Background(), &amp;addArgs)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		grpclog.Fatal(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(response.GetCode(), response.GetMessage())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-基于Token认证方式"><a href="#1-2-基于Token认证方式" class="headerlink" title="1.2 基于Token认证方式"></a>1.2 基于Token认证方式</h3><h4 id="1-2-1-Token认证介绍"><a href="#1-2-1-Token认证介绍" class="headerlink" title="1.2.1 Token认证介绍"></a>1.2.1 Token认证介绍</h4><p>在web应用的开发过程中，我们往往还会使用另外一种认证方式进行身份验证，那就是：Token认证。基于Token的身份验证是无状态，不需要将用户信息服务存在服务器或者session中。</p>
<h4 id="1-2-2-Token认证过程"><a href="#1-2-2-Token认证过程" class="headerlink" title="1.2.2 Token认证过程"></a>1.2.2 Token认证过程</h4><p>基于Token认证的身份验证主要过程是：客户端在发送请求前，首先向服务器发起请求，服务器返回一个生成的token给客户端。客户端将token保存下来，用于后续每次请求时，携带着token参数。服务端在进行处理请求之前，会首先对token进行验证，只有token验证成功了，才会处理并返回相关的数据。</p>
<h4 id="1-2-3-gRPC的自定义Token认证"><a href="#1-2-3-gRPC的自定义Token认证" class="headerlink" title="1.2.3 gRPC的自定义Token认证"></a>1.2.3 gRPC的自定义Token认证</h4><p>在gRPC中，允许开发者自定义自己的认证规则，通过</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">grpc.WithPerRPCCredentials()</span><br></pre></td></tr></table></figure>

<p>设置自定义的认证规则。WithPerRPCCredentials方法接收一个PerRPCCredentials类型的参数，进一步查看可以知道PerRPCCredentials是一个接口，定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PerRPCCredentials <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetRequestMetadata(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">    RequireTransportSecurity() <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，开发者可以实现以上接口，来定义自己的token信息。</p>
<p>在本案例中，我们自定义的token认证结构体如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//token认证</span></span><br><span class="line"><span class="keyword">type</span> TokenAuthentication <span class="keyword">struct</span> &#123;</span><br><span class="line">	AppKey    <span class="type">string</span></span><br><span class="line">	AppSecret <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//组织token信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ta *TokenAuthentication)</span></span> GetRequestMetaData(ctx context.Context, uri ...<span class="type">string</span>) (<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;appid&quot;</span>:    ta.AppKey,</span><br><span class="line">		<span class="string">&quot;appkey&quot;</span>: ta.AppSecret,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否基于TLS认证进行安全传输</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *TokenAuthentication)</span></span> RequireTransportSecurity() <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，GetRequestMetaData方法中的appid和appkey字段均需要保持小写，不能大写。RequireTransportSecurity方法用于设置是否基于tls认证进行安全传输。</p>
<p>在客户端进行连接时，我们将自定义的token认证信息作为参数进行传入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">auth := TokenAuthentication&#123;</span><br><span class="line">		AppKey:    <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">		AppSecret: <span class="string">&quot;20190812&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost:8093&quot;</span>, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(&amp;auth))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-服务端"><a href="#1-2-4-服务端" class="headerlink" title="1.2.4 服务端"></a>1.2.4 服务端</h4><p>在服务端的调用方法中实现对token请求参数的判断，可以通过metadata获取token认证信息。具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mm *MathManager)</span></span> AddMethod(ctx context.Context, request *message.RequestArgs) (response *message.Response, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过metadata</span></span><br><span class="line">	md, exist := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !exist &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unauthenticated, <span class="string">&quot;无Token认证信息&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> appKey <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> appSecret <span class="type">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> key, ok := md[<span class="string">&quot;appid&quot;</span>]; ok &#123;</span><br><span class="line">		appKey = key[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> secret, ok := md[<span class="string">&quot;appkey&quot;</span>]; ok &#123;</span><br><span class="line">		appSecret = secret[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> appKey != <span class="string">&quot;hello&quot;</span> || appSecret != <span class="string">&quot;20190812&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unauthenticated, <span class="string">&quot;Token 不合法&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot; 服务端 Add方法 &quot;</span>)</span><br><span class="line">	result := request.Args1 + request.Args2</span><br><span class="line">	fmt.Println(<span class="string">&quot; 计算结果是：&quot;</span>, result)</span><br><span class="line">	response = <span class="built_in">new</span>(message.Response)</span><br><span class="line">	response.Code = <span class="number">1</span>;</span><br><span class="line">	response.Message = <span class="string">&quot;执行成功&quot;</span></span><br><span class="line">	<span class="keyword">return</span> response, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，运行项目，token认证成功。客户端修改token信息，再次运行，会发现提示token不合法。</p>
<h2 id="二、拦截器"><a href="#二、拦截器" class="headerlink" title="二、拦截器"></a>二、拦截器</h2><p>在服务端的方法中，每个方法都要进行token的判断。程序效率太低，可以优化一下处理逻辑，在调用服务端的具体方法之前，先进行拦截，并进行token验证判断，这种方式称之为拦截器处理。</p>
<h3 id="2-2-Interceptor"><a href="#2-2-Interceptor" class="headerlink" title="2.2 Interceptor"></a>2.2 Interceptor</h3><p>使用拦截器，首先需要注册。<br>在grpc中编程实现中，可以在NewSever时添加拦截器设置，grpc框架中可以通过UnaryInterceptor方法设置自定义的拦截器，并返回ServerOption。具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">grpc.UnaryInterceptor()</span><br></pre></td></tr></table></figure>

<p>UnaryInterceptor()接收一个UnaryServerInterceptor类型，继续查看源码定义，可以发现UnaryServerInterceptor是一个func，定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryServerInterceptor <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *UnaryServerInfo, handler UnaryHandler)</span></span> (resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<p>通过以上代码，如果开发者需要注册自定义拦截器，需要自定义实现UnaryServerInterceptor的定义。</p>
<h3 id="2-3-自定义UnaryServerInterceptor"><a href="#2-3-自定义UnaryServerInterceptor" class="headerlink" title="2.3 自定义UnaryServerInterceptor"></a>2.3 自定义UnaryServerInterceptor</h3><p>接下来就自定义实现func,符合UnaryServerInterceptor的标准，在该func的定义中实现对token的验证逻辑。自定义实现func如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TokenInterceptor</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler)</span></span> (resp <span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过metadata</span></span><br><span class="line">	md, exist := metadata.FromIncomingContext(ctx)</span><br><span class="line">	<span class="keyword">if</span> !exist &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unauthenticated, <span class="string">&quot;无Token认证信息&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> appKey <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> appSecret <span class="type">string</span></span><br><span class="line">	<span class="keyword">if</span> key, ok := md[<span class="string">&quot;appid&quot;</span>]; ok &#123;</span><br><span class="line">		appKey = key[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> secret, ok := md[<span class="string">&quot;appkey&quot;</span>]; ok &#123;</span><br><span class="line">		appSecret = secret[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> appKey != <span class="string">&quot;hello&quot;</span> || appSecret != <span class="string">&quot;20190812&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unauthenticated, <span class="string">&quot;Token 不合法&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//通过token验证，继续处理请求</span></span><br><span class="line">	<span class="keyword">return</span> handler(ctx, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义的TokenInterceptor方法定义中,和之前在服务的方法调用的验证逻辑一致，从metadata中取出请求头中携带的token认证信息，并进行验证是否正确。如果token验证通过，则继续处理请求后续逻辑，后续继续处理可以由grpc.UnaryHandler进行处理。grpc.UnaryHandler同样是一个方法，其具体的实现就是开发者自定义实现的服务方法。grpc.UnaryHandler接口定义源码定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UnaryHandler <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, req <span class="keyword">interface</span>&#123;&#125;)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>

<h3 id="2-4-拦截器注册"><a href="#2-4-拦截器注册" class="headerlink" title="2.4 拦截器注册"></a>2.4 拦截器注册</h3><p>在服务端调用grpc.NewServer时进行拦截器的注册。详细如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">server := grpc.NewServer(grpc.Creds(creds), grpc.UnaryInterceptor(TokenInterceptor))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>go-micro框架介绍</title>
    <url>/2022/11/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/9go-micro%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="一、micro框架介绍"><a href="#一、micro框架介绍" class="headerlink" title="一、micro框架介绍"></a>一、micro框架介绍</h2><h3 id="1-1、背景"><a href="#1-1、背景" class="headerlink" title="1.1、背景"></a>1.1、背景</h3><p>在前面的内容中，我们已经学习了微服务之间通信采用的通信协议，如何实现服务的注册和发现，搭建服务管理集群，以及服务与服务之间的RPC通信方式。具体的内容包括：protobuf协议，consul及docker部署consul集群，gRPC框架的使用等具体的实现方案。</p>
<p>以上这些具体的方案都是为了解决微服务实践过程中具体的某个问题而提出的，实现微服务架构的项目开发。但是，在具体的项目开发过程中，开发者聚焦的是业务逻辑的开发和功能的实现，大量的环境配置，调试搭建等基础性工作会耗费相当一部分的精力，因此有必要将微服务架构中所涉及到的，相关的解决方案做集中管理和维护。这就是我们要学习的Micro。</p>
<h3 id="1-2、概述"><a href="#1-2、概述" class="headerlink" title="1.2、概述"></a>1.2、概述</h3><p>Micro是一个简化分布式开发的微服务生态系统，该系统为开发分布式应用程序提供了高效，便捷的模块构建。主要目的是简化分布式系统的开发。</p>
<p>学习完该框架以后，可以方便开发者们非常简单的开发出微服务架构的项目，并且随着业务模块的增加和功能的增加，Micro还能够提供管理微服务环境的工具和功能。</p>
<h3 id="1-3、micro组成"><a href="#1-3、micro组成" class="headerlink" title="1.3、micro组成"></a>1.3、micro组成</h3><p>micro是一个微服务工具包，是由一系列的工具包组成的，如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/3f7b63acfc0040a7bf0af827533d06df.png" alt="在这里插入图片描述"></p>
<ul>
<li><p><code>Go Micro：</code>用于在Go中编写微服务的插件式RPC框架。它提供了用于服务发现，客户端负载平衡，编码，同步和异步通信库。</p>
</li>
<li><p><code>API：</code>API主要负责提供将HTTP请求路由到相应微服务的API网关。它充当单个入口点，可以用作反向代理或将HTTP请求转换为RPC。</p>
</li>
<li><p><code>Sidecar：</code>一种对语言透明的RPC代理，具有go-micro作为HTTP端点的所有功能。虽然Go是构建微服务的伟大语言，但您也可能希望使用其他语言，因此Sidecar提供了一种将其他应用程序集成到Micro世界的方法。</p>
</li>
<li><p><code>Web：</code>用于Micro Web应用程序的仪表板和反向代理。我们认为应该基于微服务建立web应用，因此被视为微服务领域的一等公民。它的行为非常像API反向代理，但也包括对web sockets的支持。</p>
</li>
<li><p><code>CLI：</code>一个直接的命令行界面来与你的微服务进行交互。它还使您可以利用Sidecar作为代理，您可能不想直接连接到服务注册表。</p>
</li>
<li><p><code>Bot：</code>Hubot风格的bot，位于您的微服务平台中，可以通过Slack，HipChat，XMPP等进行交互。它通过消息传递提供CLI的功能。可以添加其他命令来自动执行常见的操作任务。</p>
</li>
</ul>
<h3 id="1-4、工具包介绍"><a href="#1-4、工具包介绍" class="headerlink" title="1.4、工具包介绍"></a>1.4、工具包介绍</h3><h4 id="1-4-1、API"><a href="#1-4-1、API" class="headerlink" title="1.4.1、API"></a>1.4.1、API</h4><p>启用API作为一个网关或代理，来作为微服务访问的单一入口。它应该在您的基础架构的边缘运行。它将HTTP请求转换为RPC并转发给相应的服务。</p>
<p><img src="https://img-blog.csdnimg.cn/ad97b6ed98e54234b401d0ae038ea087.png" alt="在这里插入图片描述"></p>
<h4 id="1-4-2、Web"><a href="#1-4-2、Web" class="headerlink" title="1.4.2、Web"></a>1.4.2、Web</h4><p>UI是go-micro的web版本，允许通过UI交互访问环境。在未来，它也将是一种聚合Micro Web服务的方式。它包含一种Web应用程序的代理方式。将&#x2F;[name]通过注册表路由到相应的服务。Web UI将前缀“go.micro.web。”（可以配置）添加到名称中，在注册表中查找它，然后将进行反向代理。</p>
<p><img src="https://img-blog.csdnimg.cn/b611399eba394731b32cf6cb13ea7460.png" alt="在这里插入图片描述"></p>
<h4 id="1-4-3、Sidecar"><a href="#1-4-3、Sidecar" class="headerlink" title="1.4.3、Sidecar"></a>1.4.3、Sidecar</h4><p>该Sidecar是go-micro的HTTP接口版本。这是将非Go应用程序集成到Micro环境中的一种方式。</p>
<p><img src="https://img-blog.csdnimg.cn/e3a876a140ec43f89ae34399583c96dd.png" alt="在这里插入图片描述"></p>
<h4 id="1-4-4、Bot"><a href="#1-4-4、Bot" class="headerlink" title="1.4.4、Bot"></a>1.4.4、Bot</h4><p>Bot是一个Hubot风格的工具，位于您的微服务平台中，可以通过Slack，HipChat，XMPP等进行交互。它通过消息传递提供CLI的功能。可以添加其他命令来自动执行常用操作任务。</p>
<p><img src="https://img-blog.csdnimg.cn/2e442e41363748b0a720f3a5a36993f9.png" alt="在这里插入图片描述"></p>
<h4 id="1-4-5、CLI"><a href="#1-4-5、CLI" class="headerlink" title="1.4.5、CLI"></a>1.4.5、CLI</h4><p>Micro CLI是go-micro的命令行版本，它提供了一种观察和与运行环境交互的方式。</p>
<h4 id="1-4-6、Go-Micro"><a href="#1-4-6、Go-Micro" class="headerlink" title="1.4.6、Go-Micro"></a>1.4.6、Go-Micro</h4><p>Go-micro是微服务的独立RPC框架。它是该工具包的核心，并受到上述所有组件的影响。在这里，我们将看看go-micro的每个特征。</p>
<p><img src="https://img-blog.csdnimg.cn/c463081a50b94d258536ca7ae340882d.png" alt="在这里插入图片描述"></p>
<h3 id="1-5、Go-Micro特性"><a href="#1-5、Go-Micro特性" class="headerlink" title="1.5、Go-Micro特性"></a>1.5、Go-Micro特性</h3><ul>
<li><p>Registry：主要负责服务注册和发现功能。我们之前学习过的consul，就可以和此处的Registry结合起来，实现服务的发现功能。</p>
</li>
<li><p>Selector：selector主要的作用是实现服务的负载均衡功能。当某个客户端发起请求时，将首先查询服务注册表，返回当前系统中可用的服务列表，然后从中选择其中一个节点进行查询，保证节点可用。</p>
</li>
<li><p>Broker：Broker是go-micro框架中事件发布和订阅的接口，主要是用消息队列的方式实现信息的接收和发布，用于处理系统间的异步功能。</p>
</li>
<li><p>Codec：go-micro中数据传输过程中的编码和解码接口。go-micro中有多重编码方式，默认的实现方式是protobuf，除此之外，还有json等格式。</p>
</li>
<li><p>Transport：go-micro框架中的通信接口，有很多的实现方案可以选择，默认使用的是http形式的通信方式，除此以外，还有grpc等通信方式。</p>
</li>
<li><p>Client和Server：分别是go-micro中的客户端接口和服务端接口。client负责调用，server负责等待请求处理。</p>
</li>
</ul>
<h3 id="1-6、环境安装"><a href="#1-6、环境安装" class="headerlink" title="1.6、环境安装"></a>1.6、环境安装</h3><h4 id="1-6-1、安装consul"><a href="#1-6-1、安装consul" class="headerlink" title="1.6.1、安装consul"></a>1.6.1、安装consul</h4><p>consul环境是go-micro默认使用的服务发现方式。在之前的课程中已经安装过。</p>
<h4 id="1-6-2、安装protobuf和依赖"><a href="#1-6-2、安装protobuf和依赖" class="headerlink" title="1.6.2、安装protobuf和依赖"></a>1.6.2、安装protobuf和依赖</h4><p>关于protobuf相关知识，我们之前也已经安装并学习过，此处不再赘述。</p>
<h4 id="1-6-3、micro工具包安装（可选择）"><a href="#1-6-3、micro工具包安装（可选择）" class="headerlink" title="1.6.3、micro工具包安装（可选择）"></a>1.6.3、micro工具包安装（可选择）</h4><p>前面说过，micro是一个微服务系统，提供了很多工具包，可以帮助我们进行开发和调试。</p>
<p><img src="https://img-blog.csdnimg.cn/76a0c2d37ab2413f8453237dc5d9426c.png" alt="在这里插入图片描述"></p>
<p>可以使用如下命令安装micro的一系列的工具包：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/micro/micro</span><br></pre></td></tr></table></figure>

<h4 id="1-6-4、1Go-micro安装"><a href="#1-6-4、1Go-micro安装" class="headerlink" title="1.6.4、1Go-micro安装"></a>1.6.4、1Go-micro安装</h4><p>使用go-micro框架之前，首先需要安装go-micro框架，使用如下命令：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get github.com/micro/<span class="keyword">go</span>-micro</span><br></pre></td></tr></table></figure>


<p>go-micro的源码在github上可以找到，链接如下：<a href="https://github.com/micro/go-micro">https://github.com/micro/go-micro</a></p>
<h2 id="二、创建微服务"><a href="#二、创建微服务" class="headerlink" title="二、创建微服务"></a>二、创建微服务</h2><h3 id="2-1、服务的定义"><a href="#2-1、服务的定义" class="headerlink" title="2.1、服务的定义"></a>2.1、服务的定义</h3><p>在micro框架中，服务用接口来进行定义，服务被定义为Service，完整的接口定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;</span><br><span class="line">	Init(...Option)</span><br><span class="line">	Options() Options</span><br><span class="line">	Client() client.Client</span><br><span class="line">	Server() server.Server</span><br><span class="line">	Run() <span class="type">error</span></span><br><span class="line">	String() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该接口中，定义了一个服务实例具体要包含的方法，分别是：Init、Options、Client、Server、Run、String等6个方法。</p>
<h3 id="2-2、初始化服务实例"><a href="#2-2、初始化服务实例" class="headerlink" title="2.2、初始化服务实例"></a>2.2、初始化服务实例</h3><p>micro框架，除了提供Service的定义外，提供创建服务实例的方法供开发者调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">service := micro.NewService()</span><br></pre></td></tr></table></figure>

<p>如上是最简单一种创建service实例的方式。NewService可以接受一个Options类型的可选项参数。NewService的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(opts ...Option)</span></span> Service &#123;</span><br><span class="line">	<span class="keyword">return</span> newService(opts...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-1、Options可选项配置"><a href="#2-2-1、Options可选项配置" class="headerlink" title="2.2.1、Options可选项配置"></a>2.2.1、Options可选项配置</h4><p>关于Options可配置选项，有很多可以选择的设置项。micro框架包中包含了options.go文件，定义了详细的可选项配置的内容。最基本常见的配置项有：服务名称，服务的版本，服务的地址，服务：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Name</span><span class="params">(n <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *Options)</span></span> &#123;</span><br><span class="line">		o.Server.Init(server.Name(n))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务版本</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Version</span><span class="params">(v <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *Options)</span></span> &#123;</span><br><span class="line">		o.Server.Init(server.Version(v))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务部署地址</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Address</span><span class="params">(addr <span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *Options)</span></span> &#123;</span><br><span class="line">		o.Server.Init(server.Address(addr))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//元数据项设置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Metadata</span><span class="params">(md <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> Option &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(o *Options)</span></span> &#123;</span><br><span class="line">		o.Server.Init(server.Metadata(md))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的实例化对象代码如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个新的服务对象实例</span></span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">&quot;helloservice&quot;</span>),</span><br><span class="line">		micro.Version(<span class="string">&quot;v1.0.0&quot;</span>),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开发者可以直接调用micro.Name为服务设置名称，设置版本号等信息。在对应的函数内部，调用了server.Server.Init函数对配置项进行初始化。</p>
<h3 id="2-3、定义服务接口-实现服务业务逻辑"><a href="#2-3、定义服务接口-实现服务业务逻辑" class="headerlink" title="2.3、定义服务接口,实现服务业务逻辑"></a>2.3、定义服务接口,实现服务业务逻辑</h3><p>在前面的课程中，已经学习掌握了使用protobuf定义服务接口，并对服务进行具体实现。使用protobuf定义服务接口并自动生成go语言文件,需要经过以下几个步骤，我们通过示例进行说明：</p>
<blockquote>
<p><font size=2 color='gray'>我们依然通过案例来讲解相关的知识点：在学校的教务系统中，有学生信息管理的需求。学生信息包含学生姓名，学生班级，学习成绩组成；可以根据学生姓名查询学生的相关信息，我们通过rpc调用和学生服务来实现该案例。</font></p>
</blockquote>
<h4 id="2-3-1、定义-proto文件"><a href="#2-3-1、定义-proto文件" class="headerlink" title="2.3.1、定义.proto文件"></a>2.3.1、定义.proto文件</h4><p>使用proto3语法定义数据结构体和服务方法。具体定义内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&#x27;proto3&#x27;</span>;</span><br><span class="line"><span class="keyword">package</span> message;</span><br><span class="line">option go_package=<span class="string">&quot;./;message&quot;</span>;</span><br><span class="line"><span class="comment">//学生数据体</span></span><br><span class="line">message Student &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>; <span class="comment">//姓名</span></span><br><span class="line">    <span class="type">string</span> classes = <span class="number">2</span>; <span class="comment">//班级</span></span><br><span class="line">    <span class="type">int32</span> grade = <span class="number">3</span>; <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求数据体定义</span></span><br><span class="line">message StudentRequest &#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//学生服务</span></span><br><span class="line">service StudentService &#123;</span><br><span class="line">    <span class="comment">//查询学生信息服务</span></span><br><span class="line">    rpc GetStudent (StudentRequest) returns (Student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2、编译-proto文件"><a href="#2-3-2、编译-proto文件" class="headerlink" title="2.3.2、编译.proto文件"></a>2.3.2、编译.proto文件</h4><p>在原来学习gRPC框架时，我们是将.proto文件按照grpc插件的标准来进行编译。而现在，我们学习的是go-micro，因此我们可以按照micro插件来进行编译。micro框架中的protobuf插件，我们需要单独安装。</p>
<ul>
<li><p>安装micro框架的protobuf插件</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/micro/protoc-gen-micro</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定micro插件进行编译</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=. --micro_out=. --go_out=. message.proto</span><br></pre></td></tr></table></figure>
<p>  上述编译命令执行成功，可以在项目目录下的message目录下生成message.pb.go文件，该文件是由protoc编译器自动编译生成，开发者不能修改。message.pb.go如图所示：</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/65ab260967184cf0a9776f63c52f41ec.png" alt="在这里插入图片描述"></p>
<h4 id="2-3-3、编码实现服务功能"><a href="#2-3-3、编码实现服务功能" class="headerlink" title="2.3.3、编码实现服务功能"></a>2.3.3、编码实现服务功能</h4><p>在项目目录下，实现StudentService定义的rpc GetStudent功能。新建studentManager.go文件，具体实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生服务管理实现</span></span><br><span class="line"><span class="keyword">type</span> StudentManager <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取学生信息的服务接口实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStudent</span><span class="params">(ctx context.Context, request *message.StudentRequest, response *message.Student)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	studentMap := <span class="keyword">map</span>[<span class="type">string</span>]message.Student&#123;</span><br><span class="line">		<span class="string">&quot;davie&quot;</span>:  message.Student&#123;Name: <span class="string">&quot;davie&quot;</span>, Classes: <span class="string">&quot;软件工程专业&quot;</span>, Grade: <span class="number">80</span>&#125;,</span><br><span class="line">		<span class="string">&quot;steven&quot;</span>: message.Student&#123;Name: <span class="string">&quot;steven&quot;</span>, Classes: <span class="string">&quot;计算机科学与技术&quot;</span>, Grade: <span class="number">90</span>&#125;,</span><br><span class="line">		<span class="string">&quot;tony&quot;</span>:   message.Student&#123;Name: <span class="string">&quot;tony&quot;</span>, Classes: <span class="string">&quot;计算机网络工程&quot;</span>, Grade: <span class="number">85</span>&#125;,</span><br><span class="line">		<span class="string">&quot;jack&quot;</span>:   message.Student&#123;Name: <span class="string">&quot;jack&quot;</span>, Classes: <span class="string">&quot;工商管理&quot;</span>, Grade: <span class="number">96</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> request.Name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot; 请求参数错误,请重新请求。&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	student := studentMap[request.Name]</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> student.Name != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		response = &amp;student</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot; 未查询当相关学生信息 &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4、运行服务"><a href="#2-4、运行服务" class="headerlink" title="2.4、运行服务"></a>2.4、运行服务</h3><p>在之前的学习过程中，我们是通过自己编写server.go程序,注册服务，并实现请求的监听。现在，我们用micro框架来实现服务的运行。完整的运行服务的代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建一个新的服务对象实例</span></span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">&quot;student_service&quot;</span>),</span><br><span class="line">		micro.Version(<span class="string">&quot;v1.0.0&quot;</span>),</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">//服务初始化</span></span><br><span class="line">	service.Init()</span><br><span class="line">	<span class="comment">//注册</span></span><br><span class="line">message.RegisterStudentServiceHandler(service.Server(), <span class="built_in">new</span>(StudentManager))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//运行</span></span><br><span class="line">	err := service.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5、客户端调用"><a href="#2-5、客户端调用" class="headerlink" title="2.5、客户端调用"></a>2.5、客户端调用</h3><p>客户端可以构造请求对象，并访问对应的服务方法。具体方法实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	service := micro.NewService(</span><br><span class="line">		micro.Name(<span class="string">&quot;student.client&quot;</span>),</span><br><span class="line">	)</span><br><span class="line">	service.Init()</span><br><span class="line">	studentService := message.NewStudentServiceClient(<span class="string">&quot;student_service&quot;</span>, service.Client())</span><br><span class="line">	res, err := studentService.GetStudent(context.TODO(), &amp;message.StudentRequest&#123;Name: <span class="string">&quot;davie&quot;</span>&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(res.Name)</span><br><span class="line">	fmt.Println(res.Classes)</span><br><span class="line">	fmt.Println(res.Grade)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>go-micro的版本非常混乱</p>
<p>出现问题：<br><code>panic: qtls.ConnectionState not compatible with tls.ConnectionState</code></p>
<p>解决方案：降低go的版本，降至1.13</p>
<h3 id="2-6、运行结果"><a href="#2-6、运行结果" class="headerlink" title="2.6、运行结果"></a>2.6、运行结果</h3><h4 id="2-6-1、运行服务端"><a href="#2-6-1、运行服务端" class="headerlink" title="2.6.1、运行服务端"></a>2.6.1、运行服务端</h4><p>运行main.go文件中的main函数,服务注册成功，并输出如下日志：</p>
<p><img src="https://img-blog.csdnimg.cn/4c5e06e6ba0d4d2b83c2cd6917217883.png" alt="在这里插入图片描述"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">2019</span>/<span class="number">08</span>/<span class="number">26</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">18</span> Transport [http] Listening on [::]:<span class="number">54343</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">08</span>/<span class="number">26</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">18</span> Broker [http] Connected to [::]:<span class="number">54344</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">08</span>/<span class="number">26</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">19</span> Registry [mdns] Registering node: student_service<span class="number">-346</span>b454c<span class="number">-998</span>d<span class="number">-4e85</span>-a8cc-befbc0198eef</span><br></pre></td></tr></table></figure>

<h4 id="2-6-2、运行客户端"><a href="#2-6-2、运行客户端" class="headerlink" title="2.6.2、运行客户端"></a>2.6.2、运行客户端</h4><p>客户端负责发起请求和功能调用,运行client.go程序，程序正常输出。</p>
<h3 id="2-7、注册服务到consul"><a href="#2-7、注册服务到consul" class="headerlink" title="2.7、注册服务到consul"></a>2.7、注册服务到consul</h3><h4 id="2-7-1、默认注册到mdns"><a href="#2-7-1、默认注册到mdns" class="headerlink" title="2.7.1、默认注册到mdns"></a>2.7.1、默认注册到mdns</h4><p>在我们运行服务端的程序时，我们可以看到Registry [mdns] Registering node:xxx这个日志,该日志显示go-micro框架将我们的服务使用默认的配置注册到了mdns中。mdns是可简单翻译为mdns，是go-micro的默认配置选项。</p>
<h4 id="2-7-2、注册到consul"><a href="#2-7-2、注册到consul" class="headerlink" title="2.7.2、注册到consul"></a>2.7.2、注册到consul</h4><p>在前面的微服务理论课程中，我们已经学习过consul。consul是服务注册与发现的组件,因此，如果我们本地系统已经安装了consul环境，我们可以选择将我们的服务注册到consul中。指定注册到consul时，需要先将consul进行启动。</p>
<ul>
<li><p>启动consul<br>  启动命令如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure>
<p>  通过上述命令，我们可以在终端中启动consul。</p>
</li>
<li><p>指定服务注册到consul<br>通过命令运行服务程序，并指定注册到consul，详细命令如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> --registry=consul</span><br></pre></td></tr></table></figure>
<p>通过–registry选项，指定要注册到的服务发现组件。</p>
</li>
<li><p>查看服务<br>由于consul给我们提供了ui界面，因此我们可以通过浏览器界面来访问consul节点页面。访问本地8500端口,浏览器地址是：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http:<span class="comment">//localhost:8500</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/fcd41b68258641c4aad9e017207219c7.png" alt="在这里插入图片描述"></p>
<p>在创建微服务的时候也可以使用<code>micro.Registry(consul.NewRegistry()),</code>的方式指定使用consul作为服务发现组件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">service := micro.NewService(</span><br><span class="line">		<span class="comment">// 虽然consul有默认端口，但是我们最好自己声明一个端口</span></span><br><span class="line">		micro.Address(<span class="string">&quot;127.0.0.1:12341&quot;</span>),</span><br><span class="line">		micro.Name(<span class="string">&quot;studentService&quot;</span>),</span><br><span class="line">		micro.Registry(consul.NewRegistry()),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此之前需要拉取consul插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/micro/go-plugins/registry/consul</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL优化SQL步骤</title>
    <url>/2022/11/02/MySQL/12mysql%E4%BC%98%E5%8C%96SQL%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p>在应用的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。</p>
<p>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</p>
<h3 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h3><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的统计结果和 global 级（自数据库上次启动至今）的统计结果。如果不写，默认使用参数是“session”。</p>
<p>下面的命令显示了当前 session 中所有统计参数的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/5173093edcf54e9389fee4561853adb5.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/d66e9beab9a04155a035a5bc0771e59c.png" alt="在这里插入图片描述"></p>
<p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Com_select</td>
<td>执行 select 操作的次数，一次查询只累加 1。</td>
</tr>
<tr>
<td>Com_insert</td>
<td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td>
</tr>
<tr>
<td>Com_update</td>
<td>执行 UPDATE 操作的次数。</td>
</tr>
<tr>
<td>Com_delete</td>
<td>执行 DELETE 操作的次数。</td>
</tr>
<tr>
<td>Innodb_rows_read</td>
<td>select 查询返回的行数。</td>
</tr>
<tr>
<td>Innodb_rows_inserted</td>
<td>执行 INSERT 操作插入的行数。</td>
</tr>
<tr>
<td>Innodb_rows_updated</td>
<td>执行 UPDATE 操作更新的行数。</td>
</tr>
<tr>
<td>Innodb_rows_deleted</td>
<td>执行 DELETE 操作删除的行数。</td>
</tr>
<tr>
<td>Connections</td>
<td>试图连接 MySQL 服务器的次数。</td>
</tr>
<tr>
<td>Uptime</td>
<td>服务器工作时间。</td>
</tr>
<tr>
<td>Slow_queries</td>
<td>慢查询的次数。</td>
</tr>
</tbody></table>
<p>Com_*** : 这些参数对于所有存储引擎的表操作都会进行累计。</p>
<p>Innodb_*** : 这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</p>
<h3 id="定位低效率执行SQL"><a href="#定位低效率执行SQL" class="headerlink" title="定位低效率执行SQL"></a>定位低效率执行SQL</h3><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p>
<ul>
<li><p><code>慢查询日志</code> : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[&#x3D;file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看本书第 26 章中日志管理的相关部分。</p>
</li>
<li><p><code>show processlist</code> : <code>慢查询日志在查询结束以后才记录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL正在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</code></p>
<p>  (比如新开了一个客户端(sqlyog&#x2F;navicat)连接当前mysql服务，下表就会多出一项)</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/1b09dc759b8843ecb4ddcab39d3be35c.png" alt="在这里插入图片描述"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1） id列，用户登录mysql时，系统分配的&quot;connection<span class="emphasis">_id&quot;，可以使用函数connection_</span>id()查看</span><br><span class="line"></span><br><span class="line">2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</span><br><span class="line"></span><br><span class="line">3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</span><br><span class="line"></span><br><span class="line">4） db列，显示这个进程目前连接的是哪个数据库</span><br><span class="line"></span><br><span class="line">5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等</span><br><span class="line"></span><br><span class="line">6） time列，显示这个状态持续的时间，单位是秒</span><br><span class="line"></span><br><span class="line">7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</span><br><span class="line"></span><br><span class="line">8） info列，显示这个sql语句，是判断问题语句的一个重要依据</span><br></pre></td></tr></table></figure>

<h3 id="explain分析执行计划"><a href="#explain分析执行计划" class="headerlink" title="explain分析执行计划"></a>explain分析执行计划</h3><blockquote>
<p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序</p>
</blockquote>
<p>查询SQL语句的执行计划 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/82b45990df9d4425903864455de6ab8f.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain  <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;阿尔卡特 (OT-979) 冰川白 联通3G手机3&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/23e7fb344c424516816efe66330802ed.png" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td>
</tr>
<tr>
<td>table</td>
<td>输出结果集的表</td>
</tr>
<tr>
<td>type</td>
<td>表示表的连接类型，性能由好到差的连接类型为( system —&gt; const —–&gt; eq_ref ——&gt; ref ——-&gt; ref_or_null—-&gt; index_merge —&gt; index_subquery —–&gt; range —–&gt; index ——&gt; all )</td>
</tr>
<tr>
<td>possible_keys</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>rows</td>
<td>扫描行的数量</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p><img src="https://img-blog.csdnimg.cn/fe35a027feb04d58bb84568df388e87c.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_role` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_code` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_role_name` (`role_name`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_user` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_role` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment ,</span><br><span class="line">  `user_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role_id` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `fk_ur_user_id` (`user_id`),</span><br><span class="line">  KEY `fk_ur_role_id` (`role_id`),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_role_id` <span class="keyword">FOREIGN</span> KEY (`role_id`) <span class="keyword">REFERENCES</span> `t_role` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `fk_ur_user_id` <span class="keyword">FOREIGN</span> KEY (`user_id`) <span class="keyword">REFERENCES</span> `t_user` (`id`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> ACTION <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> ACTION</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;系统管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui&#x27;</span>,<span class="string">&#x27;test02&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;stu1&#x27;</span>,<span class="string">&#x27;$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa&#x27;</span>,<span class="string">&#x27;学生1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;stu2&#x27;</span>,<span class="string">&#x27;$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm&#x27;</span>,<span class="string">&#x27;学生2&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `t_user` (`id`, `username`, `password`, `name`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;t1&#x27;</span>,<span class="string">&#x27;$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe&#x27;</span>,<span class="string">&#x27;老师1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>,<span class="string">&#x27;student&#x27;</span>,<span class="string">&#x27;学生&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>,<span class="string">&#x27;teacher&#x27;</span>,<span class="string">&#x27;老师&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>,<span class="string">&#x27;teachmanager&#x27;</span>,<span class="string">&#x27;教学管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;管理员&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t_role` (`id`, `role_name`, `role_code`, `description`) <span class="keyword">VALUES</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>,<span class="string">&#x27;super&#x27;</span>,<span class="string">&#x27;超级管理员&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_role(id,user_id,role_id) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;7&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;9&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;8&#x27;</span>),(<span class="keyword">NULL</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;10&#x27;</span>) ;</span><br></pre></td></tr></table></figure>

<h4 id="explain-之-id"><a href="#explain-之-id" class="headerlink" title="explain 之 id"></a>explain 之 id</h4><blockquote>
<p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ：</p>
</blockquote>
<p>1） <code>id 相同表示加载表的顺序是从上到下。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_role r, t_user u, user_role ur <span class="keyword">where</span> r.id <span class="operator">=</span> ur.role_id <span class="keyword">and</span> u.id <span class="operator">=</span> ur.user_id ;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/0de2edbc3be34ecabc7bdc88d904045a.png" alt="在这里插入图片描述"></p>
<p>2） <code>id 不同id值越大，优先级越高，越先被执行。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> id <span class="operator">=</span> (<span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id <span class="operator">=</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;stu1&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/42ccccdb59aa429abaf39e97a27bd493.png" alt="在这里插入图片描述"></p>
<p>3） <code>id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_role r , (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.`user_id` <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span>) a <span class="keyword">WHERE</span> r.id <span class="operator">=</span> a.role_id ; </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/1391676896aa47bd8356cf7e669b9f1a.png" alt="在这里插入图片描述"></p>
<h4 id="explain-之-select-type"><a href="#explain-之-select-type" class="headerlink" title="explain 之 select_type"></a>explain 之 select_type</h4><p>表示 SELECT 的类型，常见的取值，如下表所示：<code>从上往下效率越来越低</code></p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td><code>简单的select查询，查询中不包含子查询或者UNION</code></td>
</tr>
<tr>
<td>PRIMARY</td>
<td><code>查询中若包含任何复杂的子查询，最外层查询标记为该标识</code></td>
</tr>
<tr>
<td>SUBQUERY</td>
<td><code>在SELECT 或 WHERE 列表中包含了子查询</code></td>
</tr>
<tr>
<td>DERIVED</td>
<td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
<h4 id="explain-之-table"><a href="#explain-之-table" class="headerlink" title="explain 之 table"></a>explain 之 table</h4><p>展示这一行的数据是关于哪一张表的</p>
<h4 id="explain-之-type"><a href="#explain-之-type" class="headerlink" title="explain 之 type"></a>explain 之 type</h4><p>type 显示的是访问类型，是较为重要的一个指标，可取值为：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>MySQL不访问任何表，索引，直接返回结果</td>
</tr>
<tr>
<td>system</td>
<td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现</td>
</tr>
<tr>
<td>const</td>
<td><code>表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常量。const于将 &quot;主键&quot; 或 &quot;唯一&quot; 索引的所有部分与常量值进行比较</code></td>
</tr>
<tr>
<td>eq_ref</td>
<td><code>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</code></td>
</tr>
<tr>
<td>ref</td>
<td><code>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</code></td>
</tr>
<tr>
<td>range</td>
<td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td>
</tr>
<tr>
<td>index</td>
<td><code>index 与 ALL的区别为 index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</code></td>
</tr>
<tr>
<td>all</td>
<td><code>将遍历全表以找到匹配的行</code></td>
</tr>
</tbody></table>
<p>结果值从最好到最坏以此是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">NULL</span> <span class="operator">&gt;</span> <span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> fulltext <span class="operator">&gt;</span> ref_or_null <span class="operator">&gt;</span> index_merge <span class="operator">&gt;</span> unique_subquery <span class="operator">&gt;</span> index_subquery <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure>

<p><code>一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。</code></p>
<h4 id="explain-之-key"><a href="#explain-之-key" class="headerlink" title="explain 之 key"></a>explain 之 key</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </span><br><span class="line"></span><br><span class="line">key ： 实际使用的索引， 如果为<span class="keyword">NULL</span>， 则没有使用索引。</span><br><span class="line"></span><br><span class="line">key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</span><br></pre></td></tr></table></figure>

<h4 id="explain-之-rows"><a href="#explain-之-rows" class="headerlink" title="explain 之 rows"></a>explain 之 rows</h4><p>扫描行的数量。</p>
<h4 id="explain-之-extra"><a href="#explain-之-extra" class="headerlink" title="explain 之 extra"></a>explain 之 extra</h4><p>其他的额外的执行计划信息，在该列展示 。<code>需要优化的前面两个，保持的是后面using index</code></p>
<table>
<thead>
<tr>
<th>extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>using filesort</td>
<td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, <code>效率低。</code></td>
</tr>
<tr>
<td>using temporary</td>
<td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； <code>效率低</code></td>
</tr>
<tr>
<td>using index</td>
<td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， <code>效率不错。</code></td>
</tr>
</tbody></table>
<h3 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h3><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p>
<p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p>
<p><img src="https://img-blog.csdnimg.cn/71306a6e635a45ccbe7ee904e9419fb7.png" alt="在这里插入图片描述"></p>
<p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p>
<p><img src="https://img-blog.csdnimg.cn/8a2fc800be444d3eb7b3b1e3cff7d59f.png" alt="在这里插入图片描述"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; <span class="operator">/</span><span class="operator">/</span>开启profiling 开关；</span><br></pre></td></tr></table></figure>

<p>通过profile，我们能够更清楚地了解SQL执行的过程。</p>
<p>首先，我们可以执行一系列的操作，如下图所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line">use db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item;</span><br></pre></td></tr></table></figure>

<p>执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</p>
<p><img src="https://img-blog.csdnimg.cn/00f722fd3870485a97f6e37ba7b6dfa3.png" alt="在这里插入图片描述"></p>
<p>通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p>
<p><img src="https://img-blog.csdnimg.cn/a8e2b503b4c7444ca542372c6b55c7c4.png" alt="在这里插入图片描述"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">TIP ：</span><br><span class="line">	Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整个查询中耗时最长的状态。</span><br></pre></td></tr></table></figure>

<p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ：</p>
<p><img src="https://img-blog.csdnimg.cn/9ff587f4e647480a9dd92c806b356d2e.png" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Status</td>
<td>sql 语句执行的状态</td>
</tr>
<tr>
<td>Duration</td>
<td>sql 执行过程中每一个步骤的耗时</td>
</tr>
<tr>
<td>CPU_user</td>
<td>当前用户占有的cpu</td>
</tr>
<tr>
<td>CPU_system</td>
<td>系统占有的cpu</td>
</tr>
</tbody></table>
<h3 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h3><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p>
<p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p>执行SQL语句 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">QUERY: <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">4</span></span><br><span class="line">TRACE: &#123;</span><br><span class="line">  &quot;steps&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_preparation&quot;: &#123;</span><br><span class="line">        &quot;select#&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;expanded_query&quot;: &quot;/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_preparation */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_optimization&quot;: &#123;</span><br><span class="line">        &quot;select#&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;condition_processing&quot;: &#123;</span><br><span class="line">              &quot;condition&quot;: &quot;WHERE&quot;,</span><br><span class="line">              &quot;original_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;,</span><br><span class="line">              &quot;steps&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;equality_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;constant_propagation&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,</span><br><span class="line">                  &quot;resulting_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] <span class="comment">/* steps */</span></span><br><span class="line">            &#125; <span class="comment">/* condition_processing */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;table_dependencies&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`tb_item`&quot;,</span><br><span class="line">                &quot;row_may_be_null&quot;: <span class="literal">false</span>,</span><br><span class="line">                &quot;map_bit&quot;: <span class="number">0</span>,</span><br><span class="line">                &quot;depends_on_map_bits&quot;: [</span><br><span class="line">                ] <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* table_dependencies */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;ref_optimizer_key_uses&quot;: [</span><br><span class="line">            ] <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;rows_estimation&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`tb_item`&quot;,</span><br><span class="line">                &quot;range_analysis&quot;: &#123;</span><br><span class="line">                  &quot;table_scan&quot;: &#123;</span><br><span class="line">                    &quot;rows&quot;: <span class="number">9816098</span>,</span><br><span class="line">                    &quot;cost&quot;: <span class="number">2.04e6</span></span><br><span class="line">                  &#125; <span class="comment">/* table_scan */</span>,</span><br><span class="line">                  &quot;potential_range_indices&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                      &quot;usable&quot;: <span class="literal">true</span>,</span><br><span class="line">                      &quot;key_parts&quot;: [</span><br><span class="line">                        &quot;id&quot;</span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* potential_range_indices */</span>,</span><br><span class="line">                  &quot;setup_range_conditions&quot;: [</span><br><span class="line">                  ] <span class="comment">/* setup_range_conditions */</span>,</span><br><span class="line">                  &quot;group_index_range&quot;: &#123;</span><br><span class="line">                    &quot;chosen&quot;: <span class="literal">false</span>,</span><br><span class="line">                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;</span><br><span class="line">                  &#125; <span class="comment">/* group_index_range */</span>,</span><br><span class="line">                  &quot;analyzing_range_alternatives&quot;: &#123;</span><br><span class="line">                    &quot;range_scan_alternatives&quot;: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                        &quot;ranges&quot;: [</span><br><span class="line">                          &quot;id &lt; 4&quot;</span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        &quot;index_dives_for_eq_ranges&quot;: <span class="literal">true</span>,</span><br><span class="line">                        &quot;rowid_ordered&quot;: <span class="literal">true</span>,</span><br><span class="line">                        &quot;using_mrr&quot;: <span class="literal">false</span>,</span><br><span class="line">                        &quot;index_only&quot;: <span class="literal">false</span>,</span><br><span class="line">                        &quot;rows&quot;: <span class="number">3</span>,</span><br><span class="line">                        &quot;cost&quot;: <span class="number">1.6154</span>,</span><br><span class="line">                        &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    ] <span class="comment">/* range_scan_alternatives */</span>,</span><br><span class="line">                    &quot;analyzing_roworder_intersect&quot;: &#123;</span><br><span class="line">                      &quot;usable&quot;: <span class="literal">false</span>,</span><br><span class="line">                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;</span><br><span class="line">                    &#125; <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">                  &#125; <span class="comment">/* analyzing_range_alternatives */</span>,</span><br><span class="line">                  &quot;chosen_range_access_summary&quot;: &#123;</span><br><span class="line">                    &quot;range_access_plan&quot;: &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;range_scan&quot;,</span><br><span class="line">                      &quot;index&quot;: &quot;PRIMARY&quot;,</span><br><span class="line">                      &quot;rows&quot;: <span class="number">3</span>,</span><br><span class="line">                      &quot;ranges&quot;: [</span><br><span class="line">                        &quot;id &lt; 4&quot;</span><br><span class="line">                      ] <span class="comment">/* ranges */</span></span><br><span class="line">                    &#125; <span class="comment">/* range_access_plan */</span>,</span><br><span class="line">                    &quot;rows_for_plan&quot;: <span class="number">3</span>,</span><br><span class="line">                    &quot;cost_for_plan&quot;: <span class="number">1.6154</span>,</span><br><span class="line">                    &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                  &#125; <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                &#125; <span class="comment">/* range_analysis */</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* rows_estimation */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;considered_execution_plans&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;plan_prefix&quot;: [</span><br><span class="line">                ] <span class="comment">/* plan_prefix */</span>,</span><br><span class="line">                &quot;table&quot;: &quot;`tb_item`&quot;,</span><br><span class="line">                &quot;best_access_path&quot;: &#123;</span><br><span class="line">                  &quot;considered_access_paths&quot;: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      &quot;access_type&quot;: &quot;range&quot;,</span><br><span class="line">                      &quot;rows&quot;: <span class="number">3</span>,</span><br><span class="line">                      &quot;cost&quot;: <span class="number">2.2154</span>,</span><br><span class="line">                      &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* considered_access_paths */</span></span><br><span class="line">                &#125; <span class="comment">/* best_access_path */</span>,</span><br><span class="line">                &quot;cost_for_plan&quot;: <span class="number">2.2154</span>,</span><br><span class="line">                &quot;rows_for_plan&quot;: <span class="number">3</span>,</span><br><span class="line">                &quot;chosen&quot;: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;attaching_conditions_to_tables&quot;: &#123;</span><br><span class="line">              &quot;original_condition&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;,</span><br><span class="line">              &quot;attached_conditions_computation&quot;: [</span><br><span class="line">              ] <span class="comment">/* attached_conditions_computation */</span>,</span><br><span class="line">              &quot;attached_conditions_summary&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                  &quot;table&quot;: &quot;`tb_item`&quot;,</span><br><span class="line">                  &quot;attached&quot;: &quot;(`tb_item`.`id` &lt; 4)&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              ] <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">            &#125; <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;refine_plan&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;table&quot;: &quot;`tb_item`&quot;,</span><br><span class="line">                &quot;access_type&quot;: &quot;range&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* refine_plan */</span></span><br><span class="line">          &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_optimization */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;join_execution&quot;: &#123;</span><br><span class="line">        &quot;select#&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;steps&quot;: [</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_execution */</span></span><br><span class="line">    &#125;</span><br><span class="line">  ] <span class="comment">/* steps */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL常用sql技巧</title>
    <url>/2022/11/02/MySQL/14mysql%E5%B8%B8%E7%94%A8sql%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><p>编写顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">	<span class="operator">&lt;</span><span class="keyword">select</span> list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	<span class="operator">&lt;</span>left_table<span class="operator">&gt;</span> <span class="operator">&lt;</span>join_type<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">	<span class="operator">&lt;</span>right_table<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	<span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">	<span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">	<span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line">LIMIT</span><br><span class="line">	<span class="operator">&lt;</span>limit_params<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行顺序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>	<span class="operator">&lt;</span>left_table<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ON</span> 		<span class="operator">&lt;</span>join_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&lt;</span>join_type<span class="operator">&gt;</span>		<span class="keyword">JOIN</span>	<span class="operator">&lt;</span>right_table<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WHERE</span>		<span class="operator">&lt;</span>where_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 	<span class="operator">&lt;</span>group_by_list<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">HAVING</span>		<span class="operator">&lt;</span>having_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>		<span class="operator">&lt;</span><span class="keyword">select</span> list<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>	<span class="operator">&lt;</span>order_by_condition<span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line">LIMIT		<span class="operator">&lt;</span>limit_params<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="正则表达式使用"><a href="#正则表达式使用" class="headerlink" title="正则表达式使用"></a>正则表达式使用</h3><p>正则表达式（Regular Expression）是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>在字符串开始处进行匹配</td>
</tr>
<tr>
<td>$</td>
<td>在字符串末尾处进行匹配</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意单个字符, 包括换行符</td>
</tr>
<tr>
<td>[…]</td>
<td>匹配出括号内的任意字符</td>
</tr>
<tr>
<td>[^…]</td>
<td>匹配不出括号内的任意字符</td>
</tr>
<tr>
<td>a*</td>
<td>匹配零个或者多个a(包括空串)</td>
</tr>
<tr>
<td>a+</td>
<td>匹配一个或者多个a(不包括空串)</td>
</tr>
<tr>
<td>a?</td>
<td>匹配零个或者一个a</td>
</tr>
<tr>
<td>a1|a2</td>
<td>匹配a1或a2</td>
</tr>
<tr>
<td>a(m)</td>
<td>匹配m个a</td>
</tr>
<tr>
<td>a(m,)</td>
<td>至少匹配m个a</td>
</tr>
<tr>
<td>a(m,n)</td>
<td>匹配m个a 到 n个a</td>
</tr>
<tr>
<td>a(,n)</td>
<td>匹配0到n个a</td>
</tr>
<tr>
<td>(…)</td>
<td>将模式元素组成单一元素</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name regexp <span class="string">&#x27;^T&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name regexp <span class="string">&#x27;2$&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name regexp <span class="string">&#x27;[uvw]&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="MySQL-常用函数"><a href="#MySQL-常用函数" class="headerlink" title="MySQL 常用函数"></a>MySQL 常用函数</h3><p><code>数字函数</code></p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>ABS</td>
<td>求绝对值</td>
</tr>
<tr>
<td>SQRT</td>
<td>求二次方根</td>
</tr>
<tr>
<td>MOD</td>
<td>求余数</td>
</tr>
<tr>
<td>CEIL 和 CEILING</td>
<td>两个函数功能相同，都是返回不小于参数的最小整数，即向上取整</td>
</tr>
<tr>
<td>FLOOR</td>
<td>向下取整，返回值转化为一个BIGINT</td>
</tr>
<tr>
<td>RAND</td>
<td>生成一个0~1之间的随机数，传入整数参数是，用来产生重复序列</td>
</tr>
<tr>
<td>ROUND</td>
<td>对所传参数进行四舍五入</td>
</tr>
<tr>
<td>SIGN</td>
<td>返回参数的符号</td>
</tr>
<tr>
<td>POW 和 POWER</td>
<td>两个函数的功能相同，都是所传参数的次方的结果值</td>
</tr>
<tr>
<td>SIN</td>
<td>求正弦值</td>
</tr>
<tr>
<td>ASIN</td>
<td>求反正弦值，与函数 SIN 互为反函数</td>
</tr>
<tr>
<td>COS</td>
<td>求余弦值</td>
</tr>
<tr>
<td>ACOS</td>
<td>求反余弦值，与函数 COS 互为反函数</td>
</tr>
<tr>
<td>TAN</td>
<td>求正切值</td>
</tr>
<tr>
<td>ATAN</td>
<td>求反正切值，与函数 TAN 互为反函数</td>
</tr>
<tr>
<td>COT</td>
<td>求余切值</td>
</tr>
</tbody></table>
<p><code>字符串函数</code></p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>LENGTH</td>
<td>计算字符串长度函数，返回字符串的字节长度</td>
</tr>
<tr>
<td>CONCAT</td>
<td>合并字符串函数，返回结果为连接参数产生的字符串，参数可以使一个或多个</td>
</tr>
<tr>
<td>INSERT</td>
<td>替换字符串函数</td>
</tr>
<tr>
<td>LOWER</td>
<td>将字符串中的字母转换为小写</td>
</tr>
<tr>
<td>UPPER</td>
<td>将字符串中的字母转换为大写</td>
</tr>
<tr>
<td>LEFT</td>
<td>从左侧字截取符串，返回字符串左边的若干个字符</td>
</tr>
<tr>
<td>RIGHT</td>
<td>从右侧字截取符串，返回字符串右边的若干个字符</td>
</tr>
<tr>
<td>TRIM</td>
<td>删除字符串左右两侧的空格</td>
</tr>
<tr>
<td>REPLACE</td>
<td>字符串替换函数，返回替换后的新字符串</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>截取字符串，返回从指定位置开始的指定长度的字符换</td>
</tr>
<tr>
<td>REVERSE</td>
<td>字符串反转（逆序）函数，返回与原始字符串顺序相反的字符串</td>
</tr>
</tbody></table>
<p><code>日期函数</code></p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作 用</th>
</tr>
</thead>
<tbody><tr>
<td>CURDATE 和 CURRENT_DATE</td>
<td>两个函数作用相同，返回当前系统的日期值</td>
</tr>
<tr>
<td>CURTIME 和 CURRENT_TIME</td>
<td>两个函数作用相同，返回当前系统的时间值</td>
</tr>
<tr>
<td>NOW 和 SYSDATE</td>
<td>两个函数作用相同，返回当前系统的日期和时间值</td>
</tr>
<tr>
<td>MONTH</td>
<td>获取指定日期中的月份</td>
</tr>
<tr>
<td>MONTHNAME</td>
<td>获取指定日期中的月份英文名称</td>
</tr>
<tr>
<td>DAYNAME</td>
<td>获取指定曰期对应的星期几的英文名称</td>
</tr>
<tr>
<td>DAYOFWEEK</td>
<td>获取指定日期对应的一周的索引位置值</td>
</tr>
<tr>
<td>WEEK</td>
<td>获取指定日期是一年中的第几周，返回值的范围是否为 0〜52 或 1〜53</td>
</tr>
<tr>
<td>DAYOFYEAR</td>
<td>获取指定曰期是一年中的第几天，返回值范围是1~366</td>
</tr>
<tr>
<td>DAYOFMONTH</td>
<td>获取指定日期是一个月中是第几天，返回值范围是1~31</td>
</tr>
<tr>
<td>YEAR</td>
<td>获取年份，返回值范围是 1970〜2069</td>
</tr>
<tr>
<td>TIME_TO_SEC</td>
<td>将时间参数转换为秒数</td>
</tr>
<tr>
<td>SEC_TO_TIME</td>
<td>将秒数转换为时间，与TIME_TO_SEC 互为反函数</td>
</tr>
<tr>
<td>DATE_ADD 和 ADDDATE</td>
<td>两个函数功能相同，都是向日期添加指定的时间间隔</td>
</tr>
<tr>
<td>DATE_SUB 和 SUBDATE</td>
<td>两个函数功能相同，都是向日期减去指定的时间间隔</td>
</tr>
<tr>
<td>ADDTIME</td>
<td>时间加法运算，在原始时间上添加指定的时间</td>
</tr>
<tr>
<td>SUBTIME</td>
<td>时间减法运算，在原始时间上减去指定的时间</td>
</tr>
<tr>
<td>DATEDIFF</td>
<td>获取两个日期之间间隔，返回参数 1 减去参数 2 的值</td>
</tr>
<tr>
<td>DATE_FORMAT</td>
<td>格式化指定的日期，根据参数返回指定格式的值</td>
</tr>
<tr>
<td>WEEKDAY</td>
<td>获取指定日期在一周内的对应的工作日索引</td>
</tr>
</tbody></table>
<p><code>聚合函数</code></p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>MAX</td>
<td>查询指定列的最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>查询指定列的最小值</td>
</tr>
<tr>
<td>COUNT</td>
<td>统计查询结果的行数</td>
</tr>
<tr>
<td>SUM</td>
<td>求和，返回指定列的总和</td>
</tr>
<tr>
<td>AVG</td>
<td>求平均值，返回指定列数据的平均值</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL SQL优化</title>
    <url>/2022/11/02/MySQL/13mysqlSQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="大批量插入数据"><a href="#大批量插入数据" class="headerlink" title="大批量插入数据"></a>大批量插入数据</h3><p>环境准备 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user_2` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `birthday` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `qq` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户状态&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `unique_user_username` (`username`)  <span class="comment">-- 唯一性约束</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br></pre></td></tr></table></figure>

<p>当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。</p>
<p><img src="https://img-blog.csdnimg.cn/8769c1c191944815a0ae880da7584c86.png" alt="在这里插入图片描述"></p>
<p><code>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</code></p>
<p>1） <code>主键顺序插入</code></p>
<blockquote>
<p>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">脚本文件介绍 :</span><br><span class="line">	sql1.log  <span class="comment">----&gt; 主键有序</span></span><br><span class="line">	sql2.log  <span class="comment">----&gt; 主键无序</span></span><br></pre></td></tr></table></figure>

<p>插入ID顺序排列数据：</p>
<p><img src="https://img-blog.csdnimg.cn/3eeee7c4ddd14728ba345752f193d096.png" alt="在这里插入图片描述"></p>
<p>插入ID无序排列数据：</p>
<p><img src="https://img-blog.csdnimg.cn/85b7043d074645b8bc27eb025581e1ab.png" alt="在这里插入图片描述"></p>
<p><strong>注意出现</strong>：【LOAD DATA语法上传数据】</p>
<blockquote>
<p>具体解法见 最后【Mysql笔记ERROR】 </p>
</blockquote>
<p>2） <code>关闭唯一性校验</code></p>
<blockquote>
<p>在导入数据前执行 SET UNIQUE_CHECKS&#x3D;0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS&#x3D;1，恢复唯一性校验，可以提高导入的效率。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2429433e5e64462cae19c178b0e493ad.png" alt="在这里插入图片描述"></p>
<p>3） <code>手动提交事务</code></p>
<blockquote>
<p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT&#x3D;0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT&#x3D;1，打开自动提交，也可以提高导入的效率。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/8c02a72b439b4de7a25898bd63a2a063.png" alt="在这里插入图片描述"></p>
<h3 id="优化insert语句"><a href="#优化insert语句" class="headerlink" title="优化insert语句"></a>优化insert语句</h3><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p>
<ul>
<li><p><code>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</code></p>
<p>示例， 原始方式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>优化后的方案为 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>)，(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>在事务中进行数据插入。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>数据有序插入</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>优化后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="优化order-by语句"><a href="#优化order-by语句" class="headerlink" title="优化order by语句"></a>优化order by语句</h3><h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2300&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;Luci&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2800&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;Jay&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;21&#x27;</span>,<span class="string">&#x27;2200&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;Jerry2&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;3300&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;Luci2&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2700&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;Jay2&#x27;</span>,<span class="string">&#x27;33&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;Tom3&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;2400&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;Jerry3&#x27;</span>,<span class="string">&#x27;32&#x27;</span>,<span class="string">&#x27;3100&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;Luci3&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2900&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;Jay3&#x27;</span>,<span class="string">&#x27;37&#x27;</span>,<span class="string">&#x27;4500&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary);</span><br></pre></td></tr></table></figure>

<h4 id="两种排序方式"><a href="#两种排序方式" class="headerlink" title="两种排序方式"></a>两种排序方式</h4><p>1). 第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。效率低</p>
<p><img src="https://img-blog.csdnimg.cn/0957f31eab274f9bb8651d0cf5b55479.png" alt="在这里插入图片描述"></p>
<p>2). 第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</p>
<p><img src="https://img-blog.csdnimg.cn/0648c7addd504f53b92850cac381bae7.png" alt="在这里插入图片描述"></p>
<p>多字段排序</p>
<p><img src="https://img-blog.csdnimg.cn/7a33402c2d7849f0a8de028f13742039.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>了解了MySQL的排序方式，优化目标就清晰了：尽量减少额外的排序，通过索引直接返回有序数据(using index)。where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order by 的字段都是升序，或者都是降序。否则肯定需要额外的操作，这样就会出现FileSort。</p>
</blockquote>
<h4 id="Filesort-的优化"><a href="#Filesort-的优化" class="headerlink" title="Filesort 的优化"></a>Filesort 的优化</h4><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p>
<p>1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I&#x2F;O操作。</p>
<p>2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</p>
<p><code>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。</code></p>
<p><code>可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。</code></p>
<p><img src="https://img-blog.csdnimg.cn/d824536e54584f3f9d392ab159ac4531.png" alt="在这里插入图片描述"></p>
<h3 id="优化group-by-语句"><a href="#优化group-by-语句" class="headerlink" title="优化group by 语句"></a>优化group by 语句</h3><p>由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p>
<p><code>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序</code>。如下 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_emp_age_salary <span class="keyword">on</span> emp;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e95eb390b1bf4bc2a82c291c18f41db6.png" alt="在这里插入图片描述"></p>
<p>优化后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/204a402778dd4725b425c2b493d7d829.png" alt="在这里插入图片描述"></p>
<p>从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order by null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。</p>
<p>创建索引 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary)；</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/37e5a52d9c434b4cbe1503843cf02571.png" alt="在这里插入图片描述"></p>
<h3 id="优化嵌套查询"><a href="#优化嵌套查询" class="headerlink" title="优化嵌套查询"></a>优化嵌套查询</h3><blockquote>
<p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p>
</blockquote>
<p>示例 ，查找有角色的所有的用户信息 :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> user_role );</span><br></pre></td></tr></table></figure>

<p>执行计划为 :</p>
<p><img src="https://img-blog.csdnimg.cn/2a00dfae6cf540adbf859622a5b905cc.png" alt="在这里插入图片描述"></p>
<p>优化后 :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user u , user_role ur <span class="keyword">where</span> u.id <span class="operator">=</span> ur.user_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/88a5a891fffb4f2a96190ddf94ede70c.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p>
</blockquote>
<h3 id="优化OR条件"><a href="#优化OR条件" class="headerlink" title="优化OR条件"></a>优化OR条件</h3><p><code>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。</code></p>
<p>获取 emp 表中的所有的索引 ：</p>
<p><img src="https://img-blog.csdnimg.cn/e0bfe065fc9943a3a11c0503d305cb85.png" alt="在这里插入图片描述"></p>
<p>示例 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/3f59e9403983471b9a0b6813274cc437.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/11cfc56fb9624ecb8709b5ed14915154.png" alt="在这里插入图片描述"></p>
<p><code>建议使用 union 替换 or </code>：</p>
<p><img src="https://img-blog.csdnimg.cn/b318b2837fc940209a746b587d0e3c69.png" alt="在这里插入图片描述"></p>
<p>我们来比较下重要指标，发现主要差别是 type 和 ref 这两项</p>
<p>type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">system</span> <span class="operator">&gt;</span> const <span class="operator">&gt;</span> eq_ref <span class="operator">&gt;</span> <span class="keyword">ref</span> <span class="operator">&gt;</span> fulltext <span class="operator">&gt;</span> ref_or_null  <span class="operator">&gt;</span> index_merge <span class="operator">&gt;</span> unique_subquery <span class="operator">&gt;</span> index_subquery <span class="operator">&gt;</span> <span class="keyword">range</span> <span class="operator">&gt;</span> index <span class="operator">&gt;</span> <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure>

<p>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</p>
<p>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快</p>
<p>这两项的差距就说明了 UNION 要优于 OR 。</p>
<h3 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h3><blockquote>
<p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时需要MySQL<strong>排序</strong>前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。<br><img src="https://img-blog.csdnimg.cn/7d1c903732cd458dabf4b817ecc9c785.png" alt="在这里插入图片描述"></p>
</blockquote>
<h4 id="优化思路一"><a href="#优化思路一" class="headerlink" title="优化思路一"></a>优化思路一</h4><p><code>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</code></p>
<p><img src="https://img-blog.csdnimg.cn/8282b1a66ca74e04b1e8260354efd386.png" alt="在这里插入图片描述"></p>
<h4 id="优化思路二"><a href="#优化思路二" class="headerlink" title="优化思路二"></a>优化思路二</h4><p><code>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</code>(局限性：主键不能断层)</p>
<p><img src="https://img-blog.csdnimg.cn/6c1074e6b9fb45d5a779fec8be683890.png" alt="在这里插入图片描述"></p>
<h3 id="使用SQL提示"><a href="#使用SQL提示" class="headerlink" title="使用SQL提示"></a>使用SQL提示</h3><blockquote>
<p>SQL提示，是优化数据库的一个重要手段，简单 来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
</blockquote>
<h4 id="USE-INDEX"><a href="#USE-INDEX" class="headerlink" title="USE INDEX"></a>USE INDEX</h4><p><code>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name <span class="keyword">on</span> tb_seller(name);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/8709a171617f4b3aaba50a9baa1abdd0.png" alt="在这里插入图片描述"></p>
<h4 id="IGNORE-INDEX"><a href="#IGNORE-INDEX" class="headerlink" title="IGNORE INDEX"></a>IGNORE INDEX</h4><p><code>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller ignore index(idx_seller_name) <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;小米科技&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/48052879a35c437486d40c71c2cf85fd.png" alt="在这里插入图片描述"></p>
<h4 id="FORCE-INDEX"><a href="#FORCE-INDEX" class="headerlink" title="FORCE INDEX"></a>FORCE INDEX</h4><p><code>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2b78c0f983f447f88c76b18b1e37b006.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL应用优化</title>
    <url>/2022/11/02/MySQL/15mysql%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>在前面，我们介绍了很多数据库的优化措施。但是在实际生产环境中，由于数据库本身的性能局限，就必须要对前台的应用进行一些优化，来降低数据库的访问压力。</p>
<h3 id="使用连接池"><a href="#使用连接池" class="headerlink" title="使用连接池"></a>使用连接池</h3><p>对于访问数据库来说，建立连接的代价是比较昂贵的，因为我们频繁的创建关闭连接，是比较耗费资源的，我们有必要建立 数据库连接池，以提高访问的性能。</p>
<h3 id="减少对MySQL的访问"><a href="#减少对MySQL的访问" class="headerlink" title="减少对MySQL的访问"></a>减少对MySQL的访问</h3><h4 id="避免对数据进行重复检索"><a href="#避免对数据进行重复检索" class="headerlink" title="避免对数据进行重复检索"></a>避免对数据进行重复检索</h4><p>在编写应用代码时，需要能够理清对数据库的访问逻辑。能够一次连接就获取到结果的，就不用两次连接，这样可以大大减少对数据库无用的重复请求。</p>
<p>比如 ，需要获取书籍的id 和name字段 ， 则查询如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id , name <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure>

<p>之后，在业务逻辑中有需要获取到书籍状态信息， 则查询如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id , status <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure>

<p>这样，就需要向数据库提交两次请求，数据库就要做两次查询操作。其实完全可以用一条SQL语句得到想要的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name , status <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure>

<h4 id="增加cache层"><a href="#增加cache层" class="headerlink" title="增加cache层"></a>增加cache层</h4><p>在应用中，我们可以在应用中增加 缓存 层来达到减轻数据库负担的目的。缓存层有很多种，也有很多实现方式，只要能达到降低数据库的负担又能满足应用需求就可以。</p>
<p>因此可以部分数据从数据库中抽取出来放到应用端以文本方式存储， 或者使用框架(Mybatis, Hibernate)提供的一级缓存&#x2F;二级缓存，或者使用redis数据库来缓存数据 。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>负载均衡是应用中使用非常普遍的一种优化方法，它的机制就是利用某种均衡算法，将固定的负载量分布到不同的服务器上， 以此来降低单台服务器的负载，达到优化的效果。</p>
<h4 id="利用MySQL复制分流查询"><a href="#利用MySQL复制分流查询" class="headerlink" title="利用MySQL复制分流查询"></a>利用MySQL复制分流查询</h4><p>通过MySQL的主从复制，实现读写分离，使增删改操作走主节点，查询操作走从节点，从而可以降低单台服务器的读写压力。</p>
<p><img src="https://img-blog.csdnimg.cn/c01fced0c14848ccb4a2fcb3bc1aef1b.png" alt="在这里插入图片描述"></p>
<h4 id="采用分布式数据库架构"><a href="#采用分布式数据库架构" class="headerlink" title="采用分布式数据库架构"></a>采用分布式数据库架构</h4><p>分布式数据库架构适合大数据量、负载高的情况，它有良好的拓展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载均衡，提高访问效率。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL内存管理和并发参数调整</title>
    <url>/2022/11/02/MySQL/17mysql%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E5%B9%B6%E5%8F%91%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h2 id="mysql内存管理及优化"><a href="#mysql内存管理及优化" class="headerlink" title="mysql内存管理及优化"></a>mysql内存管理及优化</h2><h3 id="内存优化原则"><a href="#内存优化原则" class="headerlink" title="内存优化原则"></a>内存优化原则</h3><p>1） 将尽量多的内存分配给MySQL做缓存，但要给操作系统和其他程序预留足够内存。</p>
<p>2） MyISAM 存储引擎的数据文件读取依赖于操作系统自身的IO缓存，因此，如果有MyISAM表，就要预留更多的内存给操作系统做IO缓存。</p>
<p>3） 排序区、连接区等缓存是分配给每个数据库会话（session）专用的，其默认值的设置要根据最大连接数合理分配，如果设置太大，不但浪费资源，而且在并发连接较高时会导致物理内存耗尽。</p>
<h3 id="MyISAM-内存优化"><a href="#MyISAM-内存优化" class="headerlink" title="MyISAM 内存优化"></a>MyISAM 内存优化</h3><blockquote>
<p>myisam存储引擎使用 key_buffer 缓存索引块，加速myisam索引的读写速度。对于myisam表的数据块，mysql没有特别的缓存机制，完全依赖于操作系统的IO缓存。</p>
</blockquote>
<h4 id="key-buffer-size"><a href="#key-buffer-size" class="headerlink" title="key_buffer_size"></a>key_buffer_size</h4><p>key_buffer_size决定MyISAM索引块缓存区的大小，直接影响到MyISAM表的存取效率。可以在MySQL参数文件中设置key_buffer_size的值，对于一般MyISAM数据库，建议至少将1&#x2F;4可用内存分配给key_buffer_size。</p>
<p>在&#x2F;usr&#x2F;my.cnf 中做如下配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">key_buffer_size<span class="operator">=</span><span class="number">512</span>M</span><br></pre></td></tr></table></figure>

<h4 id="read-buffer-size"><a href="#read-buffer-size" class="headerlink" title="read_buffer_size"></a>read_buffer_size</h4><p>如果需要经常顺序扫描myisam表，可以通过增大read_buffer_size的值来改善性能。但需要注意的是read_buffer_size是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p>
<h4 id="read-rnd-buffer-size"><a href="#read-rnd-buffer-size" class="headerlink" title="read_rnd_buffer_size"></a>read_rnd_buffer_size</h4><p>对于需要做排序的myisam表的查询，如带有order by子句的sql，适当增加 read_rnd_buffer_size 的值，可以改善此类的sql性能。但需要注意的是 read_rnd_buffer_size 是每个session独占的，如果默认值设置太大，就会造成内存浪费。</p>
<h3 id="InnoDB-内存优化"><a href="#InnoDB-内存优化" class="headerlink" title="InnoDB 内存优化"></a>InnoDB 内存优化</h3><blockquote>
<p>innodb用一块内存区做IO缓存池，该缓存池不仅用来缓存innodb的索引块，而且也用来缓存innodb的数据块。</p>
</blockquote>
<h4 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a>innodb_buffer_pool_size</h4><p>该变量决定了 innodb 存储引擎表数据和索引数据的最大缓存区大小。在保证操作系统及其他程序有足够内存可用的情况下，innodb_buffer_pool_size 的值越大，缓存命中率越高，访问InnoDB表需要的磁盘I&#x2F;O 就越少，性能也就越高。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">innodb_buffer_pool_size<span class="operator">=</span><span class="number">512</span>M</span><br></pre></td></tr></table></figure>

<h4 id="innodb-log-buffer-size"><a href="#innodb-log-buffer-size" class="headerlink" title="innodb_log_buffer_size"></a>innodb_log_buffer_size</h4><p>决定了innodb重做日志缓存的大小，对于可能产生大量更新记录的大事务，增加innodb_log_buffer_size的大小，可以避免innodb在事务提交前就执行不必要的日志写入磁盘操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">innodb_log_buffer_size<span class="operator">=</span><span class="number">10</span>M</span><br></pre></td></tr></table></figure>

<h2 id="Mysql并发参数调整"><a href="#Mysql并发参数调整" class="headerlink" title="Mysql并发参数调整"></a>Mysql并发参数调整</h2><p>从实现上来说，MySQL Server 是多线程结构，包括后台线程和客户服务线程。多线程可以有效利用服务器资源，提高数据库的并发性能。在Mysql中，控制并发连接和线程的主要参数包括 max_connections、back_log、thread_cache_size、table_open_cahce。</p>
<h3 id="max-connections"><a href="#max-connections" class="headerlink" title="max_connections"></a>max_connections</h3><p>采用max_connections 控制允许连接到MySQL数据库的最大数量，默认值是 151。如果状态变量 connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections的值。</p>
<p>Mysql 最大可支持的连接数，取决于很多因素，包括给定操作系统平台的线程库的质量、内存大小、每个连接的负荷、CPU的处理速度，期望的响应时间等。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。</p>
<h3 id="back-log"><a href="#back-log" class="headerlink" title="back_log"></a>back_log</h3><p>back_log 参数控制MySQL监听TCP端口时设置的积压请求栈大小。<code>如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。</code>5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 但最大不超过900。</p>
<p>如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</p>
<h3 id="table-open-cache"><a href="#table-open-cache" class="headerlink" title="table_open_cache"></a>table_open_cache</h3><p>该参数用来控制所有SQL语句执行线程可打开表缓存的数量， 而在执行SQL语句时，每一个SQL执行线程至少要打开 1 个表缓存。该参数的值应该根据设置的最大连接数 max_connections 以及每个连接执行关联查询中涉及的表的最大数量来设定 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">max_connections x N ；</span><br></pre></td></tr></table></figure>

<h3 id="thread-cache-size"><a href="#thread-cache-size" class="headerlink" title="thread_cache_size"></a>thread_cache_size</h3><p>为了加快连接数据库的速度，MySQL 会缓存一定数量的客户服务线程以备重用，通过参数 thread_cache_size 可控制 MySQL 缓存客户服务线程的数量。(在MySQL Server端设置了线程池的大小)</p>
<h3 id="innodb-lock-wait-timeout"><a href="#innodb-lock-wait-timeout" class="headerlink" title="innodb_lock_wait_timeout"></a>innodb_lock_wait_timeout</h3><p>该参数是用来设置InnoDB 事务等待行锁的时间，默认值是50s ， 可以根据需要进行动态设置。<code>对于需要快速反馈的业务系统来说，可以将行锁的等待时间调小，以避免事务长时间挂起； 对于后台运行的批量处理程序来说， 可以将行锁的等待时间调大， 以避免发生大的回滚操作。</code></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL查询缓存优化</title>
    <url>/2022/11/02/MySQL/16mysql%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>开启Mysql的查询缓存，当执行完全相同的SQL语句的时候，服务器就会直接从缓存中读取结果，当数据被修改，之前的缓存会失效，修改比较频繁的表不适合做查询缓存。</p>
</blockquote>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p><img src="https://img-blog.csdnimg.cn/986ad0e888c1442b95700fcbe1ee5ab4.png" alt="在这里插入图片描述"></p>
<ol>
<li>客户端发送一条查询给服务器；</li>
<li>服务器先会检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li>
<li>服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划；</li>
<li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询；</li>
<li>将结果返回给客户端。</li>
</ol>
<h3 id="查询缓存配置"><a href="#查询缓存配置" class="headerlink" title="查询缓存配置"></a>查询缓存配置</h3><ol>
<li><p>查看当前的MySQL数据库是否支持查询缓存：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;have_query_cache&#x27;</span>;	</span><br></pre></td></tr></table></figure>

<p>  <img src="https://img-blog.csdnimg.cn/eaac2d686fa74d609a044f449248f5ec.png" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>Mysql8，已经取消了查询缓存</strong> </p>
</li>
<li><p>查看当前MySQL是否开启了查询缓存 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_type&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p> <img src="https://img-blog.csdnimg.cn/631c8d0b6ecc434dbc2ade2ae2395422.png" alt="在这里插入图片描述"></p>
</li>
<li><p>查看查询缓存的占用大小 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;query_cache_size&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p> <img src="https://img-blog.csdnimg.cn/240bac9a78334269aaf7e86a8c415ed7.png" alt="在这里插入图片描述"></p>
</li>
<li><p>查看查询缓存的状态变量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Qcache%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p> <img src="https://img-blog.csdnimg.cn/b64d0ba3085042e283d8600203c471ee.png" alt="在这里插入图片描述"></p>
<p>各个变量的含义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Qcache_free_blocks</td>
<td>查询缓存中的可用内存块数</td>
</tr>
<tr>
<td>Qcache_free_memory</td>
<td>查询缓存的可用内存量</td>
</tr>
<tr>
<td><code>Qcache_hits</code></td>
<td><code>查询缓存命中数</code></td>
</tr>
<tr>
<td><code>Qcache_inserts</code></td>
<td><code>添加到查询缓存的查询数</code></td>
</tr>
<tr>
<td>Qcache_lowmen_prunes</td>
<td>由于内存不足而从查询缓存中删除的查询数</td>
</tr>
<tr>
<td><code>Qcache_not_cached</code></td>
<td><code>非缓存查询的数量（由于 query_cache_type 设置而无法缓存或未缓存）</code></td>
</tr>
<tr>
<td>Qcache_queries_in_cache</td>
<td>查询缓存中注册的查询数</td>
</tr>
<tr>
<td>Qcache_total_blocks</td>
<td>查询缓存中的块总数</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="开启查询缓存"><a href="#开启查询缓存" class="headerlink" title="开启查询缓存"></a>开启查询缓存</h3><p>MySQL的查询缓存默认是关闭的，需要手动配置参数 query_cache_type ， 来开启查询缓存。query_cache_type 该参数的可取值有三个 ：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>OFF 或 0</td>
<td>查询缓存功能关闭</td>
</tr>
<tr>
<td>ON 或 1</td>
<td>查询缓存功能打开，SELECT的结果符合缓存条件即会缓存，否则，不予缓存，显式指定 SQL_NO_CACHE，不予缓存</td>
</tr>
<tr>
<td>DEMAND 或 2</td>
<td>查询缓存功能按需进行，显式指定 SQL_CACHE 的SELECT语句才会缓存；其它均不予缓存</td>
</tr>
</tbody></table>
<p>在 &#x2F;usr&#x2F;my.cnf 配置中，增加以下配置 ：</p>
<p><code>query_cache_type=1</code></p>
<p>配置完毕之后，重启服务既可生效 ；</p>
<p>然后就可以在命令行执行SQL语句进行验证 ，执行一条比较耗时的SQL语句，然后再多执行几次，查看后面几次的执行时间；获取通过查看查询缓存的缓存命中数，来判定是否走查询缓存。</p>
<h3 id="查询缓存SELECT选项"><a href="#查询缓存SELECT选项" class="headerlink" title="查询缓存SELECT选项"></a>查询缓存SELECT选项</h3><p>可以在SELECT语句中指定两个与查询缓存相关的选项 ：</p>
<p><code>SQL_CACHE : 如果查询结果是可缓存的，并且 query_cache_type 系统变量的值为ON或 DEMAND ，则缓存查询结果 。</code></p>
<p><code>SQL_NO_CACHE : 服务器不使用查询缓存。它既不检查查询缓存，也不检查结果是否已缓存，也不缓存查询结果。</code></p>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SQL_CACHE id, name <span class="keyword">FROM</span> customer;</span><br><span class="line"><span class="keyword">SELECT</span> SQL_NO_CACHE id, name <span class="keyword">FROM</span> customer;</span><br></pre></td></tr></table></figure>

<h3 id="查询缓存失效的情况"><a href="#查询缓存失效的情况" class="headerlink" title="查询缓存失效的情况"></a>查询缓存失效的情况</h3><p>1）<code> SQL 语句不一致的情况， 要想命中查询缓存，查询的SQL语句必须一致。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL1 : <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item;</span><br><span class="line">SQL2 : <span class="keyword">Select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_item;</span><br></pre></td></tr></table></figure>

<p>2） <code>当查询语句中有一些不确定的时，则不会缓存。如 ： now() , current_date() , curdate() , curtime() , rand() , uuid() , user() , database() 。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SQL1 : <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> updatetime <span class="operator">&lt;</span> now() limit <span class="number">1</span>;</span><br><span class="line">SQL2 : <span class="keyword">select</span> <span class="keyword">user</span>();</span><br><span class="line">SQL3 : <span class="keyword">select</span> database();</span><br></pre></td></tr></table></figure>

<p>3） <code>不使用任何表查询语句。</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>4）<code> 查询 mysql， information_schema或 performance_schema 数据库中的表时，不会走查询缓存。</code>(默认的系统数据库)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.engines;</span><br></pre></td></tr></table></figure>

<p>5） <code>在存储的函数，触发器或事件的主体内执行的查询。</code></p>
<p>6） <code>如果表更改，则使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除</code>。这包括使用<code>MERGE</code>映射到已更改表的表的查询。一个表可以被许多类型的语句，如被改变 INSERT， UPDATE， DELETE， TRUNCATE TABLE， ALTER TABLE， DROP TABLE，或 DROP DATABASE 。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL复制</title>
    <url>/2022/11/02/MySQL/19mysql%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h3 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h3><p>复制是指将主数据库的DDL 和 DML 操作通过<code>二进制日志</code>传到从库服务器中，然后在从库上对这些日志重新执行（也叫重做），从而使得从库和主库的数据保持同步。</p>
<p>MySQL支持一台主库同时向多台从库进行复制， 从库同时也可以作为其他从服务器的主库，实现链状复制。</p>
<h3 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h3><p>MySQL 的主从复制原理如下。</p>
<p><img src="https://img-blog.csdnimg.cn/d7dc2ac097814bed999e08106b4d5fab.png" alt="在这里插入图片描述"></p>
<p>从上层来看，复制分成三步：</p>
<ul>
<li><code>Master 主库在事务提交时，会把数据变更作为时间 Events 记录在二进制日志文件 Binlog 中。</code></li>
<li><code>主库推送二进制日志文件 Binlog 中的日志事件到从库的中继日志 Relay Log 。</code></li>
<li><code>slave重做中继日志中的事件，将改变反映它自己的数据。</code></li>
</ul>
<h3 id="复制优势"><a href="#复制优势" class="headerlink" title="复制优势"></a>复制优势</h3><p>MySQL 复制的有点主要包含以下三个方面：</p>
<ul>
<li><code>主库出现问题，可以快速切换到从库提供服务。</code></li>
<li><code>可以在从库上执行查询操作，从主库中更新，实现读写分离，降低主库的访问压力。</code></li>
<li><code>可以在从库中执行备份，以避免备份期间影响主库的服务。</code></li>
</ul>
<h3 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h3><h4 id="master"><a href="#master" class="headerlink" title="master"></a>master</h4><p>1） 在master 的配置文件（&#x2F;usr&#x2F;my.cnf）中，配置如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql 服务ID,保证整个集群环境中唯一</span></span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql binlog 日志的存储路径和文件名</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br><span class="line"></span><br><span class="line"><span class="comment">#错误日志,默认已经开启</span></span><br><span class="line"><span class="comment">#log-err</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的安装目录</span></span><br><span class="line"><span class="comment">#basedir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的临时目录</span></span><br><span class="line"><span class="comment">#tmpdir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#mysql的数据存放目录</span></span><br><span class="line"><span class="comment">#datadir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否只读,1 代表只读, 0 代表读写</span></span><br><span class="line">read-only=0</span><br><span class="line"></span><br><span class="line"><span class="comment">#忽略的数据, 指不需要同步的数据库</span></span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定同步的数据库</span></span><br><span class="line"><span class="comment">#binlog-do-db=db01</span></span><br></pre></td></tr></table></figure>

<p>2） 执行完毕之后，需要重启Mysql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">service mysql restart ；</span><br></pre></td></tr></table></figure>

<p>3） <strong>创建同步数据的账户</strong>，并且进行授权操作：为了完成主从复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;192.168.192.131&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;itcast&#x27;</span>;	</span><br><span class="line"></span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主服务器的ip是192.168.192.130</span></span><br><span class="line"><span class="comment">-- 从服务器的ip是192.168.192.131</span></span><br></pre></td></tr></table></figure>

<p>4） 查看master状态：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/e5bdd59d9ace47999e9bad9eab66547c.png" alt="在这里插入图片描述"></p>
<p>字段含义：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">File : 从哪个日志文件开始推送日志文件 </span><br><span class="line">Position ： 从哪个位置开始推送日志</span><br><span class="line">Binlog_Ignore_DB : 指定不需要同步的数据库</span><br></pre></td></tr></table></figure>

<h4 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h4><p>1） 在 slave 端配置文件中，配置如下内容：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mysql服务端ID,唯一</span></span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line"><span class="comment">#指定binlog日志</span></span><br><span class="line">log-bin=/var/lib/mysql/mysqlbin</span><br></pre></td></tr></table></figure>

<p>2） 执行完毕之后，需要重启Mysql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">service mysql restart；</span><br></pre></td></tr></table></figure>

<p>3） 执行如下指令 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span> <span class="string">&#x27;192.168.192.130&#x27;</span>, master_user<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, master_password<span class="operator">=</span><span class="string">&#x27;itcast&#x27;</span>, master_log_file<span class="operator">=</span><span class="string">&#x27;mysqlbin.000001&#x27;</span>, master_log_pos<span class="operator">=</span><span class="number">413</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定主节点的ip，账户，密码，二进制日志文件名称，以及从哪一行开始同步</span></span><br></pre></td></tr></table></figure>

<p>指定当前从库对应的主库的IP地址，用户名，密码，从哪个日志文件开始的那个位置开始同步推送日志。</p>
<p>4） 开启同步操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> slave;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> slave status \G;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/60de16bdfe1d4160b832a268980f7c41.png" alt="在这里插入图片描述"></p>
<p>5） 停止同步操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<h4 id="验证同步操作"><a href="#验证同步操作" class="headerlink" title="验证同步操作"></a>验证同步操作</h4><p>1） 在主库中创建数据库，创建表，并插入数据 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span> db01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">	id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">	sex <span class="type">varchar</span>(<span class="number">1</span>),</span><br><span class="line">	<span class="keyword">primary</span> key (id)</span><br><span class="line">)engine<span class="operator">=</span>innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Trigger&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,sex) <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Dawn&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>2） 在从库中查询数据，进行验证 ：</p>
<p>在从库中，可以查看到刚才创建的数据库：</p>
<p><img src="https://img-blog.csdnimg.cn/cbab063bb1724ad692ab92dc27349285.png" alt="在这里插入图片描述"></p>
<p>在该数据库中，查询user表中的数据：</p>
<p><img src="https://img-blog.csdnimg.cn/336eb0fbe346429b97fe11e445677a50.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL锁问题</title>
    <url>/2022/11/02/MySQL/18mysql%E9%94%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）。</p>
<p>在数据库中，除传统的计算资源（如 CPU、RAM、I&#x2F;O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p>从对数据操作的粒度分 ：</p>
<p>1） 表锁：操作时，会锁定整个表。</p>
<p>2） 行锁：操作时，会锁定当前操作行。</p>
<p>从对数据操作的类型分：</p>
<p>1） 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</p>
<p>2） 写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</p>
<h3 id="Mysql-锁"><a href="#Mysql-锁" class="headerlink" title="Mysql 锁"></a>Mysql 锁</h3><p>相对其他数据库而言，MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。下表中罗列出了各存储引擎对锁的支持情况：</p>
<table>
<thead>
<tr>
<th>存储引擎</th>
<th>表级锁</th>
<th>行级锁</th>
<th>页面锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td><code>支持</code></td>
<td><code>不支持</code></td>
<td>不支持</td>
</tr>
<tr>
<td>InnoDB</td>
<td><code>支持</code></td>
<td><code>支持</code>(默认)</td>
<td>不支持</td>
</tr>
<tr>
<td>MEMORY</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>BDB</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
</tbody></table>
<p>MySQL这3种锁的特性可大致归纳如下 ：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>表级锁</td>
<td><code>偏向MyISAM 存储引擎，开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</code></td>
</tr>
<tr>
<td>行级锁</td>
<td><code>偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</code></td>
</tr>
<tr>
<td>页面锁</td>
<td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</td>
</tr>
</tbody></table>
<p>从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说：表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p>
<h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 存储引擎只支持表锁，这也是MySQL开始几个版本中唯一支持的锁类型。</p>
<h4 id="如何加表锁"><a href="#如何加表锁" class="headerlink" title="如何加表锁"></a>如何加表锁</h4><blockquote>
<p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p>
</blockquote>
<p>显示加表锁语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">加读锁 ： lock <span class="keyword">table</span> table_name read;</span><br><span class="line"></span><br><span class="line">加写锁 ： lock <span class="keyword">table</span> table_name write；</span><br></pre></td></tr></table></figure>

<h4 id="读锁案例"><a href="#读锁案例" class="headerlink" title="读锁案例"></a>读锁案例</h4><p>准备环境</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database demo_03 <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_03;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_book` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `publish_time` <span class="type">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;java编程思想&#x27;</span>,<span class="string">&#x27;2088-08-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_book (id, name, publish_time, status) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;solr编程思想&#x27;</span>,<span class="string">&#x27;2088-08-08&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user` (</span><br><span class="line">  `id` <span class="type">INT</span>(<span class="number">11</span>) auto_increment,</span><br><span class="line">  `name` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>myisam <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user (id, name) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;令狐冲&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_user (id, name) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;田伯光&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>客户端 一 ：</p>
<p>1）获得tb_book 表的读锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock <span class="keyword">table</span> tb_book read;</span><br></pre></td></tr></table></figure>

<p>客户端 一 ：</p>
<p>2） 执行查询操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/aaa91d7ac3ac44ab8a14c7b5d6f77fe9.png" alt="在这里插入图片描述"></p>
<p>可以正常执行 ， 查询出数据。</p>
<p>客户端 二 ：</p>
<p>3） 执行查询操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/bccf624f7ac149c1805ae6a848e4902b.png" alt="在这里插入图片描述"></p>
<p>也可以正常执行，查询出数据。</p>
<p>客户端 一 ：</p>
<p>4）查询未锁定的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/1b5deda15ba04d0cb5466ab0294177ef.png" alt="在这里插入图片描述"></p>
<p>客户端一查询未锁定的表失败。因为持有了一张tb_book的读锁，并未释放锁。</p>
<p>客户端 二 ：</p>
<p>5）查询未锁定的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name <span class="keyword">from</span> tb_seller;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/197275f466f246098192a97f12607c98.png" alt="在这里插入图片描述"></p>
<p>可以正常查询出未锁定的表；</p>
<p>客户端 一 ：</p>
<p>6） 执行插入操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/0f9a81df3e0343bfb96ab135e7b9506c.png" alt="在这里插入图片描述"></p>
<p>执行插入， 直接报错 ， 由于当前tb_book 获得的是 读锁， 不能执行更新操作。只能读</p>
<p>客户端 二 ：</p>
<p>7） 执行插入操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Mysql高级&#x27;</span>,<span class="string">&#x27;2088-01-01&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/3ad75a033c344906816a8c644b9e2b74.png" alt="在这里插入图片描述"></p>
<p>当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 inesrt 语句 ， 立即执行 ；</p>
<blockquote>
<p>如果对某一张表加了读锁，不会阻塞其它线程的读操作，但是会阻塞其它线程的写操作。</p>
</blockquote>
<h4 id="写锁案例"><a href="#写锁案例" class="headerlink" title="写锁案例"></a>写锁案例</h4><p>客户端 一 :</p>
<p>1）获得tb_book 表的写锁</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">lock <span class="keyword">table</span> tb_book write ;</span><br></pre></td></tr></table></figure>

<p>客户端 一 :</p>
<p>2）执行查询操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book ;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/792a99a15efb4904967f3e817b626e03.png" alt="在这里插入图片描述"></p>
<p>查询操作执行成功；加了写锁可以读。</p>
<p>客户端 一 :</p>
<p>3）执行更新操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_book <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;java编程思想（第二版）&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/ab20cd5f7b93423b946c754da141fab4.png" alt="在这里插入图片描述"></p>
<p>更新操作执行成功 ；（加了写锁当然可以写）</p>
<p>客户端 二 :</p>
<p>4）执行查询操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book ;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/6f09ed7581834d229f180c8824f32d6a.png" alt="在这里插入图片描述"></p>
<p>当在客户端一中释放锁指令 unlock tables 后 ， 客户端二中的 select 语句 ， 立即执行 ；（因为客户端一线程加的是写锁，写锁是排他锁，会阻断其他线程的读和写操作）</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>锁模式的相互兼容性如表中所示：</p>
<p><img src="https://img-blog.csdnimg.cn/58b6ddcc90764e7bbf5522c53a4de22a.png" alt="在这里插入图片描述"></p>
<p>由上表可见：</p>
<p> 1） <code>对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</code></p>
<p> 2） <code>对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</code></p>
<p> <code>简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</code></p>
<blockquote>
<p>此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p>
</blockquote>
<h4 id="查看锁的争用情况"><a href="#查看锁的争用情况" class="headerlink" title="查看锁的争用情况"></a>查看锁的争用情况</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/ee829cc97280451181d682137c76aed4.png" alt="在这里插入图片描述"></p>
<p>In_user : 表当前被查询使用的次数。如果该数为零，则表是打开的，但是当前没有被使用。</p>
<p>Name_locked：表名称是否被锁定。名称锁定用于取消表或对表进行重命名等操作。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Table_locks%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/b497c1e9dc4049a1a16c100c0e7eb1e7.png" alt="在这里插入图片描述"></p>
<p>Table_locks_immediate ： 指的是能够立即获得表级锁的次数，每立即获取锁，值加1。</p>
<p><code>Table_locks_waited ： 指的是不能立即获取表级锁而需要等待的次数，每等待一次，该值加1，此值高说明存在着较为严重的表级锁争用情况。</code></p>
<br>

<h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><h4 id="行锁介绍"><a href="#行锁介绍" class="headerlink" title="行锁介绍"></a>行锁介绍</h4><blockquote>
<p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
</blockquote>
<p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是采用了行级锁。</p>
<h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><p><strong>事务及其ACID属性</strong></p>
<p>事务是由一组SQL语句组成的逻辑处理单元。</p>
<p>事务具有以下4个特性，简称为事务ACID属性。</p>
<table>
<thead>
<tr>
<th>ACID属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（Atomicity）</td>
<td>事务是一个原子操作单元，其对数据的修改，要么全部成功，要么全部失败。</td>
</tr>
<tr>
<td>一致性（Consistent）</td>
<td>在事务开始和完成时，数据都必须保持一致状态。</td>
</tr>
<tr>
<td>隔离性（Isolation）</td>
<td>数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的 “独立” 环境下运行。</td>
</tr>
<tr>
<td>持久性（Durable）</td>
<td>事务完成之后，对于数据的修改是永久的。</td>
</tr>
</tbody></table>
<p><strong>并发事务处理带来的问题</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>丢失更新（Lost Update）</td>
<td>当两个或多个事务选择同一行，最初的事务修改的值，会被后面的事务修改的值覆盖。</td>
</tr>
<tr>
<td>脏读（Dirty Reads）</td>
<td>当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。</td>
</tr>
<tr>
<td>不可重复读（Non-Repeatable Reads）</td>
<td>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现和以前读出的数据不一致。</td>
</tr>
<tr>
<td>幻读（Phantom Reads）</td>
<td>一个事务按照相同的查询条件重新读取以前查询过的数据，却发现其他事务插入了满足其查询条件的新数据。</td>
</tr>
</tbody></table>
<p><strong>事务隔离级别</strong></p>
<p>为了解决上述提到的事务并发问题，数据库提供一定的事务隔离机制来解决这个问题。数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使用事务在一定程度上“串行化” 进行，这显然与“并发” 是矛盾的。</p>
<p>数据库的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏写、脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>丢失更新</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>Read uncommitted</td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Read committed</td>
<td>×</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>Repeatable read（默认）</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>Serializable</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>备注 ： √ 代表可能出现 ， × 代表不会出现 。</p>
<p>Mysql 的数据库的默认隔离级别为 Repeatable read ， 查看方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;tx_isolation&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/ba623c2ae6ac4e88ab19827865140a7a.png" alt="在这里插入图片描述"></p>
<h4 id="InnoDB-的行锁模式"><a href="#InnoDB-的行锁模式" class="headerlink" title="InnoDB 的行锁模式"></a>InnoDB 的行锁模式</h4><p>InnoDB 实现了以下两种类型的行锁。</p>
<ul>
<li>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</li>
<li>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</li>
</ul>
<p><code>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</code></p>
<p><code>对于普通SELECT语句，InnoDB不会加任何锁；</code></p>
<p>可以通过以下语句显示给记录集加共享锁或排他锁 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">共享锁（S）：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"></span><br><span class="line">排他锁（X) ：<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>    （悲观锁）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>悲观锁和乐观锁</strong></p>
<p>悲观锁：事务必须排队执行。数据锁住了，不允许并发。（行级锁：select后面添加for update）</p>
<p>乐观锁：支持并发，事务也不需要排队，只不过需要一个版本号。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Cz5HPKPl-1645446071152)(C:\Users\28097\Desktop\java笔记\MySQL高级.assets\image-20210701184001613.png)]</p>
</blockquote>
<h4 id="案例准备工作"><a href="#案例准备工作" class="headerlink" title="案例准备工作"></a>案例准备工作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_innodb_lock(</span><br><span class="line">	id <span class="type">int</span>(<span class="number">11</span>),</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">	sex <span class="type">varchar</span>(<span class="number">1</span>)</span><br><span class="line">)engine <span class="operator">=</span> innodb <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;100&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;400&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;500&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;600&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;700&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">&#x27;800&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">&#x27;900&#x27;</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_innodb_lock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;200&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_test_innodb_lock_id <span class="keyword">on</span> test_innodb_lock(id);</span><br><span class="line"><span class="keyword">create</span> index idx_test_innodb_lock_name <span class="keyword">on</span> test_innodb_lock(name);</span><br></pre></td></tr></table></figure>

<h4 id="行锁基本演示"><a href="#行锁基本演示" class="headerlink" title="行锁基本演示"></a>行锁基本演示</h4><p><img src="https://img-blog.csdnimg.cn/32c73744e9ec4b0abaa7d975a37367c1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>如果执行了更新语句，会对这一行数据加上排他锁（写锁），提交commit之后，会释放锁。另外一个线程update语句才可以执行解除阻塞状态。前提是两个线程操作同一行数据。</p>
</blockquote>
<h4 id="无索引行锁升级为表锁"><a href="#无索引行锁升级为表锁" class="headerlink" title="无索引行锁升级为表锁"></a>无索引行锁升级为表锁</h4><blockquote>
<p>如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟表锁一样。</p>
</blockquote>
<p>查看当前表的索引 ： show index from test_innodb_lock ;</p>
<p><img src="https://img-blog.csdnimg.cn/4be34ce7e7294477b20a937ddf5b2812.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/020d2a85cab440cc8997b4cc4be44f60.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>由于 执行更新时 ， name字段本来为varchar类型， 我们是作为数组类型使用，存在类型转换，索引失效，最终行锁变为表锁 ；(字符串类型，在SQL语句使用的时候没有加单引号，导致索引失效，查询没有走索引，进行全表扫描时，索引失效，行锁就升级为表锁)</p>
</blockquote>
<h4 id="间隙锁危害"><a href="#间隙锁危害" class="headerlink" title="间隙锁危害"></a>间隙锁危害</h4><blockquote>
<p>当我们用范围条件，而不是使用相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据进行加锁； 对于键值在条件范围内但并不存在的记录，叫做 “间隙（GAP）” ， InnoDB也会对这个 “间隙” 加锁，这种锁机制就是所谓的 间隙锁（Next-Key锁） 。</p>
</blockquote>
<p>示例 ：</p>
<p><img src="https://img-blog.csdnimg.cn/28f2751249444014ba33bac7b3e70b7a.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>怎样避免间隙锁呢？</p>
<p>在更新的时候，或者对数据行进行加锁的时候，尽量去缩小条件，使得间隙数据尽量的少，最大程度避免间隙锁的存在。</p>
</blockquote>
<h4 id="InnoDB-行锁争用情况"><a href="#InnoDB-行锁争用情况" class="headerlink" title="InnoDB 行锁争用情况"></a>InnoDB 行锁争用情况</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span>  status <span class="keyword">like</span> <span class="string">&#x27;innodb_row_lock%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/a749911338eb48889a008ec608a3be92.png" alt="在这里插入图片描述"></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Innodb<span class="emphasis">_row_</span>lock<span class="emphasis">_current_</span>waits: 当前正在等待锁定的数量</span><br><span class="line"></span><br><span class="line">Innodb<span class="emphasis">_row_</span>lock<span class="emphasis">_time: 从系统启动到现在锁定总时间长度</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">`Innodb_</span>row<span class="emphasis">_lock_</span>time<span class="emphasis">_avg:每次等待所花平均时长</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">Innodb_</span>row<span class="emphasis">_lock_</span>time<span class="emphasis">_max:从系统启动到现在等待最长的一次所花的时间</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">`Innodb_</span>row<span class="emphasis">_lock_</span>waits: 系统启动后到现在总共等待的次数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当等待的次数很高，而且每次等待的时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</span><br></pre></td></tr></table></figure>

<h4 id="5-5-9-总结"><a href="#5-5-9-总结" class="headerlink" title="5.5.9 总结"></a>5.5.9 总结</h4><blockquote>
<p>InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面带来了性能损耗可能比表锁会更高一些，但是在整体并发处理能力方面要远远由于MyISAM的表锁的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势。</p>
</blockquote>
<blockquote>
<p>但是，InnoDB的行级锁同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。</p>
</blockquote>
<p>优化建议：</p>
<ul>
<li>尽可能让所有数据检索都能通过索引来完成，避免无索引行锁升级为表锁。</li>
<li>合理设计索引，尽量缩小锁的范围。</li>
<li>尽可能减少索引条件，及索引范围，避免间隙锁。</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度。</li>
<li>尽可使用低级别事务隔离（但是需要业务层面满足需求）。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS安装MySQL</title>
    <url>/2022/11/02/MySQL/1centos%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<h2 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h2><p><strong>1.下载mysql软件包</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql80-community-release-el8-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/c6645ce924da4c678da4a0854699535b.png" alt="请添加图片描述"></p>
<p><strong>2.安装数据源</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql80-community-release-el8-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/99e021dc164149008c67439bfd58b0af.png" alt="请添加图片描述"></p>
<p><strong>3.检查数据源</strong></p>
<p>查看mysql源是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum repolist enabled | grep <span class="string">&quot;mysql.*-community.*&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/744f6d43c4714144964c590bf6057c0f.png" alt="请添加图片描述"></p>
<p><strong>4.禁用centos8自带的mysql模块</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum module <span class="built_in">disable</span> mysql</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/da850f20972441faa044e380cb2c581a.png" alt="请添加图片描述"></p>
<p><strong>5.安装数据库</strong></p>
<p>真正按安装mysql：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql-community-server</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/289a4f56ea7d4945995eeaf00f20bdaf.png" alt="请添加图片描述"></p>
<p><strong>6.启动mysql</strong></p>
<p>启动mysql服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/de5da238b65b4d95baa178c80a92d313.png" alt="请添加图片描述"></p>
<p>查看mysql运行状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld status</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://img-blog.csdnimg.cn/3e9be3b730b045d1b6b8717aefdb8e71.png" alt="请添加图片描述"></p>
<p><strong>7.显示mysql的随机密码</strong></p>
<p>查看mysql生成的随机密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;temporary password&#x27;</span> /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>进入mysql服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p [随机密码]</span><br></pre></td></tr></table></figure>

<p><strong>如果这个日志文件是空的，按以下步骤来进行：</strong></p>
<ul>
<li>首先使用 <code>find / -name my.cnf</code> 查询<code>my.cnf</code>文件路径</li>
<li>然后在 <code>[mysqld]</code>下面加上 <code>skip-grant-tables</code> ,表示跳过数据库权限验证，就可以不用密码进入mysql服务</li>
<li>使用 <code>service mysqld restart</code> 命令重启<code>mysqld</code>服务</li>
<li>使用<code>mysql -uroot -p</code>，输入密码的时候直接回车即可</li>
</ul>
<p><strong>8.修改mysql密码</strong></p>
<p>切换到mysql数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure>
<p>修改密码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">user</span> <span class="keyword">set</span> password<span class="operator">=</span>password(&quot;123456&quot;) <span class="keyword">where</span> <span class="keyword">user</span> <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/385632ded4814c7cb66c444a7960f50e.png" alt="请添加图片描述"></p>
<p><strong>查看密码</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;validate_password%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> 修改密码长度：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.length<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>修改密码等级：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>9.mysql开放远程访问</strong></p>
<p>1、先创建权限记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>2、授权：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">with</span> <span class="keyword">grant</span> option;</span><br></pre></td></tr></table></figure>

<p><strong>10.开放防火墙端口</strong></p>
<p>mysql8.0默认采用caching_sha2_password的加密方式。sqlyog不支持这种加密方式。</p>
<p>1、修改密码过期</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span><span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span> PASSWORD EXPIRE NEVER;</span><br></pre></td></tr></table></figure>

<p>2、重新修改密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span><span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>3、刷新权限（不做可能无法生效）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p><strong>11.mysql的默认安装目录</strong></p>
<p>可以使用<code>ps -ef|grep mysql</code>命令来查找：</p>
<p><img src="https://img-blog.csdnimg.cn/079f461a11f64d60a188e77cce97d48e.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/c349e08f3ad94642b0d278a3d1d7bfcd.png" alt="在这里插入图片描述"></p>
<h2 id="在docker中安装"><a href="#在docker中安装" class="headerlink" title="在docker中安装"></a>在docker中安装</h2><p>如果只是为了测试的话，可以将mysql中安装在docker中，比较方便快捷。</p>
<p><strong>1. 下载最新的mysql镜像</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure>

<p><strong>2. 运行docker容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --name mysql01  -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 --privileged=<span class="literal">true</span> mysql:latest</span><br></pre></td></tr></table></figure>

<p><strong>3. 进入容器</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mysql01 bash</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL日志</title>
    <url>/2022/11/02/MySQL/20mysql%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件。MySQL 也不例外，在 MySQL 中，有 4 种不同的日志，分别是<code>错误日志、二进制日志（BINLOG 日志）、查询日志和慢查询日志</code>，这些日志记录着数据库在不同方面的踪迹。</p>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><blockquote>
<p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</p>
</blockquote>
<p><code>该日志是默认开启的 </code>， 默认存放目录为 mysql 的数据目录（var&#x2F;lib&#x2F;mysql）, 默认的日志文件名为 hostname.err（hostname是主机名）。</p>
<p>查看日志位置指令 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/fc9904725f6145728d8f3421d5f5a16b.png" alt="在这里插入图片描述"></p>
<p>查看日志内容 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">tail <span class="operator">-</span>f <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>xaxh<span class="operator">-</span>server.err</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/613c1ff5767e42a9a9c13a5e33de7f15.png" alt="在这里插入图片描述"></p>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><blockquote>
<p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。</p>
</blockquote>
<p><code>二进制日志，默认情况下是没有开启的，需要到MySQL的配置文件中开启，并配置MySQL日志的格式。</code></p>
<p>配置文件位置 : &#x2F;usr&#x2F;my.cnf</p>
<p>日志存放位置 : 配置时，给定了文件名但是没有指定路径，日志默认写入Mysql的数据目录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#配置开启binlog日志， 日志的文件前缀为 mysqlbin <span class="comment">-----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span></span><br><span class="line">log_bin<span class="operator">=</span>mysqlbin</span><br><span class="line"></span><br><span class="line">#配置二进制日志的格式</span><br><span class="line">binlog_format<span class="operator">=</span>STATEMENT</span><br></pre></td></tr></table></figure>

<h4 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h4><p><strong>STATEMENT</strong></p>
<p>该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次。</p>
<p><strong>ROW</strong></p>
<p>该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status&#x3D;’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更。</p>
<p><strong>MIXED</strong></p>
<p>这是目前MySQL默认的日志格式，即混合了STATEMENT 和 ROW两种格式。默认情况下采用STATEMENT，但是在一些特殊情况下采用ROW来进行记录。MIXED 格式能尽量利用两种模式的优点，而避开他们的缺点。</p>
<h4 id="日志读取"><a href="#日志读取" class="headerlink" title="日志读取"></a>日志读取</h4><p>由于日志以二进制方式存储，不能直接读取，需要用mysqlbinlog工具来查看，语法如下 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog log<span class="operator">-</span>file；</span><br></pre></td></tr></table></figure>

<p><strong>查看STATEMENT格式日志</strong></p>
<p>执行插入语句 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;Lucene&#x27;</span>,<span class="string">&#x27;2088-05-01&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>查看日志文件 ：</p>
<p><img src="https://img-blog.csdnimg.cn/b5b627f92bce46e689f9fd3c47ece604.png" alt="在这里插入图片描述"></p>
<p>mysqlbin.index : 该文件是日志索引文件 ， 记录日志的文件名；</p>
<p>mysqlbing.000001 ：日志文件</p>
<p>查看日志内容 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog mysqlbing<span class="number">.000001</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/da26d2ddfacf4c8b99e06842e29c2975.png" alt="在这里插入图片描述"></p>
<p><strong>查看ROW格式日志</strong></p>
<p>配置 :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#配置开启binlog日志， 日志的文件前缀为 mysqlbin <span class="comment">-----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span></span><br><span class="line">log_bin<span class="operator">=</span>mysqlbin</span><br><span class="line"></span><br><span class="line">#配置二进制日志的格式</span><br><span class="line">binlog_format<span class="operator">=</span><span class="type">ROW</span></span><br></pre></td></tr></table></figure>

<p>插入数据 :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_book <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;SpringCloud实战&#x27;</span>,<span class="string">&#x27;2088-05-05&#x27;</span>,<span class="string">&#x27;0&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>如果日志格式是 ROW , 直接查看数据 , 是查看不懂的 ; 可以在mysqlbinlog 后面加上参数 -vv</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog <span class="operator">-</span>vv mysqlbin<span class="number">.000002</span> </span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/16620df508264429ad8ab0d30086dbd3.png" alt="在这里插入图片描述"></p>
<h4 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a>日志删除</h4><p>对于比较繁忙的系统，由于每天生成日志量大 ，这些日志如果长时间不清楚，将会占用大量的磁盘空间。下面我们将会讲解几种删除日志的常见方法 ：</p>
<p><strong>方式一</strong></p>
<p>通过 Reset Master 指令删除全部 binlog 日志，删除之后，日志编号，将从 xxxx.000001重新开始 。</p>
<p>查询之前 ，先查询下日志文件 ：</p>
<p><img src="https://img-blog.csdnimg.cn/71451e4b92634e3e89df16df778e4875.png" alt="在这里插入图片描述"></p>
<p>执行删除日志指令：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Reset Master</span><br></pre></td></tr></table></figure>

<p>执行之后， 查看日志文件 ：</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BAwwowpZ-1645532310778)(C:\Users\28097\Desktop\java笔记\MySQL高级.assets\1554118675264.png)]</p>
<p><strong>方式二</strong></p>
<p>执行指令 <code>purge master logs to &#39;mysqlbin.******&#39;</code> ，该命令将删除 <code>******</code> 编号之前的所有日志。</p>
<p><strong>方式三</strong></p>
<p>执行指令 <code>purge master logs before &#39;yyyy-mm-dd hh24:mi:ss&#39;</code> ，该命令将删除日志为 “yyyy-mm-dd hh24:mi:ss” 之前产生的所有日志 。</p>
<p><strong>方式四</strong></p>
<p>设置参数 –expire_logs_days&#x3D;# ，此参数的含义是设置日志的过期天数， 过了指定的天数后日志将会被自动删除，这样将有利于减少DBA 管理日志的工作量。</p>
<p>配置如下 ：<br><img src="https://img-blog.csdnimg.cn/409bde225f97418397a5d9b2a6ff59bf.png" alt="在这里插入图片描述"></p>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><blockquote>
<p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。</p>
</blockquote>
<p><code>默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#该选项用来开启查询日志 ， 可选值 ： <span class="number">0</span> 或者 <span class="number">1</span> ； <span class="number">0</span> 代表关闭， <span class="number">1</span> 代表开启 </span><br><span class="line">general_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line">#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log </span><br><span class="line">general_log_file<span class="operator">=</span>file_name</span><br></pre></td></tr></table></figure>

<p>在 mysql 的配置文件 &#x2F;usr&#x2F;my.cnf 中配置如下内容 ：</p>
<p><img src="https://img-blog.csdnimg.cn/0f49cd5714034a7b900bb6990c887629.png" alt="在这里插入图片描述"></p>
<p>配置完毕之后，在数据库执行以下操作 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> tb_book <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lucene入门指南&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_book <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>执行完毕之后， 再次来查询日志文件 ：</p>
<p><img src="https://img-blog.csdnimg.cn/34824ec3344e455fbd1feba425805b5a.png" alt="在这里插入图片描述"></p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><blockquote>
<p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。</p>
</blockquote>
<h4 id="文件位置和格式"><a href="#文件位置和格式" class="headerlink" title="文件位置和格式"></a>文件位置和格式</h4><p><code>慢查询日志默认是关闭的 。可以通过两个参数来控制慢查询日志 ：</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 该参数用来控制慢查询日志是否开启， 可取值： <span class="number">1</span> 和 <span class="number">0</span> ， <span class="number">1</span> 代表开启， <span class="number">0</span> 代表关闭</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span> </span><br><span class="line"></span><br><span class="line"># 该参数用来指定慢查询日志的文件名</span><br><span class="line">slow_query_log_file<span class="operator">=</span>slow_query.log</span><br><span class="line"></span><br><span class="line"># 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认<span class="number">10</span>s</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="日志的读取"><a href="#日志的读取" class="headerlink" title="日志的读取"></a>日志的读取</h4><p><code>和错误日志、查询日志一样，慢查询日志记录的格式也是纯文本，可以被直接读取。</code></p>
<p>1） 查询long_query_time 的值。</p>
<p><img src="https://img-blog.csdnimg.cn/5c1b0ae4901741229d67c3fbbd2462a3.png" alt="在这里插入图片描述"></p>
<p>2） 执行查询操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, title,price,num ,status <span class="keyword">from</span> tb_item <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/1a4c3b5eba3f47a8a4cba4e4dd89b25a.png" alt="在这里插入图片描述"></p>
<p>由于该语句执行时间很短，为0s ， 所以不会记录在慢查询日志中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_item <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">&#x27;%阿尔卡特 (OT-927) 炭黑 联通3G手机 双卡双待165454%&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/673fb8ba4b834b0abdb505cac03b78f5.png" alt="在这里插入图片描述"></p>
<p>该SQL语句 ， 执行时长为 26.77s ，超过10s ， 所以会记录在慢查询日志文件中。</p>
<p>3） 查看慢查询日志文件</p>
<p>直接通过cat 指令查询该日志文件 ：</p>
<p><img src="https://img-blog.csdnimg.cn/729daa96218c4b0d9d420cff87df7e11.png" alt="在这里插入图片描述"></p>
<p><code>如果慢查询日志内容很多， 直接查看文件，比较麻烦， 这个时候可以借助于mysql自带的 mysqldumpslow 工具， 来对慢查询日志进行分类汇总。</code><br><img src="https://img-blog.csdnimg.cn/6d461717f1c346238f0465d823913970.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>数据库与缓存一致性解决方案</title>
    <url>/2022/11/02/MySQL/21%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>项目中如果用到了缓存，就会涉及到数据库与缓存的双写，由于这两个操作不是原子性的，在并发的场景下，容易产生数据库与缓存不一致的情况。</p>
<h2 id="几种方案的分析"><a href="#几种方案的分析" class="headerlink" title="几种方案的分析"></a>几种方案的分析</h2><p>数据库与缓存的双写有很多种方案，我们先来看几种最常见的：</p>
<p><strong>1. 先更新数据库再更新缓存</strong></p>
<p>这种方案最容易想到，但是也很容易出问题，比如写请求A先更新了数据库，这时候，写请求B也更新了数据库，接着又更新了缓存，最后写请求A又更新了一次缓存，这个时候缓存中就出现了脏数据。</p>
<p><img src="https://img-blog.csdnimg.cn/a386fad61a704949b1830ec223413df0.png" alt="在这里插入图片描述"></p>
<p><strong>2. 先更新缓存再更新数据库</strong></p>
<p>假如缓存更新成功，数据库更新失败，那么肯定会照成数据不一致。</p>
<p><strong>3. 先删除缓存再更新数据库</strong></p>
<p>写请求A进行写操作，删除缓存，读请求B查询缓存发现不存在，B去数据库查询得到旧值然后写入缓存，最后写请求A才将新值写入数据库，这个时候缓存中就是脏数据。</p>
<p>由于对数据库的读一般比写要快，所以这种情况是比较容易发生的。</p>
<p><img src="https://img-blog.csdnimg.cn/02aa24053a1a4a4eacf080f834ee292a.png" alt="在这里插入图片描述"></p>
<p><strong>4. 先更新数据库再删除缓存</strong></p>
<p>读请求A查询数据库，得到一个旧值，写请求B将新值写入数据库，写请求B删除缓存，请求A将查询到的旧值写入数据库，这个时候缓存中就出现了脏数据。</p>
<p>但是这种情况发生的概率比较低，因为数据库的读操作一般比写操作快，所以操作1完成之后，马上就会进行操作4。所以最推荐就是这种方式。<br><img src="https://img-blog.csdnimg.cn/4d01a4990a5244d6a2793455157eb3f8.png" alt="在这里插入图片描述"></p>
<p><strong>删缓存还是写缓存？</strong></p>
<p>现在我们发现，对缓存的操作有两种，一种是更新缓存，一种是删除缓存。其实一般采取的是删缓存，原因有两点：</p>
<ol>
<li>并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就更加容易导致数据库与缓存数据不一致问题。(删除缓存直接和简单很多)。</li>
<li>如果每次更新了数据库，都要更新缓存（这里指的是写多读少的场景），倒不如直接删除掉。等再次读取时，缓存里没有，就去数据库找，在数据库找到再写到缓存里边（体现懒加载）。</li>
</ol>
<p><strong>删除缓存失败</strong></p>
<p>明确了删缓存的方案之后，现在面临最大的问题就是缓存删除失败了该怎么办，如果删除失败了就一定会出现不一致的情况，在这里，其实可以做一个保障删除缓存失败后重试的机制，请看方案5。</p>
<p><strong>5. 订阅MySql的binlog日志，发送到消息队列再做删除</strong></p>
<p>首先更新数据库的数据，数据库会将数据表数据的变更信息写入binlog日志中，监听到日志文件的变化后，把数据库变更信息发送到消息队列中，程序接收到消息队列中的数据，对缓存做删除。如果删除失败了，程序就把数据再次发送到消息队列中，再做一次删除，实现删除失败后的重试。</p>
<p>这种方案还有一种好处就是不会对业务代码造成过多的侵入，我们可以专门起一条协程来监听消息队列，如果收到消息队列中的数据，直接去删除对应的缓存即可，而不必在业务代码中去写。</p>
<p><img src="https://img-blog.csdnimg.cn/11e892dfadec4b62a966c095cccdfa21.png" alt="在这里插入图片描述"></p>
<h2 id="方案的实现"><a href="#方案的实现" class="headerlink" title="方案的实现"></a>方案的实现</h2><p>下面我们来实现一下刚刚列举的最后一种方案：</p>
<p><strong>1.mysql的配置</strong></p>
<p>mysql需要开启binlog，首先查看一下mysql是否开启了binlog：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果log_bin的值为OFF是未开启，为ON是已开启</span></span><br><span class="line">SHOW VARIABLES LIKE <span class="string">&#x27;%log_bin%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果未开启的话，可以修改一下<code>/etc/my.cnf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog-format=ROW</span><br><span class="line">server_id=1</span><br></pre></td></tr></table></figure>

<p>配置好之后重启一下mysql。</p>
<p>接着创建用于同步的mysql账号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p password</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">create user canal@<span class="string">&#x27;%&#x27;</span> IDENTIFIED by <span class="string">&#x27;canal&#x27;</span>;</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO <span class="string">&#x27;canal&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p><strong>2.rabbitmq的配置</strong></p>
<p>我们把canal订阅的binlog更新信息发送到rabbitmq中，再由程序去读取。为了方便，将rabbitmq安装在docker中。</p>
<p>首先创建一个目录用于与容器中的rabbitmq配置文件形成映射：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /opt/module/rabbitmq/data -p</span><br></pre></td></tr></table></figure>
<p>接着在docker中运行rabbitmq镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5672是rabbitmq 默认TCP监听端口，到时候程序连接的也是这个端口</span></span><br><span class="line"><span class="comment"># 15672是rabbitmq提供的ui管理界面的端口</span></span><br><span class="line"><span class="comment"># 25672是rabbitmq集群之间通信的端口</span></span><br><span class="line"><span class="comment"># 如果docker跑在云服务器上，记得在安全组中开放5672和15672端口</span></span><br><span class="line">docker run -d --hostname rabbit-svr --name rabbit -p 5672:5672 -p 15672:15672 -p 25672:25672 -v /opt/module/rabbitmq/data:/var/lib/rabbitmq rabbitmq:management</span><br></pre></td></tr></table></figure>

<p>然后就可以在浏览器中访问rabbitmq的ui控制界面了，默认账号和密码都是<code>guest</code>：</p>
<p><img src="https://img-blog.csdnimg.cn/86f825c0b4744b7286015ee8ce10aa13.png" alt="在这里插入图片描述"><br>我们先创建一个exchange，类型选择fanout：</p>
<p><img src="https://img-blog.csdnimg.cn/8ce08862d6114c1ca62a23b088e94294.png" alt="在这里插入图片描述"><br>接着创建一个queue用于监听exchang中的消息，创建好queue之后需要点进去绑定一下刚刚创建的<code>canal.deleteCache</code>：</p>
<p><img src="https://img-blog.csdnimg.cn/ef9f9651a57047dcb68752a146d018d3.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/24b6aaa017ac49ab881d9eea3c61f701.png" alt="在这里插入图片描述"></p>
<p><strong>3.canal配置</strong></p>
<p>canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL。</p>
<p>它可以订阅mysql的binlog日志，然后将更新的数据发送到消息队列中。</p>
<p>下载地址：<a href="https://github.com/alibaba/canal/releases/download/canal-1.1.5-alpha-2/canal.deployer-1.1.5-SNAPSHOT.tar.gz">https://github.com/alibaba/canal/releases/download/canal-1.1.5-alpha-2/canal.deployer-1.1.5-SNAPSHOT.tar.gz</a></p>
<p>由于这个工具是java开发的，所以我们还需要在linux环境下配置一下java环境，我配置的是jdk1.8。</p>
<p>首先将jdk目录放在<code>/usr/local/java/</code>目录下，接着编辑<code>/etc/profile</code>文件配置一下环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_181</span><br><span class="line">export JRE_HOME=$&#123;JAVA_HOME&#125;/jre</span><br><span class="line">export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH</span><br></pre></td></tr></table></figure>

<p>执行一下这个配置脚本：<code>source /etc/profile</code>。</p>
<p>执行<code>echo $JAVA_HOME</code>命令，可以看到jdk文件的路径：</p>
<p><img src="https://img-blog.csdnimg.cn/543a71b810af44779719a712caf4e10f.png" alt="在这里插入图片描述"><br>自此，java的环境就配好了，接着来配置一下	<code>canal</code>：</p>
<p>先将<code>.tar.gz</code>文件解压到<code>/opt/module/canal/</code>目录下，首先来编辑<code>conf/</code>目录下的<code>canal.properties</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canal.serverMode = rabbitMQ</span><br><span class="line"> </span><br><span class="line">rabbitmq.host = 127.0.0.1</span><br><span class="line">rabbitmq.virtual.host = /</span><br><span class="line"># rabbitmq 中新建的 Exchange</span><br><span class="line">rabbitmq.exchange = canal.deleteCache</span><br><span class="line">rabbitmq.username = guest</span><br><span class="line">rabbitmq.password = guest</span><br></pre></td></tr></table></figure>

<p>接着编辑<code>conf/example/</code>目录下的<code>instance.properties</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canal.instance.master.address=127.0.0.1:3306</span><br><span class="line"> </span><br><span class="line"># mysql中配置的用于同步的canal用户</span><br><span class="line">canal.instance.dbUsername=canal</span><br><span class="line">canal.instance.dbPassword=canal</span><br><span class="line"> </span><br><span class="line"># rabbitmq中配置的 绑定的 routingkey，如果是topic模式就需要配置，fanout模式不用配置</span><br><span class="line"># canal.mq.topic=test.routingKey</span><br><span class="line"></span><br><span class="line"># 指定要订阅哪个库下哪个表的更新记录，默认是今天所有库</span><br><span class="line"># canal.instance.filter.regex=.*\\..*</span><br><span class="line">canal.instance.filter.regex=cloud-disk.user_repository</span><br></pre></td></tr></table></figure>

<p>在启动canal之前，最好把mysql的binlog文件清理一下，不然可能会出现匹配不到当前位置的错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p password</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令会删除所有binlog</span></span><br><span class="line">RESET MASTER;</span><br><span class="line"><span class="comment"># 删除mysql-bin.010之前所有日志</span></span><br><span class="line">PURGE MASTER LOGS TO <span class="string">&#x27;mysql-bin.010&#x27;</span>;</span><br><span class="line"><span class="comment"># 删除2003-04-02 22:46:26之前产生的所有日志</span></span><br><span class="line">PURGE MASTER LOGS BEFORE <span class="string">&#x27;2003-04-02 22:46:26&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>最后启动<code>bin</code>目录下的<code>startup.sh</code>脚本，查看<code>logs/canal</code>目录下的的<code>canal.log</code>，出现以下内容说明启动成功：</p>
<p><img src="https://img-blog.csdnimg.cn/c69e4bb8f0d7494db855e76a1e4f144d.png" alt="在这里插入图片描述"></p>
<p>至此，环境准备完成。</p>
<p><strong>4.测试数据</strong></p>
<p>Go语言可以使用<code>github.com/streadway/amqp</code>库来操作rabbitmq，执行以下命令来安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/streadway/amqp</span><br></pre></td></tr></table></figure>

<p>然后我们对这个库做一个二次封装方便使用，将以下程序写到<code>mq/rabbitmq.go</code>中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> mq</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/streadway/amqp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RabbitMQ RabbitMQ结构图</span></span><br><span class="line"><span class="keyword">type</span> RabbitMQ <span class="keyword">struct</span> &#123;</span><br><span class="line">	channel  *amqp.Channel</span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	exchange <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 连接RabbitMQ服务，声明一个消息队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(s, name <span class="type">string</span>)</span></span> *RabbitMQ &#123;</span><br><span class="line">	conn, e := amqp.Dial(s)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ch, e := conn.Channel()</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q, e := ch.QueueDeclare(</span><br><span class="line">		name,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mq := <span class="built_in">new</span>(RabbitMQ)</span><br><span class="line">	mq.channel = ch</span><br><span class="line">	mq.Name = q.Name</span><br><span class="line">	<span class="keyword">return</span> mq</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind 消息队列绑定交换机</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Bind(exchange, key <span class="type">string</span>) &#123;</span><br><span class="line">	e := q.channel.QueueBind(</span><br><span class="line">		q.Name,</span><br><span class="line">		key,</span><br><span class="line">		exchange,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	q.exchange = exchange</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send 向消息队列发布消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Send(queue <span class="type">string</span>, body <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e = q.channel.Publish(</span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		queue,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="type">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Publish 向交换机发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Publish(excahnge <span class="type">string</span>, body <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	str, e := json.Marshal(body)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	e = q.channel.Publish(</span><br><span class="line">		excahnge,</span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		amqp.Publishing&#123;</span><br><span class="line">			ReplyTo: q.Name,</span><br><span class="line">			Body:    []<span class="type">byte</span>(str),</span><br><span class="line">		&#125;)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Consume 消费消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Consume() &lt;-<span class="keyword">chan</span> amqp.Delivery &#123;</span><br><span class="line">	c, e := q.channel.Consume(</span><br><span class="line">		q.Name,</span><br><span class="line">		<span class="string">&quot;&quot;</span>,</span><br><span class="line">		<span class="literal">true</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">false</span>,</span><br><span class="line">		<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(e)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *RabbitMQ)</span></span> Close() &#123;</span><br><span class="line">	q.channel.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个<code>WatchBinLog</code>函数来获取mq中的数据，一旦监听到数据，就可以对缓存进行删除，如果缓存删除失败，就再次向绑定的exchange中发送binlog的更新信息，实现删除重试：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WatchBinLog</span><span class="params">(conf config.Config)</span></span> &#123;</span><br><span class="line">	q := New(config.Conf.RabbitMQ.RabbitURL, <span class="string">&quot;queue.deleteCache&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> q.Close()</span><br><span class="line"></span><br><span class="line">	q.Bind(config.Conf.RabbitMQ.CanalExchange, <span class="string">&quot;&quot;</span>)</span><br><span class="line">	c := q.Consume()</span><br><span class="line"></span><br><span class="line">	cacheDB := models.InitCacheDB(conf)</span><br><span class="line">	conn := cacheDB.RedisPool.Get()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> msg := <span class="keyword">range</span> c &#123;</span><br><span class="line">		payload := getPayload(msg.Body)</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="comment">// 监听到了mq发送过来的binlog变动，删除缓存</span></span><br><span class="line">		_, err = conn.Do(<span class="string">&quot;HDEL&quot;</span>, payload.UserIdentity, payload.ParentId+<span class="string">&quot;file&quot;</span>)</span><br><span class="line">		_, err = conn.Do(<span class="string">&quot;HDEL&quot;</span>, payload.UserIdentity, payload.ParentId+<span class="string">&quot;folder&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果失败，往mq中重新发送</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			logx.Error(<span class="string">&quot;删除缓存失败, payload: &quot;</span>, payload)</span><br><span class="line">			retryMq := New(config.Conf.RabbitMQ.RabbitURL, <span class="string">&quot;&quot;</span>)</span><br><span class="line">			retryMq.Publish(config.Conf.RabbitMQ.CanalExchange, <span class="type">string</span>(msg.Body))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<code>main</code>函数中起一个协程来运行<code>WatchBinLog</code>函数，不对业务代码进行侵入：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> mq.WatchBinLog(config.Conf)</span><br></pre></td></tr></table></figure>

<p>程序启动之后，改变数据库中的数据，就会发现缓存会被自动删除。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS干净卸载MySQL</title>
    <url>/2022/11/02/MySQL/2centos%E5%B9%B2%E5%87%80%E5%8D%B8%E8%BD%BDmysql/</url>
    <content><![CDATA[<p>卸载主要分为三步：</p>
<ol>
<li>卸载已安装的mysql程序；</li>
<li>删除相关的文件夹；</li>
<li>删除my.cnf文件。</li>
</ol>
<h2 id="卸载已安装的mysql程序"><a href="#卸载已安装的mysql程序" class="headerlink" title="卸载已安装的mysql程序"></a>卸载已安装的mysql程序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看已经安装的程序</span></span><br><span class="line"><span class="comment"># 把查询出来的文件全部删除</span></span><br><span class="line"><span class="comment"># 部分文件可能存在依赖，换个顺序删除即可</span></span><br><span class="line">rpm -qa | grep -i mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除centos默认系统自带的</span></span><br><span class="line">rpm -qa | grep -i mariadb</span><br></pre></td></tr></table></figure>

<h2 id="删除相关的文件夹"><a href="#删除相关的文件夹" class="headerlink" title="删除相关的文件夹"></a>删除相关的文件夹</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看对应的MySQL目录</span></span><br><span class="line"><span class="comment"># 把出现的目录全部删除</span></span><br><span class="line"><span class="comment"># 和docker有关的不能删除</span></span><br><span class="line">find / -name mysql</span><br></pre></td></tr></table></figure>


<h2 id="删除配置文件"><a href="#删除配置文件" class="headerlink" title="删除配置文件"></a>删除配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最后删除配置文件</span></span><br><span class="line"><span class="built_in">rm</span> -rf /etc/my.cnf</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL表之间的关系、数据库设计</title>
    <url>/2022/11/02/MySQL/4%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="表与表之间的三种关系"><a href="#表与表之间的三种关系" class="headerlink" title="表与表之间的三种关系"></a>表与表之间的三种关系</h2><p>一对多：最常用的关系 部门和员工。<br>多对多：学生选课表 和 学生表，一门课程可以有多个学生选择，一个学生选择多门课程。<br>一对一：相对使用比较少。员工表 简历表，公民表 护照表。</p>
<h3 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h3><p>一对多（1:n） 例如：班级和学生，部门和员工，客户和订单，分类和商品。<br>一对多建表原则: 在从表(多方)创建一个字段,字段作为外键指向主表(一方)的主键。</p>
<p><img src="https://img-blog.csdnimg.cn/07d21f96da74498697b8c0ee630b445d.png" alt="在这里插入图片描述"></p>
<h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><p>多对多关系建表原则: 需要创建第三张表，中间表中至少两个字段，这两个字段分别作为外键指向各自一方的主键。</p>
<p><img src="https://img-blog.csdnimg.cn/11818edd460a428fb57caa875e12d53f.png" alt="在这里插入图片描述"></p>
<h3 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h3><p>一对一（1:1） 在实际的开发中应用不多, 因为一对一可以创建成一张表。<br>两种建表原则：</p>
<ul>
<li>外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一UNIQUE。</li>
<li>外键是主键：主表的主键和从表的主键，形成主外键关系。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c697e3656dda4731896658c51020bb20.png" alt="在这里插入图片描述"></p>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>好的数据库设计对数据的存储性能和后期的程序开发，都会产生重要的影响。建立科学的，规范的数据库就需要满足一些规则来优化数据的设计和存储，这些规则就称为<code>范式</code>。</p>
<h3 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h3><p>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。<br>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多规范要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式(3NF）就行了。</p>
<h4 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h4><p><strong>概念</strong></p>
<p>数据库表的每一列都是不可分割的原子数据项，不能是集合、数组等非原子数据项。即表中的某个列有多个值时，必须拆分为不同的列。简而言之，第一范式每一列不可再拆分，称为原子性。</p>
<p><strong>班级表</strong></p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>班级</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>一年三班</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>一年二班</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>二年三班</td>
</tr>
</tbody></table>
<h4 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h4><p><strong>概念</strong></p>
<p>在满足第一范式的前提下，表中的每一个字段都完全依赖于主键。<br>所谓完全依赖是指不能存在仅依赖主键一部分的列。<code>简而言之，第二范式就是在第一范式的基础上所有列完全依赖于主键列。</code>当存在一个复合主键包含多个主键列的时候，才会发生不符合第二范式的情况。比如有一个主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式。</p>
<p><strong>第二范式的特点</strong></p>
<ul>
<li>一张表只描述一件事情。</li>
<li>表中每一列都完全依赖于主键。</li>
</ul>
<p><strong>示例</strong></p>
<p>借书证列表：</p>
<table>
<thead>
<tr>
<th><code>学生证号</code></th>
<th>学生证名称</th>
<th>学生证办理时间</th>
<th><code>借书证号</code></th>
<th>借书证名称</th>
<th>借书证办理时间</th>
</tr>
</thead>
</table>
<p>分成两张表：</p>
<table>
<thead>
<tr>
<th><code>学生证号</code></th>
<th>学生证名称</th>
<th>学生证办理时间</th>
</tr>
</thead>
<tbody><tr>
<td><code>借书证号</code></td>
<td>借书证名称</td>
<td>借书证办理时间</td>
</tr>
</tbody></table>
<h4 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h4><p><strong>概念</strong></p>
<p>在满足第二范式的前提下，表中的每一列都直接依赖于主键，而不是通过其它的列来间接依赖于主键。<br>简而言之，第三范式就是所有列不依赖于其它非主键列，也就是在满足 2NF 的基础上，<code>任何非主列不得传递依赖于主键</code>。所谓传递依赖，指的是如果存在”A → B → C”的决定关系，则 C 传递依赖于 A。因此，满足第三范式的数据库表应该不存在如下依赖关系：主键列 → 非主键列 x → 非主键列 y。</p>
<p><strong>示例</strong></p>
<p>学生信息表：</p>
<table>
<thead>
<tr>
<th><code>学号</code></th>
<th>姓名</th>
<th>年龄</th>
<th><code>所在学院</code></th>
<th><code>学院地点</code></th>
</tr>
</thead>
</table>
<p>存在传递的决定关系：</p>
<p><code>学号 -&gt; 所在学院 -&gt; 学院地点</code></p>
<p>拆分成两张表：</p>
<table>
<thead>
<tr>
<th><code>学号</code></th>
<th>姓名</th>
<th>年龄</th>
<th>所在学院的编号(外键)</th>
</tr>
</thead>
</table>
<table>
<thead>
<tr>
<th><code>学院编号</code></th>
<th>所在学院</th>
<th>学院地点</th>
</tr>
</thead>
</table>
<h3 id="三大范式小结"><a href="#三大范式小结" class="headerlink" title="三大范式小结"></a>三大范式小结</h3><table>
<thead>
<tr>
<th>范式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>1NF</td>
<td>原子性：表中每列不可再拆分。</td>
</tr>
<tr>
<td>2NF</td>
<td>不产生局部依赖，一张表只描述一件事情。</td>
</tr>
<tr>
<td>3NF</td>
<td>不产生传递依赖，表中每一列都直接依赖于主键。而是通过其它列间接依赖于主键。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL数据库表的约束、级联操作</title>
    <url>/2022/11/02/MySQL/3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E7%BA%A6%E6%9D%9F%E3%80%81%E7%BA%A7%E8%81%94%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="约束的作用"><a href="#约束的作用" class="headerlink" title="约束的作用"></a>约束的作用</h2><p>对表中的数据进行限制，保证数据的正确性、有效性和完整性。一个表如果添加了约束，不正确的数据将无法插入到表中。约束在创建表的时候添加比较合适。</p>
<h2 id="约束种类"><a href="#约束种类" class="headerlink" title="约束种类"></a>约束种类</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">primary</span> key  # 主键</span><br><span class="line"><span class="keyword">unique</span>       # 唯一</span><br><span class="line"><span class="keyword">not</span> <span class="keyword">null</span>     # 非空</span><br><span class="line"><span class="keyword">foreign</span> key  # 外键</span><br><span class="line"><span class="keyword">check</span>        # 检查约束 （mysql不支持）</span><br></pre></td></tr></table></figure>


<h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p><strong>主键的作用</strong></p>
<p>用来唯一标识数据库中的每一条记录。</p>
<p><strong>哪个字段应该作为表的主键</strong></p>
<p>通常不用业务字段作为主键，单独给每张表设计一个id，把id作为主键。<code>主键是给数据库和程序使用的，不是给最终的客户使用的。所以主键有没有含义没有关系，只要不重复，非空就行。</code></p>
<p>比如：身份证、学号不建议做成主键。</p>
<p><strong>创建和删除主键</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在创建表的时候给字段添加主键</span><br><span class="line">字段名 字段类型 <span class="keyword">PRIMARY</span> KEY</span><br><span class="line"></span><br><span class="line"># 在已有的表中添加主键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(字段名);</span><br><span class="line"></span><br><span class="line"># 在已有的表中删除主键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>


<p>举例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建学生表st，包含字段(id, name, age)将id作为主键</span><br><span class="line"></span><br><span class="line"># 创建表的时候给字段添加主键</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> st(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 在已有的表中添加主键</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> st(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> st <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除st表中的主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> st <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br></pre></td></tr></table></figure>

<p><strong>主键自增</strong></p>
<p>主键如果让我们自己添加很有可能重复,我们通常希望在每次插入新记录时,数据库自动生成主键字段的值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 表示自动增长(字段类型必须是整数类型)</span><br><span class="line">字段名 字段类型 <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT </span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在st表中插入新的学生信息</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> st <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"># id会自动增长</span><br></pre></td></tr></table></figure>

<p><strong>修改自增长的默认值</strong></p>
<p>默认地 AUTO_INCREMENT 的开始值是 1，如果希望修改起始值,请使用下列 SQL 语法。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建表时指定自增长起始值</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">	列名 <span class="type">int</span> <span class="keyword">primary</span> key AUTO_INCREMENT</span><br><span class="line">)AUTO_INCREMENT<span class="operator">=</span>起始值;</span><br><span class="line"></span><br><span class="line"># 创建好以后指定自增长起始值</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 AUTO_INCREMENT<span class="operator">=</span>起始值;</span><br></pre></td></tr></table></figure>

<p><strong>DELETE和TRUNCATE对自增长的影响</strong></p>
<ul>
<li>DELETE删除所有的记录以后，自增长没有影响。</li>
<li>TRUNCATE删除以后，自增长又重新开始。</li>
</ul>
<h3 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h3><p>什么是唯一约束： 表中某一列不能出现重复的值。</p>
<p><strong>唯一约束的格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">UNIQUE</span>;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建学生表st，包含字段(id, name), name这一列设置唯一约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> st(</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span></span><br><span class="line">);</span><br><span class="line"># 设置完以后，不能出现同名的学生</span><br></pre></td></tr></table></figure>

<h3 id="NOT-NULL"><a href="#NOT-NULL" class="headerlink" title="NOT NULL"></a>NOT NULL</h3><p>什么是非空约束：某一列不能为null。</p>
<p><strong>非空约束的语法格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建表学生表 st, 包含字段(id,name,gender)，其中 name 不能为 <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> st (</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">	gender <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"># 之后添加记录的时候，name字段不能为空</span><br></pre></td></tr></table></figure>

<h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><p>什么是默认值：如果插入一条记录的某个字段为空，恰好该字段为DEFAULT，那么会使用先前设置的默认值。</p>
<p><strong>默认值的语法格式</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">DEFAULT</span> 默认值</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建一个学生表 st，包含字段(id,name,address)， 地址默认值是广州</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> st9 (</span><br><span class="line">	 id <span class="type">int</span>,</span><br><span class="line">	 name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	 address <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;广州&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>主键与非空+唯一的区别</strong></p>
<p>如果一个字段设置了非空与唯一约束，该字段与主键的区别是什么？</p>
<ul>
<li>主键在一个表中只能有一个。主键可以单列，也可以多列。</li>
<li>自增长只能用在主键上。</li>
</ul>
<h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>什么是外键约束：<br>一张表的一个字段受限于另外一张表的一个字段对应的值。这里涉及到两张表：被引用的表叫主表（父表），另外一张叫从表（子表）。</p>
<p>优点：可以解决单表的数据冗余问题。</p>
<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建一个员工表包含如下列(id, name, age, dep_name, dep_location),id 主键并自动增长,添加 <span class="number">5</span> 条数据</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">	age <span class="type">INT</span>,</span><br><span class="line">	dep_name <span class="type">VARCHAR</span>(<span class="number">30</span>),</span><br><span class="line">	dep_location <span class="type">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;研发部&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">&#x27;李四&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;研发部&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">&#x27;王五&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;研发部&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">&#x27;老王&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">&#x27;大王&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp (NAME, age, dep_name, dep_location) <span class="keyword">VALUES</span> (<span class="string">&#x27;小王&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 以上数据表的缺点非常明显，就是数据冗余，后期还会出现增删改的问题</span><br></pre></td></tr></table></figure>


<p><strong>外键约束的基本语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 新建表时增加外键</span><br><span class="line">[<span class="keyword">CONSTRAINT</span>] [外键约束名称] <span class="keyword">FOREIGN</span> KEY(外键字段名) <span class="keyword">REFERENCES</span> 主表名(主键字段名)</span><br><span class="line"></span><br><span class="line">#已有表增加外键</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span>] [外键约束名称] <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主</span><br><span class="line">键字段名);</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 先建立主表：department表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> department(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	dep_location <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#  创建从表 employee 并添加外键约束 emp_depid_fk</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">int</span>,</span><br><span class="line">	dep_id <span class="type">int</span>, <span class="comment">-- 外键对应主表的主键</span></span><br><span class="line">	<span class="comment">-- 创建外键约束</span></span><br><span class="line">	<span class="keyword">constraint</span> emp_depid_fk <span class="keyword">foreign</span> key (dep_id) <span class="keyword">references</span> department(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加 <span class="number">2</span> 个部门</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> department <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="string">&#x27;研发部&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>), (<span class="keyword">null</span>, <span class="string">&#x27;销售部&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 添加员工</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee (name, age, dep_id) <span class="keyword">values</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line"># 这个员工就对应主表中的&quot;研发部 广州&quot;</span><br><span class="line"></span><br><span class="line"># 如果插入不存在的部门，会提示错误。</span><br></pre></td></tr></table></figure>

<p><strong>删除外键</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表 <span class="keyword">drop</span> <span class="keyword">foreign</span> key 外键名称;</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除employee表的emp_depid_fk外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employee <span class="keyword">drop</span> <span class="keyword">foreign</span> key emp_depid_fk;</span><br><span class="line"></span><br><span class="line"># 在 employee 表情存在的情况下添加外键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> employee <span class="keyword">add</span> <span class="keyword">constraint</span> emp_depid_fk</span><br><span class="line"><span class="keyword">foreign</span> key (dep_id) <span class="keyword">references</span> department(id);</span><br></pre></td></tr></table></figure>


<h3 id="级联操作"><a href="#级联操作" class="headerlink" title="级联操作"></a>级联操作</h3><p>在修改和删除主表的主键时，同时更新或删除副表的外键值，称为级联操作。</p>
<p>我们可以在创建数据表之前禁用所有的外键约束：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>也可以像下面一样，禁用某一个数据表的外键约束：</p>
<p><strong>级联操作的语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 级联更新，只能是创建表的时候创建级联关系。更新主表中的主键，从表中的外键列也自动同步更新</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">UPDATE</span> CASCADE</span><br><span class="line"></span><br><span class="line"># 级联删除</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 删除 employee 表，重新创建 employee 表，添加级联更新和级联删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">	name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">	age <span class="type">int</span>,</span><br><span class="line">	dep_id <span class="type">int</span>, # 外键对应主表的主键</span><br><span class="line">	# 创建外键约束时添加级联更新和删除</span><br><span class="line">	<span class="keyword">constraint</span> emp_depid_fk <span class="keyword">foreign</span> key (dep_id) <span class="keyword">references</span></span><br><span class="line">	 department(id) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>浅识ACID</title>
    <url>/2022/11/02/MySQL/8%E6%B5%85%E8%AF%86ACID/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>ACID是关系型数据库事务的四大特性, 即<code>原子性 (Atomicity)</code>、 <code>一致性(Consistency)</code>、<code>隔离性(Isolation)</code> 和 <code>持久性(Durability)</code>。</p>
<p>首先来看事务, 事务是一组原子性的sql执行单元, <code>要么全部执行成功（commit），要么全部执行失败（rollback）</code>。而要保证事务的这种特性, 就必须借助于<code>ACID</code>。换一种说法, 借助于ACID, 关系型数据库的事务操作实现了CAP理论中的CA, 即一致性和可用性。</p>
<br>

<h2 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h2><p><strong>1.原子性(Atomicity)</strong></p>
<p>  单个事务，为一个不可分割的最小工作单元，整个事务中的所有操作要么全部commit成功，要么全部失败rollback，对于一个事务来说，不可能只执行其中的一部分SQL操作，这就是事务的原子性。
  </p>
<blockquote>
<p>例如A和B原来分别有1000块钱, 现在A要去银行转账两百块给B。这个过程包含两个步骤:</p>
<ol>
<li>A: 1000-200&#x3D;800</li>
<li>B: 1000+200&#x3D;1200</li>
</ol>
<p>原子性可以保证这两个步骤一起成功，或者一起失败，不能只发生其中一个动作。</p>
</blockquote>
<br>

<p><strong>2.一致性(Consistency)</strong></p>
<p>  数据库总是从一个一致性的状态转换到另外一个一致性的状态。换句话说就是一致性保证了事务在执行完前，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中，保证数据一致性。</p>
<blockquote>
<p>还是上面的例子: A和B原来分别有1000块钱, 现在A要去银行转账两百块给B。这个过程包含两个步骤:</p>
<ol>
<li>A: 1000-200&#x3D;800</li>
<li>B: 1000+200&#x3D;1200</li>
</ol>
<p>一致性可以保证事务完成后，符合逻辑运算。</p>
</blockquote>
<br>

<p><strong>3.隔离性(Isolation)</strong></p>
<p>  同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。</p>
<blockquote>
<p>比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p>
</blockquote>
<p><strong>4.持久性(Durability)</strong></p>
<p>  一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</p>
<blockquote>
<p>举例: 操作前A：800，B：200 操作后A：600，B：400<br>如果在操作前（事务还没有提交）服务器宕机或者断电，那么重启数据库以后，数据状态应该为 A：800，B：200<br>如果在操作后（事务已经提交）服务器宕机或者断电，那么重启数据库以后，数据状态应该为 A：600，B：400</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL索引</title>
    <url>/2022/11/02/MySQL/9mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p><code>索引（index）是帮助MySQL高效获取数据的数据结构（有序）</code>。索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的<code>示意图</code>所示 :</p>
<p><img src="https://img-blog.csdnimg.cn/9d720c1c02ee4644a8a3530a91b9272d.png" alt="在这里插入图片描述"><br>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。</p>
<p><code>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</code></p>
<h3 id="索引优势劣势"><a href="#索引优势劣势" class="headerlink" title="索引优势劣势"></a>索引优势劣势</h3><p>优势</p>
<p>1） 类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</p>
<p>2） 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</p>
<p>劣势</p>
<p>1） 实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</p>
<p>2） 虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件。每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</p>
<h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p><code>索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的</code>。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p>
<ul>
<li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li>
<li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li>
<li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li>
<li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li>
</ul>
<p><strong>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</strong></p>
<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB引擎</th>
<th>MyISAM引擎</th>
<th>Memory引擎</th>
</tr>
</thead>
<tbody><tr>
<td>BTREE索引</td>
<td><code>支持</code></td>
<td><code>支持</code></td>
<td><code>支持</code></td>
</tr>
<tr>
<td>HASH 索引</td>
<td>不支持</td>
<td>不支持</td>
<td><code>支持</code></td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p>
<h4 id="BTREE-结构"><a href="#BTREE-结构" class="headerlink" title="BTREE 结构"></a>BTREE 结构</h4><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p>
<ul>
<li>树中每个节点最多包含m个孩子。</li>
<li>除根节点与叶子节点外，每个节点至少有[ceil(m&#x2F;2)]个孩子。</li>
<li>若根节点不是叶子节点，则至少有两个孩子。</li>
<li>所有的叶子节点都在同一层。</li>
<li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1</li>
</ul>
<p>以5叉BTree为例，key的数量：公式推导[ceil(m&#x2F;2)-1] &lt;&#x3D; n &lt;&#x3D; m-1。所以 2 &lt;&#x3D; n &lt;&#x3D;4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p>
<p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p>
<p>演变过程如下：</p>
<p>1). 插入前4个字母 C N G A</p>
<p><img src="https://img-blog.csdnimg.cn/76af26db2853488a81fef534a9b51021.png" alt="在这里插入图片描述"><br>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p>
<p><img src="https://img-blog.csdnimg.cn/f1ffc0f5ed664f1d8cb39b52d3ed48e0.png" alt="在这里插入图片描述"><br>3). 插入E，K，Q不需要分裂</p>
<p><img src="https://img-blog.csdnimg.cn/b61f4b71528f45ee813463e7feea71ee.png" alt="在这里插入图片描述"><br>4). 插入M，中间元素M字母向上分裂到父节点G</p>
<p><img src="https://img-blog.csdnimg.cn/36c6b3aa207c437caef35d60eda14ebc.png" alt="在这里插入图片描述"><br>5). 插入F，W，L，T不需要分裂</p>
<p><img src="https://img-blog.csdnimg.cn/cf8f84ef2d58448fa9d61aea87652fa8.png" alt="在这里插入图片描述"><br>6). 插入Z，中间元素T向上分裂到父节点中</p>
<p><img src="https://img-blog.csdnimg.cn/85347414242b4bf5830f3de3dd19e428.png" alt="在这里插入图片描述"><br>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p>
<p><img src="https://img-blog.csdnimg.cn/2147b39d2a884b51bb871219d9a700e5.png" alt="在这里插入图片描述"><br>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p>
<p><img src="https://img-blog.csdnimg.cn/95e42a57cbda4d3296d985de8433efd8.png" alt="在这里插入图片描述"><br>到此，该BTREE树就已经构建完成了， <code>BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</code></p>
<h4 id="B-TREE-结构"><a href="#B-TREE-结构" class="headerlink" title="B+TREE 结构"></a>B+TREE 结构</h4><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p>
<blockquote>
<p>1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p>
<p>2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p>
<p>3). 所有的非叶子节点都可以看作是key的索引部分。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/e783d26ae6c643d980fba8d9bf83e2b3.png" alt="在这里插入图片描述"><br>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p>
<h4 id="MySQL中的B-Tree"><a href="#MySQL中的B-Tree" class="headerlink" title="MySQL中的B+Tree"></a>MySQL中的B+Tree</h4><p><code>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</code></p>
<p>MySQL中的 B+Tree 索引结构示意图:</p>
<p><img src="https://img-blog.csdnimg.cn/d1c0b6bb0db84b2dadeabacf858c53a2.png" alt="在这里插入图片描述"></p>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p>1） 单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</p>
<p>2） 唯一索引 ：索引列的值必须唯一，但允许有空值</p>
<p>3） 复合索引 ：即一个索引包含多个列</p>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p>
<p><strong>准备环境:</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database demo_01 <span class="keyword">default</span> charset<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line">use demo_01;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `city` (</span><br><span class="line">  `city_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `city_name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `country_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`city_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `country` (</span><br><span class="line">  `country_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `country_name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`country_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;西安&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;NewYork&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `city` (`city_id`, `city_name`, `country_id`) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;China&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;America&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Japan&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `country` (`country_id`, `country_name`) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;UK&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p><strong>语法 ：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> 	[<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL]  INDEX index_name </span><br><span class="line">[<span class="keyword">USING</span>  index_type]</span><br><span class="line"><span class="keyword">ON</span> tbl_name(index_col_name,...)</span><br><span class="line"></span><br><span class="line">index_col_name : column_name[(length)][<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p>示例 ： 为city表中的city_name字段创建索引 :</p>
<p><img src="https://img-blog.csdnimg.cn/4966625774d84f6c95430aabee420193.png" alt="在这里插入图片描述"></p>
<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> index  <span class="keyword">from</span>  table_name;</span><br></pre></td></tr></table></figure>

<p>示例：查看city表中的索引信息：</p>
<p><img src="https://img-blog.csdnimg.cn/09c02c63641f4210a3e4511822afeba3.png" alt="在这里插入图片描述"></p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  INDEX  index_name  <span class="keyword">ON</span>  tbl_name;</span><br></pre></td></tr></table></figure>

<p>示例 ： 想要删除city表上的索引idx_city_name，可以操作如下：</p>
<p><img src="https://img-blog.csdnimg.cn/e5b681d0f493485e81cba4cb6274f6f3.png" alt="在这里插入图片描述"></p>
<h4 id="ALERT命令"><a href="#ALERT命令" class="headerlink" title="ALERT命令"></a>ALERT命令</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>). <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  <span class="keyword">primary</span>  key(column_list); </span><br><span class="line">	该语句添加一个主键，这意味着索引值必须是唯一的，且不能为<span class="keyword">NULL</span>	</span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>). <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  <span class="keyword">unique</span> index_name(column_list);</span><br><span class="line">	这条语句创建索引的值必须是唯一的（除了<span class="keyword">NULL</span>外，<span class="keyword">NULL</span>可能会出现多次）</span><br><span class="line">	</span><br><span class="line"><span class="number">3</span>). <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  index index_name(column_list);</span><br><span class="line">	添加普通索引， 索引值可以出现多次。</span><br><span class="line">	</span><br><span class="line"><span class="number">4</span>). <span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  fulltext  index_name(column_list);</span><br><span class="line">	该语句指定了索引为FULLTEXT， 用于全文索引</span><br></pre></td></tr></table></figure>

<h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><p>索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p>
<ul>
<li><p><code>对查询频次较高，且数据量比较大的表建立索引。</code></p>
</li>
<li><p><code>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</code></p>
</li>
<li><p><code>使用唯一索引</code>，区分度越高，使用索引的效率越高。</p>
</li>
<li><p><code>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高</code>。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。<code>另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</code></p>
</li>
<li><p><code>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。</code>假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I&#x2F;O效率。</p>
</li>
<li><p><code>利用最左前缀</code>，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p>
</li>
</ul>
<p>创建复合索引:<br>    CREATE INDEX idx_name_email_status ON tb_seller(NAME,email,STATUS);</p>
<p>就相当于<br>    对name 创建索引 ;<br>    对name , email 创建了索引 ;<br>    对name , email, status 创建了索引 ;</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL事务</title>
    <url>/2022/11/02/MySQL/6mysql%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="事务的应用场景"><a href="#事务的应用场景" class="headerlink" title="事务的应用场景"></a>事务的应用场景</h2><p>什么是事务： 在实际的开发过程中，一个业务操作如：转账，往往是要多次访问数据库才能完成的。转账是一个用户扣钱，另一个用户加钱。如果其中有一条 SQL 语句出现异常，这条 SQL 就可能执行失败。</p>
<p>事务执行是一个整体，所有的 SQL 语句都必须执行成功。如果其中有 1 条 SQL 语句出现异常，则所有的SQL 语句都要回滚，整个业务执行失败。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 转账的操作</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> account(</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	NAME <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">	balance <span class="keyword">DOUBLE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 添加数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> account (NAME, balance) <span class="keyword">VALUES</span> (<span class="string">&#x27;张三&#x27;</span>, <span class="number">1000</span>), (<span class="string">&#x27;李四&#x27;</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"># 模拟张三给李四转<span class="number">500</span>元钱，一个转账业务操作最少要执行下面的<span class="number">2</span>条语句：</span><br><span class="line"># 张三账号<span class="number">-500</span></span><br><span class="line"># 李四账号<span class="operator">+</span><span class="number">500</span></span><br><span class="line"></span><br><span class="line"># 张三账号<span class="number">-500</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 李四账号<span class="operator">+</span><span class="number">500</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 现在假设当张三账号上<span class="number">-500</span>元，服务器崩溃了。李四的账号上并没有<span class="operator">+</span><span class="number">500</span>元，数据就出现问题了。我们需要保证其中一条<span class="keyword">SQL</span>语句出现问题，整个转账就算失败。只有两条<span class="keyword">SQL</span>都成功了转账才算成功。这个时候就需要用到事务。</span><br></pre></td></tr></table></figure>

<h2 id="手动提交事务"><a href="#手动提交事务" class="headerlink" title="手动提交事务"></a>手动提交事务</h2><p>MySQL中可以有两种方式进行事务的操作：</p>
<ul>
<li>手动提交事务</li>
<li>自动提交事务</li>
</ul>
<p><strong>手动提交事务的SQL语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"># 提交事务</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"># 回滚事务</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<p><strong>手动提交事务使用过程</strong></p>
<ul>
<li>执行成功的情况：开启事务 -&gt; 执行多条SQL语句 -&gt; 成功提交事务</li>
<li>执行失败的情况：开启事务 -&gt; 执行多条SQL语句 -&gt; 事务的回滚</li>
</ul>
<p><strong>案例演示1 ：事务提交</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 模拟张三给李四转<span class="number">500</span>元</span><br><span class="line"># 此时张三和李四各有<span class="number">1000</span>元</span><br><span class="line"></span><br><span class="line"># 开启事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"># 张三账号<span class="number">-500</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"># 李四账号<span class="operator">+</span><span class="number">500</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">500</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用SQLyog查看数据库，发现数据并没有改变</span><br><span class="line"># 在控制台执行<span class="keyword">commit</span>提交事务</span><br><span class="line"># 使用SQLyog查看数据库，发现数据改变</span><br></pre></td></tr></table></figure>

<p><strong>案例演示2 ：事务回滚</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 模拟张三给李四转<span class="number">500</span>元（失败）</span><br><span class="line"># 目前张三和李四各<span class="number">1000</span>元</span><br><span class="line"># 开启事务</span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"># 张三账号<span class="number">-500</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">500</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 使用SQLyog查看数据库，发现数据并没有改变</span><br><span class="line"># 在控制台执行<span class="keyword">rollback</span>回滚事务</span><br><span class="line"># 使用SQLyog查看数据库，发现数据没有改变</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>如果事务中SQL语句没有问题，commit提交事务，会对数据库数据的数据进行改变。如果事务中SQL语句有问题，rollback回滚事务，会退回到开启事务时的状态。</p>
<h2 id="自动提交事务"><a href="#自动提交事务" class="headerlink" title="自动提交事务"></a>自动提交事务</h2><p>MySQL 默认每一条 DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕自动提交事务，MySQL 默认开始自动提交事务。</p>
<p><strong>取消自动提交</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看MySQL是否开启自动提交事务</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"># <span class="number">1</span>表示开启 <span class="number">0</span>表示关闭</span><br><span class="line"></span><br><span class="line"># 取消自动提交事务</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>


<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p>事务开启之后, 所有的操作都会临时保存到事务日志中, 事务日志只有在得到 commit 命令才会同步到数据表<br>中，其他任何情况都会清空事务日志(rollback，断开连接) 。</p>
<h3 id="事务原理图"><a href="#事务原理图" class="headerlink" title="事务原理图"></a>事务原理图</h3><p><img src="https://img-blog.csdnimg.cn/56559f1478564b8ab8ff5eb83eb38153.png" alt="在这里插入图片描述"></p>
<h3 id="事务的步骤"><a href="#事务的步骤" class="headerlink" title="事务的步骤"></a>事务的步骤</h3><ol>
<li>客户端连接数据库服务器，创建连接时创建此用户临时日志文件。</li>
<li>开启事务以后，所有的操作都会先写入到临时日志文件中。</li>
<li>所有的查询操作从表中查询，但会经过日志文件加工后才返回。</li>
<li>如果事务提交则将日志文件中的数据写到表中，否则清空日志文件。</li>
</ol>
<h3 id="回滚点"><a href="#回滚点" class="headerlink" title="回滚点"></a>回滚点</h3><p>在某些成功的操作完成之后，后续的操作有可能成功有可能失败，但是不管成功还是失败，前面操作都已经成功，可以在当前成功的位置设置一个回滚点。可以供后续失败操作返回到该位置，而不是返回所有操作，这个点称之为回滚点。</p>
<p><strong>回滚点的操作语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置回滚点</span><br><span class="line"><span class="keyword">savepoint</span> 名字</span><br><span class="line"># 回到回滚点</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> 名字</span><br></pre></td></tr></table></figure>

<p><strong>具体操作</strong></p>
<ol>
<li>将数据还原到 1000</li>
<li>开启事务</li>
<li>让张三账号减 3 次钱，每次 10 块</li>
<li>设置回滚点：savepoint three_times;</li>
<li>让张三账号减 4 次钱，每次 10 块</li>
<li>回到回滚点：rollback to three_times;</li>
<li>分析执行过程</li>
</ol>
<p><strong>总结</strong></p>
<p>设置回滚点可以让我们在失败的时候回到回滚点，而不是回到事务开启的时候。</p>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h3><ul>
<li>原子性：每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功，要么都失败。</li>
<li>一致性：事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前2个人的总金额是 2000，转账后 2 个人总金额也是 2000。</li>
<li>隔离性：事务与事务之间不应该相互影响，执行时保持隔离的状态。</li>
<li>持久性：一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。</li>
</ul>
<h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3><p>事务在操作时的理想状态： 所有的事务之间保持隔离，互不影响。因为并发操作，多个用户同时访问同一个数据。可能引发并发访问的问题：</p>
<ul>
<li>脏读：一个事务读取到了另一个事务中尚未提交的数据。</li>
<li>不可重复读：一个事务中两次读取的数据<code>内容</code>不一致，要求的是一个事务中多次读取时数据是一致的，这是事务 update 时引发的问题</li>
<li>幻读：一个事务中两次读取的数据的<code>数量</code>不一致，要求在一个事务多次读取的数据的数量是一致的，这是 insert 或 delete时引发的问题。</li>
</ul>
<h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><table>
<thead>
<tr>
<th>级别</th>
<th>名字</th>
<th>隔离级别</th>
<th>脏读</th>
<th>幻读</th>
<th>数据库隔离级别</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>读未提交</td>
<td>read uncommitted</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>2</td>
<td>读已提交</td>
<td>read committed</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>3</td>
<td>可重复读</td>
<td>repeatable</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>4</td>
<td>串行化</td>
<td>serializable</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p><em>隔离级别越高，性能越差，安全性越高。</em></p>
<h3 id="事务隔离级别相关命令"><a href="#事务隔离级别相关命令" class="headerlink" title="事务隔离级别相关命令"></a>事务隔离级别相关命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询全局事务隔离级别</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"></span><br><span class="line"># 设置事务隔离级别，需要退出MySQL再重新登录才能看到隔离级别的变化</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level 级别字符串;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL连接查询</title>
    <url>/2022/11/02/MySQL/5mysql%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>在多表查询的时候，一般有两种实现方式：<code>子查询和连接查询</code>。因为子查询在使用上比较灵活，也比较简单，所以我们用的最多就是子查询。但是当数据量很大的时候，由于子查询会多次遍历数据表，所以在效率上是不如可以生成临时表的连接查询的。<br>因此本篇主要介绍的是连接查询。</p>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a </span><br><span class="line">[<span class="keyword">inner</span>] <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure>

<p><strong>描述</strong></p>
<p>组合两个表中的记录，返回关联字段相符的记录，即做交集运算。</p>
<p><img src="https://img-blog.csdnimg.cn/c9cdfeb5cf194ea9bb2c9994af050db1.png" alt="在这里插入图片描述"></p>
<h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure>

<p><strong>描述</strong></p>
<p>左表记录将会全部表示出来，而右表只会显示符合搜索条件的记录。右表记录不足的地方均为NULL，即在做交集运算的基础上再加上左边独有的部分。</p>
<p><img src="https://img-blog.csdnimg.cn/9a8086c3cb614109b9f239baa5f09309.png" alt="在这里插入图片描述"></p>
<h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure>

<p><strong>描述</strong></p>
<p>与左外连接相反，右外连接，左表只会显示符合搜索条件的记录，而右表的记录将会全部表示出来。左表记录不足的地方均为NULL，即在做交集运算的基础上再加上右边独有的部分。</p>
<p><img src="https://img-blog.csdnimg.cn/be595faa849d4060aa204ec8f04d1f34.png" alt="在这里插入图片描述"></p>
<h3 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h3><p>mysql中没有全外连接的关键字<code>full join on</code>，在oracle中是支持的，但是mysql可以使用union来实现。</p>
<p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure>

<p><strong>描述</strong></p>
<p>就是两张表的数据做并集。<br><img src="https://img-blog.csdnimg.cn/e1595728b31b4b758875dc3b16f3abf7.png" alt="在这里插入图片描述"></p>
<h3 id="只得到左表独有的数据"><a href="#只得到左表独有的数据" class="headerlink" title="只得到左表独有的数据"></a>只得到左表独有的数据</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br><span class="line"><span class="keyword">where</span> b.id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/96082970d216415e8d5bc094c776daca.png" alt="在这里插入图片描述"></p>
<h3 id="只得到右表独有的数据"><a href="#只得到右表独有的数据" class="headerlink" title="只得到右表独有的数据"></a>只得到右表独有的数据</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br><span class="line"><span class="keyword">where</span> a.id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/b116bf77c2944e6b9fef3a0572cfc6fc.png" alt="在这里插入图片描述"></p>
<h3 id="只得到两表各自独有的内容"><a href="#只得到两表各自独有的内容" class="headerlink" title="只得到两表各自独有的内容"></a>只得到两表各自独有的内容</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br><span class="line"><span class="keyword">where</span> b.id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> 表<span class="number">1</span> a</span><br><span class="line"><span class="keyword">right</span> <span class="keyword">join</span> 表<span class="number">2</span> b</span><br><span class="line"><span class="keyword">on</span> a.id<span class="operator">=</span>b.id</span><br><span class="line"><span class="keyword">where</span> a.id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/be3114c2a8644d4daeeb23fb0609252e.png" alt="在这里插入图片描述"></p>
<h2 id="案例：子查询-连接查询实现"><a href="#案例：子查询-连接查询实现" class="headerlink" title="案例：子查询+连接查询实现"></a>案例：子查询+连接查询实现</h2><p>这个案例来源于我们的数据库实验，题目比较基础，就当练手了。</p>
<h3 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h3><p>建表的脚本文件我放在了github上面：</p>
<p><a href="https://github.com/JunesFour/TempFiles/tree/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3">https://github.com/JunesFour/TempFiles/tree/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3</a></p>
<p>下面是表结构：</p>
<p><img src="https://img-blog.csdnimg.cn/3589edbb28a147ec8de0d5198bf5cece.png" alt="在这里插入图片描述"></p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>1.查询选修了课程的学生的<code>学号</code>、<code>姓名</code>、所选课程号、<code>课程名称</code>以及所取得的<code>成绩</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 子查询：</span><br><span class="line"><span class="keyword">SELECT</span> Student.sno <span class="keyword">AS</span> 学号, Student.sname <span class="keyword">AS</span> 姓名, SC.cno <span class="keyword">AS</span> 课程号, Course.cname <span class="keyword">AS</span> 课程名, SC.grade <span class="keyword">AS</span> 成绩 </span><br><span class="line"><span class="keyword">FROM</span> Student, SC, Course </span><br><span class="line"><span class="keyword">WHERE</span> SC.sno<span class="operator">=</span>Student.sno <span class="keyword">AND</span> Course.cno<span class="operator">=</span>SC.cno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Student.sno;</span><br><span class="line"></span><br><span class="line"># 连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> st.sno <span class="keyword">AS</span> 学号, st.sname <span class="keyword">AS</span> 姓名, c.cno <span class="keyword">AS</span> 课程号, c.cname <span class="keyword">AS</span> 课程名, sc.grade <span class="keyword">AS</span> 成绩</span><br><span class="line"><span class="keyword">FROM</span> Student st</span><br><span class="line"><span class="keyword">JOIN</span> SC sc <span class="keyword">ON</span> (sc.sno<span class="operator">=</span>st.sno)</span><br><span class="line"><span class="keyword">JOIN</span> Course c <span class="keyword">ON</span> (sc.cno<span class="operator">=</span>c.cno)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> st.sno;</span><br></pre></td></tr></table></figure>

<p>2.查询每一门课程及其先修课程，查询结果要求显示<code>课程号</code>、<code>课程名</code>和<code>先修课程名</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cno <span class="keyword">AS</span> 课程号, cname 课程名, cpno <span class="keyword">AS</span> 先修课程名</span><br><span class="line"><span class="keyword">FROM</span> Course;</span><br><span class="line"></span><br><span class="line"># 连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> c.cno <span class="keyword">AS</span> 课程号, c.cname <span class="keyword">AS</span> 课程名, c.cpno <span class="keyword">AS</span> 先修课程名</span><br><span class="line"><span class="keyword">FROM</span> Course c</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Course cp</span><br><span class="line"><span class="keyword">ON</span> (c.cpno <span class="operator">=</span> cp.cno);</span><br></pre></td></tr></table></figure>

<p>3.查询和“陈奕迅”在一个班级的学生的信息(即<code>列出所有属性</code>)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 子查询：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> class<span class="operator">=</span>(<span class="keyword">SELECT</span> class <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> sname<span class="operator">=</span><span class="string">&#x27;陈奕迅&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> st1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student st1</span><br><span class="line"><span class="keyword">JOIN</span> Student st2</span><br><span class="line"><span class="keyword">ON</span> (st2.sname<span class="operator">=</span><span class="string">&#x27;陈奕迅&#x27;</span> <span class="keyword">AND</span> st1.class<span class="operator">=</span>st2.class);</span><br></pre></td></tr></table></figure>

<p>4.查询选修了‘操作系统’课的学生的<code>学号</code>、<code>姓名</code>、<code>性别</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 子查询：</span><br><span class="line"><span class="keyword">SELECT</span> Student.sno, Student.sname, Student.ssex </span><br><span class="line"><span class="keyword">FROM</span> SC, Student</span><br><span class="line"><span class="keyword">WHERE</span> SC.cno<span class="operator">=</span>(<span class="keyword">SELECT</span> cno <span class="keyword">FROM</span> Course <span class="keyword">WHERE</span> cname<span class="operator">=</span><span class="string">&#x27;操作系统&#x27;</span>) <span class="keyword">AND</span> Student.sno<span class="operator">=</span>SC.sno;</span><br><span class="line"></span><br><span class="line"># 连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> st.sno, st.sname, st.ssex</span><br><span class="line"><span class="keyword">FROM</span> Student st</span><br><span class="line"><span class="keyword">JOIN</span> SC sc</span><br><span class="line"><span class="keyword">ON</span> (st.sno<span class="operator">=</span>sc.sno)</span><br><span class="line"><span class="keyword">JOIN</span> Course c</span><br><span class="line"><span class="keyword">ON</span> (sc.cno <span class="operator">=</span> c.cno <span class="keyword">AND</span> c.cname<span class="operator">=</span><span class="string">&#x27;操作系统&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>5.查询没有选修课程的学生的<code>学号</code>、<code>姓名</code>、<code>性别</code>、<code>班级</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 子查询：</span><br><span class="line"><span class="keyword">SELECT</span> sno, sname, ssex </span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> sno <span class="keyword">NOT</span> <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> SC);</span><br><span class="line"></span><br><span class="line"># 左外连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> st.sno, st.sname, st.ssex</span><br><span class="line"><span class="keyword">FROM</span> Student st</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> SC sc</span><br><span class="line"><span class="keyword">ON</span> (st.sno<span class="operator">=</span>sc.sno)</span><br><span class="line"><span class="keyword">WHERE</span> sc.sno <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>6.查询所学课程超过该门课的平均成绩的学生的<code>学号</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">子查询：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sno </span><br><span class="line"><span class="keyword">FROM</span> SC a </span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(grade) <span class="keyword">FROM</span> SC b <span class="keyword">WHERE</span> a.cno<span class="operator">=</span>b.cno <span class="keyword">GROUP</span> <span class="keyword">BY</span> cno);</span><br><span class="line"></span><br><span class="line">连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sc1.sno</span><br><span class="line"><span class="keyword">FROM</span> SC sc1</span><br><span class="line"><span class="keyword">JOIN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> cno, <span class="built_in">AVG</span>(grade) average</span><br><span class="line">	<span class="keyword">FROM</span> SC</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> cno</span><br><span class="line">) sc2</span><br><span class="line"><span class="keyword">ON</span> (sc1.cno<span class="operator">=</span>sc2.cno)</span><br><span class="line"><span class="keyword">AND</span> sc1.grade <span class="operator">&gt;</span> sc2.average;</span><br></pre></td></tr></table></figure>

<p>7.查询学生“赵薇”选修的所有课程的<code>学分之和</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 子查询：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(ccredit) </span><br><span class="line"><span class="keyword">FROM</span> Course </span><br><span class="line"><span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="keyword">ANY</span>(<span class="keyword">SELECT</span> cno <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> sno <span class="operator">=</span> (<span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> sname<span class="operator">=</span><span class="string">&#x27;赵薇&#x27;</span>));</span><br><span class="line"></span><br><span class="line"># 连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(c.ccredit)</span><br><span class="line"><span class="keyword">FROM</span> Course c</span><br><span class="line"><span class="keyword">JOIN</span> SC sc</span><br><span class="line"><span class="keyword">ON</span> (c.cno<span class="operator">=</span>sc.cno)</span><br><span class="line"><span class="keyword">JOIN</span> Student st</span><br><span class="line"><span class="keyword">ON</span> (st.sno<span class="operator">=</span>sc.sno <span class="keyword">AND</span> st.sname<span class="operator">=</span><span class="string">&#x27;赵薇&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>8.查询同时选修了“计算机基础”和“C语言基础”的学生的<code>班级</code>、<code>姓名</code>、<code>性别</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 子查询：</span><br><span class="line"><span class="keyword">SELECT</span> class, sname, ssex</span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> sno <span class="operator">=</span> <span class="keyword">ANY</span>(<span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> SC,Course <span class="keyword">WHERE</span> SC.cno<span class="operator">=</span>Course.cno <span class="keyword">AND</span> cname<span class="operator">=</span>&quot;计算机基础&quot; <span class="keyword">AND</span> sno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> SC, Course <span class="keyword">WHERE</span> cname<span class="operator">=</span>&quot;C语言基础&quot; <span class="keyword">AND</span> Course.cno<span class="operator">=</span>SC.cno));</span><br><span class="line"></span><br><span class="line"># 连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> st.class, st.sname, st.ssex</span><br><span class="line"><span class="keyword">FROM</span> Student st</span><br><span class="line"><span class="keyword">JOIN</span> SC sc1</span><br><span class="line"><span class="keyword">ON</span> (st.sno<span class="operator">=</span>sc1.sno)</span><br><span class="line"><span class="keyword">JOIN</span> SC sc2</span><br><span class="line"><span class="keyword">ON</span> (st.sno<span class="operator">=</span>sc2.sno)</span><br><span class="line"><span class="keyword">JOIN</span> Course c1</span><br><span class="line"><span class="keyword">ON</span> (sc1.cno<span class="operator">=</span>c1.cno <span class="keyword">AND</span> c1.cname<span class="operator">=</span><span class="string">&#x27;计算机基础&#x27;</span>)</span><br><span class="line"><span class="keyword">JOIN</span> Course c2</span><br><span class="line"><span class="keyword">ON</span> (sc2.cno<span class="operator">=</span>c2.cno <span class="keyword">AND</span> c2.cname<span class="operator">=</span><span class="string">&#x27;C语言基础&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>9.查询教师的<code>编号</code>、<code>姓名</code>、上课的<code>课程号</code>、<code>课程名称</code>及<code>班级</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Teacher.tno, Teacher.tname, Course.cno, Course.cname, TC.class <span class="keyword">FROM</span> Teacher, TC, Course</span><br><span class="line"><span class="keyword">WHERE</span> Teacher.tno<span class="operator">=</span>TC.tno <span class="keyword">AND</span> TC.cno<span class="operator">=</span>Course.cno;</span><br><span class="line"></span><br><span class="line"># 连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> t.tno, t.tname, tc.cno, c.cname, tc.class</span><br><span class="line"><span class="keyword">FROM</span> Teacher t</span><br><span class="line"><span class="keyword">JOIN</span> TC tc</span><br><span class="line"><span class="keyword">ON</span> (t.tno<span class="operator">=</span>tc.tno)</span><br><span class="line"><span class="keyword">JOIN</span> Course c</span><br><span class="line"><span class="keyword">ON</span> (tc.cno<span class="operator">=</span>c.cno);</span><br></pre></td></tr></table></figure>

<p>10.统计每一位教师上课的<code>数量</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Teacher.tname <span class="keyword">AS</span> 教师名, <span class="built_in">COUNT</span>(TC.cno) <span class="keyword">AS</span> 课程数量</span><br><span class="line"><span class="keyword">FROM</span> Teacher,TC</span><br><span class="line"><span class="keyword">WHERE</span> Teacher.tno<span class="operator">=</span>TC.tno</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TC.tno;</span><br><span class="line"></span><br><span class="line">连接查询：</span><br><span class="line"><span class="keyword">SELECT</span> t.tname <span class="keyword">AS</span> 教师名, <span class="built_in">COUNT</span>(tc.cno) <span class="keyword">AS</span> 课程数量</span><br><span class="line"><span class="keyword">FROM</span> Teacher t</span><br><span class="line"><span class="keyword">JOIN</span> TC tc</span><br><span class="line"><span class="keyword">ON</span> (t.tno<span class="operator">=</span>tc.tno)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> t.tno;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>CentOS下MySQL匿名用户登录</title>
    <url>/2022/11/02/MySQL/7centos%E4%B8%8Bmysql%E7%9C%8B%E4%B8%8D%E5%88%B0mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>centos8中，使用root账号登录时，输入密码发现是错的，密码为空才能进入mysql服务。但是进去之后发现没有mysql和之前创建过的其它数据库，只有一个<code>information_schema</code>数据库。</p>
<p><strong>原因：</strong></p>
<p>这可能是因为mysql数据库的user表里，存在用户名为空的账户即匿名账户，导致登录的时候是虽然用的是root，但实际是匿名登录的。</p>
<p>1.关闭mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld stop</span><br></pre></td></tr></table></figure>

<p>2.屏蔽权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld_safe --skip-grant-table</span><br></pre></td></tr></table></figure>

<p>3.新开启一个终端进入mysql服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root mysql</span><br></pre></td></tr></table></figure>
<p>删除空用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">delete from user <span class="built_in">where</span> USER=<span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>刷新mysql系统权限表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>4.重启mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<p>5.登录mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p [密码]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes 介绍（组件、概念）</title>
    <url>/2022/11/02/kubernetes/1kubernetes%20%E4%BB%8B%E7%BB%8D%EF%BC%88%E7%BB%84%E4%BB%B6%E3%80%81%E6%A6%82%E5%BF%B5%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-kubernetes-简介"><a href="#1-kubernetes-简介" class="headerlink" title="1. kubernetes 简介"></a>1. kubernetes 简介</h2><p>kubernetes的本质是<strong>一组服务器集群</strong>，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。目的是实现资源管理的自动化，主要提供了如下的主要功能：</p>
<ul>
<li><strong>自我修复</strong>：一旦某一个容器崩溃，能够在1秒中左右迅速启动新的容器</li>
<li><strong>弹性伸缩</strong>：可以根据需要，自动对集群中正在运行的容器数量进行调整</li>
<li><strong>服务发现</strong>：服务可以通过自动发现的形式找到它所依赖的服务</li>
<li><strong>负载均衡</strong>：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li>
<li><strong>版本回退</strong>：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li>
<li><strong>存储编排</strong>：可以根据容器自身的需求自动创建存储卷</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/dd04bb5a05f64d898c225398a3c36d8b.png" alt="在这里插入图片描述"></p>
<h2 id="2-kubernetes-组件"><a href="#2-kubernetes-组件" class="headerlink" title="2. kubernetes 组件"></a>2. kubernetes 组件</h2><p>一个kubernetes集群主要是由**控制节点(master)<strong>、</strong>工作节点(node)**构成，每个节点上都会安装不同的组件。</p>
<p><strong>master：集群的控制平面，负责集群的决策  (  管理  )</strong></p>
<ul>
<li><p><strong>ApiServer</strong> : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API注册和发现等机制</p>
</li>
<li><p><strong>Scheduler</strong> : 负责集群资源调度，按照预定的调度策略将Pod调度到相应的node节点上</p>
</li>
<li><p><strong>ControllerManager</strong> : 负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等</p>
</li>
<li><p><strong>Etcd</strong>：负责存储集群中各种资源对象的信息</p>
</li>
</ul>
<p><strong>node：集群的数据平面，负责为容器提供运行环境 ( 干活 )</strong></p>
<ul>
<li><p><strong>Kubelet</strong> : 负责维护容器的生命周期，即通过控制docker，来创建、更新、销毁容器</p>
</li>
<li><p><strong>KubeProxy</strong> : 负责提供集群内部的服务发现和负载均衡</p>
</li>
<li><p><strong>Docker</strong> : 负责节点上容器的各种操作</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/12d20a35039a4105bc2bbb4bc7caae8c.png" alt="在这里插入图片描述"></p>
<p>下面，以部署一个nginx服务来说明kubernetes系统各个组件调用关系：</p>
<ol>
<li><p>首先要明确，一旦kubernetes环境启动之后，master和node都会将自身的信息存储到etcd数据库中</p>
</li>
<li><p>一个nginx服务的安装请求会首先被发送到master节点的apiServer组件</p>
</li>
<li><p>apiServer组件会调用scheduler组件来决定到底应该把这个服务安装到哪个node节点上</p>
<p>在此时，它会从etcd中读取各个node节点的信息，然后按照一定的算法进行选择，并将结果告知apiServer</p>
</li>
<li><p>apiServer调用controller-manager去调度Node节点安装nginx服务</p>
</li>
<li><p>kubelet接收到指令后，会通知docker，然后由docker来启动一个nginx的pod</p>
<p>pod是kubernetes的最小操作单元，容器必须跑在pod中至此，</p>
</li>
<li><p>一个nginx服务就运行了，如果需要访问nginx，就需要通过kube-proxy来对pod产生访问的代理</p>
</li>
</ol>
<p>​        这样，外界用户就可以访问集群中的nginx服务了。</p>
<h2 id="3-kubernetes-概念"><a href="#3-kubernetes-概念" class="headerlink" title="3. kubernetes 概念"></a>3. kubernetes 概念</h2><p><strong>Master</strong>：集群控制节点，每个集群需要至少一个master节点负责集群的管控</p>
<p><strong>Node</strong>：工作负载节点，由master分配容器到这些node工作节点上，然后node节点上的docker负责容器的运行</p>
<p><strong>Pod</strong>：kubernetes的最小控制单元，容器都是运行在pod中的，一个pod中可以有1个或者多个容器</p>
<p><strong>Controller</strong>：控制器，通过它来实现对pod的管理，比如启动pod、停止pod、伸缩pod的数量等等</p>
<p><strong>Service</strong>：pod对外服务的统一入口，下面可以维护者同一类的多个pod</p>
<p><strong>Label</strong>：标签，用于对pod进行分类，同一类pod会拥有相同的标签</p>
<p><strong>NameSpace</strong>：命名空间，用来隔离pod的运行环境</p>
<p><img src="https://img-blog.csdnimg.cn/0bb0c7d8f96942ec850d7469928f175d.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes 数据存储</title>
    <url>/2022/11/02/kubernetes/10kubernetes%20%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>在前面已经提到，容器的生命周期可能很短，会被频繁地创建和销毁。那么容器在销毁时，保存在容器中的数据也会被清除。这种结果对用户来说，在某些情况下是不乐意看到的。为了持久化保存容器的数据，kubernetes引入了Volume的概念。</p>
<p>Volume是Pod中能够被多个容器访问的共享目录，它被定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，kubernetes通过Volume实现同一个Pod中不同容器之间的数据共享以及数据的持久化存储。Volume的生命容器不与Pod中单个容器的生命周期相关，当容器终止或者重启时，Volume中的数据也不会丢失。</p>
<p>kubernetes的Volume支持多种类型，比较常见的有下面几个：</p>
<ul>
<li>简单存储：EmptyDir、HostPath、NFS</li>
<li>高级存储：PV、PVC</li>
<li>配置存储：ConfigMap、Secret</li>
</ul>
<h2 id="1-基本存储"><a href="#1-基本存储" class="headerlink" title="1. 基本存储"></a>1. 基本存储</h2><h3 id="1-1-EmptyDir"><a href="#1-1-EmptyDir" class="headerlink" title="1.1 EmptyDir"></a>1.1 EmptyDir</h3><p>EmptyDir是最基础的Volume类型，一个EmptyDir就是Host上的一个空目录。</p>
<p>​    EmptyDir是在Pod被分配到Node时创建的，它的初始内容为空，并且无须指定宿主机上对应的目录文件，因为kubernetes会自动分配一个目录，当Pod销毁时， EmptyDir中的数据也会被永久删除。 EmptyDir用途如下：</p>
<ul>
<li><p>临时空间，例如用于某些应用程序运行时所需的临时目录，且无须永久保留</p>
</li>
<li><p>一个容器需要从另一个容器中获取数据的目录（多容器共享目录）</p>
</li>
</ul>
<p>接下来，通过一个容器之间文件共享的案例来使用一下EmptyDir。</p>
<p>​    在一个Pod中准备两个容器nginx和busybox，然后声明一个Volume分别挂在到两个容器的目录中，然后nginx容器负责向<br>Volume中写日志，busybox中通过命令将日志内容读到控制台。</p>
<p><img src="https://img-blog.csdnimg.cn/d3507848866046c88b7a608c90ad69ba.png" alt="在这里插入图片描述"><br>创建一个<code>volume-emptydir.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-emptydir</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14-alpine</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume挂在到nginx容器中，对应的目录为 /var/log/nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] <span class="comment"># 初始命令，动态读取指定文件中内容</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>  <span class="comment"># 将logs-volume 挂在到busybox容器中，对应的目录为 /logs</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 声明volume， name为logs-volume，类型为emptyDir</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f volume-emptydir.yaml</span></span><br><span class="line">pod/volume<span class="literal">-emptydir</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods volume-emptydir -n dev -o wide</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ...... </span><br><span class="line">volume<span class="literal">-emptydir</span>   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">97</span>s   <span class="number">10.244</span>.<span class="number">1.100</span>   node1  ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过podIp访问nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.100</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过kubectl logs命令查看指定容器的标准输出</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl logs -f volume-emptydir -n dev -c busybox</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">0.0</span> - - [<span class="number">13</span>/<span class="type">Apr</span>/<span class="number">2020</span>:<span class="number">10</span>:<span class="number">58</span>:<span class="number">47</span> +<span class="number">0000</span>] <span class="string">&quot;GET / HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">612</span> <span class="string">&quot;-&quot;</span> <span class="string">&quot;curl/7.29.0&quot;</span> <span class="string">&quot;-&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-HostPath"><a href="#1-2-HostPath" class="headerlink" title="1.2 HostPath"></a>1.2 HostPath</h3><p>上面提到，EmptyDir中数据不会被持久化，它会随着Pod的结束而销毁，如果想简单的将数据持久化到主机中，可以选择HostPath。</p>
<p>​    HostPath就是将Node主机中一个实际目录挂在到Pod中，以供容器使用，这样的设计就可以保证Pod销毁了，但是数据依据可以存在于Node主机上。</p>
<p><img src="https://img-blog.csdnimg.cn/58de020051064f5a83042b01d6ffdf3c.png" alt="在这里插入图片描述"><br>创建一个<code>volume-hostpath.yaml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-hostpath</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">hostPath:</span> </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/logs</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">DirectoryOrCreate</span>  <span class="comment"># 目录存在就使用，不存在就先创建后使用</span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">关于type的值的一点说明：</span><br><span class="line"><span class="code">	DirectoryOrCreate 目录存在就使用，不存在就先创建后使用</span></span><br><span class="line"><span class="code">	Directory	目录必须存在</span></span><br><span class="line"><span class="code">	FileOrCreate  文件存在就使用，不存在就先创建后使用</span></span><br><span class="line"><span class="code">	File 文件必须存在	</span></span><br><span class="line"><span class="code">    Socket	unix套接字必须存在</span></span><br><span class="line"><span class="code">	CharDevice	字符设备必须存在</span></span><br><span class="line"><span class="code">	BlockDevice 块设备必须存在</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f volume-hostpath.yaml</span></span><br><span class="line">pod/volume<span class="literal">-hostpath</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods volume-hostpath -n dev -o wide</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE   IP             NODE   ......</span><br><span class="line">pod<span class="literal">-volume-hostpath</span>   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">16</span>s   <span class="number">10.244</span>.<span class="number">1.104</span>   node1  ......</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.104</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就可以去host的/root/logs目录下查看存储的文件了</span></span><br><span class="line"><span class="comment">###  注意: 下面的操作需要到Pod所在的节点运行（案例中是node1）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ls /root/logs/</span></span><br><span class="line">access.log  error.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样的道理，如果在此目录下创建一个文件，到容器中也是可以看到的</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-NFS"><a href="#1-3-NFS" class="headerlink" title="1.3 NFS"></a>1.3 NFS</h3><p>HostPath可以解决数据持久化的问题，但是一旦Node节点故障了，Pod如果转移到了别的节点，又会出现问题了，此时需要准备单独的网络存储系统，比较常用的用NFS、CIFS。</p>
<p>​    NFS是一个网络文件存储系统，可以搭建一台NFS服务器，然后将Pod中的存储直接连接到NFS系统上，这样的话，无论Pod在节点上怎么转移，只要Node跟NFS的对接没问题，数据就可以成功访问。</p>
<p><img src="https://img-blog.csdnimg.cn/9bcf8cc1e4e6448495fe70e819a83e92.png" alt="在这里插入图片描述"><br>1）首先要准备nfs的服务器，这里为了简单，直接是master节点做nfs服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在master上安装nfs服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install nfs-utils -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备一个共享目录</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /root/data/nfs -pv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将共享目录以读写权限暴露给192.168.109.0/24网段中的所有主机</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim /etc/exports</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /etc/exports</span></span><br><span class="line">/root/<span class="keyword">data</span>/nfs     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nfs服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl start nfs</span></span><br></pre></td></tr></table></figure>

<p>2）接下来，要在的每个node节点上都安装下nfs，这样的目的是为了node节点可以驱动nfs设备</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在node上安装nfs服务，注意不需要启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install nfs-utils -y</span></span><br></pre></td></tr></table></figure>

<p>3）接下来，就可以编写pod的配置文件了，创建<code>volume-nfs.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">volume-nfs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log/nginx</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;tail -f /logs/access.log&quot;</span>] </span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/logs</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs-volume</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span>  <span class="comment">#nfs服务器地址</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/root/data/nfs</span> <span class="comment">#共享文件路径</span></span><br></pre></td></tr></table></figure>

<p>4）最后，运行下pod，观察结果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f volume-nfs.yaml</span></span><br><span class="line">pod/volume<span class="literal">-nfs</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods volume-nfs -n dev</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">volume<span class="literal">-nfs</span>        <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">2</span>m9s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nfs服务器上的共享目录，发现已经有文件了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ls /root/data/</span></span><br><span class="line">access.log  error.log</span><br></pre></td></tr></table></figure>

<h2 id="2-高级存储"><a href="#2-高级存储" class="headerlink" title="2. 高级存储"></a>2. 高级存储</h2><h3 id="2-1-PV和PVC"><a href="#2-1-PV和PVC" class="headerlink" title="2.1 PV和PVC"></a>2.1 PV和PVC</h3><p>前面已经学习了使用NFS提供存储，此时就要求用户会搭建NFS系统，并且会在yaml配置nfs。由于kubernetes支持的存储系统有很多，要求客户全都掌握，显然不现实。为了能够屏蔽底层存储实现的细节，方便用户使用， kubernetes引入PV和PVC两种资源对象。</p>
<p>​    PV（Persistent Volume）是持久化卷的意思，是对底层的共享存储的一种抽象。一般情况下PV由kubernetes管理员进行创建和配置，它与底层具体的共享存储技术有关，并通过插件完成与共享存储的对接。</p>
<p>​    PVC（Persistent Volume Claim）是持久卷声明的意思，是用户对于存储需求的一种声明。换句话说，PVC其实就是用户向kubernetes系统发出的一种资源需求申请。</p>
<p><img src="https://img-blog.csdnimg.cn/a16968fd40194e50af018a9741b880d5.png" alt="在这里插入图片描述"><br>使用了PV和PVC之后，工作可以得到进一步的细分：</p>
<ul>
<li>存储：存储工程师维护</li>
<li>PV：  kubernetes管理员维护</li>
<li>PVC：kubernetes用户维护</li>
</ul>
<h3 id="2-2-PV"><a href="#2-2-PV" class="headerlink" title="2.2 PV"></a>2.2 PV</h3><p>PV是存储资源的抽象，下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  </span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 存储类型，与底层真正存储对应</span></span><br><span class="line">  <span class="attr">capacity:</span>  <span class="comment"># 存储能力，目前只支持存储空间的设置</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span>  <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="comment"># 回收策略</span></span><br></pre></td></tr></table></figure>

<p>PV 的关键配置参数说明：</p>
<ul>
<li><p><strong>存储类型</strong></p>
<p>底层实际存储的类型，kubernetes支持多种存储类型，每种存储类型的配置都有所差异</p>
</li>
<li><p><strong>存储能力（capacity）</strong></p>
</li>
</ul>
<p>​      目前只支持存储空间的设置( storage&#x3D;1Gi )，不过未来可能会加入IOPS、吞吐量等指标的配置</p>
<ul>
<li><p><strong>访问模式（accessModes）</strong></p>
<p>用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：</p>
<ul>
<li>ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载</li>
<li>ReadOnlyMany（ROX）：  只读权限，可以被多个节点挂载</li>
<li>ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的访问模式不同</code></p>
</li>
<li><p><strong>回收策略（persistentVolumeReclaimPolicy）</strong></p>
<p>当PV不再被使用了之后，对其的处理方式。目前支持三种策略：</p>
<ul>
<li>Retain  （保留）  保留数据，需要管理员手工清理数据</li>
<li>Recycle（回收）  清除 PV 中的数据，效果相当于执行 rm -rf &#x2F;thevolume&#x2F;*</li>
<li>Delete  （删除） 与 PV 相连的后端存储完成 volume 的删除操作，当然这常见于云服务商的存储服务</li>
</ul>
<p><code>需要注意的是，底层不同的存储类型可能支持的回收策略不同</code></p>
</li>
<li><p><strong>存储类别</strong></p>
<p>PV可以通过storageClassName参数指定一个存储类别</p>
<ul>
<li><p>具有特定类别的PV只能与请求了该类别的PVC进行绑定</p>
</li>
<li><p>未设定类别的PV则只能与不请求任何类别的PVC进行绑定</p>
</li>
</ul>
</li>
<li><p><strong>状态（status）</strong></p>
<p>一个 PV 的生命周期中，可能会处于4中不同的阶段：</p>
<ul>
<li>Available（可用）：     表示可用状态，还未被任何 PVC 绑定</li>
<li>Bound（已绑定）：     表示 PV 已经被 PVC 绑定</li>
<li>Released（已释放）： 表示 PVC 被删除，但是资源还未被集群重新声明</li>
<li>Failed（失败）：         表示该 PV 的自动回收失败</li>
</ul>
</li>
</ul>
<p><strong>实验</strong></p>
<p>使用NFS作为存储，来演示PV的使用，创建3个PV，对应NFS中的3个暴露的路径。</p>
<ol>
<li><p>准备NFS环境</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /root/data/&#123;pv1,pv2,pv3&#125; -pv</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /etc/exports</span></span><br><span class="line">/root/<span class="keyword">data</span>/pv1     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line">/root/<span class="keyword">data</span>/pv2     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line">/root/<span class="keyword">data</span>/pv3     <span class="number">192.168</span>.<span class="number">109.0</span>/<span class="number">24</span>(rw,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  systemctl restart nfs</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>pv.yaml</code></p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv1</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv2</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">2Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv2</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">pv3</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span> </span><br><span class="line">    <span class="attr">storage:</span> <span class="string">3Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line">  <span class="attr">nfs:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/root/data/pv3</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pv.yaml</span></span><br><span class="line">persistentvolume/pv1 created</span><br><span class="line">persistentvolume/pv2 created</span><br><span class="line">persistentvolume/pv3 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pv -o wide</span></span><br><span class="line">NAME   CAPACITY   ACCESS MODES  RECLAIM POLICY  STATUS      AGE   VOLUMEMODE</span><br><span class="line">pv1    <span class="number">1</span><span class="built_in">Gi</span>        RWX            Retain        Available    <span class="number">10</span>s   Filesystem</span><br><span class="line">pv2    <span class="number">2</span><span class="built_in">Gi</span>        RWX            Retain        Available    <span class="number">10</span>s   Filesystem</span><br><span class="line">pv3    <span class="number">3</span><span class="built_in">Gi</span>        RWX            Retain        Available    <span class="number">9</span>s    Filesystem</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-3-PVC"><a href="#2-3-PVC" class="headerlink" title="2.3 PVC"></a>2.3 PVC</h3><p>PVC是资源的申请，用来声明对存储空间、访问模式、存储类别需求信息。下面是资源清单文件:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 采用标签对PV选择</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="comment"># 存储类别</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="comment"># 请求空间</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>

<p>PVC 的关键配置参数说明：</p>
<ul>
<li><strong>访问模式（accessModes）</strong></li>
</ul>
<p>​       用于描述用户应用对存储资源的访问权限</p>
<ul>
<li><p><strong>选择条件（selector）</strong></p>
<p>通过Label Selector的设置，可使PVC对于系统中己存在的PV进行筛选</p>
</li>
<li><p><strong>存储类别（storageClassName）</strong></p>
<p>PVC在定义时可以设定需要的后端存储的类别，只有设置了该class的pv才能被系统选出</p>
</li>
<li><p><strong>资源请求（Resources ）</strong></p>
<p>描述对存储资源的请求</p>
</li>
</ul>
<p><strong>实验</strong></p>
<p>1.创建<code>pvc.yaml</code>，申请pv</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line">     </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pvc3</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">1Gi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pvc</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pvc.yaml</span></span><br><span class="line">persistentvolumeclaim/pvc1 created</span><br><span class="line">persistentvolumeclaim/pvc2 created</span><br><span class="line">persistentvolumeclaim/pvc3 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pvc</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pvc  -n dev -o wide</span></span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      <span class="number">1</span><span class="built_in">Gi</span>        RWX                           <span class="number">15</span>s   Filesystem</span><br><span class="line">pvc2   Bound    pv2      <span class="number">2</span><span class="built_in">Gi</span>        RWX                           <span class="number">15</span>s   Filesystem</span><br><span class="line">pvc3   Bound    pv3      <span class="number">3</span><span class="built_in">Gi</span>        RWX                           <span class="number">15</span>s   Filesystem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pv -o wide</span></span><br><span class="line">NAME  CAPACITY ACCESS MODES  RECLAIM POLICY  STATUS    CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    <span class="number">1</span><span class="built_in">Gi</span>        RWx        Retain          Bound    dev/pvc1    <span class="number">3</span>h37m    Filesystem</span><br><span class="line">pv2    <span class="number">2</span><span class="built_in">Gi</span>        RWX        Retain          Bound    dev/pvc2    <span class="number">3</span>h37m    Filesystem</span><br><span class="line">pv3    <span class="number">3</span><span class="built_in">Gi</span>        RWX        Retain          Bound    dev/pvc3    <span class="number">3</span>h37m    Filesystem   </span><br></pre></td></tr></table></figure>

<p>2.创建<code>pods.yaml</code>, 使用pv</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod1</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod1 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc1</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod2</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do echo pod2 &gt;&gt; /root/out.txt; sleep 10; done;&quot;</span>]</span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/root/</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">volume</span></span><br><span class="line">      <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">        <span class="attr">claimName:</span> <span class="string">pvc2</span></span><br><span class="line">        <span class="attr">readOnly:</span> <span class="literal">false</span>        </span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pods.yaml</span></span><br><span class="line">pod/pod1 created</span><br><span class="line">pod/pod2 created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME   READY   STATUS    RESTARTS   AGE   IP            NODE   </span><br><span class="line">pod1   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">14</span>s   <span class="number">10.244</span>.<span class="number">1.69</span>   node1   </span><br><span class="line">pod2   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">14</span>s   <span class="number">10.244</span>.<span class="number">1.70</span>   node1  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pvc</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pvc -n dev -o wide</span></span><br><span class="line">NAME   STATUS   VOLUME   CAPACITY   ACCESS MODES      AGE   VOLUMEMODE</span><br><span class="line">pvc1   Bound    pv1      <span class="number">1</span><span class="built_in">Gi</span>        RWX               <span class="number">94</span>m   Filesystem</span><br><span class="line">pvc2   Bound    pv2      <span class="number">2</span><span class="built_in">Gi</span>        RWX               <span class="number">94</span>m   Filesystem</span><br><span class="line">pvc3   Bound    pv3      <span class="number">3</span><span class="built_in">Gi</span>        RWX               <span class="number">94</span>m   Filesystem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pv</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pv -n dev -o wide</span></span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM       AGE     VOLUMEMODE</span><br><span class="line">pv1    <span class="number">1</span><span class="built_in">Gi</span>        RWX            Retain           Bound    dev/pvc1    <span class="number">5</span>h11m   Filesystem</span><br><span class="line">pv2    <span class="number">2</span><span class="built_in">Gi</span>        RWX            Retain           Bound    dev/pvc2    <span class="number">5</span>h11m   Filesystem</span><br><span class="line">pv3    <span class="number">3</span><span class="built_in">Gi</span>        RWX            Retain           Bound    dev/pvc3    <span class="number">5</span>h11m   Filesystem</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看nfs中的文件存储</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /root/data/pv1/out.txt</span></span><br><span class="line">node1</span><br><span class="line">node1</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># more /root/data/pv2/out.txt</span></span><br><span class="line">node2</span><br><span class="line">node2</span><br></pre></td></tr></table></figure>

<h3 id="2-4-生命周期"><a href="#2-4-生命周期" class="headerlink" title="2.4 生命周期"></a>2.4 生命周期</h3><p>PVC和PV是一一对应的，PV和PVC之间的相互作用遵循以下生命周期：</p>
<ul>
<li><p><strong>资源供应</strong>：管理员手动创建底层存储和PV</p>
</li>
<li><p><strong>资源绑定</strong>：用户创建PVC，kubernetes负责根据PVC的声明去寻找PV，并绑定</p>
<p>在用户定义好PVC之后，系统将根据PVC对存储资源的请求在已存在的PV中选择一个满足条件的</p>
<ul>
<li><p>一旦找到，就将该PV与用户定义的PVC进行绑定，用户的应用就可以使用这个PVC了</p>
</li>
<li><p>如果找不到，PVC则会无限期处于Pending状态，直到等到系统管理员创建了一个符合其要求的PV</p>
</li>
</ul>
<p>PV一旦绑定到某个PVC上，就会被这个PVC独占，不能再与其他PVC进行绑定了</p>
</li>
<li><p><strong>资源使用</strong>：用户可在pod中像volume一样使用pvc</p>
<p>Pod使用Volume的定义，将PVC挂载到容器内的某个路径进行使用。</p>
</li>
<li><p><strong>资源释放</strong>：用户删除pvc来释放pv</p>
<p>当存储资源使用完毕后，用户可以删除PVC，与该PVC绑定的PV将会被标记为“已释放”，但还不能立刻与其他PVC进行绑定。通过之前PVC写入的数据可能还被留在存储设备上，只有在清除之后该PV才能再次使用。</p>
</li>
<li><p><strong>资源回收</strong>：kubernetes根据pv设置的回收策略进行资源的回收</p>
<p>对于PV，管理员可以设定回收策略，用于设置与之绑定的PVC释放资源之后如何处理遗留数据的问题。只有PV的存储空间完成回收，才能供新的PVC绑定和使用</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/abf8a1a3804e468c94f1179351d29ee5.png" alt="在这里插入图片描述"></p>
<h2 id="3-配置存储"><a href="#3-配置存储" class="headerlink" title="3. 配置存储"></a>3. 配置存储</h2><h3 id="3-1-ConfigMap"><a href="#3-1-ConfigMap" class="headerlink" title="3.1 ConfigMap"></a>3.1 ConfigMap</h3><p>ConfigMap是一种比较特殊的存储卷，它的主要作用是用来存储配置信息的。</p>
<p>创建<code>configmap.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">info:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    username:admin</span></span><br><span class="line"><span class="string">    password:123456</span></span><br></pre></td></tr></table></figure>

<p>接下来，使用此配置文件创建configmap</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建configmap</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f configmap.yaml</span></span><br><span class="line">configmap/configmap created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看configmap详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe cm configmap -n dev</span></span><br><span class="line">Name:         configmap</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Data</span></span><br><span class="line">====</span><br><span class="line">info:</span><br><span class="line"><span class="literal">----</span></span><br><span class="line">username:admin</span><br><span class="line">password:<span class="number">123456</span></span><br><span class="line"></span><br><span class="line">Events:  &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>接下来创建一个<code>pod-configmap.yaml</code>，将上面创建的configmap挂载进去</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-configmap</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将configmap挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/configmap/config</span></span><br><span class="line">  <span class="attr">volumes:</span> <span class="comment"># 引用configmap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">configmap</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-configmap.yaml</span></span><br><span class="line">pod/pod<span class="literal">-configmap</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-configmap -n dev</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-configmap</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">6</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec -it pod-configmap -n dev /bin/sh</span></span><br><span class="line"><span class="comment"># cd /configmap/config/</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">info</span><br><span class="line"><span class="comment"># more info</span></span><br><span class="line">username:admin</span><br><span class="line">password:<span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到映射已经成功，每个configmap都映射成了一个目录</span></span><br><span class="line"><span class="comment"># key---&gt;文件     value----&gt;文件中的内容</span></span><br><span class="line"><span class="comment"># 此时如果更新configmap的内容, 容器中的值也会动态更新</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-Secret"><a href="#3-2-Secret" class="headerlink" title="3.2 Secret"></a>3.2 Secret</h3><p>在kubernetes中，还存在一种和ConfigMap非常类似的对象，称为Secret对象。它主要用于存储敏感信息，例如密码、秘钥、证书等等。</p>
<p>1.首先使用base64对数据进行编码</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># echo -n &#x27;admin&#x27; | base64 #准备username</span></span><br><span class="line"><span class="string">YWRtaW4=</span></span><br><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># echo -n &#x27;123456&#x27; | base64 #准备password</span></span><br><span class="line"><span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>

<p>2.接下来编写<code>secret.yaml</code>，并创建Secret</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">YWRtaW4=</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">MTIzNDU2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建secret</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f secret.yaml</span></span><br><span class="line">secret/secret created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看secret详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe secret secret -n dev</span></span><br><span class="line">Name:         secret</span><br><span class="line">Namespace:    dev</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"><span class="built_in">Type</span>:  Opaque</span><br><span class="line"><span class="keyword">Data</span></span><br><span class="line">====</span><br><span class="line">password:  <span class="number">6</span> bytes</span><br><span class="line">username:  <span class="number">5</span> bytes</span><br></pre></td></tr></table></figure>

<p>2.创建<code>pod-secret.yaml</code>，将上面创建的secret挂载进去：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-secret</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">volumeMounts:</span> <span class="comment"># 将secret挂载到目录</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/secret/config</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">config</span></span><br><span class="line">    <span class="attr">secret:</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">secret</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-secret.yaml</span></span><br><span class="line">pod/pod<span class="literal">-secret</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-secret -n dev</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-secret</span>      <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m28s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器，查看secret信息，发现已经自动解码了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec -it pod-secret /bin/sh -n dev</span></span><br><span class="line">/ <span class="comment"># ls /secret/config/</span></span><br><span class="line">password  username</span><br><span class="line">/ <span class="comment"># more /secret/config/username</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># more /secret/config/password</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>至此，已经实现了利用secret实现了信息的编码。</p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes集群环境搭建</title>
    <url>/2022/11/02/kubernetes/2kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="1-环境规划"><a href="#1-环境规划" class="headerlink" title="1. 环境规划"></a>1. 环境规划</h2><h3 id="1-1-集群类型"><a href="#1-1-集群类型" class="headerlink" title="1.1 集群类型"></a>1.1 集群类型</h3><p>kubernetes集群大体上分为两类：<strong>一主多从</strong>和<strong>多主多从</strong>。</p>
<ul>
<li>一主多从：一台Master节点和多台Node节点，搭建简单，但是有单机故障风险，适合用于测试环境</li>
<li>多主多从：多台Master节点和多台Node节点，搭建麻烦，安全性高，适合用于生产环境</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/437faa3af6be4e5287b4a909511172c4.png" alt="在这里插入图片描述"><br>为了测试简单，本次搭建的是<strong>一主两从</strong>类型的集群。</p>
<h3 id="1-2-安装方式"><a href="#1-2-安装方式" class="headerlink" title="1.2 安装方式"></a>1.2 安装方式</h3><p>kubernetes有多种部署方式，目前主流的方式有kubeadm、minikube、二进制包</p>
<ul>
<li>minikube：一个用于快速搭建单节点kubernetes的工具</li>
<li>kubeadm：一个用于快速搭建kubernetes集群的工具</li>
<li>二进制包 ：从官网下载每个组件的二进制包，依次去安装，此方式对于理解kubernetes组件更加有效</li>
</ul>
<blockquote>
<p>说明：现在需要安装kubernetes的集群环境，但是又不想过于麻烦，所以选择使用kubeadm方式</p>
</blockquote>
<h3 id="1-3-主机规划"><a href="#1-3-主机规划" class="headerlink" title="1.3 主机规划"></a>1.3 主机规划</h3><table>
<thead>
<tr>
<th>作用</th>
<th>IP地址</th>
<th>操作系统</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>Master</td>
<td>192.168.109.101</td>
<td>Centos7.5    基础设施服务器</td>
<td>2颗CPU  2G内存   50G硬盘</td>
</tr>
<tr>
<td>Node1</td>
<td>192.168.109.102</td>
<td>Centos7.5    基础设施服务器</td>
<td>2颗CPU  2G内存   50G硬盘</td>
</tr>
<tr>
<td>Node2</td>
<td>192.168.109.103</td>
<td>Centos7.5    基础设施服务器</td>
<td>2颗CPU  2G内存   50G硬盘</td>
</tr>
</tbody></table>
<p><strong>注意:</strong> centos的版本要在7.5或7.5以上.</p>
<h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><p>本次环境搭建需要安装三台Centos服务器（一主二从），然后在每台服务器中分别安装docker（18.06.3），kubeadm（1.17.4）、kubelet（1.17.4）、kubectl（1.17.4）程序。</p>
<h3 id="2-1-主机安装"><a href="#2-1-主机安装" class="headerlink" title="2.1 主机安装"></a>2.1 主机安装</h3><p>安装虚拟机过程中注意下面选项的设置：</p>
<ul>
<li><p>操作系统环境：CPU（2C）    内存（2G）   硬盘（50G）    </p>
</li>
<li><p>语言选择：中文简体</p>
</li>
<li><p>软件选择：基础设施服务器</p>
</li>
<li><p>分区选择：自动分区</p>
</li>
<li><p>网络配置：按照下面配置网路地址信息</p>
</li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">网络地址：192.168.109.100  （每台主机都不一样  分别为100、101、102）</span><br><span class="line">子网掩码：255.255.255.0</span><br><span class="line">默认网关：192.168.109.2</span><br><span class="line">DNS：    223.5.5.5</span><br></pre></td></tr></table></figure>


<ul>
<li>主机名设置：按照下面信息设置主机名</li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">master节点： master</span><br><span class="line">node节点：   node1</span><br><span class="line">node节点：   node2</span><br></pre></td></tr></table></figure>

<h3 id="2-2-环境初始化"><a href="#2-2-环境初始化" class="headerlink" title="2.2 环境初始化"></a>2.2 环境初始化</h3><ol>
<li>检查操作系统的版本</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat /etc/redhat-release</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/71e994842d34444eb8014d53849d9637.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li>主机名解析</li>
</ol>
<p>为了方便后面集群节点间的直接调用，在这配置一下主机名解析，企业中推荐使用内部DNS服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机名成解析 编辑三台服务器的/etc/hosts文件，添加下面内容</span></span><br><span class="line"><span class="number">192.168</span>.<span class="number">109.100</span>  master</span><br><span class="line"><span class="number">192.168</span>.<span class="number">109.101</span>  node1</span><br><span class="line"><span class="number">192.168</span>.<span class="number">109.102</span>  node2</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>时间同步</li>
</ol>
<p>kubernetes要求集群中的节点时间必须精确一致，这里直接使用chronyd服务从网络同步时间。</p>
<p>企业中建议配置内部的时间同步服务器</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动chronyd服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl start chronyd</span></span><br><span class="line"><span class="comment"># 设置chronyd服务开机自启</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable chronyd</span></span><br><span class="line"><span class="comment"># chronyd服务启动稍等几秒钟，就可以使用date命令验证时间了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># date</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>禁用iptables和firewalld服务</li>
</ol>
<p>kubernetes和docker在运行中会产生大量的iptables规则，为了不让系统规则跟它们混淆，直接关闭系统的规则</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 关闭firewalld服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line"><span class="comment"># 2 关闭iptables服务</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl stop iptables</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl disable iptables</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>禁用selinux</li>
</ol>
<p> selinux是linux系统下的一个安全服务，如果不关闭它，在安装集群中会产生各种各样的奇葩问题</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑 /etc/selinux/config 文件，修改SELINUX的值为disabled</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line">SELINUX=disabled</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>禁用swap分区</li>
</ol>
<p>swap分区指的是虚拟内存分区，它的作用是在物理内存使用完之后，将磁盘空间虚拟成内存来使用</p>
<p>启用swap设备会对系统的性能产生非常负面的影响，因此kubernetes要求每个节点都要禁用swap设备</p>
<p>但是如果因为某些原因确实不能关闭swap分区，就需要在集群安装过程中通过明确的参数进行配置说明</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑分区配置文件/etc/fstab，注释掉swap分区一行</span></span><br><span class="line"><span class="comment"># 注意修改完毕之后需要重启linux服务</span></span><br><span class="line"> UUID=<span class="number">455</span>cc753<span class="literal">-7a60-4c17-a424-7741728c44a1</span> /boot    xfs     defaults        <span class="number">0</span> <span class="number">0</span></span><br><span class="line"> /dev/mapper/centos<span class="literal">-home</span> /home                      xfs     defaults        <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="comment"># /dev/mapper/centos-swap swap                      swap    defaults        0 0</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>修改linux的内核参数</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改linux的内核参数，添加网桥过滤和地址转发功能</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysctl.d/kubernetes.conf文件，添加如下配置:</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-ip6tables</span> = <span class="number">1</span></span><br><span class="line">net.bridge.bridge<span class="literal">-nf-call-iptables</span> = <span class="number">1</span></span><br><span class="line">net.ipv4.ip_forward = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sysctl -p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载网桥过滤模块</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># modprobe br_netfilter</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网桥过滤模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep br_netfilter</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>配置ipvs功能</li>
</ol>
<p>在kubernetes中service有两种代理模型，一种是基于iptables的，一种是基于ipvs的</p>
<p>两者比较的话，ipvs的性能明显要高一些，但是如果要使用它，需要手动载入ipvs模块</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 安装ipset和ipvsadm</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install ipset ipvsadmin -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 添加需要加载的模块写入脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF &gt;  /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">modprobe <span class="literal">--</span> ip_vs</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_rr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_wrr</span><br><span class="line">modprobe <span class="literal">--</span> ip_vs_sh</span><br><span class="line">modprobe <span class="literal">--</span> nf_conntrack_ipv4</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 为脚本文件添加执行权限</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># chmod +x /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 执行脚本文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># /bin/bash /etc/sysconfig/modules/ipvs.modules</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 查看对应的模块是否加载成功</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span></span><br></pre></td></tr></table></figure>

<p>9） 重启服务器</p>
<p>上面步骤完成之后，需要重新启动linux系统</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># reboot</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-安装docker"><a href="#2-3-安装docker" class="headerlink" title="2.3 安装docker"></a>2.3 安装docker</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 切换镜像源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 查看当前镜像源中支持的docker版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum list docker-ce --showduplicates</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 安装特定版本的docker-ce</span></span><br><span class="line"><span class="comment"># 必须指定--setopt=obsoletes=0，否则yum会自动安装更高版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 docker-ce-18.06.3.ce-3.el7 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 添加一个配置文件</span></span><br><span class="line"><span class="comment"># Docker在默认情况下使用的Cgroup Driver为cgroupfs，而kubernetes推荐使用systemd来代替cgroupfs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir /etc/docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cat &lt;&lt;EOF &gt;  /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://kn0t2bca.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 启动docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl restart docker</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable docker</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6 检查docker状态和版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># docker version</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-安装kubernetes组件"><a href="#2-4-安装kubernetes组件" class="headerlink" title="2.4 安装kubernetes组件"></a>2.4 安装kubernetes组件</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于kubernetes的镜像源在国外，速度比较慢，这里切换成国内的镜像源</span></span><br><span class="line"><span class="comment"># 编辑/etc/yum.repos.d/kubernetes.repo，添加下面的配置 </span></span><br><span class="line">[<span class="type">kubernetes</span>]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes<span class="literal">-el7-x86_64</span></span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">0</span></span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum<span class="literal">-key</span>.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm<span class="literal">-package-key</span>.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装kubeadm、kubelet和kubectl</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install --setopt=obsoletes=0 kubeadm-1.17.4-0 kubelet-1.17.4-0 kubectl-1.17.4-0 -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置kubelet的cgroup</span></span><br><span class="line"><span class="comment"># 编辑/etc/sysconfig/kubelet，添加下面的配置</span></span><br><span class="line">KUBELET_CGROUP_ARGS=<span class="string">&quot;--cgroup-driver=systemd&quot;</span></span><br><span class="line">KUBE_PROXY_MODE=<span class="string">&quot;ipvs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 设置kubelet开机自启</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># systemctl enable kubelet</span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-准备集群镜像"><a href="#2-5-准备集群镜像" class="headerlink" title="2.5 准备集群镜像"></a>2.5 准备集群镜像</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在安装kubernetes集群之前，必须要提前准备好集群需要的镜像，所需镜像可以通过下面命令查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm config images list</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line"><span class="comment"># 此镜像在kubernetes的仓库中,由于网络原因,无法连接，下面提供了一种替代方案</span></span><br><span class="line">images=(</span><br><span class="line">    kube<span class="literal">-apiserver</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-controller-manager</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-scheduler</span>:v1.<span class="number">17.4</span></span><br><span class="line">    kube<span class="literal">-proxy</span>:v1.<span class="number">17.4</span></span><br><span class="line">    pause:<span class="number">3.1</span></span><br><span class="line">    etcd:<span class="number">3.4</span>.<span class="number">3</span><span class="literal">-0</span></span><br><span class="line">    coredns:<span class="number">1.6</span>.<span class="number">5</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> imageName <span class="keyword">in</span> <span class="variable">$</span>&#123;images[<span class="selector-tag">@</span>]&#125; ; <span class="keyword">do</span></span><br><span class="line">	docker pull registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">	docker tag registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span> 		k8s.gcr.io/<span class="variable">$imageName</span></span><br><span class="line">	docker rmi registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/<span class="variable">$imageName</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="2-6-集群初始化"><a href="#2-6-集群初始化" class="headerlink" title="2.6 集群初始化"></a>2.6 集群初始化</h3><p>下面开始对集群进行初始化，并将node节点加入到集群中</p>
<blockquote>
<p>下面的操作只需要在<code>master</code>节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm init \</span></span><br><span class="line">	<span class="literal">--kubernetes-version</span>=v1.<span class="number">17.4</span> \</span><br><span class="line">    <span class="literal">--pod-network-cidr</span>=<span class="number">10.244</span>.<span class="number">0.0</span>/<span class="number">16</span> \</span><br><span class="line">    <span class="literal">--service-cidr</span>=<span class="number">10.96</span>.<span class="number">0.0</span>/<span class="number">12</span> \</span><br><span class="line">    <span class="literal">--apiserver-advertise-address</span>=<span class="number">192.168</span>.<span class="number">109.100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建必要文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir -p $HOME/.kube</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># sudo chown $(id -u):$(id -g) $HOME/.kube/config</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>下面的操作只需要在<code>node</code>节点上执行即可</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将node节点加入集群</span></span><br><span class="line"><span class="comment"># 每个人执行时的token会不一样, kubeadm init 执行完毕之后可以看到</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubeadm join 192.168.109.100:6443 \ </span></span><br><span class="line">	<span class="literal">--token</span> <span class="number">8507</span>uc.o0knircuri8etnw2 \</span><br><span class="line">	<span class="literal">--discovery-token-ca-cert-hash</span> \</span><br><span class="line">	sha256:acc37967fb5b0acf39d7598f8a439cc7dc88f439a3f4d0c9cae88e7901b9d3f</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 查看集群状态 此时的集群状态为NotReady，这是因为还没有配置网络插件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME     STATUS     ROLES    AGE     VERSION</span><br><span class="line">master   NotReady   master   <span class="number">6</span>m43s   v1.<span class="number">17.4</span></span><br><span class="line">node1    NotReady   &lt;none&gt;   <span class="number">22</span>s     v1.<span class="number">17.4</span></span><br><span class="line">node2    NotReady   &lt;none&gt;   <span class="number">19</span>s     v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure>

<h3 id="2-7-安装网络插件"><a href="#2-7-安装网络插件" class="headerlink" title="2.7 安装网络插件"></a>2.7 安装网络插件</h3><p>kubernetes支持多种网络插件，比如flannel、calico、canal等等，任选一种使用即可，本次选择flannel</p>
<blockquote>
<p>下面操作依旧只在<code>master</code>节点执行即可，插件使用的是DaemonSet的控制器，它会在每个节点上都运行</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取fannel的配置文件</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件中quay.io仓库为quay-mirror.qiniu.com</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置文件启动fannel</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl apply -f kube-flannel.yml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 稍等片刻，再次查看集群节点的状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME     STATUS   ROLES    AGE     VERSION</span><br><span class="line">master   Ready    master   <span class="number">15</span>m     v1.<span class="number">17.4</span></span><br><span class="line">node1    Ready    &lt;none&gt;   <span class="number">8</span>m53s   v1.<span class="number">17.4</span></span><br><span class="line">node2    Ready    &lt;none&gt;   <span class="number">8</span>m50s   v1.<span class="number">17.4</span></span><br></pre></td></tr></table></figure>

<p>至此，kubernetes的集群环境搭建完成</p>
<h2 id="3-服务部署"><a href="#3-服务部署" class="headerlink" title="3. 服务部署"></a>3. 服务部署</h2><p>接下来在kubernetes集群中部署一个nginx程序，测试下集群是否在正常工作。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 部署nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create deployment nginx --image=nginx:1.14-alpine</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl expose deployment nginx --port=80 --type=NodePort</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看服务状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods,service</span></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-86c57db685-fdc2k</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">18</span>m</span><br><span class="line"></span><br><span class="line">NAME                 <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)        AGE</span><br><span class="line">service/kubernetes   ClusterIP   <span class="number">10.96</span>.<span class="number">0.1</span>       &lt;none&gt;        <span class="number">443</span>/TCP        <span class="number">82</span>m</span><br><span class="line">service/nginx        NodePort    <span class="number">10.104</span>.<span class="number">121.45</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">30073</span>/TCP   <span class="number">17</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 最后在电脑上访问下部署的nginx服务</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/8bd0d689a01b4dd28196d5011a43bc6e.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kubermetes资源管理（YAML介绍、资源管理方式）</title>
    <url>/2022/11/02/kubernetes/3kubermetes%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%EF%BC%88YAML%E4%BB%8B%E7%BB%8D%E3%80%81%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1-资源管理介绍"><a href="#1-资源管理介绍" class="headerlink" title="1. 资源管理介绍"></a>1. 资源管理介绍</h2><p>在kubernetes中，所有的内容都抽象为资源，用户需要通过操作资源来管理kubernetes。</p>
<ul>
<li><p>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署服务，其实就是在kubernetes集群中运行一个个的容器，并将指定的程序跑在容器中。</p>
</li>
<li><p>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在<code>Pod</code>中，而kubernetes一般也不会直接管理Pod，而是通过<code>Pod控制器</code>来管理Pod的。</p>
</li>
<li><p>Pod可以提供服务之后，就要考虑如何访问Pod中服务，kubernetes提供了<code>Service</code>资源实现这个功能。</p>
</li>
<li><p>当然，如果Pod中程序的数据需要持久化，kubernetes还提供了各种<code>存储</code>系统。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/c3d4b32d8db644ba94f86207a162e3bf.png" alt="在这里插入图片描述"></p>
<h2 id="2-YAML语言介绍"><a href="#2-YAML语言介绍" class="headerlink" title="2. YAML语言介绍"></a>2. YAML语言介绍</h2><p>YAML是一个类似 XML、JSON 的标记性语言。它强调以<strong>数据</strong>为中心，并不是以标识语言为重点。因而YAML本身的定义比较简单，号称”一种人性化的数据格式语言”。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan/<span class="tag">&lt;<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">student:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">	<span class="attr">id:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>YAML的语法比较简单，主要有下面几个：</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格( 低版本限制 )</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
</ul>
<p>YAML支持以下几种数据类型：</p>
<ul>
<li>纯量：单个的、不可再分的值</li>
<li>对象：键值对的集合，又称为映射（mapping）&#x2F; 哈希（hash） &#x2F; 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） &#x2F; 列表（list）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 纯量, 就是指的一个简单的值，字符串、布尔值、整数、浮点数、Null、时间、日期</span></span><br><span class="line"><span class="comment"># 1 布尔类型</span></span><br><span class="line"><span class="attr">c1:</span> <span class="literal">true</span> <span class="string">(或者True)</span></span><br><span class="line"><span class="comment"># 2 整型</span></span><br><span class="line"><span class="attr">c2:</span> <span class="number">234</span></span><br><span class="line"><span class="comment"># 3 浮点型</span></span><br><span class="line"><span class="attr">c3:</span> <span class="number">3.14</span></span><br><span class="line"><span class="comment"># 4 null类型 </span></span><br><span class="line"><span class="attr">c4:</span> <span class="string">~</span>  <span class="comment"># 使用~表示null</span></span><br><span class="line"><span class="comment"># 5 日期类型</span></span><br><span class="line"><span class="attr">c5:</span> <span class="number">2018-02-17</span>    <span class="comment"># 日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="comment"># 6 时间类型</span></span><br><span class="line"><span class="attr">c6:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment"># 时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"><span class="comment"># 7 字符串类型</span></span><br><span class="line"><span class="attr">c7:</span> <span class="string">nihao</span>     <span class="comment"># 简单写法，直接写值 , 如果字符串中间有特殊字符，必须使用双引号或者单引号包裹 </span></span><br><span class="line"><span class="attr">c8:</span> <span class="string">line1</span></span><br><span class="line">    <span class="string">line2</span>     <span class="comment"># 字符串过多的情况可以拆成多行，每一行会被转化成一个空格</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">student:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line">	<span class="attr">id:</span> <span class="number">123456</span></span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">student:</span> &#123;<span class="attr">name:</span> <span class="string">zhangsan</span>,<span class="attr">id:</span> <span class="number">123456</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数组</span></span><br><span class="line"><span class="comment"># 形式一(推荐):</span></span><br><span class="line"><span class="attr">address:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">顺义</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">昌平</span>	</span><br><span class="line"><span class="comment"># 形式二(了解):</span></span><br><span class="line"><span class="attr">address:</span> [<span class="string">顺义</span>,<span class="string">昌平</span>]</span><br></pre></td></tr></table></figure>


<blockquote>
<p>小提示：</p>
<ol>
<li>书写yaml切记<code>:</code> 后面要加一个空格</li>
<li>如果需要将多段yaml配置放在一个文件中，中间要使用<code>---</code>分隔</li>
<li>下面是一个yaml转json的网站，可以通过它验证yaml是否书写正确<br><a href="https://www.json2yaml.com/convert-yaml-to-json">https://www.json2yaml.com/convert-yaml-to-json</a></li>
</ol>
</blockquote>
<h2 id="3-资源管理方式"><a href="#3-资源管理方式" class="headerlink" title="3. 资源管理方式"></a>3. 资源管理方式</h2><ul>
<li><p><strong>命令式对象管理</strong>：直接使用命令去操作kubernetes资源</p>
<p><code>kubectl run nginx-pod --image=nginx:1.17.1 --port=80</code></p>
</li>
<li><p><strong>命令式对象配置</strong>：通过命令配置和配置文件去操作kubernetes资源</p>
<p><code>kubectl create/patch -f nginx-pod.yaml</code></p>
</li>
<li><p><strong>声明式对象配置</strong>：通过apply命令和配置文件去操作kubernetes资源</p>
<p><code>kubectl apply -f nginx-pod.yaml</code></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>操作对象</th>
<th>适用环境</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>命令式对象管理</td>
<td>对象</td>
<td>测试</td>
<td>简单</td>
<td>只能操作活动对象，无法审计、跟踪</td>
</tr>
<tr>
<td>命令式对象配置</td>
<td>文件</td>
<td>开发</td>
<td>可以审计、跟踪</td>
<td>项目大时，配置文件多，操作麻烦</td>
</tr>
<tr>
<td>声明式对象配置</td>
<td>目录</td>
<td>开发</td>
<td>支持目录操作</td>
<td>意外情况下难以调试</td>
</tr>
</tbody></table>
<h3 id="3-1-命令式对象管理"><a href="#3-1-命令式对象管理" class="headerlink" title="3.1 命令式对象管理"></a>3.1 命令式对象管理</h3><p><strong>kubectl命令</strong></p>
<p>kubectl是kubernetes集群的命令行工具，通过它能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。kubectl命令的语法如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl [<span class="type">command</span>] [<span class="type">type</span>] [<span class="type">name</span>] [<span class="type">flags</span>]</span><br></pre></td></tr></table></figure>

<p><strong>comand</strong>：指定要对资源执行的操作，例如create、get、delete</p>
<p><strong>type</strong>：指定资源类型，比如deployment、pod、service</p>
<p><strong>name</strong>：指定资源的名称，名称大小写敏感</p>
<p><strong>flags</strong>：指定额外的可选参数</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有pod</span></span><br><span class="line">kubectl get pod </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个pod</span></span><br><span class="line">kubectl get pod pod_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个pod,以yaml格式展示结果</span></span><br><span class="line">kubectl get pod pod_name <span class="literal">-o</span> yaml</span><br></pre></td></tr></table></figure>

<p><strong>资源类型</strong></p>
<p>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl api<span class="literal">-resources</span></span><br></pre></td></tr></table></figure>

<p>经常使用的资源有下面这些：</p>
<table>
    <tr>
        <th>资源分类</th>
        <th>资源名称</th>
        <th>缩写</th>
        <th>资源作用</th>
    </tr>
    <tr>
        <td rowspan="2">集群级别资源</td>
        <td>nodes</td>
        <td>no</td>
        <td>集群组成部分</td>
    </tr>
    <tr>
        <td>namespaces</td>
        <td>ns</td>
        <td>隔离Pod</td>
    </tr>
    <tr>
        <td>pod资源</td>
        <td>pods</td>
        <td>po</td>
        <td>装载容器</td>
    </tr>
    <tr>
        <td rowspan="8">pod资源控制器</td>
        <td>replicationcontrollers</td>
        <td>rc</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>replicasets</td>
        <td>rs</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>deployments</td>
        <td>deploy</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>daemonsets</td>
        <td>ds</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td>jobs</td>
        <td></td>
        <td>控制pod资源</td>
    </tr>	
    <tr>
        <td>cronjobs</td>
        <td>cj</td>
        <td>控制pod资源</td>
    </tr>	
    <tr>
        <td>horizontalpodautoscalers</td>
        <td>hpa</td>
        <td>控制pod资源</td>
    </tr>	
    <tr>
        <td>statefulsets</td>
        <td>sts</td>
        <td>控制pod资源</td>
    </tr>
    <tr>
        <td rowspan="2">服务发现资源</td>
        <td>services</td>
        <td>svc</td>
        <td>统一pod对外接口</td>
    </tr>
    <tr>
        <td>ingress</td>
        <td>ing</td>
        <td>统一pod对外接口</td>
    </tr>
    <tr>
        <td rowspan="3">存储资源</td>
        <td>volumeattachments</td>
        <td></td>
        <td>存储</td>
    </tr>
    <tr>
        <td>persistentvolumes</td>
        <td>pv</td>
        <td>存储</td>
    </tr>
    <tr>
        <td>persistentvolumeclaims</td>
        <td>pvc</td>
        <td>存储</td>
    </tr>
    <tr>
        <td rowspan="2">配置资源</td>
        <td>configmaps</td>
        <td>cm</td>
        <td>配置</td>
    </tr>
    <tr>
        <td>secrets</td>
        <td></td>
        <td>配置</td>
    </tr>
</table>

<p><strong>操作</strong></p>
<p>kubernetes允许对资源进行多种操作，可以通过–help查看详细的操作命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">kubectl <span class="literal">--help</span></span><br></pre></td></tr></table></figure>

<p>经常使用的操作有下面这些：</p>
<table>
    <tr>
        <th>命令分类</th>
        <th>命令</th>
        <th>翻译</th>
        <th>命令作用</th>
    </tr>
    <tr>
        <td rowspan="6">基本命令</td>
        <td>create</td>
        <td>创建</td>
        <td>创建一个资源</td>
    </tr>
    <tr>
        <td>edit</td>
        <td>编辑</td>
        <td>编辑一个资源</td>
    </tr>
    <tr>
        <td>get</td>
        <td>获取</td>
        <td>获取一个资源</td>
    </tr>
   <tr>
        <td>patch</td>
        <td>更新</td>
        <td>更新一个资源</td>
    </tr>
    <tr>
        <td>delete</td>
        <td>删除</td>
        <td>删除一个资源</td>
    </tr>
    <tr>
        <td>explain</td>
        <td>解释</td>
        <td>展示资源文档</td>
    </tr>
    <tr>
        <td rowspan="10">运行和调试</td>
        <td>run</td>
        <td>运行</td>
        <td>在集群中运行一个指定的镜像</td>
    </tr>
    <tr>
        <td>expose</td>
        <td>暴露</td>
        <td>暴露资源为Service</td>
    </tr>
    <tr>
        <td>describe</td>
        <td>描述</td>
        <td>显示资源内部信息</td>
    </tr>
    <tr>
        <td>logs</td>
        <td>日志</td>
        <td>输出容器在 pod 中的日志</td>
    </tr>	
    <tr>
        <td>attach</td>
        <td>缠绕</td>
        <td>进入运行中的容器</td>
    </tr>	
    <tr>
        <td>exec</td>
        <td>执行</td>
        <td>执行容器中的一个命令</td>
    </tr>	
    <tr>
        <td>cp</td>
        <td>复制</td>
        <td>在Pod内外复制文件</td>
    </tr>
        <tr>
        <td>rollout</td>
        <td>首次展示</td>
        <td>管理资源的发布</td>
    </tr>
    <tr>
        <td>scale</td>
        <td>规模</td>
        <td>扩(缩)容Pod的数量</td>
    </tr>
    <tr>
        <td>autoscale</td>
        <td>自动调整</td>
        <td>自动调整Pod的数量</td>
    </tr>
    <tr>
        <td rowspan="2">高级命令</td>
        <td>apply</td>
        <td>rc</td>
        <td>通过文件对资源进行配置</td>
    </tr>
    <tr>
        <td>label</td>
        <td>标签</td>
        <td>更新资源上的标签</td>
    </tr>
    <tr>
        <td rowspan="2">其他命令</td>
        <td>cluster-info</td>
        <td>集群信息</td>
        <td>显示集群信息</td>
    </tr>
    <tr>
        <td>version</td>
        <td>版本</td>
        <td>显示当前Server和Client的版本</td>
    </tr>
</table>

<p>下面以一个namespace &#x2F; pod的创建和删除简单演示下命令的使用：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create namespace dev</span></span><br><span class="line">namespace/dev created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line">dev               Active   <span class="number">21</span>s</span><br><span class="line">kube<span class="literal">-node-lease</span>   Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-public</span>       Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-system</span>       Active   <span class="number">21</span><span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在此namespace下创建并运行一个nginx的Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run pod --image=nginx -n dev</span></span><br><span class="line">kubectl run <span class="literal">--generator</span>=deployment/apps.v1 is DEPRECATED and will be removed <span class="keyword">in</span> a future version. Use kubectl run <span class="literal">--generator</span>=run<span class="literal">-pod</span>/v1 or kubectl create instead.</span><br><span class="line">deployment.apps/pod created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看新创建的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev</span></span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-864f9875b9-pcw7x</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">21</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete pod pod-864f9875b9-pcw7x -n dev</span></span><br><span class="line">pod <span class="string">&quot;pod-864f9875b9-pcw7x&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete ns dev</span></span><br><span class="line">namespace <span class="string">&quot;dev&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h3 id="3-2-命令式对象配置"><a href="#3-2-命令式对象配置" class="headerlink" title="3.2 命令式对象配置"></a>3.2 命令式对象配置</h3><p>命令式对象配置就是使用命令配合配置文件一起来操作kubernetes资源。</p>
<p>1） 创建一个nginxpod.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginxpod</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-containers</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<p>2）执行create命令，创建资源：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># kubectl create -f nginxpod.yaml</span></span><br><span class="line"><span class="string">namespace/dev</span> <span class="string">created</span></span><br><span class="line"><span class="string">pod/nginxpod</span> <span class="string">created</span></span><br></pre></td></tr></table></figure>

<p>此时发现创建了两个资源对象，分别是namespace和pod</p>
<p>3）执行get命令，查看资源：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get -f nginxpod.yaml</span></span><br><span class="line">NAME            STATUS   AGE</span><br><span class="line">namespace/dev   Active   <span class="number">18</span>s</span><br><span class="line"></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginxpod    <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">17</span>s</span><br></pre></td></tr></table></figure>

<p>这样就显示了两个资源对象的信息</p>
<p>4）执行delete命令，删除资源：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f nginxpod.yaml</span></span><br><span class="line">namespace <span class="string">&quot;dev&quot;</span> deleted</span><br><span class="line">pod <span class="string">&quot;nginxpod&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p>此时发现两个资源对象被删除了</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line"><span class="code">	命令式对象配置的方式操作资源，可以简单的认为：命令  +  yaml配置文件（里面是命令需要的各种参数）</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-声明式对象配置"><a href="#3-3-声明式对象配置" class="headerlink" title="3.3 声明式对象配置"></a>3.3 声明式对象配置</h3><p>声明式对象配置跟命令式对象配置很相似，但是它只有一个命令apply。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先执行一次kubectl apply -f yaml文件，发现创建了资源</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl apply -f nginxpod.yaml</span></span><br><span class="line">namespace/dev created</span><br><span class="line">pod/nginxpod created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次执行一次kubectl apply -f yaml文件，发现说资源没有变动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl apply -f nginxpod.yaml</span></span><br><span class="line">namespace/dev unchanged</span><br><span class="line">pod/nginxpod unchanged</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">总结:</span><br><span class="line"><span class="code">    其实声明式对象配置就是使用apply描述一个资源最终的状态（在yaml中定义状态）</span></span><br><span class="line"><span class="code">	使用apply操作资源：</span></span><br><span class="line"><span class="code">        如果资源不存在，就创建，相当于 kubectl create</span></span><br><span class="line"><span class="code">		如果资源已存在，就更新，相当于 kubectl patch</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：kubectl可以在node节点上运行吗 ?</p>
</blockquote>
<p>kubectl的运行是需要进行配置的，它的配置文件是$HOME&#x2F;.kube，如果想要在node节点运行此命令，需要将master上的.kube文件复制到node节点上，即在master节点上执行下面操作：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">scp  <span class="literal">-r</span>  HOME/.kube   node1: HOME/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用推荐:  三种方式应该怎么用 ?</p>
</blockquote>
<table>
    <tr>
        <td>创建/更新资源</td>
        <td>使用声明式对象配置 kubectl apply -f  XXX.yaml</td>
    </tr>
    <tr>
    </tr>
        <tr>
        <td>删除资源</td>
        <td>使用命令式对象配置 kubectl delete -f  XXX.yaml</td>
    </tr>
        <tr>
    </tr>
        <tr>
        <td>查询资源</td>
        <td>使用命令式对象管理 kubectl get(describe) 资源名称</td>
    </tr>
</table>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes五种核心资源对象</title>
    <url>/2022/11/02/kubernetes/4kubernetes%E4%BA%94%E7%A7%8D%E6%A0%B8%E5%BF%83%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="1-Namespace"><a href="#1-Namespace" class="headerlink" title="1. Namespace"></a>1. Namespace</h2><p>Namespace是kubernetes系统中的一种非常重要资源，它的主要作用是用来实现<strong>多套环境的资源隔离</strong>或者<strong>多租户的资源隔离</strong>。</p>
<p>​    默认情况下，kubernetes集群中的所有的Pod都是可以相互访问的。但是在实际中，可能不想让两个Pod之间进行互相的访问，那此时就可以将两个Pod划分到不同的namespace下。kubernetes通过将集群内部的资源分配到不同的Namespace中，可以形成逻辑上的”组”，以方便不同的组的资源进行隔离使用和管理。</p>
<p>​    可以通过kubernetes的授权机制，将不同的namespace交给不同租户进行管理，这样就实现了多租户的资源隔离。此时还能结合kubernetes的资源配额机制，限定不同租户能占用的资源，例如CPU使用量、内存使用量等等，来实现租户可用资源的管理。</p>
<p><img src="https://img-blog.csdnimg.cn/2e1b32a3f6f5485181dc6401b1470381.png" alt="在这里插入图片描述">kubernetes在集群启动之后，会默认创建几个namespace</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  get namespace</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  所有未指定Namespace的对象都会被分配在default命名空间</span></span><br><span class="line">kube<span class="literal">-node-lease</span>   Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  集群节点之间的心跳维护，v1.13开始引入</span></span><br><span class="line">kube<span class="literal">-public</span>       Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  此命名空间下的资源可以被所有人访问（包括未认证用户）</span></span><br><span class="line">kube<span class="literal">-system</span>       Active   <span class="number">45</span><span class="built_in">h</span>     <span class="comment">#  所有由Kubernetes系统创建的资源都处于这个命名空间</span></span><br></pre></td></tr></table></figure>

<p>下面来看namespace资源的具体操作：</p>
<p><strong>查看</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1 查看所有的ns  命令：kubectl get ns</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns</span></span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   <span class="number">45</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-node-lease</span>   Active   <span class="number">45</span><span class="built_in">h</span></span><br><span class="line">kube<span class="literal">-public</span>       Active   <span class="number">45</span><span class="built_in">h</span>     </span><br><span class="line">kube<span class="literal">-system</span>       Active   <span class="number">45</span><span class="built_in">h</span>     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 查看指定的ns   命令：kubectl get ns ns名称</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns default</span></span><br><span class="line">NAME      STATUS   AGE</span><br><span class="line">default   Active   <span class="number">45</span><span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 指定输出格式  命令：kubectl get ns ns名称  -o 格式参数</span></span><br><span class="line"><span class="comment"># kubernetes支持的格式有很多，比较常见的是wide、json、yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ns default -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2020-04-05T04:44:16Z&quot;</span></span><br><span class="line">  name: default</span><br><span class="line">  resourceVersion: <span class="string">&quot;151&quot;</span></span><br><span class="line">  selfLink: /api/v1/namespaces/default</span><br><span class="line">  uid: <span class="number">7405</span>f73a<span class="literal">-e486-43d4-9db6-145f1409f090</span></span><br><span class="line">spec:</span><br><span class="line">  finalizers:</span><br><span class="line">  - kubernetes</span><br><span class="line">status:</span><br><span class="line">  phase: Active</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 4 查看ns详情  命令：kubectl describe ns ns名称</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ns default</span></span><br><span class="line">Name:         default</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active  <span class="comment"># Active 命名空间正在使用中  Terminating 正在删除命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ResourceQuota 针对namespace做的资源限制</span></span><br><span class="line"><span class="comment"># LimitRange针对namespace中的每个组件做的资源限制</span></span><br><span class="line">No resource quota.</span><br><span class="line">No LimitRange resource.</span><br></pre></td></tr></table></figure>

<p><strong>创建</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create ns dev</span></span><br><span class="line">namespace/dev created</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete ns dev</span></span><br><span class="line">namespace <span class="string">&quot;dev&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p><strong>配置方式</strong></p>
<p>首先准备一个yaml文件：<code>ns-dev.yaml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<ul>
<li>创建：<code>kubectl  create  -f  ns-dev.yaml</code></li>
<li>删除：<code>kubectl  delete  -f  ns-dev.yaml</code></li>
</ul>
<h2 id="2-Pod"><a href="#2-Pod" class="headerlink" title="2. Pod"></a>2. Pod</h2><p>Pod是kubernetes集群进行管理的最小单元，程序要运行必须部署在容器中，而容器必须存在于Pod中。</p>
<p>Pod可以认为是容器的封装，一个Pod中可以存在一个或者多个容器。</p>
<p><img src="https://img-blog.csdnimg.cn/96c5c45919a04517b88df52cbc0dd875.png" alt="在这里插入图片描述"><br>kubernetes在集群启动之后，集群中的各个组件也都是以Pod方式运行的。可以通过下面命令查看：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n kube-system</span></span><br></pre></td></tr></table></figure>

<p><strong>创建并运行</strong></p>
<p>kubernetes没有提供单独运行Pod的命令，都是通过Pod控制器来实现的：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式： kubectl run (pod控制器名称) [参数] </span></span><br><span class="line"><span class="comment"># --image  指定Pod的镜像</span></span><br><span class="line"><span class="comment"># --port   指定端口</span></span><br><span class="line"><span class="comment"># --namespace  指定namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run nginx --image=nginx:1.17.1 --port=80 --namespace dev </span></span><br><span class="line">deployment.apps/nginx created</span><br></pre></td></tr></table></figure>

<p><strong>查看pod信息</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看Pod基本信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod的详细信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod nginx-5ff7956ff6-fg2db -n dev</span></span><br></pre></td></tr></table></figure>

<p><strong>访问Pod</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取podIP</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE    IP             NODE    ... </span><br><span class="line">nginx<span class="literal">-5ff7956ff6-fg2db</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">190</span>s   <span class="number">10.244</span>.<span class="number">1.23</span>   node1   ...</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问POD</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl http://10.244.1.23:80</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;p&gt;&lt;em&gt;Thank you <span class="keyword">for</span> <span class="keyword">using</span> nginx.&lt;/em&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>删除指定Pod</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除指定Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete pod nginx-5ff7956ff6-fg2db -n dev</span></span><br><span class="line">pod <span class="string">&quot;nginx-5ff7956ff6-fg2db&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时，显示删除Pod成功，但是再查询，发现又新产生了一个 </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-jj4ng</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">21</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是因为当前Pod是由Pod控制器创建的，控制器会监控Pod状况，一旦发现Pod死亡，会立即重建</span></span><br><span class="line"><span class="comment"># 此时要想删除Pod，必须删除Pod控制器</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先来查询一下当前namespace下的Pod控制器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy -n  dev</span></span><br><span class="line">NAME    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">9</span>m7s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，删除此PodPod控制器</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete deploy nginx -n dev</span></span><br><span class="line">deployment.apps <span class="string">&quot;nginx&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 稍等片刻，再查询Pod，发现Pod被删除了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">No resources found <span class="keyword">in</span> dev namespace.</span><br></pre></td></tr></table></figure>

<p><strong>配置操作</strong></p>
<p>创建一个<code>pod-nginx.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<ul>
<li>创建：kubectl  create  -f  pod-nginx.yaml</li>
<li>删除：kubectl  delete  -f  pod-nginx.yaml</li>
</ul>
<h2 id="3-Label"><a href="#3-Label" class="headerlink" title="3. Label"></a>3. Label</h2><p>Label是kubernetes系统中的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择。</p>
<p>Label的特点：</p>
<ul>
<li>一个Label会以key&#x2F;value键值对的形式附加到各种对象上，如Node、Pod、Service等等</li>
<li>一个资源对象可以定义任意数量的Label ，同一个Label也可以被添加到任意数量的资源对象上去</li>
<li>Label通常在资源对象定义时确定，当然也可以在对象创建后动态添加或者删除</li>
</ul>
<p>可以通过Label实现资源的多维度分组，以便灵活、方便地进行资源分配、调度、配置、部署等管理工作。</p>
<blockquote>
<p>一些常用的Label 示例如下：</p>
<ul>
<li>版本标签：”version”:”release”, “version”:”stable”……</li>
<li>环境标签：”environment”:”dev”，”environment”:”test”，”environment”:”pro”</li>
<li>架构标签：”tier”:”frontend”，”tier”:”backend”</li>
</ul>
</blockquote>
<p>标签定义完毕之后，还要考虑到标签的选择，这就要使用到Label Selector，即：</p>
<p>​    Label用于给某个资源对象定义标识</p>
<p>​    Label Selector用于查询和筛选拥有某些标签的资源对象</p>
<p>当前有两种Label Selector：</p>
<ul>
<li><p>基于等式的Label Selector</p>
<p>name &#x3D; slave: 选择所有包含Label中key&#x3D;”name”且value&#x3D;”slave”的对象</p>
<p>env !&#x3D; production: 选择所有包括Label中的key&#x3D;”env”且value不等于”production”的对象</p>
</li>
<li><p>基于集合的Label Selector</p>
<p>name in (master, slave): 选择所有包含Label中的key&#x3D;”name”且value&#x3D;”master”或”slave”的对象</p>
<p>name not in (frontend): 选择所有包含Label中的key&#x3D;”name”且value不等于”frontend”的对象</p>
</li>
</ul>
<p>标签的选择条件可以使用多个，此时将多个Label Selector进行组合，使用逗号”,”进行分隔即可。例如：</p>
<p>​		name&#x3D;slave，env!&#x3D;production</p>
<p>​		name not in (frontend)，env!&#x3D;production</p>
<p><strong>命令方式</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为pod资源打标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label pod nginx-pod version=1.0 -n dev</span></span><br><span class="line">pod/nginx<span class="literal">-pod</span> labeled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为pod资源更新标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label pod nginx-pod version=2.0 -n dev --overwrite</span></span><br><span class="line">pod/nginx<span class="literal">-pod</span> labeled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod nginx-pod  -n dev --show-labels</span></span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx<span class="literal">-pod</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>m   version=<span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev -l version=2.0  --show-labels</span></span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">nginx<span class="literal">-pod</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">17</span>m   version=<span class="number">2.0</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev -l version!=2.0 --show-labels</span></span><br><span class="line">No resources found <span class="keyword">in</span> dev namespace.</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除标签</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label pod nginx-pod version- -n dev</span></span><br><span class="line">pod/nginx<span class="literal">-pod</span> labeled</span><br></pre></td></tr></table></figure>

<p><strong>配置方式</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span> </span><br><span class="line">    <span class="attr">env:</span> <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">pod</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的更新命令了：kubectl  apply  -f  pod-nginx.yaml</p>
<h2 id="4-Deployment"><a href="#4-Deployment" class="headerlink" title="4. Deployment"></a>4. Deployment</h2><p>在kubernetes中，Pod是最小的控制单元，但是kubernetes很少直接控制Pod，一般都是通过Pod控制器来完成的。Pod控制器用于pod的管理，确保pod资源符合预期的状态，当pod的资源出现故障时，会尝试进行重启或重建pod。</p>
<p>​     在kubernetes中Pod控制器的种类有很多，本章节只介绍一种：Deployment。</p>
<p><img src="https://img-blog.csdnimg.cn/702ed4b09d8c45dea4b2bd01ec7549dc.png" alt="在这里插入图片描述"></p>
<p><strong>命令操作</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式: kubectl run deployment名称  [参数]</span></span><br><span class="line"><span class="comment"># --image  指定pod的镜像</span></span><br><span class="line"><span class="comment"># --port   指定端口</span></span><br><span class="line"><span class="comment"># --replicas  指定创建pod数量</span></span><br><span class="line"><span class="comment"># --namespace  指定namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run nginx --image=nginx:1.17.1 --port=80 --replicas=3 -n dev</span></span><br><span class="line">deployment.apps/nginx created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看创建的Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-6k8cb</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-jxfjt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line">nginx<span class="literal">-5ff7956ff6-v6jqw</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment的信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy -n dev</span></span><br><span class="line">NAME    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">nginx   <span class="number">3</span>/<span class="number">3</span>     <span class="number">3</span>            <span class="number">3</span>           <span class="number">2</span>m42s</span><br><span class="line"></span><br><span class="line"><span class="comment"># UP-TO-DATE：成功升级的副本数量</span></span><br><span class="line"><span class="comment"># AVAILABLE：可用副本的数量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy -n dev -o wide</span></span><br><span class="line">NAME    READY UP<span class="literal">-TO-DATE</span>  AVAILABLE   AGE     CONTAINERS   IMAGES              SELECTOR</span><br><span class="line">nginx   <span class="number">3</span>/<span class="number">3</span>     <span class="number">3</span>         <span class="number">3</span>           <span class="number">2</span>m51s   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>        run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment的详细信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe deploy nginx -n dev</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除 </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete deploy nginx -n dev</span></span><br><span class="line">deployment.apps <span class="string">&quot;nginx&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<p><strong>配置操作</strong></p>
<p>创建一个deploy-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<ul>
<li>创建：kubectl  create  -f  deploy-nginx.yaml</li>
<li>删除：kubectl  delete  -f  deploy-nginx.yaml</li>
</ul>
<h2 id="5-Service"><a href="#5-Service" class="headerlink" title="5. Service"></a>5. Service</h2><p>虽然每个Pod都会分配一个单独的Pod IP，然而却存在如下两问题：</p>
<ul>
<li>Pod IP 会随着Pod的重建产生变化</li>
<li>Pod IP 仅仅是集群内可见的虚拟IP，外部无法访问</li>
</ul>
<p>这样对于访问这个服务带来了难度。因此，kubernetes设计了Service来解决这个问题。</p>
<p>Service可以看作是一组同类Pod<strong>对外的访问接口</strong>。借助Service，应用可以方便地实现服务发现和负载均衡。</p>
<p><img src="https://img-blog.csdnimg.cn/221f59877c664ef99c594341859b23af.png" alt="在这里插入图片描述"></p>
<p><strong>操作一：创建集群内部可访问的Service</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暴露Service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl expose deploy nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n dev</span></span><br><span class="line">service/svc<span class="literal">-nginx1</span> exposed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc svc-nginx -n dev -o wide</span></span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>       EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE     SELECTOR</span><br><span class="line">svc<span class="literal">-nginx1</span>   ClusterIP   <span class="number">10.109</span>.<span class="number">179.231</span>   &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">3</span>m51s   run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里产生了一个CLUSTER-IP，这就是service的IP，在Service的生命周期中，这个地址是不会变动的</span></span><br><span class="line"><span class="comment"># 可以通过这个IP访问当前service对应的POD</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.109.179.231:80</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</span><br><span class="line">.......</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>操作二：创建集群外部也可访问的Service</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上面创建的Service的type类型为ClusterIP，这个ip地址只用集群内部可访问</span></span><br><span class="line"><span class="comment"># 如果需要创建外部也可以访问的Service，需要修改type为NodePort</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl expose deploy nginx --name=svc-nginx2 --type=NodePort --port=80 --target-port=80 -n dev</span></span><br><span class="line">service/svc<span class="literal">-nginx2</span> exposed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看，会发现出现了NodePort类型的Service，而且有一对Port（80:31928/TC）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc  svc-nginx-1  -n dev -o wide</span></span><br><span class="line">NAME          <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>       EXTERNAL<span class="literal">-IP</span>   PORT(S)        AGE    SELECTOR</span><br><span class="line">svc<span class="literal">-nginx2</span>    NodePort    <span class="number">10.100</span>.<span class="number">94.0</span>      &lt;none&gt;        <span class="number">80</span>:<span class="number">31928</span>/TCP   <span class="number">9</span>s     run=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来就可以通过集群外的主机访问 节点IP:31928访问服务了</span></span><br><span class="line"><span class="comment"># 例如在的电脑主机上通过浏览器访问下面的地址</span></span><br><span class="line">http://<span class="number">192.168</span>.<span class="number">109.100</span>:<span class="number">31928</span>/</span><br></pre></td></tr></table></figure>

<p><strong>删除Service</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete svc svc-nginx-1 -n dev                                   service &quot;svc-nginx-1&quot; deleted</span></span><br></pre></td></tr></table></figure>

<p><strong>配置方式</strong></p>
<p>创建一个svc-nginx.yaml，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">svc-nginx</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.109</span><span class="number">.179</span><span class="number">.231</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br></pre></td></tr></table></figure>

<p>然后就可以执行对应的创建和删除命令了：</p>
<ul>
<li>创建：kubectl  create  -f  svc-nginx.yaml</li>
<li>删除：kubectl  delete  -f  svc-nginx.yaml</li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes Pod调度</title>
    <url>/2022/11/02/kubernetes/7kubernetes%20Pod%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>在默认情况下，一个Pod在哪个Node节点上运行，是由Scheduler组件采用相应的算法计算出来的，这个过程是不受人工控制的。但是在实际使用中，这并不满足的需求，因为很多情况下，我们想控制某些Pod到达某些节点上，那么应该怎么做呢？这就要求了解kubernetes对Pod的调度规则，kubernetes提供了四大类调度方式：</p>
<ul>
<li>自动调度：运行在哪个节点上完全由Scheduler经过一系列的算法计算得出</li>
<li>定向调度：NodeName、NodeSelector</li>
<li>亲和性调度：NodeAffinity、PodAffinity、PodAntiAffinity</li>
<li>污点（容忍）调度：Taints、Toleration</li>
</ul>
<h2 id="1-定向调度"><a href="#1-定向调度" class="headerlink" title="1. 定向调度"></a>1. 定向调度</h2><p>定向调度，指的是利用在pod上声明nodeName或者nodeSelector，以此将Pod调度到期望的node节点上。注意，这里的调度是强制的，这就意味着即使要调度的目标Node不存在，也会向上面进行调度，只不过pod运行失败而已。</p>
<p><strong>NodeName</strong></p>
<p>NodeName用于强制约束将Pod调度到指定的Name的Node节点上。这种方式，其实是直接跳过Scheduler的调度逻辑，直接将Pod调度到指定名称的节点。</p>
<p>接下来，实验一下：创建一个<code>pod-nodename.yaml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodename</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 指定调度到node1节点上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodename.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodename</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodename -n dev -o wide</span></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP            NODE      ......</span><br><span class="line">pod<span class="literal">-nodename</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">56</span>s   <span class="number">10.244</span>.<span class="number">1.87</span>   node1     ......   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，删除pod，修改nodeName的值为node3（并没有node3节点）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pod-nodename.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-nodename&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-nodename.yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodename.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodename</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次查看，发现已经向Node3节点调度，但是由于不存在node3节点，所以pod无法正常运行</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodename -n dev -o wide</span></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE   IP       NODE    ......</span><br><span class="line">pod<span class="literal">-nodename</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">6</span>s    &lt;none&gt;   node3   ......           </span><br></pre></td></tr></table></figure>

<p><strong>NodeSelector</strong></p>
<p>NodeSelector用于将pod调度到添加了指定标签的node节点上。它是通过kubernetes的label-selector机制实现的，也就是说，在pod创建之前，会由scheduler使用MatchNodeSelector调度策略进行label匹配，找出目标node，然后将pod调度到目标节点，该匹配规则是强制约束。</p>
<p>接下来，实验一下：</p>
<ol>
<li><p>首先分别为node节点添加标签</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label nodes node1 nodeenv=pro</span></span><br><span class="line">node/node2 labeled</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl label nodes node2 nodeenv=test</span></span><br><span class="line">node/node2 labeled</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个<code>pod-nodeselector.yaml</code>文件，并使用它创建Pod</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeselector</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> </span><br><span class="line">    <span class="attr">nodeenv:</span> <span class="string">pro</span> <span class="comment"># 指定调度到具有nodeenv=pro标签的节点上</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeselector.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeselector</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看Pod调度到NODE属性，确实是调度到了node1节点上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodeselector -n dev -o wide</span></span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP          NODE    ......</span><br><span class="line">pod<span class="literal">-nodeselector</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">47</span>s   <span class="number">10.244</span>.<span class="number">1.87</span>   node1   ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，删除pod，修改nodeSelector的值为nodeenv: xxxx（不存在打有此标签的节点）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pod-nodeselector.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-nodeselector&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-nodeselector.yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeselector.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeselector</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次查看，发现pod无法正常运行,Node的值为none</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME               READY   STATUS    RESTARTS   AGE     IP       NODE    </span><br><span class="line">pod<span class="literal">-nodeselector</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">2</span>m20s   &lt;none&gt;   &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情,发现node selector匹配失败的提示</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-nodeselector -n dev</span></span><br><span class="line">.......</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>     Reason            Age        From               Message</span><br><span class="line">  <span class="literal">----</span>     <span class="literal">------</span>            <span class="literal">----</span>       <span class="literal">----</span>               <span class="literal">-------</span></span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">3</span> nodes are available: <span class="number">3</span> node(s) didn<span class="string">&#x27;t match node selector.</span></span><br><span class="line"><span class="string">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;</span>t match node selector.</span><br></pre></td></tr></table></figure>

<h2 id="2-亲和性调度"><a href="#2-亲和性调度" class="headerlink" title="2. 亲和性调度"></a>2. 亲和性调度</h2><p>上一节，介绍了两种定向调度的方式，使用起来非常方便，但是也有一定的问题，那就是如果没有满足条件的Node，那么Pod将不会被运行，即使在集群中还有可用Node列表也不行，这就限制了它的使用场景。</p>
<p>​    基于上面的问题，kubernetes还提供了一种亲和性调度（Affinity）。它在NodeSelector的基础之上的进行了扩展，可以通过配置的形式，实现优先选择满足条件的Node进行调度，如果没有，也可以调度到不满足条件的节点上，使调度更加灵活。</p>
<p>Affinity主要分为三类：</p>
<ul>
<li><p>nodeAffinity(node亲和性）: 以node为目标，解决pod可以调度到哪些node的问题</p>
</li>
<li><p>podAffinity(pod亲和性) :  以pod为目标，解决pod可以和哪些已存在的pod部署在同一个拓扑域中的问题</p>
</li>
<li><p>podAntiAffinity(pod反亲和性) :  以pod为目标，解决pod不能和哪些已存在pod部署在同一个拓扑域中的问题</p>
</li>
</ul>
<blockquote>
<p>关于亲和性(反亲和性)使用场景的说明：</p>
<p><strong>亲和性</strong>：如果两个应用频繁交互，那就有必要利用亲和性让两个应用的尽可能的靠近，这样可以减少因网络通信而带来的性能损耗。</p>
<p><strong>反亲和性</strong>：当应用的采用多副本部署时，有必要采用反亲和性让各个应用实例打散分布在各个node上，这样可以提高服务的高可用性。</p>
</blockquote>
<p><strong>NodeAffinity</strong></p>
<p>首先来看一下<code>NodeAffinity</code>的可配置项：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.nodeAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  Node节点必须满足指定的所有规则才可以，相当于硬限制</span><br><span class="line"><span class="code">    nodeSelectorTerms  节点选择列表</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持Exists, DoesNotExist, In, NotIn, Gt, Lt</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 优先调度到满足指定的规则的Node，相当于软限制 (倾向)</span></span><br><span class="line"><span class="code">    preference   一个节点选择器项，与相应的权重相关联</span></span><br><span class="line"><span class="code">      matchFields   按节点字段列出的节点选择器要求列表</span></span><br><span class="line"><span class="code">      matchExpressions   按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist, Gt, Lt</span></span><br><span class="line"><span class="code">	weight 倾向权重，在范围1-100。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">关系符的使用说明:</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> matchExpressions:</span><br><span class="line"><span class="bullet">  -</span> key: nodeenv              # 匹配存在标签的key为nodeenv的节点</span><br><span class="line"><span class="code">    operator: Exists</span></span><br><span class="line"><span class="code">  - key: nodeenv              # 匹配标签的key为nodeenv,且value是&quot;xxx&quot;或&quot;yyy&quot;的节点</span></span><br><span class="line"><span class="code">    operator: In</span></span><br><span class="line"><span class="code">    values: [&quot;xxx&quot;,&quot;yyy&quot;]</span></span><br><span class="line"><span class="code">  - key: nodeenv              # 匹配标签的key为nodeenv,且value大于&quot;xxx&quot;的节点</span></span><br><span class="line"><span class="code">    operator: Gt</span></span><br><span class="line"><span class="code">    values: &quot;xxx&quot;</span></span><br></pre></td></tr></table></figure>

<p>接下来首先演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建<code>pod-nodeaffinity-required.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">        <span class="attr">nodeSelectorTerms:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态 （运行失败）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodeaffinity-required -n dev -o wide</span></span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP       NODE    ...... </span><br><span class="line">pod<span class="literal">-nodeaffinity-required</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">16</span>s   &lt;none&gt;   &lt;none&gt;  ......</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod的详情</span></span><br><span class="line"><span class="comment"># 发现调度失败，提示node选择失败</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod pod-nodeaffinity-required -n dev</span></span><br><span class="line">......</span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">3</span> nodes are available: <span class="number">3</span> node(s) didn<span class="string">&#x27;t match node selector.</span></span><br><span class="line"><span class="string">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  0/3 nodes are available: 3 node(s) didn&#x27;</span>t match node selector.</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来，停止pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pod-nodeaffinity-required.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-nodeaffinity-required&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件，将values: [&quot;xxx&quot;,&quot;yyy&quot;]------&gt; [&quot;pro&quot;,&quot;yyy&quot;]</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-nodeaffinity-required.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次启动</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时查看，发现调度成功，已经将pod调度到了node1上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-nodeaffinity-required -n dev -o wide</span></span><br><span class="line">NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE  ...... </span><br><span class="line">pod<span class="literal">-nodeaffinity-required</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">11</span>s   <span class="number">10.244</span>.<span class="number">1.89</span>   node1 ......</span><br></pre></td></tr></table></figure>

<p>接下来再演示一下<code>requiredDuringSchedulingIgnoredDuringExecution</code> ,</p>
<p>创建<code>pod-nodeaffinity-preferred.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-nodeaffinity-preferred</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">nodeAffinity:</span> <span class="comment">#设置node亲和性</span></span><br><span class="line">      <span class="attr">preferredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 软限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">weight:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">preference:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签(当前环境没有)</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">nodeenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-nodeaffinity-preferred.yaml</span></span><br><span class="line">pod/pod<span class="literal">-nodeaffinity-preferred</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态 （运行成功）</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-nodeaffinity-preferred -n dev</span></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-nodeaffinity-preferred</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">40</span>s</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">NodeAffinity规则设置的注意事项：</span><br><span class="line"><span class="code">    1 如果同时定义了nodeSelector和nodeAffinity，那么必须两个条件都得到满足，Pod才能运行在指定的Node上</span></span><br><span class="line"><span class="code">    2 如果nodeAffinity指定了多个nodeSelectorTerms，那么只需要其中一个能够匹配成功即可</span></span><br><span class="line"><span class="code">    3 如果一个nodeSelectorTerms中有多个matchExpressions ，则一个节点必须满足所有的才能匹配成功</span></span><br><span class="line"><span class="code">    4 如果一个pod所在的Node在Pod运行期间其标签发生了改变，不再符合该Pod的节点亲和性需求，则系统将忽略此变化</span></span><br></pre></td></tr></table></figure>

<p><strong>PodAffinity</strong></p>
<p>PodAffinity主要实现以运行的Pod为参照，实现让新创建的Pod跟参照pod在一个区域的功能。</p>
<p>首先来看一下<code>PodAffinity</code>的可配置项：</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">pod.spec.affinity.podAffinity</span><br><span class="line">  requiredDuringSchedulingIgnoredDuringExecution  硬限制</span><br><span class="line"><span class="code">    namespaces       指定参照pod的namespace</span></span><br><span class="line"><span class="code">    topologyKey      指定调度作用域</span></span><br><span class="line"><span class="code">    labelSelector    标签选择器</span></span><br><span class="line"><span class="code">      matchExpressions  按节点标签列出的节点选择器要求列表(推荐)</span></span><br><span class="line"><span class="code">        key    键</span></span><br><span class="line"><span class="code">        values 值</span></span><br><span class="line"><span class="code">        operator 关系符 支持In, NotIn, Exists, DoesNotExist.</span></span><br><span class="line"><span class="code">      matchLabels    指多个matchExpressions映射的内容</span></span><br><span class="line"><span class="code">  preferredDuringSchedulingIgnoredDuringExecution 软限制</span></span><br><span class="line"><span class="code">    podAffinityTerm  选项</span></span><br><span class="line"><span class="code">      namespaces      </span></span><br><span class="line"><span class="code">      topologyKey</span></span><br><span class="line"><span class="code">      labelSelector</span></span><br><span class="line"><span class="code">        matchExpressions  </span></span><br><span class="line"><span class="code">          key    键</span></span><br><span class="line"><span class="code">          values 值</span></span><br><span class="line"><span class="code">          operator</span></span><br><span class="line"><span class="code">        matchLabels </span></span><br><span class="line"><span class="code">    weight 倾向权重，在范围1-100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">topologyKey用于指定调度时作用域,例如:</span><br><span class="line"><span class="code">    如果指定为kubernetes.io/hostname，那就是以Node节点为区分范围</span></span><br><span class="line"><span class="code">	如果指定为beta.kubernetes.io/os,则以Node节点的操作系统类型来区分</span></span><br></pre></td></tr></table></figure>

<p>接下来，演示下<code>requiredDuringSchedulingIgnoredDuringExecution</code>,</p>
<p>1）首先创建一个参照Pod，<code>pod-podaffinity-target.yaml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-target</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">podenv:</span> <span class="string">pro</span> <span class="comment">#设置标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">node1</span> <span class="comment"># 将目标pod名确指定到node1上</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动目标pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podaffinity-target.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podaffinity-target</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods  pod-podaffinity-target -n dev</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-podaffinity-target</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>s</span><br></pre></td></tr></table></figure>

<p>2）创建<code>pod-podaffinity-required.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配env的值在[&quot;xxx&quot;,&quot;yyy&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;xxx&quot;</span>,<span class="string">&quot;yyy&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;xxx或者nodeenv&#x3D;yyy的pod在同一Node上，显然现在没有这样pod，接下来，运行测试一下。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态，发现未运行</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-podaffinity-required -n dev</span></span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-podaffinity-required</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">9</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详细信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-podaffinity-required  -n dev</span></span><br><span class="line">......</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>     Reason            Age        From               Message</span><br><span class="line">  <span class="literal">----</span>     <span class="literal">------</span>            <span class="literal">----</span>       <span class="literal">----</span>               <span class="literal">-------</span></span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">3</span> nodes are available: <span class="number">2</span> node(s) didn<span class="string">&#x27;t match pod affinity rules, 1 node(s) had taints that the pod didn&#x27;</span>t tolerate.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来修改  values: [&quot;xxx&quot;,&quot;yyy&quot;]-----&gt;values:[&quot;pro&quot;,&quot;yyy&quot;]</span></span><br><span class="line"><span class="comment"># 意思是：新Pod必须要与拥有标签nodeenv=xxx或者nodeenv=yyy的pod在同一Node上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-podaffinity-required.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后重新创建pod，查看效果</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f  pod-podaffinity-required.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-podaffinity-required&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现此时Pod运行正常</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-podaffinity-required -n dev</span></span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE   LABELS</span><br><span class="line">pod<span class="literal">-podaffinity-required</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">6</span>s    &lt;none&gt;</span><br></pre></td></tr></table></figure>

<p>关于<code>PodAffinity</code>的 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，这里不再演示。</p>
<p><strong>PodAntiAffinity</strong></p>
<p>PodAntiAffinity主要实现以运行的Pod为参照，让新创建的Pod跟参照pod不在一个区域中的功能。</p>
<p>它的配置方式和选项跟PodAffinty是一样的，这里不再做详细解释，直接做一个测试案例。</p>
<p>1）继续使用上个案例中目标pod</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide --show-labels</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE    LABELS</span><br><span class="line">pod<span class="literal">-podaffinity-required</span> <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>m29s   <span class="number">10.244</span>.<span class="number">1.38</span>   node1   &lt;none&gt;     </span><br><span class="line">pod<span class="literal">-podaffinity-target</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">9</span>m25s   <span class="number">10.244</span>.<span class="number">1.37</span>   node1   podenv=pro</span><br></pre></td></tr></table></figure>

<p>2）创建<code>pod-podantiaffinity-required.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-podantiaffinity-required</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">affinity:</span>  <span class="comment">#亲和性设置</span></span><br><span class="line">    <span class="attr">podAntiAffinity:</span> <span class="comment">#设置pod亲和性</span></span><br><span class="line">      <span class="attr">requiredDuringSchedulingIgnoredDuringExecution:</span> <span class="comment"># 硬限制</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">labelSelector:</span></span><br><span class="line">          <span class="attr">matchExpressions:</span> <span class="comment"># 匹配podenv的值在[&quot;pro&quot;]中的标签</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">podenv</span></span><br><span class="line">            <span class="attr">operator:</span> <span class="string">In</span></span><br><span class="line">            <span class="attr">values:</span> [<span class="string">&quot;pro&quot;</span>]</span><br><span class="line">        <span class="attr">topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br></pre></td></tr></table></figure>

<p>上面配置表达的意思是：新Pod必须要与拥有标签nodeenv&#x3D;pro的pod不在同一Node上，运行测试一下。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-podantiaffinity-required.yaml</span></span><br><span class="line">pod/pod<span class="literal">-podantiaffinity-required</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line"><span class="comment"># 发现调度到了node2上</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-podantiaffinity-required -n dev -o wide</span></span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE   IP            NODE   .. </span><br><span class="line">pod<span class="literal">-podantiaffinity-required</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">30</span>s   <span class="number">10.244</span>.<span class="number">1.96</span>   node2  ..</span><br></pre></td></tr></table></figure>

<h2 id="3-污点和容忍"><a href="#3-污点和容忍" class="headerlink" title="3. 污点和容忍"></a>3. 污点和容忍</h2><p><strong>污点（Taints）</strong></p>
<p>前面的调度方式都是站在Pod的角度上，通过在Pod上添加属性，来确定Pod是否要调度到指定的Node上，其实我们也可以站在Node的角度上，通过在Node上添加<strong>污点</strong>属性，来决定是否允许Pod调度过来。</p>
<p>​    Node被设置上污点之后就和Pod之间存在了一种相斥的关系，进而拒绝Pod调度进来，甚至可以将已经存在的Pod驱逐出去。</p>
<p>污点的格式为：<code>key=value:effect</code>, key和value是污点的标签，effect描述污点的作用，支持如下三个选项：</p>
<ul>
<li>PreferNoSchedule：kubernetes将尽量避免把Pod调度到具有该污点的Node上，除非没有其他节点可调度</li>
<li>NoSchedule：kubernetes将不会把Pod调度到具有该污点的Node上，但不会影响当前Node上已存在的Pod</li>
<li>NoExecute：kubernetes将不会把Pod调度到具有该污点的Node上，同时也会将Node上已存在的Pod驱离</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/8ba3c39946b94b98897ecb157f506819.png" alt="在这里插入图片描述"><br>使用kubectl设置和去除污点的命令示例如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置污点</span></span><br><span class="line">kubectl taint nodes node1 key=value:effect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除污点</span></span><br><span class="line">kubectl taint nodes node1 key:effect-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除所有污点</span></span><br><span class="line">kubectl taint nodes node1 key-</span><br></pre></td></tr></table></figure>

<p>接下来，演示下污点的效果：</p>
<ol>
<li>准备节点node1（为了演示效果更加明显，暂时停止node2节点）</li>
<li>为node1节点设置一个污点: <code>tag=heima:PreferNoSchedule</code>；然后创建pod1( pod1 可以 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoSchedule</code>；然后创建pod2( pod1 正常  pod2 失败 )</li>
<li>修改为node1节点设置一个污点: <code>tag=heima:NoExecute</code>；然后创建pod3 ( 3个pod都失败 )</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为node1设置污点(PreferNoSchedule)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag=heima:PreferNoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pod1</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run taint1 --image=nginx:1.17.1 -n dev</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP           NODE   </span><br><span class="line">taint1<span class="literal">-7665f7fd85-574h4</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m24s   <span class="number">10.244</span>.<span class="number">1.59</span>   node1    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为node1设置污点(取消PreferNoSchedule，设置NoSchedule)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag:PreferNoSchedule-</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag=heima:NoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pod2</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run taint2 --image=nginx:1.17.1 -n dev</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods taint2 -n dev -o wide</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE     IP            NODE</span><br><span class="line">taint1<span class="literal">-7665f7fd85-574h4</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m24s   <span class="number">10.244</span>.<span class="number">1.59</span>   node1 </span><br><span class="line">taint2<span class="literal">-544694789-6zmlf</span>    <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">21</span>s     &lt;none&gt;        &lt;none&gt;   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为node1设置污点(取消NoSchedule，设置NoExecute)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag:NoSchedule-</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl taint nodes node1 tag=heima:NoExecute</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建pod3</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl run taint3 --image=nginx:1.17.1 -n dev</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                      READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">taint1<span class="literal">-7665f7fd85-htkmp</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">35</span>s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;    </span><br><span class="line">taint2<span class="literal">-544694789-bn7wb</span>    <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">35</span>s   &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br><span class="line">taint3<span class="literal">-6d78dbd749-tktkq</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">6</span>s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;     </span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">小提示：</span><br><span class="line"><span class="code">    使用kubeadm搭建的集群，默认就会给master节点添加一个污点标记,所以pod就不会调度到master节点上.</span></span><br></pre></td></tr></table></figure>

<p><strong>容忍（Toleration）</strong></p>
<p>上面介绍了污点的作用，我们可以在node上添加污点用于拒绝pod调度上来，但是如果就是想将一个pod调度到一个有污点的node上去，这时候应该怎么做呢？这就要使用到<strong>容忍</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/db047197e374495398e5f726ca7279cb.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>污点就是拒绝，容忍就是忽略，Node通过污点拒绝pod调度上去，Pod通过容忍忽略拒绝</p>
</blockquote>
<p>下面先通过一个案例看下效果：</p>
<ol>
<li>上一小节，已经在node1节点上打上了<code>NoExecute</code>的污点，此时pod是调度不上去的</li>
<li>本小节，可以通过给pod添加容忍，然后将其调度上去</li>
</ol>
<p>创建<code>pod-toleration.yaml</code>，内容如下 </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-toleration</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="attr">tolerations:</span>      <span class="comment"># 添加容忍</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">&quot;tag&quot;</span>        <span class="comment"># 要容忍的污点的key</span></span><br><span class="line">    <span class="attr">operator:</span> <span class="string">&quot;Equal&quot;</span> <span class="comment"># 操作符</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&quot;heima&quot;</span>    <span class="comment"># 容忍的污点的value</span></span><br><span class="line">    <span class="attr">effect:</span> <span class="string">&quot;NoExecute&quot;</span>   <span class="comment"># 添加容忍的规则，这里必须和标记的污点规则相同</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加容忍之前的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP       NODE     NOMINATED </span><br><span class="line">pod<span class="literal">-toleration</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">3</span>s    &lt;none&gt;   &lt;none&gt;   &lt;none&gt;           </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加容忍之后的pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME             READY   STATUS    RESTARTS   AGE   IP            NODE    NOMINATED</span><br><span class="line">pod<span class="literal">-toleration</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>s    <span class="number">10.244</span>.<span class="number">1.62</span>   node1   &lt;none&gt;        </span><br></pre></td></tr></table></figure>

<p>下面看一下容忍的详细配置：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.tolerations</span></span><br><span class="line">......</span><br><span class="line">FIELDS:</span><br><span class="line">   key       <span class="comment"># 对应着要容忍的污点的键，空意味着匹配所有的键</span></span><br><span class="line">   value     <span class="comment"># 对应着要容忍的污点的值</span></span><br><span class="line">   operator  <span class="comment"># key-value的运算符，支持Equal和Exists（默认）</span></span><br><span class="line">   effect    <span class="comment"># 对应污点的effect，空意味着匹配所有影响</span></span><br><span class="line">   tolerationSeconds   <span class="comment"># 容忍时间, 当effect为NoExecute时生效，表示pod在Node上的停留时间</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kuternetes Pod介绍与配置</title>
    <url>/2022/11/02/kubernetes/5kuternetes%20Pod%E4%BB%8B%E7%BB%8D%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-Pod介绍"><a href="#1-Pod介绍" class="headerlink" title="1. Pod介绍"></a>1. Pod介绍</h2><h3 id="1-1-Pod结构"><a href="#1-1-Pod结构" class="headerlink" title="1.1 Pod结构"></a>1.1 Pod结构</h3><p><img src="https://img-blog.csdnimg.cn/23fcd3ffcf604a849c93e4d023e1a52e.png" alt="在这里插入图片描述"><br>每个Pod中都可以包含一个或者多个容器，这些容器可以分为两类：</p>
<ul>
<li><p>用户程序所在的容器，数量可多可少</p>
</li>
<li><p>Pause容器，这是每个Pod都会有的一个<strong>根容器</strong>，它的作用有两个：</p>
<ul>
<li><p>可以以它为依据，评估整个Pod的健康状态</p>
</li>
<li><p>可以在根容器上设置Ip地址，其它容器都使用这个Ip（Pod IP），以实现Pod内部的网路通信</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">这里是Pod内部的通讯，Pod的之间的通讯采用虚拟二层网络技术来实现，我们当前环境用的是Flannel</span><br></pre></td></tr></table></figure>


<h3 id="1-2-Pod定义"><a href="#1-2-Pod定义" class="headerlink" title="1.2 Pod定义"></a>1.2 Pod定义</h3><p>下面是Pod的资源清单：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>     <span class="comment">#必选，版本号，例如v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>       　 <span class="comment">#必选，资源类型，例如 Pod</span></span><br><span class="line"><span class="attr">metadata:</span>       　 <span class="comment">#必选，元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span>     <span class="comment">#必选，Pod名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">string</span>  <span class="comment">#Pod所属的命名空间,默认为&quot;default&quot;</span></span><br><span class="line">  <span class="attr">labels:</span>       　　  <span class="comment">#自定义标签列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      　          </span><br><span class="line"><span class="attr">spec:</span>  <span class="comment">#必选，Pod中容器的详细定义</span></span><br><span class="line">  <span class="attr">containers:</span>  <span class="comment">#必选，Pod中容器列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>   <span class="comment">#必选，容器名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">string</span>  <span class="comment">#必选，容器的镜像名称</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> [ <span class="string">Always|Never|IfNotPresent</span> ]  <span class="comment">#获取镜像的策略 </span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">string</span>]   <span class="comment">#容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">    <span class="attr">args:</span> [<span class="string">string</span>]      <span class="comment">#容器的启动命令参数列表</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">string</span>  <span class="comment">#容器的工作目录</span></span><br><span class="line">    <span class="attr">volumeMounts:</span>       <span class="comment">#挂载到容器内部的存储卷配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>      <span class="comment">#引用pod定义的共享存储卷的名称，需用volumes[]部分定义的的卷名</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">string</span> <span class="comment">#存储卷在容器内mount的绝对路径，应少于512字符</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="string">boolean</span> <span class="comment">#是否为只读模式</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment">#需要暴露的端口库号列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>        <span class="comment">#端口的名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="string">int</span>  <span class="comment">#容器需要监听的端口号</span></span><br><span class="line">      <span class="attr">hostPort:</span> <span class="string">int</span>       <span class="comment">#容器所在主机需要监听的端口号，默认与Container相同</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">string</span>    <span class="comment">#端口协议，支持TCP和UDP，默认TCP</span></span><br><span class="line">    <span class="attr">env:</span>   <span class="comment">#容器运行前需设置的环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>  <span class="comment">#环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">string</span> <span class="comment">#环境变量的值</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment">#资源限制和请求的设置</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment">#资源限制的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>     <span class="comment">#Cpu的限制，单位为core数，将用于docker run --cpu-shares参数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span>  <span class="comment">#内存限制，单位可以为Mib/Gib，将用于docker run --memory参数</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment">#资源请求的设置</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">string</span>    <span class="comment">#Cpu请求，容器启动的初始可用数量</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">string</span> <span class="comment">#内存请求,容器启动的初始可用数量</span></span><br><span class="line">    <span class="attr">lifecycle:</span> <span class="comment">#生命周期钩子</span></span><br><span class="line">		<span class="attr">postStart:</span> <span class="comment">#容器启动后立即执行此钩子,如果执行失败,会根据重启策略进行重启</span></span><br><span class="line">		<span class="attr">preStop:</span> <span class="comment">#容器终止前执行此钩子,无论结果如何,容器都会终止</span></span><br><span class="line">    <span class="attr">livenessProbe:</span>  <span class="comment">#对Pod内各容器健康检查的设置，当探测无响应几次后将自动重启该容器</span></span><br><span class="line">      <span class="attr">exec:</span>       　 <span class="comment">#对Pod容器内检查方式设置为exec方式</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">string</span>]  <span class="comment">#exec方式需要制定的命令或脚本</span></span><br><span class="line">      <span class="attr">httpGet:</span>       <span class="comment">#对Pod内个容器健康检查方法设置为HttpGet，需要制定Path、port</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">        <span class="attr">host:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">HttpHeaders:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">tcpSocket:</span>     <span class="comment">#对Pod内个容器健康检查方式设置为tcpSocket方式</span></span><br><span class="line">         <span class="attr">port:</span> <span class="string">number</span></span><br><span class="line">       <span class="attr">initialDelaySeconds:</span> <span class="number">0</span>       <span class="comment">#容器启动完成后首次探测的时间，单位为秒</span></span><br><span class="line">       <span class="attr">timeoutSeconds:</span> <span class="number">0</span>    　　    <span class="comment">#对容器健康检查探测等待响应的超时时间，单位秒，默认1秒</span></span><br><span class="line">       <span class="attr">periodSeconds:</span> <span class="number">0</span>     　　    <span class="comment">#对容器监控检查的定期探测时间设置，单位秒，默认10秒一次</span></span><br><span class="line">       <span class="attr">successThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">failureThreshold:</span> <span class="number">0</span></span><br><span class="line">       <span class="attr">securityContext:</span></span><br><span class="line">         <span class="attr">privileged:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> [<span class="string">Always</span> <span class="string">|</span> <span class="string">Never</span> <span class="string">|</span> <span class="string">OnFailure</span>]  <span class="comment">#Pod的重启策略</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">&lt;string&gt;</span> <span class="comment">#设置NodeName表示将该Pod调度到指定到名称的node节点上</span></span><br><span class="line">  <span class="attr">nodeSelector:</span> <span class="string">obeject</span> <span class="comment">#设置NodeSelector表示将该Pod调度到包含这个label的node上</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span> <span class="comment">#Pull镜像时使用的secret名称，以key：secretkey格式指定</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">hostNetwork:</span> <span class="literal">false</span>   <span class="comment">#是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</span></span><br><span class="line">  <span class="attr">volumes:</span>   <span class="comment">#在该pod上定义共享存储卷列表</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">string</span>    <span class="comment">#共享存储卷名称 （volumes类型有很多种）</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;       <span class="comment">#类型为emtyDir的存储卷，与Pod同生命周期的一个临时目录。为空值</span></span><br><span class="line">    <span class="attr">hostPath:</span> <span class="string">string</span>   <span class="comment">#类型为hostPath的存储卷，表示挂载Pod所在宿主机的目录</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">string</span>      　　        <span class="comment">#Pod所在宿主机的目录，将被用于同期中mount的目录</span></span><br><span class="line">    <span class="attr">secret:</span>       　　　<span class="comment">#类型为secret的存储卷，挂载集群与定义的secret对象到容器内部</span></span><br><span class="line">      <span class="attr">scretname:</span> <span class="string">string</span>  </span><br><span class="line">      <span class="attr">items:</span>     </span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br><span class="line">    <span class="attr">configMap:</span>         <span class="comment">#类型为configMap的存储卷，挂载预定义的configMap对象到容器内部</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">      <span class="attr">items:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">string</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">string</span></span><br></pre></td></tr></table></figure>

<p><strong>查看pod的可配置项</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以通过explain命令来查看每种资源的可配置项</span></span><br><span class="line"><span class="comment">#   kubectl explain 资源类型         查看某种资源可以配置的一级属性</span></span><br><span class="line"><span class="comment">#	kubectl explain 资源类型.属性     查看属性的子属性</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">FIELDS:</span><br><span class="line">   apiVersion   &lt;string&gt;</span><br><span class="line">   kind &lt;string&gt;</span><br><span class="line">   metadata     &lt;Object&gt;</span><br><span class="line">   spec &lt;Object&gt;</span><br><span class="line">   status       &lt;Object&gt;</span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.metadata</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: metadata &lt;Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   annotations  &lt;map[<span class="built_in">string</span>]string&gt;</span><br><span class="line">   clusterName  &lt;string&gt;</span><br><span class="line">   creationTimestamp    &lt;string&gt;</span><br><span class="line">   deletionGracePeriodSeconds   &lt;integer&gt;</span><br><span class="line">   deletionTimestamp    &lt;string&gt;</span><br><span class="line">   finalizers   &lt;[]string&gt;</span><br><span class="line">   generateName &lt;string&gt;</span><br><span class="line">   generation   &lt;integer&gt;</span><br><span class="line">   labels       &lt;map[<span class="built_in">string</span>]string&gt;</span><br><span class="line">   managedFields        &lt;[]Object&gt;</span><br><span class="line">   name &lt;string&gt;</span><br><span class="line">   namespace    &lt;string&gt;</span><br><span class="line">   ownerReferences      &lt;[]Object&gt;</span><br><span class="line">   resourceVersion      &lt;string&gt;</span><br><span class="line">   selfLink     &lt;string&gt;</span><br><span class="line">   uid  &lt;string&gt;</span><br></pre></td></tr></table></figure>

<p>在kubernetes中基本所有资源的一级属性都是一样的，主要包含5部分：</p>
<ul>
<li><p>apiVersion   &lt;string&gt;     版本，由kubernetes内部定义，版本号必须可以用 kubectl api-versions 查询到</p>
</li>
<li><p>kind &lt;string&gt;                类型，由kubernetes内部定义，版本号必须可以用 kubectl api-resources 查询到</p>
</li>
<li><p>metadata   &lt;Object&gt;     元数据，主要是资源标识和说明，常用的有name、namespace、labels等</p>
</li>
<li><p>spec &lt;Object&gt;               描述，这是配置中最重要的一部分，里面是对各种资源配置的详细描述                </p>
</li>
<li><p>status  &lt;Object&gt;            状态信息，里面的内容不需要定义，由kubernetes自动生成</p>
</li>
</ul>
<p>在上面的属性中，spec是接下来研究的重点，继续看下它的常见子属性:</p>
<ul>
<li>containers   &lt;[]Object&gt;       容器列表，用于定义容器的详细信息 </li>
<li>nodeName &lt;String&gt;           根据nodeName的值将pod调度到指定的Node节点上</li>
<li>nodeSelector   &lt;map[]&gt;      根据NodeSelector中定义的信息选择将该Pod调度到包含这些label的Node 上</li>
<li>hostNetwork  &lt;boolean&gt;    是否使用主机网络模式，默认为false，如果设置为true，表示使用宿主机网络</li>
<li>volumes      &lt;[]Object&gt;       存储卷，用于定义Pod上面挂在的存储信息 </li>
<li>restartPolicy	&lt;string&gt;       重启策略，表示Pod在遇到故障的时候的处理策略</li>
</ul>
<h2 id="2-Pod配置"><a href="#2-Pod配置" class="headerlink" title="2. Pod配置"></a>2. Pod配置</h2><p>本小节主要来研究<code>pod.spec.containers</code>属性，这也是pod配置中最为关键的一项配置。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.containers</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: containers &lt;[]Object&gt;   <span class="comment"># 数组，代表可以有多个容器</span></span><br><span class="line">FIELDS:</span><br><span class="line">   name  &lt;string&gt;     <span class="comment"># 容器名称</span></span><br><span class="line">   image &lt;string&gt;     <span class="comment"># 容器需要的镜像地址</span></span><br><span class="line">   imagePullPolicy  &lt;string&gt; <span class="comment"># 镜像拉取策略 </span></span><br><span class="line">   command  &lt;[]string&gt; <span class="comment"># 容器的启动命令列表，如不指定，使用打包时使用的启动命令</span></span><br><span class="line">   args     &lt;[]string&gt; <span class="comment"># 容器的启动命令需要的参数列表</span></span><br><span class="line">   env      &lt;[]Object&gt; <span class="comment"># 容器环境变量的配置</span></span><br><span class="line">   ports    &lt;[]Object&gt;     <span class="comment"># 容器需要暴露的端口号列表</span></span><br><span class="line">   resources &lt;Object&gt;      <span class="comment"># 资源限制和资源请求的设置</span></span><br></pre></td></tr></table></figure>


<h3 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h3><p>创建<code>pod-base.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-base</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">light</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p>上面定义了一个比较简单Pod的配置，里面有两个容器：</p>
<ul>
<li>nginx：用1.17.1版本的nginx镜像创建，（nginx是一个轻量级web容器）</li>
<li>busybox：用1.30版本的busybox镜像创建，（busybox是一个小巧的linux命令集合）</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl apply -f pod-base.yaml</span></span><br><span class="line">pod/pod<span class="literal">-base</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod状况</span></span><br><span class="line"><span class="comment"># READY 1/2 : 表示当前Pod中有2个容器，其中1个准备就绪，1个未就绪</span></span><br><span class="line"><span class="comment"># RESTARTS  : 重启次数，因为有1个容器故障了，Pod一直在重启试图恢复它</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl get pod -n dev</span></span><br><span class="line">NAME       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-base</span>   <span class="number">1</span>/<span class="number">2</span>     Running   <span class="number">4</span>          <span class="number">95</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过describe查看内部的详情</span></span><br><span class="line"><span class="comment"># 此时已经运行起来了一个基本的Pod，虽然它暂时有问题</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl describe pod pod-base -n dev</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-镜像拉取"><a href="#2-2-镜像拉取" class="headerlink" title="2.2 镜像拉取"></a>2.2 镜像拉取</h3><p>创建<code>pod-imagepullpolicy.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-imagepullpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">Always</span> <span class="comment"># 用于设置镜像拉取策略</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br></pre></td></tr></table></figure>

<p>imagePullPolicy，用于设置镜像拉取策略，kubernetes支持配置三种拉取策略：</p>
<ul>
<li>Always：总是从远程仓库拉取镜像（一直远程下载）</li>
<li>IfNotPresent：本地有则使用本地镜像，本地没有则从远程仓库拉取镜像（本地有就本地  本地没远程下载）</li>
<li>Never：只使用本地镜像，从不去远程仓库拉取，本地没有就报错 （一直使用本地）</li>
</ul>
<blockquote>
<p>默认值说明：<br> 如果镜像tag为具体版本号， 默认策略是：IfNotPresent<br>如果镜像tag为：latest（最终版本） ，默认策略是always</p>
</blockquote>
<h3 id="2-3-启动命令"><a href="#2-3-启动命令" class="headerlink" title="2.3 启动命令"></a>2.3 启动命令</h3><p> 在前面的案例中，一直有一个问题没有解决，就是的busybox容器一直没有成功运行，那么到底是什么原因导致这个容器的故障呢？</p>
<p>​    原来busybox并不是一个程序，而是类似于一个工具类的集合，kubernetes集群启动管理后，它会自动关闭。解决方法就是让其一直在运行，这就用到了command配置。</p>
<p>创建pod-command.yaml文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-command</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;touch /tmp/hello.txt;while true;do /bin/echo $(date +%T) &gt;&gt; /tmp/hello.txt; sleep 3; done;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>command，用于在pod中的容器初始化完毕之后运行一个命令。</p>
<blockquote>
<p>稍微解释下上面命令的意思：<br>​    “&#x2F;bin&#x2F;sh”,”-c”,  使用sh执行命令<br>​    touch &#x2F;tmp&#x2F;hello.txt;   创建一个&#x2F;tmp&#x2F;hello.txt 文件<br>​    while true;do &#x2F;bin&#x2F;echo $(date +%T) &gt;&gt; &#x2F;tmp&#x2F;hello.txt; sleep 3; done;  每隔3秒向文件中写入当前时间</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl create  -f pod-command.yaml</span></span><br><span class="line">pod/pod<span class="literal">-command</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod状态</span></span><br><span class="line"><span class="comment"># 此时发现两个pod都正常运行了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl get pods pod-command -n dev</span></span><br><span class="line">NAME          READY   STATUS   RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-command</span>   <span class="number">2</span>/<span class="number">2</span>     Runing   <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入pod中的busybox容器，查看文件内容</span></span><br><span class="line"><span class="comment"># 补充一个命令: kubectl exec  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令</span></span><br><span class="line"><span class="comment"># 使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span></span><br><span class="line"><span class="comment"># 比如，可以查看txt文件的内容</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">pod</span>]<span class="comment"># kubectl exec pod-command -n dev -it -c busybox /bin/sh</span></span><br><span class="line">/ <span class="comment"># tail -f /tmp/hello.txt</span></span><br><span class="line"><span class="number">13</span>:<span class="number">35</span>:<span class="number">35</span></span><br><span class="line"><span class="number">13</span>:<span class="number">35</span>:<span class="number">38</span></span><br><span class="line"><span class="number">13</span>:<span class="number">35</span>:<span class="number">41</span></span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line"><span class="section"># 创建Pod</span></span><br><span class="line">[root@master pod]# kubectl create  -f pod-command.yaml</span><br><span class="line">pod/pod-command created</span><br><span class="line"></span><br><span class="line"><span class="section"># 查看Pod状态</span></span><br><span class="line"><span class="section"># 此时发现两个pod都正常运行了</span></span><br><span class="line">[root@master pod]# kubectl get pods pod-command -n dev</span><br><span class="line">NAME          READY   STATUS   RESTARTS   AGE</span><br><span class="line">pod-command   2/2     Runing   0          2s</span><br><span class="line"></span><br><span class="line"><span class="section"># 进入pod中的busybox容器，查看文件内容</span></span><br><span class="line"><span class="section"># 补充一个命令: kubectl exec  pod名称 -n 命名空间 -it -c 容器名称 /bin/sh  在容器内部执行命令</span></span><br><span class="line"><span class="section"># 使用这个命令就可以进入某个容器的内部，然后进行相关操作了</span></span><br><span class="line"><span class="section"># 比如，可以查看txt文件的内容</span></span><br><span class="line">[root@master pod]# kubectl exec pod-command -n dev -it -c busybox /bin/sh</span><br><span class="line">/ # tail -f /tmp/hello.txt</span><br><span class="line">13:35:35</span><br><span class="line">13:35:38</span><br><span class="line">13:35:41</span><br></pre></td></tr></table></figure>

<h3 id="2-4-环境变量"><a href="#2-4-环境变量" class="headerlink" title="2.4 环境变量"></a>2.4 环境变量</h3><p>创建<code>pod-env.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;while true;do /bin/echo $(date +%T);sleep 60; done;&quot;</span>]</span><br><span class="line">    <span class="attr">env:</span> <span class="comment"># 设置环境变量列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;username&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;admin&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;password&quot;</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;123456&quot;</span></span><br></pre></td></tr></table></figure>

<p>env，环境变量，用于在pod中的容器设置环境变量。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-env.yaml</span></span><br><span class="line">pod/pod<span class="literal">-env</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器，输出环境变量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec pod-env -n dev -c busybox -it /bin/sh</span></span><br><span class="line">/ <span class="comment"># echo $username</span></span><br><span class="line">admin</span><br><span class="line">/ <span class="comment"># echo $password</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>这种方式不是很推荐，推荐将这些配置单独存储在配置文件中，这种方式将在后面介绍。</p>
<h3 id="2-5-端口设置"><a href="#2-5-端口设置" class="headerlink" title="2.5 端口设置"></a>2.5 端口设置</h3><p>下面来介绍容器的端口设置，也就是containers的ports选项。</p>
<p>首先看下ports支持的子选项：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.containers.ports</span></span><br><span class="line">KIND:     Pod</span><br><span class="line">VERSION:  v1</span><br><span class="line">RESOURCE: ports &lt;[]Object&gt;</span><br><span class="line">FIELDS:</span><br><span class="line">   name         &lt;string&gt;  <span class="comment"># 端口名称，如果指定，必须保证name在pod中是唯一的		</span></span><br><span class="line">   containerPort&lt;integer&gt; <span class="comment"># 容器要监听的端口(0&lt;x&lt;65536)</span></span><br><span class="line">   hostPort     &lt;integer&gt; <span class="comment"># 容器要在主机上公开的端口，如果设置，主机上只能运行容器的一个副本(一般省略) </span></span><br><span class="line">   hostIP       &lt;string&gt;  <span class="comment"># 要将外部端口绑定到的主机IP(一般省略)</span></span><br><span class="line">   protocol     &lt;string&gt;  <span class="comment"># 端口协议。必须是UDP、TCP或SCTP。默认为“TCP”。</span></span><br></pre></td></tr></table></figure>

<p>接下来，编写一个测试案例，创建<code>pod-ports.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-ports</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 设置容器暴露的端口列表</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-ports.yaml</span></span><br><span class="line">pod/pod<span class="literal">-ports</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line"><span class="comment"># 在下面可以明显看到配置信息</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-ports -n dev -o yaml</span></span><br><span class="line">......</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:<span class="number">1.17</span>.<span class="number">1</span></span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: nginx</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: <span class="number">80</span></span><br><span class="line">      hostPort: <span class="number">80</span></span><br><span class="line">      name: nginx<span class="literal">-port</span></span><br><span class="line">      protocol: TCP</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>访问容器中的程序需要使用的是<code>podIp:containerPort</code></p>
<h3 id="2-6-资源配额"><a href="#2-6-资源配额" class="headerlink" title="2.6 资源配额"></a>2.6 资源配额</h3><p>容器中的程序要运行，肯定是要占用一定资源的，比如cpu和内存等，如果不对某个容器的资源做限制，那么它就可能吃掉大量资源，导致其它容器无法运行。针对这种情况，kubernetes提供了对内存和cpu的资源进行配额的机制，这种机制主要通过resources选项实现，他有两个子选项：</p>
<ul>
<li><p>limits：用于限制运行时容器的最大占用资源，当容器占用资源超过limits时会被终止，并进行重启</p>
</li>
<li><p>requests ：用于设置容器需要的最小资源，如果环境资源不够，容器将无法启动</p>
</li>
</ul>
<p>可以通过上面两个选项设置资源的上下限。</p>
<p>接下来，编写一个测试案例，创建<code>pod-resources.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-resources</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">resources:</span> <span class="comment"># 资源配额</span></span><br><span class="line">      <span class="attr">limits:</span>  <span class="comment"># 限制资源（上限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span> <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Gi&quot;</span> <span class="comment"># 内存限制</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment"># 请求资源（下限）</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span>  <span class="comment"># CPU限制，单位是core数</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;10Mi&quot;</span>  <span class="comment"># 内存限制</span></span><br></pre></td></tr></table></figure>

<p>在这对cpu和memory的单位做一个说明：</p>
<ul>
<li><p>cpu：core数，可以为整数或小数</p>
</li>
<li><p>memory： 内存大小，可以使用Gi、Mi、G、M等形式</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create  -f pod-resources.yaml</span></span><br><span class="line">pod/pod<span class="literal">-resources</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看发现pod运行正常</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-resources -n dev</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE  </span><br><span class="line">pod<span class="literal">-resources</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">39</span>s   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，停止Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete  -f pod-resources.yaml</span></span><br><span class="line">pod <span class="string">&quot;pod-resources&quot;</span> deleted</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑pod，修改resources.requests.memory的值为10Gi</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># vim pod-resources.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次启动pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create  -f pod-resources.yaml</span></span><br><span class="line">pod/pod<span class="literal">-resources</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod状态，发现Pod启动失败</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-resources -n dev -o wide</span></span><br><span class="line">NAME            READY   STATUS    RESTARTS   AGE          </span><br><span class="line">pod<span class="literal">-resources</span>   <span class="number">0</span>/<span class="number">2</span>     Pending   <span class="number">0</span>          <span class="number">20</span>s    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod详情会发现，如下提示</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod pod-resources -n dev</span></span><br><span class="line">......</span><br><span class="line">Warning  FailedScheduling  &lt;unknown&gt;  default<span class="literal">-scheduler</span>  <span class="number">0</span>/<span class="number">2</span> nodes are available: <span class="number">2</span> Insufficient memory.(内存不足)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kuternetes Pod生命周期</title>
    <url>/2022/11/02/kubernetes/6kuternetes%20Pod%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>我们一般将pod对象从创建至终的这段时间范围称为pod的生命周期，它主要包含下面的过程：</p>
<ul>
<li><p>pod创建过程</p>
</li>
<li><p>运行初始化容器（init container）过程</p>
</li>
<li><p>运行主容器（main container）</p>
<ul>
<li><p>容器启动后钩子（post start）、容器终止前钩子（pre stop）</p>
</li>
<li><p>容器的存活性探测（liveness probe）、就绪性探测（readiness probe）</p>
</li>
</ul>
</li>
<li><p>pod终止过程</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/351bf896f47a4e62b71d4a080810e6bb.png" alt="在这里插入图片描述"><br>在整个生命周期中，Pod会出现5种<strong>状态</strong>（<strong>相位</strong>），分别如下：</p>
<ul>
<li>挂起（Pending）：apiserver已经创建了pod资源对象，但它尚未被调度完成或者仍处于下载镜像的过程中</li>
<li>运行中（Running）：pod已经被调度至某节点，并且所有容器都已经被kubelet创建完成</li>
<li>成功（Succeeded）：pod中的所有容器都已经成功终止并且不会被重启</li>
<li>失败（Failed）：所有容器都已经终止，但至少有一个容器终止失败，即容器返回了非0值的退出状态</li>
<li>未知（Unknown）：apiserver无法正常获取到pod对象的状态信息，通常由网络通信失败所导致</li>
</ul>
<h2 id="1-创建和终止"><a href="#1-创建和终止" class="headerlink" title="1.创建和终止"></a>1.创建和终止</h2><p><strong>pod的创建过程</strong></p>
<ol>
<li><p>用户通过kubectl或其他api客户端提交需要创建的pod信息给apiServer</p>
</li>
<li><p>apiServer开始生成pod对象的信息，并将信息存入etcd，然后返回确认信息至客户端</p>
</li>
<li><p>apiServer开始反映etcd中的pod对象的变化，其它组件使用watch机制来跟踪检查apiServer上的变动</p>
</li>
<li><p>scheduler发现有新的pod对象要创建，开始为Pod分配主机并将结果信息更新至apiServer</p>
</li>
<li><p>node节点上的kubelet发现有pod调度过来，尝试调用docker启动容器，并将结果回送至apiServer</p>
</li>
<li><p>apiServer将接收到的pod状态信息存入etcd中</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/1f1d9b95496644de9fcad400edc74b7a.png" alt="在这里插入图片描述"><br><strong>pod的终止过程</strong></p>
<ol>
<li>用户向apiServer发送删除pod对象的命令</li>
<li>apiServcer中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li>
<li>将pod标记为terminating状态</li>
<li>kubelet在监控到pod对象转为terminating状态的同时启动pod关闭过程</li>
<li>端点控制器监控到pod对象的关闭行为时将其从所有匹配到此端点的service资源的端点列表中移除</li>
<li>如果当前pod对象定义了preStop钩子处理器，则在其标记为terminating后即会以同步的方式启动执行</li>
<li>pod对象中的容器进程收到停止信号</li>
<li>宽限期结束后，若pod中还存在仍在运行的进程，那么pod对象会收到立即终止的信号</li>
<li>kubelet请求apiServer将此pod资源的宽限期设置为0从而完成删除操作，此时pod对于用户已不可见</li>
</ol>
<h2 id="2-初始化容器"><a href="#2-初始化容器" class="headerlink" title="2. 初始化容器"></a>2. 初始化容器</h2><p>初始化容器是在pod的主容器启动之前要运行的容器，主要是做一些主容器的前置工作，它具有两大特征：</p>
<ol>
<li>初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成</li>
<li>初始化容器必须按照定义的顺序执行，当且仅当前一个成功之后，后面的一个才能运行</li>
</ol>
<p>初始化容器有很多的应用场景，下面列出的是最常见的几个：</p>
<ul>
<li>提供主容器镜像中不具备的工具程序或自定义代码</li>
<li>初始化容器要先于应用容器串行启动并运行完成，因此可用于延后应用容器的启动直至其依赖的条件得到满足</li>
</ul>
<p>接下来做一个案例，模拟下面这个需求：</p>
<p>​    假设要以主容器来运行nginx，但是要求在运行nginx之前先要能够连接上mysql和redis所在服务器</p>
<p>​    为了简化测试，事先规定好mysql<code>(192.168.109.201)</code>和redis<code>(192.168.109.202)</code>服务器的地址</p>
<p>创建<code>pod-initcontainer.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-initcontainer</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">initContainers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-mysql</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.109.201 -c 1 ; do echo waiting for mysql...; sleep 2; done;&#x27;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-redis</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;until ping 192.168.109.202 -c 1 ; do echo waiting for reids...; sleep 2; done;&#x27;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-initcontainer.yaml</span></span><br><span class="line">pod/pod<span class="literal">-initcontainer</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod状态</span></span><br><span class="line"><span class="comment"># 发现pod卡在启动第一个初始化容器过程中，后面的容器不会运行</span></span><br><span class="line">root@master ~]<span class="comment"># kubectl describe pod  pod-initcontainer -n dev</span></span><br><span class="line">........</span><br><span class="line">Events:</span><br><span class="line">  <span class="built_in">Type</span>    Reason     Age   From               Message</span><br><span class="line">  <span class="literal">----</span>    <span class="literal">------</span>     <span class="literal">----</span>  <span class="literal">----</span>               <span class="literal">-------</span></span><br><span class="line">  Normal  Scheduled  <span class="number">49</span>s   default<span class="literal">-scheduler</span>  Successfully assigned dev/pod<span class="literal">-initcontainer</span> to node1</span><br><span class="line">  Normal  Pulled     <span class="number">48</span>s   kubelet, node1     Container image <span class="string">&quot;busybox:1.30&quot;</span> already present on machine</span><br><span class="line">  Normal  Created    <span class="number">48</span>s   kubelet, node1     Created container <span class="built_in">test-mysql</span></span><br><span class="line">  Normal  Started    <span class="number">48</span>s   kubelet, node1     Started container <span class="built_in">test-mysql</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-initcontainer -n dev -w</span></span><br><span class="line">NAME                             READY   STATUS     RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     Init:<span class="number">0</span>/<span class="number">2</span>   <span class="number">0</span>          <span class="number">15</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     Init:<span class="number">1</span>/<span class="number">2</span>   <span class="number">0</span>          <span class="number">52</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     Init:<span class="number">1</span>/<span class="number">2</span>   <span class="number">0</span>          <span class="number">53</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">0</span>/<span class="number">1</span>     PodInitializing   <span class="number">0</span>          <span class="number">89</span>s</span><br><span class="line">pod<span class="literal">-initcontainer</span>                <span class="number">1</span>/<span class="number">1</span>     Running           <span class="number">0</span>          <span class="number">90</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来新开一个shell，为当前服务器新增两个ip，观察pod的变化</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ifconfig ens33:1 192.168.109.201 netmask 255.255.255.0 up</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ifconfig ens33:2 192.168.109.202 netmask 255.255.255.0 up</span></span><br></pre></td></tr></table></figure>

<h2 id="3-钩子函数"><a href="#3-钩子函数" class="headerlink" title="3. 钩子函数"></a>3. 钩子函数</h2><p>钩子函数能够感知自身生命周期中的事件，并在相应的时刻到来时运行用户指定的程序代码。</p>
<p>kubernetes在主容器的启动之后和停止之前提供了两个钩子函数：</p>
<ul>
<li>post start：容器创建之后执行，如果失败了会重启容器</li>
<li>pre stop  ：容器终止之前执行，执行完成之后容器将成功终止，在其完成之前会阻塞删除容器的操作</li>
</ul>
<p>钩子处理器支持使用下面三种方式定义动作：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span> </span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCPSocket：在当前容器尝试访问指定的socket</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPGet：在当前容器中向某url发起http请求</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">lifecycle:</span></span><br><span class="line">    <span class="attr">postStart:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.109</span><span class="number">.100</span> <span class="comment">#主机地址</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>接下来，以exec方式为例，演示下钩子函数的使用，创建<code>pod-hook-exec.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-hook-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">lifecycle:</span></span><br><span class="line">      <span class="attr">postStart:</span> </span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器启动的时候执行一个命令，修改掉nginx的默认首页内容</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo postStart... &gt; /usr/share/nginx/html/index.html&quot;</span>]</span><br><span class="line">      <span class="attr">preStop:</span></span><br><span class="line">        <span class="attr">exec:</span> <span class="comment"># 在容器停止之前停止nginx服务</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>,<span class="string">&quot;-s&quot;</span>,<span class="string">&quot;quit&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-hook-exec.yaml</span></span><br><span class="line">pod/pod<span class="literal">-hook-exec</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods  pod-hook-exec -n dev -o wide</span></span><br><span class="line">NAME           READY   STATUS     RESTARTS   AGE    IP            NODE    </span><br><span class="line">pod<span class="literal">-hook-exec</span>  <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">0</span>          <span class="number">29</span>s    <span class="number">10.244</span>.<span class="number">2.48</span>   node2   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.2.48</span></span><br><span class="line">postStart...</span><br></pre></td></tr></table></figure>

<h2 id="4-容器探测"><a href="#4-容器探测" class="headerlink" title="4. 容器探测"></a>4. 容器探测</h2><p>容器探测用于检测容器中的应用实例是否正常工作，是保障业务可用性的一种传统机制。如果经过探测，实例的状态不符合预期，那么kubernetes就会把该问题实例” 摘除 “，不承担业务流量。kubernetes提供了两种探针来实现容器探测，分别是：</p>
<ul>
<li><p>liveness probes：存活性探针，用于检测应用实例当前是否处于正常运行状态，如果不是，k8s会重启容器</p>
</li>
<li><p>readiness probes：就绪性探针，用于检测应用实例当前是否可以接收请求，如果不能，k8s不会转发流量</p>
</li>
</ul>
<blockquote>
<p>livenessProbe 决定是否重启容器，readinessProbe 决定是否将请求转发给容器。</p>
</blockquote>
<p>上面两种探针目前均支持三种探测方式：</p>
<ul>
<li><p>Exec命令：在容器内执行一次命令，如果命令执行的退出码为0，则认为程序正常，否则不正常</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">exec:</span></span><br><span class="line">      <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/tmp/healthy</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TCPSocket：将会尝试访问一个用户容器的端口，如果能够建立这条连接，则认为程序正常，否则不正常</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span>      </span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">tcpSocket:</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPGet：调用容器内Web应用的URL，如果返回的状态码在200和399之间，则认为程序正常，否则不正常</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">……</span></span><br><span class="line">  <span class="attr">livenessProbe:</span></span><br><span class="line">    <span class="attr">httpGet:</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/</span> <span class="comment">#URI地址</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#主机地址</span></span><br><span class="line">      <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line"><span class="string">……</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>下面以<code>liveness probes</code>为例，做几个演示：</p>
<p><strong>方式一：Exec</strong></p>
<p>创建<code>pod-liveness-exec.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-exec</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">exec:</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;/bin/cat&quot;</span>,<span class="string">&quot;/tmp/hello.txt&quot;</span>] <span class="comment"># 执行一个查看文件的命令</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-liveness-exec.yaml</span></span><br><span class="line">pod/pod<span class="literal">-liveness-exec</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-liveness-exec -n dev</span></span><br><span class="line">......</span><br><span class="line">  Normal   Created    <span class="number">20</span>s (x2 over <span class="number">50</span>s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    <span class="number">20</span>s (x2 over <span class="number">50</span>s)  kubelet, node1     Started container nginx</span><br><span class="line">  Normal   Killing    <span class="number">20</span>s                kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line">  Warning  Unhealthy  <span class="number">0</span>s (x5 over <span class="number">40</span>s)   kubelet, node1     Liveness probe failed: <span class="built_in">cat</span>: can<span class="string">&#x27;t open &#x27;</span>/tmp/hello11.txt<span class="string">&#x27;: No such file or directory</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string"># 观察上面的信息就会发现nginx容器启动之后就进行了健康检查</span></span><br><span class="line"><span class="string"># 检查失败之后，容器被kill掉，然后尝试进行重启（这是重启策略的作用，后面讲解）</span></span><br><span class="line"><span class="string"># 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line"><span class="string">[root@master ~]# kubectl get pods pod-liveness-exec -n dev</span></span><br><span class="line"><span class="string">NAME                READY   STATUS             RESTARTS   AGE</span></span><br><span class="line"><span class="string">pod-liveness-exec   0/1     CrashLoopBackOff   2          3m19s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 当然接下来，可以修改成一个存在的文件，比如/tmp/hello.txt，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>


<p><strong>方式二：TCPSocket</strong></p>
<p>创建<code>pod-liveness-tcpsocket.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-tcpsocket</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">tcpSocket:</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 尝试访问8080端口</span></span><br></pre></td></tr></table></figure>

<p> 创建pod，观察效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-liveness-tcpsocket.yaml</span></span><br><span class="line">pod/pod<span class="literal">-liveness-tcpsocket</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pods pod-liveness-tcpsocket -n dev</span></span><br><span class="line">......</span><br><span class="line">  Normal   Scheduled  <span class="number">31</span>s                            default<span class="literal">-scheduler</span>  Successfully assigned dev/pod<span class="literal">-liveness-tcpsocket</span> to node2</span><br><span class="line">  Normal   Pulled     &lt;invalid&gt;                      kubelet, node2     Container image <span class="string">&quot;nginx:1.17.1&quot;</span> already present on machine</span><br><span class="line">  Normal   Created    &lt;invalid&gt;                      kubelet, node2     Created container nginx</span><br><span class="line">  Normal   Started    &lt;invalid&gt;                      kubelet, node2     Started container nginx</span><br><span class="line">  Warning  Unhealthy  &lt;invalid&gt; (x2 over &lt;invalid&gt;)  kubelet, node2     Liveness probe failed: dial tcp <span class="number">10.244</span>.<span class="number">2.44</span>:<span class="number">8080</span>: connect: connection refused</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 观察上面的信息，发现尝试访问8080端口,但是失败了</span></span><br><span class="line"><span class="comment"># 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods pod-liveness-tcpsocket  -n dev</span></span><br><span class="line">NAME                     READY   STATUS             RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-liveness-tcpsocket</span>   <span class="number">0</span>/<span class="number">1</span>     CrashLoopBackOff   <span class="number">2</span>          <span class="number">3</span>m19s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然接下来，可以修改成一个可以访问的端口，比如80，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>

<p><strong>方式三：HTTPGet</strong></p>
<p>创建<code>pod-liveness-httpget.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span>  <span class="comment"># 其实就是访问http://127.0.0.1:80/hello  </span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span> <span class="comment">#支持的协议，http或者https</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> <span class="comment">#端口号</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span> <span class="comment">#URI地址</span></span><br></pre></td></tr></table></figure>

<p>创建pod，观察效果</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-liveness-httpget.yaml</span></span><br><span class="line">pod/pod<span class="literal">-liveness-httpget</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe pod pod-liveness-httpget -n dev</span></span><br><span class="line">.......</span><br><span class="line">  Normal   Pulled     <span class="number">6</span>s (x3 over <span class="number">64</span>s)  kubelet, node1     Container image <span class="string">&quot;nginx:1.17.1&quot;</span> already present on machine</span><br><span class="line">  Normal   Created    <span class="number">6</span>s (x3 over <span class="number">64</span>s)  kubelet, node1     Created container nginx</span><br><span class="line">  Normal   Started    <span class="number">6</span>s (x3 over <span class="number">63</span>s)  kubelet, node1     Started container nginx</span><br><span class="line">  Warning  Unhealthy  <span class="number">6</span>s (x6 over <span class="number">56</span>s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: <span class="number">404</span></span><br><span class="line">  Normal   Killing    <span class="number">6</span>s (x2 over <span class="number">36</span>s)  kubelet, node1     Container nginx failed liveness probe, will be restarted</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 观察上面信息，尝试访问路径，但是未找到,出现404错误</span></span><br><span class="line"><span class="comment"># 稍等一会之后，再观察pod信息，就可以看到RESTARTS不再是0，而是一直增长</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod pod-liveness-httpget -n dev</span></span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-liveness-httpget</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">5</span>          <span class="number">3</span>m17s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然接下来，可以修改成一个可以访问的路径path，比如/，再试，结果就正常了......</span></span><br></pre></td></tr></table></figure>


<p>至此，已经使用liveness Probe演示了三种探测方式，但是查看livenessProbe的子属性，会发现除了这三种方式，还有一些其他的配置，在这里一并解释下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl explain pod.spec.containers.livenessProbe</span></span><br><span class="line">FIELDS:</span><br><span class="line">   exec &lt;Object&gt;  </span><br><span class="line">   tcpSocket    &lt;Object&gt;</span><br><span class="line">   httpGet      &lt;Object&gt;</span><br><span class="line">   initialDelaySeconds  &lt;integer&gt;  <span class="comment"># 容器启动后等待多少秒执行第一次探测</span></span><br><span class="line">   timeoutSeconds       &lt;integer&gt;  <span class="comment"># 探测超时时间。默认1秒，最小1秒</span></span><br><span class="line">   periodSeconds        &lt;integer&gt;  <span class="comment"># 执行探测的频率。默认是10秒，最小1秒</span></span><br><span class="line">   failureThreshold     &lt;integer&gt;  <span class="comment"># 连续探测失败多少次才被认定为失败。默认是3。最小值是1</span></span><br><span class="line">   successThreshold     &lt;integer&gt;  <span class="comment"># 连续探测成功多少次才被认定为成功。默认是1</span></span><br></pre></td></tr></table></figure>

<p>下面稍微配置两个，演示下效果即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">[<span class="string">root@master</span> <span class="string">~</span>]<span class="comment"># more pod-liveness-httpget.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-liveness-httpget</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span> </span><br><span class="line">        <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">      <span class="attr">initialDelaySeconds:</span> <span class="number">30</span> <span class="comment"># 容器启动后30s开始探测</span></span><br><span class="line">      <span class="attr">timeoutSeconds:</span> <span class="number">5</span> <span class="comment"># 探测超时时间为5s</span></span><br></pre></td></tr></table></figure>

<h2 id="5-重启策略"><a href="#5-重启策略" class="headerlink" title="5. 重启策略"></a>5. 重启策略</h2><p>在上一节中，一旦容器探测出现了问题，kubernetes就会对容器所在的Pod进行重启，其实这是由pod的重启策略决定的，pod的重启策略有 3 种，分别如下：</p>
<ul>
<li>Always ：容器失效时，自动重启该容器，这也是默认值。</li>
<li>OnFailure ： 容器终止运行且退出码不为0时重启</li>
<li>Never ： 不论状态为何，都不重启该容器</li>
</ul>
<p>​    重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长以此为10s、20s、40s、80s、160s和300s，300s是最大延迟时长。</p>
<p>创建<code>pod-restartpolicy.yaml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pod-restartpolicy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-port</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">livenessProbe:</span></span><br><span class="line">      <span class="attr">httpGet:</span></span><br><span class="line">        <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/hello</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 设置重启策略为Never</span></span><br></pre></td></tr></table></figure>

<p>运行Pod测试</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pod-restartpolicy.yaml</span></span><br><span class="line">pod/pod<span class="literal">-restartpolicy</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod详情，发现nginx容器失败</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  describe pods pod-restartpolicy  -n dev</span></span><br><span class="line">......</span><br><span class="line">  Warning  Unhealthy  <span class="number">15</span>s (x3 over <span class="number">35</span>s)  kubelet, node1     Liveness probe failed: HTTP probe failed with statuscode: <span class="number">404</span></span><br><span class="line">  Normal   Killing    <span class="number">15</span>s                kubelet, node1     Container nginx failed liveness probe</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 多等一会，再观察pod的重启次数，发现一直是0，并未重启   </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  get pods pod-restartpolicy -n dev</span></span><br><span class="line">NAME                   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod<span class="literal">-restartpolicy</span>      <span class="number">0</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>min42s</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes Service详解</title>
    <url>/2022/11/02/kubernetes/9kubernetes%20Service%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>本章节主要介绍kubernetes的流量负载组件：Service和Ingress。</p>
<h2 id="1-Service-介绍"><a href="#1-Service-介绍" class="headerlink" title="1. Service 介绍"></a>1. Service 介绍</h2><p>在kubernetes中，pod是应用程序的载体，我们可以通过pod的ip来访问应用程序，但是pod的ip地址不是固定的，这也就意味着不方便直接采用pod的ip对服务进行访问。</p>
<p><img src="https://img-blog.csdnimg.cn/32a65b5c3c9e4f949244935a12ee3dfb.png" alt="在这里插入图片描述"><br>Service在很多情况下只是一个概念，真正起作用的其实是kube-proxy服务进程，每个Node节点上都运行着一个kube-proxy服务进程。当创建Service的时候会通过api-server向etcd写入创建的service的信息，而kube-proxy会基于监听的机制发现这种Service的变动，然后<strong>它会将最新的Service信息转换成对应的访问规则</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/050e9f6feade4e76aac6a16ffae58b28.png" alt="在这里插入图片描述"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 10.97.97.97:80 是service提供的访问入口</span></span><br><span class="line"><span class="comment"># 当访问这个入口的时候，可以发现后面有三个pod的服务在等待调用，</span></span><br><span class="line"><span class="comment"># kube-proxy会基于rr（轮询）的策略，将请求分发到其中一个pod上去</span></span><br><span class="line"><span class="comment"># 这个规则会同时在集群内的所有节点上都生成，所以在任何一个节点上访问都可以。</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version <span class="number">1.2</span>.<span class="number">1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>kube-proxy目前支持三种工作模式:</p>
<p><strong>userspace 模式</strong></p>
<p>userspace模式下，kube-proxy会为每一个Service创建一个监听端口，发向Cluster IP的请求被Iptables规则重定向到kube-proxy监听的端口上，kube-proxy根据LB算法选择一个提供服务的Pod并和其建立链接，以将请求转发到Pod上。<br>​该模式下，kube-proxy充当了一个四层负责均衡器的角色。由于kube-proxy运行在userspace中，在进行转发处理时会增加内核和用户空间之间的数据拷贝，虽然比较稳定，但是效率比较低。</p>
<p><img src="https://img-blog.csdnimg.cn/f0d4c0b5c4f34f5fb330d42b6de5e71c.png" alt="在这里插入图片描述"><br><strong>iptables 模式</strong></p>
<p>iptables模式下，kube-proxy为service后端的每个Pod创建对应的iptables规则，直接将发向Cluster IP的请求重定向到一个Pod IP。<br>​该模式下kube-proxy不承担四层负责均衡器的角色，只负责创建   iptables规则。该模式的优点是较userspace模式效率更高，但不能提供灵活的LB策略，当后端Pod不可用时也无法进行重试。</p>
<p><img src="https://img-blog.csdnimg.cn/6803fe37f67d481f9f9ac991c4210fac.png" alt="在这里插入图片描述"><br><strong>ipvs 模式</strong></p>
<p>ipvs模式和iptables类似，kube-proxy监控Pod的变化并创建相应的ipvs规则。ipvs相对iptables转发效率更高。除此以外，ipvs支持更多的LB算法。</p>
<p><img src="https://img-blog.csdnimg.cn/1026df7cb2d64509aeecdb8ea1025ecb.png" alt="在这里插入图片描述"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 此模式必须安装ipvs内核模块，否则会降级为iptables</span></span><br><span class="line"><span class="comment"># 开启ipvs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit cm kube-proxy -n kube-system</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete pod -l k8s-app=kube-proxy -n kube-system</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">node1</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">IP Virtual Server version <span class="number">1.2</span>.<span class="number">1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="2-Service类型"><a href="#2-Service类型" class="headerlink" title="2. Service类型"></a>2. Service类型</h2><p>Service的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Service</span>  <span class="comment"># 资源类型</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span>  <span class="comment"># 资源版本</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service</span> <span class="comment"># 资源名称</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span> <span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 描述</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 标签选择器，用于确定当前service代理哪些pod</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">type:</span> <span class="comment"># Service类型，指定service的访问方式</span></span><br><span class="line">  <span class="attr">clusterIP:</span>  <span class="comment"># 虚拟服务的ip地址</span></span><br><span class="line">  <span class="attr">sessionAffinity:</span> <span class="comment"># session亲和性，支持ClientIP、None两个选项</span></span><br><span class="line">  <span class="attr">ports:</span> <span class="comment"># 端口信息</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">3017</span>  <span class="comment"># service端口</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">5003</span> <span class="comment"># pod端口</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">31122</span> <span class="comment"># 主机端口</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ClusterIP：默认值，它是Kubernetes系统自动分配的虚拟IP，只能在集群内部访问</li>
<li>NodePort：将Service通过指定的Node上的端口暴露给外部，通过此方法，就可以在集群外部访问服务</li>
<li>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，注意此模式需要外部云环境支持</li>
<li>ExternalName： 把集群外部的服务引入集群内部，直接使用</li>
</ul>
<h2 id="3-Service使用"><a href="#3-Service使用" class="headerlink" title="3. Service使用"></a>3. Service使用</h2><h3 id="3-1-实验环境准备"><a href="#3-1-实验环境准备" class="headerlink" title="3.1 实验环境准备"></a>3.1 实验环境准备</h3><p>在使用service之前，首先利用Deployment创建出3个pod，注意要为pod设置<code>app=nginx-pod</code>的标签</p>
<p>创建<code>deployment.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f deployment.yaml</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -o wide --show-labels</span></span><br><span class="line">NAME                             READY   STATUS     IP            NODE     LABELS</span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-8p84h</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">1.40</span>   node1    app=nginx<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-vx8vx</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">2.33</span>   node2    app=nginx<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-deployment-66cb59b984-wnncx</span>   <span class="number">1</span>/<span class="number">1</span>     Running    <span class="number">10.244</span>.<span class="number">1.39</span>   node1    app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为了方便后面的测试，修改下三台nginx的index.html页面（三台修改的IP地址不一致）</span></span><br><span class="line"><span class="comment"># kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line"><span class="comment"># echo &quot;10.244.1.40&quot; &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改完毕之后，访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.244.1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-ClusterIP类型的Service"><a href="#3-2-ClusterIP类型的Service" class="headerlink" title="3.2 ClusterIP类型的Service"></a>3.2 ClusterIP类型的Service</h3><p>创建<code>service-clusterip.yaml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-clusterip</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="number">10.97</span><span class="number">.97</span><span class="number">.97</span> <span class="comment"># service的ip地址，如果不写，默认会生成一个</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># Service端口       </span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span> <span class="comment"># pod端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-clusterip.yaml</span></span><br><span class="line">service/service<span class="literal">-clusterip</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev -o wide</span></span><br><span class="line">NAME                <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>    EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE   SELECTOR</span><br><span class="line">service<span class="literal">-clusterip</span>   ClusterIP   <span class="number">10.97</span>.<span class="number">97.97</span>   &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">13</span>s   app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service的详细信息</span></span><br><span class="line"><span class="comment"># 在这里有一个Endpoints列表，里面就是当前service可以负载到的服务入口</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe svc service-clusterip -n dev</span></span><br><span class="line">Name:              service<span class="literal">-clusterip</span></span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx<span class="literal">-pod</span></span><br><span class="line"><span class="built_in">Type</span>:              ClusterIP</span><br><span class="line">IP:                <span class="number">10.97</span>.<span class="number">97.97</span></span><br><span class="line">Port:              &lt;unset&gt;  <span class="number">80</span>/TCP</span><br><span class="line">TargetPort:        <span class="number">80</span>/TCP</span><br><span class="line">Endpoints:         <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ipvs的映射规则</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问10.97.97.97:80观察效果</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># curl 10.97.97.97:80</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br></pre></td></tr></table></figure>

<p><strong>Endpoint</strong></p>
<p>Endpoint是kubernetes中的一个资源对象，存储在etcd中，用来记录一个service对应的所有pod的访问地址，它是根据service配置文件中selector描述产生的。</p>
<p>​    一个Service由一组Pod组成，这些Pod通过Endpoints暴露出来，<strong>Endpoints是实现实际服务的端点集合</strong>。换句话说，service和pod之间的联系是通过endpoints实现的。</p>
<p><img src="https://img-blog.csdnimg.cn/b190c34a6e334e339cbd0620232c07d5.png" alt="在这里插入图片描述"><br><strong>负载分发策略</strong></p>
<p>对Service的访问被分发到了后端的Pod上去，目前kubernetes提供了两种负载分发策略：</p>
<ul>
<li><p>如果不定义，默认使用kube-proxy的策略，比如随机、轮询</p>
</li>
<li><p>基于客户端地址的会话保持模式，即来自同一个客户端发起的所有请求都会转发到固定的一个Pod上，此模式可以使在spec中添加<code>sessionAffinity:ClientIP</code>选项</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看ipvs的映射规则【rr 轮询】</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># while true;do curl 10.97.97.97:80; sleep 5; done;</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分发策略----sessionAffinity:ClientIP</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ipvs规则【persistent 代表持久】</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># ipvsadm -Ln</span></span><br><span class="line">TCP  <span class="number">10.97</span>.<span class="number">97.97</span>:<span class="number">80</span> rr persistent <span class="number">10800</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">  -&gt; <span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span>               Masq    <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环访问测试</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># while true;do curl 10.97.97.97; sleep 5; done;</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line"><span class="number">10.244</span>.<span class="number">2.33</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f service-clusterip.yaml</span></span><br><span class="line">service <span class="string">&quot;service-clusterip&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h3 id="3-3-HeadLiness类型的Service"><a href="#3-3-HeadLiness类型的Service" class="headerlink" title="3.3 HeadLiness类型的Service"></a>3.3 HeadLiness类型的Service</h3><p>在某些场景中，开发人员可能不想使用Service提供的负载均衡功能，而希望自己来控制负载均衡策略，针对这种情况，kubernetes提供了HeadLiness  Service，这类Service不会分配Cluster IP，如果想要访问service，只能通过service的域名进行查询。</p>
<p>创建<code>service-headliness.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-headliness</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span> <span class="comment"># 将clusterIP设置为None，即可创建headliness Service</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span>    </span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-headliness.yaml</span></span><br><span class="line">service/service<span class="literal">-headliness</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取service， 发现CLUSTER-IP未分配</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc service-headliness -n dev -o wide</span></span><br><span class="line">NAME                 <span class="built_in">TYPE</span>        CLUSTER<span class="literal">-IP</span>   EXTERNAL<span class="literal">-IP</span>   PORT(S)   AGE   SELECTOR</span><br><span class="line">service<span class="literal">-headliness</span>   ClusterIP   None         &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">11</span>s   app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe svc service-headliness  -n dev</span></span><br><span class="line">Name:              service<span class="literal">-headliness</span></span><br><span class="line">Namespace:         dev</span><br><span class="line">Labels:            &lt;none&gt;</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          app=nginx<span class="literal">-pod</span></span><br><span class="line"><span class="built_in">Type</span>:              ClusterIP</span><br><span class="line">IP:                None</span><br><span class="line">Port:              &lt;unset&gt;  <span class="number">80</span>/TCP</span><br><span class="line">TargetPort:        <span class="number">80</span>/TCP</span><br><span class="line">Endpoints:         <span class="number">10.244</span>.<span class="number">1.39</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.40</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.33</span>:<span class="number">80</span></span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看域名的解析情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl exec -it pc-deployment-66cb59b984-8p84h -n dev /bin/sh</span></span><br><span class="line">/ <span class="comment"># cat /etc/resolv.conf</span></span><br><span class="line">nameserver <span class="number">10.96</span>.<span class="number">0.10</span></span><br><span class="line">search dev.svc.cluster.local svc.cluster.local cluster.local</span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># dig @10.96.0.10 service-headliness.dev.svc.cluster.local</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">1.40</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">1.39</span></span><br><span class="line">service<span class="literal">-headliness</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> A <span class="number">10.244</span>.<span class="number">2.33</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-NodePort类型的Service"><a href="#3-4-NodePort类型的Service" class="headerlink" title="3.4 NodePort类型的Service"></a>3.4 NodePort类型的Service</h3><p>在之前的样例中，创建的Service的ip地址只有集群内部才可以访问，如果希望将Service暴露给集群外部使用，那么就要使用到另外一种类型的Service，称为NodePort类型。NodePort的工作原理其实就是<strong>将service的端口映射到Node的一个端口上</strong>，然后就可以通过<code>NodeIp:NodePort</code>来访问service了。</p>
<p><img src="https://img-blog.csdnimg.cn/b142a9fdce87416da0b98335662bb774.png" alt="在这里插入图片描述"><br>创建<code>service-nodeport.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-nodeport</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">nodePort:</span> <span class="number">30002</span> <span class="comment"># 指定绑定的node的端口(默认的取值范围是：30000-32767), 如果不指定，会默认分配</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f service-nodeport.yaml</span></span><br><span class="line">service/service<span class="literal">-nodeport</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get svc -n dev -o wide</span></span><br><span class="line">NAME               <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)       SELECTOR</span><br><span class="line">service<span class="literal">-nodeport</span>   NodePort   <span class="number">10.105</span>.<span class="number">64.191</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">30002</span>/TCP  app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来可以通过电脑主机的浏览器去访问集群中任意一个nodeip的30002端口，即可访问到pod</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-LoadBalancer类型的Service"><a href="#3-5-LoadBalancer类型的Service" class="headerlink" title="3.5 LoadBalancer类型的Service"></a>3.5 LoadBalancer类型的Service</h3><p>LoadBalancer和NodePort很相似，目的都是向外部暴露一个端口，区别在于LoadBalancer会在集群的外部再来做一个负载均衡设备，而这个设备需要外部环境支持的，外部服务发送到这个设备上的请求，会被设备负载之后转发到集群中。</p>
<p><img src="https://img-blog.csdnimg.cn/7cb67b1c1efb45eba68ba6f19c0c01b0.png" alt="在这里插入图片描述"></p>
<h3 id="3-6-ExternalName类型的Service"><a href="#3-6-ExternalName类型的Service" class="headerlink" title="3.6 ExternalName类型的Service"></a>3.6 ExternalName类型的Service</h3><p>ExternalName类型的Service用于引入集群外部的服务，它通过<code>externalName</code>属性指定外部一个服务的地址，然后在集群内部访问此service就可以访问到外部的服务了。</p>
<p><img src="https://img-blog.csdnimg.cn/f34cbfb849364be2ad8171bb527c3c07.png" alt="在这里插入图片描述"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">service-externalname</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ExternalName</span> <span class="comment"># service类型</span></span><br><span class="line">  <span class="attr">externalName:</span> <span class="string">www.baidu.com</span>  <span class="comment">#改成ip地址也可以</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  create -f service-externalname.yaml</span></span><br><span class="line">service/service<span class="literal">-externalname</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 域名解析</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># dig @10.96.0.10 service-externalname.dev.svc.cluster.local</span></span><br><span class="line">service<span class="literal">-externalname</span>.dev.svc.cluster.local. <span class="number">30</span> <span class="keyword">IN</span> CNAME www.baidu.com.</span><br><span class="line">www.baidu.com.          <span class="number">30</span>      <span class="keyword">IN</span>      CNAME   www.a.shifen.com.</span><br><span class="line">www.a.shifen.com.       <span class="number">30</span>      <span class="keyword">IN</span>      A       <span class="number">39.156</span>.<span class="number">66.18</span></span><br><span class="line">www.a.shifen.com.       <span class="number">30</span>      <span class="keyword">IN</span>      A       <span class="number">39.156</span>.<span class="number">66.14</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Ingress介绍"><a href="#4-Ingress介绍" class="headerlink" title="4. Ingress介绍"></a>4. Ingress介绍</h2><p>在前面课程中已经提到，Service对集群之外暴露服务的主要方式有两种：NotePort和LoadBalancer，但是这两种方式，都有一定的缺点：</p>
<ul>
<li>NodePort方式的缺点是会占用很多集群机器的端口，那么当集群服务变多的时候，这个缺点就愈发明显</li>
<li>LB方式的缺点是每个service需要一个LB，浪费、麻烦，并且需要kubernetes之外设备的支持</li>
</ul>
<p>​    基于这种现状，kubernetes提供了Ingress资源对象，Ingress只需要一个NodePort或者一个LB就可以满足暴露多个Service的需求。工作机制大致如下图表示：</p>
<p><img src="https://img-blog.csdnimg.cn/9045462da60f4233b0d68e6e39209952.png" alt="在这里插入图片描述"><br>实际上，Ingress相当于一个7层的负载均衡器，是kubernetes对反向代理的一个抽象，它的工作原理类似于Nginx，可以理解成在<strong>Ingress里建立诸多映射规则，Ingress Controller通过监听这些配置规则并转化成Nginx的反向代理配置 , 然后对外部提供服务</strong>。在这里有两个核心概念：</p>
<ul>
<li>ingress：kubernetes中的一个对象，作用是定义请求如何转发到service的规则</li>
<li>ingress controller：具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发，实现方式有很多，比如Nginx, Contour, Haproxy等等</li>
</ul>
<p>Ingress（以Nginx为例）的工作原理如下：</p>
<ol>
<li>用户编写Ingress规则，说明哪个域名对应kubernetes集群中的哪个Service</li>
<li>Ingress控制器动态感知Ingress服务规则的变化，然后生成一段对应的Nginx反向代理配置</li>
<li>Ingress控制器会将生成的Nginx配置写入到一个运行着的Nginx服务中，并动态更新</li>
<li>到此为止，其实真正在工作的就是一个Nginx了，内部配置了用户定义的请求转发规则</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2ee2a3c00d88429c9ce75e54b69584c0.png" alt="在这里插入图片描述"></p>
<h2 id="5-Ingress使用"><a href="#5-Ingress使用" class="headerlink" title="5. Ingress使用"></a>5. Ingress使用</h2><h3 id="5-1-环境准备"><a href="#5-1-环境准备" class="headerlink" title="5.1 环境准备"></a>5.1 环境准备</h3><p><strong>搭建ingress环境</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># mkdir ingress-controller</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cd ingress-controller/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取ingress-nginx，本次案例使用的是0.30版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/mandatory.yaml</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.30.0/deploy/static/provider/baremetal/service-nodeport.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改mandatory.yaml文件中的仓库</span></span><br><span class="line"><span class="comment"># 修改quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 为quay-mirror.qiniu.com/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0</span></span><br><span class="line"><span class="comment"># 创建ingress-nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl apply -f ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ingress-nginx</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl get pod -n ingress-nginx</span></span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-ingress-controller-fbf967dd5-4qpbp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">12</span><span class="built_in">h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="type">ingress</span>-<span class="type">controller</span>]<span class="comment"># kubectl get svc -n ingress-nginx</span></span><br><span class="line">NAME            <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>     EXTERNAL<span class="literal">-IP</span>   PORT(S)                      AGE</span><br><span class="line">ingress<span class="literal">-nginx</span>   NodePort   <span class="number">10.98</span>.<span class="number">75.163</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">32240</span>/TCP,<span class="number">443</span>:<span class="number">31335</span>/TCP   <span class="number">11</span><span class="built_in">h</span></span><br></pre></td></tr></table></figure>

<p><strong>准备service和pod</strong></p>
<p>为了后面的实验比较方便，创建如下图所示的模型</p>
<p><img src="https://img-blog.csdnimg.cn/1370102b959b4fd9b8d0a592ccd70151.png" alt="在这里插入图片描述"><br>创建<code>tomcat-nginx.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tomcat</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">tomcat:8.5-jre10-slim</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">tomcat-service</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">tomcat-pod</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-Http代理"><a href="#5-2-Http代理" class="headerlink" title="5.2 Http代理"></a>5.2 Http代理</h3><p>创建<code>ingress-http.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-http</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.omlight.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.omlight.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f ingress-http.yaml</span></span><br><span class="line">ingress.extensions/ingress<span class="literal">-http</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ing ingress-http -n dev</span></span><br><span class="line">NAME           HOSTS                                  ADDRESS   PORTS   AGE</span><br><span class="line">ingress<span class="literal">-http</span>   nginx.omlight.com,tomcat.omlight.com             <span class="number">80</span>      <span class="number">22</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ing ingress-http  -n dev</span></span><br><span class="line">...</span><br><span class="line">Rules:</span><br><span class="line">Host                Path  Backends</span><br><span class="line"><span class="literal">----</span>                <span class="literal">----</span>  <span class="literal">--------</span></span><br><span class="line">nginx.omlight.com   / nginx<span class="literal">-service</span>:<span class="number">80</span> (<span class="number">10.244</span>.<span class="number">1.96</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.97</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.112</span>:<span class="number">80</span>)</span><br><span class="line">tomcat.omlight.com  / tomcat<span class="literal">-service</span>:<span class="number">8080</span>(<span class="number">10.244</span>.<span class="number">1.94</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">1.95</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.111</span>:<span class="number">8080</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来,在本地电脑上配置host文件,解析上面的两个域名到192.168.109.100(master)上</span></span><br><span class="line"><span class="comment"># 然后,就可以分别访问tomcat.omlight.com:32240  和  nginx.omlight.com:32240 查看效果了</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-Https代理"><a href="#5-3-Https代理" class="headerlink" title="5.3 Https代理"></a>5.3 Https代理</h3><p>创建证书</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成证书</span></span><br><span class="line">openssl req <span class="literal">-x509</span> <span class="literal">-sha256</span> <span class="literal">-nodes</span> <span class="literal">-days</span> <span class="number">365</span> <span class="literal">-newkey</span> rsa:<span class="number">2048</span> <span class="literal">-keyout</span> tls.key <span class="literal">-out</span> tls.crt <span class="literal">-subj</span> <span class="string">&quot;/C=CN/ST=BJ/L=BJ/O=nginx/CN=omlight.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建密钥</span></span><br><span class="line">kubectl create secret tls tls<span class="literal">-secret</span> <span class="literal">--key</span> tls.key <span class="literal">--cert</span> tls.crt</span><br></pre></td></tr></table></figure>

<p>创建<code>ingress-https.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-https</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">tls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">hosts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nginx.omlight.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">tomcat.omlight.com</span></span><br><span class="line">      <span class="attr">secretName:</span> <span class="string">tls-secret</span> <span class="comment"># 指定秘钥</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">nginx.omlight.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">nginx-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">80</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">tomcat.omlight.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">serviceName:</span> <span class="string">tomcat-service</span></span><br><span class="line">          <span class="attr">servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f ingress-https.yaml</span></span><br><span class="line">ingress.extensions/ingress<span class="literal">-https</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get ing ingress-https -n dev</span></span><br><span class="line">NAME            HOSTS                                  ADDRESS         PORTS     AGE</span><br><span class="line">ingress<span class="literal">-https</span>   nginx.omlight.com,tomcat.omlight.com   <span class="number">10.104</span>.<span class="number">184.38</span>   <span class="number">80</span>, <span class="number">443</span>   <span class="number">2</span>m42s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看详情</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl describe ing ingress-https -n dev</span></span><br><span class="line">...</span><br><span class="line">TLS:</span><br><span class="line">  tls<span class="literal">-secret</span> terminates nginx.omlight.com,tomcat.omlight.com</span><br><span class="line">Rules:</span><br><span class="line">Host              Path Backends</span><br><span class="line"><span class="literal">----</span>              <span class="literal">----</span> <span class="literal">--------</span></span><br><span class="line">nginx.omlight.com  /  nginx<span class="literal">-service</span>:<span class="number">80</span> (<span class="number">10.244</span>.<span class="number">1.97</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">1.98</span>:<span class="number">80</span>,<span class="number">10.244</span>.<span class="number">2.119</span>:<span class="number">80</span>)</span><br><span class="line">tomcat.omlight.com /  tomcat<span class="literal">-service</span>:<span class="number">8080</span>(<span class="number">10.244</span>.<span class="number">1.99</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.117</span>:<span class="number">8080</span>,<span class="number">10.244</span>.<span class="number">2.120</span>:<span class="number">8080</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面可以通过浏览器访问https://nginx.omlight.com:31335 和 https://tomcat.omlight.com:31335来查看了</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
  <entry>
    <title>kubernetes Pod控制器</title>
    <url>/2022/11/02/kubernetes/8kubernetes%20Pod%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>Pod是kubernetes的最小管理单元，在kubernetes中，按照pod的创建方式可以将其分为两类：</p>
<ul>
<li><p>自主式pod：kubernetes直接创建出来的Pod，这种pod删除后就没有了，也不会重建</p>
</li>
<li><p>控制器创建的pod：kubernetes通过控制器创建的pod，这种pod删除了之后还会自动重建</p>
</li>
</ul>
<blockquote>
<p><strong><code>什么是Pod控制器</code></strong> </p>
<p>​    Pod控制器是管理pod的中间层，使用Pod控制器之后，只需要告诉Pod控制器，想要多少个什么样的Pod就可以了，它会创建出满足条件的Pod并确保每一个Pod资源处于用户期望的目标状态。如果Pod资源在运行中出现故障，它会基于指定策略重新编排Pod。</p>
</blockquote>
<p>在kubernetes中，有很多类型的pod控制器，每种都有自己的适合的场景，常见的有下面这些：</p>
<ul>
<li><p>ReplicationController：比较原始的pod控制器，已经被废弃，由ReplicaSet替代</p>
</li>
<li><p>ReplicaSet：保证副本数量一直维持在期望值，并支持pod数量扩缩容，镜像版本升级</p>
</li>
<li><p>Deployment：通过控制ReplicaSet来控制Pod，并支持滚动升级、回退版本</p>
</li>
<li><p>Horizontal Pod Autoscaler：可以根据集群负载自动水平调整Pod的数量，实现削峰填谷</p>
</li>
<li><p>DaemonSet：在集群中的指定Node上运行且仅运行一个副本，一般用于守护进程类的任务</p>
</li>
<li><p>Job：它创建出来的pod只要完成任务就立即退出，不需要重启或重建，用于执行一次性任务</p>
</li>
<li><p>Cronjob：它创建的Pod负责周期性任务控制，不需要持续后台运行</p>
</li>
<li><p>StatefulSet：管理有状态应用</p>
</li>
</ul>
<h2 id="1-ReplicaSet-RS"><a href="#1-ReplicaSet-RS" class="headerlink" title="1. ReplicaSet(RS)"></a>1. ReplicaSet(RS)</h2><p>ReplicaSet的主要作用是<strong>保证一定数量的pod正常运行</strong>，它会持续监听这些Pod的运行状态，一旦Pod发生故障，就会重启或重建。同时它还支持对pod数量的扩缩容和镜像版本的升降级。</p>
<p><img src="https://img-blog.csdnimg.cn/3551d6bca79d4f50aba848813a2460d4.png" alt="在这里插入图片描述"><br>ReplicaSet的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">rs</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>在这里面，需要新了解的配置项就是<code>spec</code>下面几个选项：</p>
<ul>
<li><p>replicas：指定副本数量，其实就是当前rs创建出来的pod的数量，默认为1</p>
</li>
<li><p>selector：选择器，它的作用是建立pod控制器和pod之间的关联关系，采用的Label Selector机制，在pod模板上定义label，在控制器上定义选择器，就可以表明当前控制器能管理哪些pod了</p>
</li>
<li><p>template：模板，就是当前控制器创建pod所使用的模板板，里面其实就是前一章学过的pod的定义</p>
</li>
</ul>
<p><strong>创建ReplicaSet</strong></p>
<p>创建<code>pc-replicaset.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span>   </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-replicaset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span> </span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建rs</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-replicaset.yaml</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看rs</span></span><br><span class="line"><span class="comment"># DESIRED:期望副本数量  </span></span><br><span class="line"><span class="comment"># CURRENT:当前副本数量  </span></span><br><span class="line"><span class="comment"># READY:已经准备好提供服务的副本数量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs pc-replicaset -n dev -o wide</span></span><br><span class="line">NAME          DESIRED   CURRENT READY AGE   CONTAINERS   IMAGES             SELECTOR</span><br><span class="line">pc<span class="literal">-replicaset</span> <span class="number">3</span>         <span class="number">3</span>       <span class="number">3</span>     <span class="number">22</span>s   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>       app=nginx<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前控制器创建出来的pod</span></span><br><span class="line"><span class="comment"># 这里发现控制器创建出来的pod的名称是在控制器名称后面拼接了-xxxxx随机码</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-6vmvt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">54</span>s</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">54</span>s</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">54</span>s</span><br></pre></td></tr></table></figure>

<p><strong>扩缩容</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑rs的副本数量，修改spec:replicas: 6即可</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit rs pc-replicaset -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> edited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                          READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-6vmvt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">114</span>m</span><br><span class="line">pc<span class="literal">-replicaset-cftnp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>s</span><br><span class="line">pc<span class="literal">-replicaset-fjlm6</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>s</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">114</span>m</span><br><span class="line">pc<span class="literal">-replicaset-s2whj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">10</span>s</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">114</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然也可以直接使用命令实现</span></span><br><span class="line"><span class="comment"># 使用scale命令实现扩缩容， 后面--replicas=n直接指定目标数量即可</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl scale rs pc-replicaset --replicas=2 -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> scaled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令运行完毕，立即查看，发现已经有4个开始准备退出了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                       READY   STATUS        RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-6vmvt</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">118</span>m</span><br><span class="line">pc<span class="literal">-replicaset-cftnp</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m17s</span><br><span class="line">pc<span class="literal">-replicaset-fjlm6</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m17s</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running       <span class="number">0</span>          <span class="number">118</span>m</span><br><span class="line">pc<span class="literal">-replicaset-s2whj</span>   <span class="number">0</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">4</span>m17s</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running       <span class="number">0</span>          <span class="number">118</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment">#稍等片刻，就只剩下2个了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-fmb8f</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">119</span>m</span><br><span class="line">pc<span class="literal">-replicaset-snrk2</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">119</span>m</span><br></pre></td></tr></table></figure>

<p><strong>镜像升级</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑rs的容器镜像 - image: nginx:1.17.2</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit rs pc-replicaset -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> edited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES        ...</span><br><span class="line">pc<span class="literal">-replicaset</span>       <span class="number">2</span>        <span class="number">2</span>         <span class="number">2</span>       <span class="number">140</span>m   nginx         nginx:<span class="number">1.17</span>.<span class="number">2</span>  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同样的道理，也可以使用命令完成这个工作</span></span><br><span class="line"><span class="comment"># kubectl set image rs rs名称 容器=镜像版本 -n namespace</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl set image rs pc-replicaset nginx=nginx:1.17.1  -n dev</span></span><br><span class="line">replicaset.apps/pc<span class="literal">-replicaset</span> image updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看，发现镜像版本已经变更了</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                 DESIRED  CURRENT   READY   AGE    CONTAINERS   IMAGES            ...</span><br><span class="line">pc<span class="literal">-replicaset</span>        <span class="number">2</span>        <span class="number">2</span>         <span class="number">2</span>       <span class="number">145</span>m   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span> ... </span><br></pre></td></tr></table></figure>

<p><strong>删除ReplicaSet</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用kubectl delete命令会删除此RS以及它管理的Pod</span></span><br><span class="line"><span class="comment"># 在kubernetes删除RS前，会将RS的replicasclear调整为0，等待所有的Pod被删除后，在执行RS对象的删除</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete rs pc-replicaset -n dev</span></span><br><span class="line">replicaset.apps <span class="string">&quot;pc-replicaset&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pod -n dev -o wide</span></span><br><span class="line">No resources found <span class="keyword">in</span> dev namespace.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果希望仅仅删除RS对象（保留Pod），可以使用kubectl delete命令时添加--cascade=false选项（不推荐）。</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete rs pc-replicaset -n dev --cascade=false</span></span><br><span class="line">replicaset.apps <span class="string">&quot;pc-replicaset&quot;</span> deleted</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                  READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-replicaset-cl82j</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">75</span>s</span><br><span class="line">pc<span class="literal">-replicaset-dslhb</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">75</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用yaml直接删除(推荐)</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-replicaset.yaml</span></span><br><span class="line">replicaset.apps <span class="string">&quot;pc-replicaset&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="2-Deployment-Deploy"><a href="#2-Deployment-Deploy" class="headerlink" title="2. Deployment(Deploy)"></a>2. Deployment(Deploy)</h2><p>为了更好的解决服务编排的问题，kubernetes在V1.2版本开始，引入了Deployment控制器。值得一提的是，这种控制器并不直接管理pod，而是通过管理ReplicaSet来简介管理Pod，即：Deployment管理ReplicaSet，ReplicaSet管理Pod。所以Deployment比ReplicaSet功能更加强大。</p>
<p><img src="https://img-blog.csdnimg.cn/19fef7435f1240d089f698bc81a6e353.png" alt="在这里插入图片描述"><br>Deployment主要功能有下面几个：</p>
<ul>
<li>支持ReplicaSet的所有功能</li>
<li>支持发布的停止、继续</li>
<li>支持滚动升级和回滚版本</li>
</ul>
<p>Deployment的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span> <span class="comment"># 副本数量</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">paused:</span> <span class="literal">false</span> <span class="comment"># 暂停部署，默认是false</span></span><br><span class="line">  <span class="attr">progressDeadlineSeconds:</span> <span class="number">600</span> <span class="comment"># 部署超时时间（s），默认是600</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大额外可以存在的副本数，可以为百分比，也可以为整数</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">30</span><span class="string">%</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>创建deployment</strong></p>
<p>创建<code>pc-deployment.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-deployment</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建deployment</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-deployment.yaml --record=true</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment</span></span><br><span class="line"><span class="comment"># UP-TO-DATE 最新版本的pod的数量</span></span><br><span class="line"><span class="comment"># AVAILABLE  当前可用的pod的数量</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy pc-deployment -n dev</span></span><br><span class="line">NAME            READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">pc<span class="literal">-deployment</span>   <span class="number">3</span>/<span class="number">3</span>     <span class="number">3</span>            <span class="number">3</span>           <span class="number">15</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看rs</span></span><br><span class="line"><span class="comment"># 发现rs的名称是在原来deployment的名字后面添加了一个10位数的随机串</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">23</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-d2c8n</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">107</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-smpvp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">107</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-wvjd8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">107</span>s</span><br></pre></td></tr></table></figure>

<p><strong>扩缩容</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变更副本数量为5个</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl scale deploy pc-deployment --replicas=5  -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> scaled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看deployment</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deploy pc-deployment -n dev</span></span><br><span class="line">NAME            READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">pc<span class="literal">-deployment</span>   <span class="number">5</span>/<span class="number">5</span>     <span class="number">5</span>            <span class="number">5</span>           <span class="number">2</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-d2c8n</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>m19s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-jxmdq</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">94</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-mktqv</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">93</span>s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-smpvp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>m19s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-wvjd8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">4</span>m19s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑deployment的副本数量，修改spec:replicas: 4即可</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl edit deploy pc-deployment -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> edited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-d2c8n</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m23s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-jxmdq</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">2</span>m38s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-smpvp</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m23s</span><br><span class="line">pc<span class="literal">-deployment-6696798b78-wvjd8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m23s</span><br></pre></td></tr></table></figure>

<p><strong>镜像更新</strong></p>
<p>deployment支持两种更新策略:<code>重建更新</code>和<code>滚动更新</code>,可以通过<code>strategy</code>指定策略类型,支持两个属性:</p>
<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">strategy：指定新的Pod替换旧的Pod的策略， 支持两个属性：</span><br><span class="line">  type：指定策略类型，支持两种策略</span><br><span class="line"><span class="code">    Recreate：在创建出新的Pod之前会先杀掉所有已存在的Pod</span></span><br><span class="line"><span class="code">    RollingUpdate：滚动更新，就是杀死一部分，就启动一部分，在更新过程中，存在两个版本Pod</span></span><br><span class="line"><span class="code">  rollingUpdate：当type为RollingUpdate时生效，用于为RollingUpdate设置参数，支持两个属性：</span></span><br><span class="line"><span class="code">    maxUnavailable：用来指定在升级过程中不可用Pod的最大数量，默认为25%。</span></span><br><span class="line"><span class="code">    maxSurge： 用来指定在升级过程中可以超过期望的Pod的最大数量，默认为25%。</span></span><br></pre></td></tr></table></figure>

<p>重建更新</p>
<ol>
<li><p>编辑pc-deployment.yaml,在spec节点下添加更新策略</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Recreate</span> <span class="comment"># 重建更新</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建deploy进行验证</p>
 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变更镜像</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl set image deployment pc-deployment nginx=nginx:1.17.2 -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> image updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察升级过程</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get pods -n dev -w</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-65qcw</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-w5nzv</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-xpt7w</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-xpt7w</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">41</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-65qcw</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">41</span>s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-w5nzv</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating   <span class="number">0</span>          <span class="number">41</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-grn8z</span>   <span class="number">0</span>/<span class="number">1</span>     Pending       <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-hbl4v</span>   <span class="number">0</span>/<span class="number">1</span>     Pending       <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-67nz2</span>   <span class="number">0</span>/<span class="number">1</span>     Pending       <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-grn8z</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-hbl4v</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-67nz2</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-grn8z</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">1</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-67nz2</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">1</span>s</span><br><span class="line">pc<span class="literal">-deployment-675d469f8b-hbl4v</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br></pre></td></tr></table></figure></li>
</ol>
<p>滚动更新</p>
<ol>
<li><p>编辑<code>pc-deployment.yaml</code>，在spec节点下添加更新策略</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span> </span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建deploy进行验证</p>
</li>
</ol>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 变更镜像</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl set image deployment pc-deployment nginx=nginx:1.17.3 -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> image updated</span><br><span class="line"></span><br><span class="line"><span class="comment"># 观察升级过程</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-c848d767-8rbzt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line">pc<span class="literal">-deployment-c848d767-h4p68</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line">pc<span class="literal">-deployment-c848d767-hlmz4</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line">pc<span class="literal">-deployment-c848d767-rrqcn</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">31</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-226rx</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-226rx</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-226rx</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">1</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-h4p68</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-cnd44</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-cnd44</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-cnd44</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-hlmz4</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-px48p</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-px48p</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-px48p</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-8rbzt</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-dkmqp</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-dkmqp</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-deployment-966bf7f44-dkmqp</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-deployment-c848d767-rrqcn</span>    <span class="number">0</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">34</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 至此，新版本的pod创建完毕，就版本的pod销毁完毕</span></span><br><span class="line"><span class="comment"># 中间过程是滚动进行的，也就是边销毁边创建</span></span><br></pre></td></tr></table></figure>

<p>滚动更新的过程：</p>
<p><img src="https://img-blog.csdnimg.cn/42f0d0d045a440f9bc370728256c87ab.png" alt="在这里插入图片描述"><br>镜像更新中rs的变化:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看rs,发现原来的rs的依旧存在，只是pod数量变为了0，而后又新产生了一个rs，pod数量为4</span></span><br><span class="line"><span class="comment"># 其实这就是deployment能够进行版本回退的奥妙所在，后面会详细解释</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE</span><br><span class="line">pc<span class="literal">-deployment-6696798b78</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">7</span>m37s</span><br><span class="line">pc<span class="literal">-deployment-6696798b11</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">5</span>m37s</span><br><span class="line">pc<span class="literal">-deployment-c848d76789</span>   <span class="number">4</span>         <span class="number">4</span>         <span class="number">4</span>       <span class="number">72</span>s</span><br></pre></td></tr></table></figure>

<p><strong>版本回退</strong></p>
<p>deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</p>
<p>kubectl rollout： 版本升级相关功能，支持下面的选项：</p>
<ul>
<li><p>status       显示当前升级状态</p>
</li>
<li><p>history     显示 升级历史记录</p>
</li>
<li><p>pause       暂停版本升级过程</p>
</li>
<li><p>resume    继续已经暂停的版本升级过程</p>
</li>
<li><p>restart      重启版本升级过程</p>
</li>
<li><p>undo        回滚到上一级版本（可以使用–to-revision回滚到指定版本）</p>
</li>
</ul>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">deployment支持版本升级过程中的暂停、继续功能以及版本回退等诸多功能，下面具体来看.</span><br><span class="line"></span><br><span class="line">kubectl rollout： 版本升级相关功能，支持下面的选项：</span><br><span class="line"></span><br><span class="line">- status       显示当前升级状态</span><br><span class="line">- <span class="built_in">history</span>     显示 升级历史记录</span><br><span class="line"></span><br><span class="line">- pause       暂停版本升级过程</span><br><span class="line">- resume    继续已经暂停的版本升级过程</span><br><span class="line">- restart      重启版本升级过程</span><br><span class="line">- undo        回滚到上一级版本（可以使用<span class="literal">--to-revision</span>回滚到指定版本）</span><br></pre></td></tr></table></figure>

<p><strong>金丝雀发布</strong></p>
<p>Deployment控制器支持控制更新过程中的控制，如“暂停(pause)”或“继续(resume)”更新操作。</p>
<p>​    比如有一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新deployment的版本，并配置暂停deployment</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl set image deploy pc-deployment nginx=nginx:1.17.4 -n dev &amp;&amp; kubectl rollout pause deployment pc-deployment  -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> image updated</span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> paused</span><br><span class="line"></span><br><span class="line"><span class="comment">#观察更新状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl rollout status deploy pc-deployment -n dev　</span></span><br><span class="line">Waiting <span class="keyword">for</span> deployment <span class="string">&quot;pc-deployment&quot;</span> rollout to finish: <span class="number">2</span> out of <span class="number">4</span> new replicas have been updated...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令</span></span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9</span>   <span class="number">3</span>         <span class="number">3</span>         <span class="number">3</span>       <span class="number">19</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>   </span><br><span class="line">pc<span class="literal">-deployment-675d469f8b</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">14</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">2</span>   </span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb</span>   <span class="number">2</span>         <span class="number">2</span>         <span class="number">2</span>       <span class="number">3</span>m16s   nginx        nginx:<span class="number">1.17</span>.<span class="number">4</span>   </span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-rj8sq</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">7</span>m33s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-ttwgg</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">7</span>m35s</span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9-v4wvc</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">7</span>m34s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-996rt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>m31s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-j2gtj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">3</span>m31s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保更新的pod没问题了，继续更新</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl rollout resume deploy pc-deployment -n dev</span></span><br><span class="line">deployment.apps/pc<span class="literal">-deployment</span> resumed</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最后的更新情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get rs -n dev -o wide</span></span><br><span class="line">NAME                       DESIRED   CURRENT   READY   AGE     CONTAINERS   IMAGES         </span><br><span class="line">pc<span class="literal">-deployment-5d89bdfbf9</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">21</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>   </span><br><span class="line">pc<span class="literal">-deployment-675d469f8b</span>   <span class="number">0</span>         <span class="number">0</span>         <span class="number">0</span>       <span class="number">16</span>m     nginx        nginx:<span class="number">1.17</span>.<span class="number">2</span>   </span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb</span>   <span class="number">4</span>         <span class="number">4</span>         <span class="number">4</span>       <span class="number">5</span>m11s   nginx        nginx:<span class="number">1.17</span>.<span class="number">4</span>   </span><br><span class="line"></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">NAME                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-7bfwh</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-996rt</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m27s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-j2gtj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>m27s</span><br><span class="line">pc<span class="literal">-deployment-6c9f56fcfb-rf84v</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s</span><br></pre></td></tr></table></figure>


<p><strong>删除Deployment</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除deployment，其下的rs和pod也将被删除</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-deployment.yaml</span></span><br><span class="line">deployment.apps <span class="string">&quot;pc-deployment&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="3-Horizontal-Pod-Autoscaler-HPA"><a href="#3-Horizontal-Pod-Autoscaler-HPA" class="headerlink" title="3. Horizontal Pod Autoscaler(HPA)"></a>3. Horizontal Pod Autoscaler(HPA)</h2><p>在前面的内容中，我们已经可以实现通过手工执行<code>kubectl scale</code>命令实现Pod扩容或缩容，但是这显然不符合Kubernetes的定位目标–自动化、智能化。 Kubernetes期望可以实现通过监测Pod的使用情况，实现pod数量的自动调整，于是就产生了Horizontal Pod Autoscaler（HPA）这种控制器。</p>
<p>​    HPA可以获取每个Pod利用率，然后和HPA中定义的指标进行对比，同时计算出需要伸缩的具体值，最后实现Pod的数量的调整。其实HPA与之前的Deployment一样，也属于一种Kubernetes资源对象，它通过追踪分析RC控制的所有目标Pod的负载变化情况，来确定是否需要针对性地调整目标Pod的副本数，这是HPA的实现原理。</p>
<p><img src="https://img-blog.csdnimg.cn/f27a17dd0c5c4ef88869d39ecca8c343.png" alt="在这里插入图片描述"></p>
<p>接下来，我们来做一个实验</p>
<p><strong>1 安装metrics-server</strong></p>
<p>metrics-server可以用来收集集群中的资源使用情况</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装git</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># yum install git -y</span></span><br><span class="line"><span class="comment"># 获取metrics-server, 注意使用的版本</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># git clone -b v0.3.6 https://github.com/kubernetes-incubator/metrics-server</span></span><br><span class="line"><span class="comment"># 修改deployment, 注意修改的是镜像和初始化参数</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># cd /root/metrics-server/deploy/1.8+/</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># vim metrics-server-deployment.yaml</span></span><br><span class="line">按图中添加下面选项</span><br><span class="line">hostNetwork: true</span><br><span class="line">image: registry.cn<span class="literal">-hangzhou</span>.aliyuncs.com/google_containers/metrics<span class="literal">-server-amd64</span>:v0.<span class="number">3.6</span></span><br><span class="line">args:</span><br><span class="line">- <span class="literal">--kubelet-insecure-tls</span></span><br><span class="line">- <span class="literal">--kubelet-preferred-address-types</span>=InternalIP,Hostname,InternalDNS,ExternalDNS,ExternalIP</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/583f8f9eff4e492089fe1f98d265ff95.png" alt="在这里插入图片描述"></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装metrics-server</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl apply -f ./</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod运行情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl get pod -n kube-system</span></span><br><span class="line">metrics<span class="literal">-server-6b976979db-2xwbj</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">90</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用kubectl top node 查看资源使用情况</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl top node</span></span><br><span class="line">NAME     CPU(cores)   CPU%   MEMORY(bytes)   MEMORY%</span><br><span class="line">master   <span class="number">98</span>m          <span class="number">4</span>%     <span class="number">1067</span><span class="built_in">Mi</span>          <span class="number">62</span>%</span><br><span class="line">node1    <span class="number">27</span>m          <span class="number">1</span>%     <span class="number">727</span><span class="built_in">Mi</span>           <span class="number">42</span>%</span><br><span class="line">node2    <span class="number">34</span>m          <span class="number">1</span>%     <span class="number">800</span><span class="built_in">Mi</span>           <span class="number">46</span>%</span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl top pod -n kube-system</span></span><br><span class="line">NAME                              CPU(cores)   MEMORY(bytes)</span><br><span class="line">coredns<span class="literal">-6955765f44-7ptsb</span>          <span class="number">3</span>m           <span class="number">9</span><span class="built_in">Mi</span></span><br><span class="line">coredns<span class="literal">-6955765f44-vcwr5</span>          <span class="number">3</span>m           <span class="number">8</span><span class="built_in">Mi</span></span><br><span class="line">etcd<span class="literal">-master</span>                       <span class="number">14</span>m          <span class="number">145</span><span class="built_in">Mi</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 至此,metrics-server安装完成</span></span><br></pre></td></tr></table></figure>

<p><strong>2 准备deployment和servie</strong></p>
<p>为了操作简单,直接使用命令</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建deployment </span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl run nginx --image=nginx:latest --requests=cpu=100m -n dev</span></span><br><span class="line"><span class="comment"># 创建service</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl expose deployment nginx --type=NodePort --port=80 -n dev</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl get deployment,pod,svc -n dev</span></span><br><span class="line">NAME                    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">deployment.apps/nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">47</span>s</span><br><span class="line"></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/nginx<span class="literal">-7df9756ccc-bh8dr</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">47</span>s</span><br><span class="line"></span><br><span class="line">NAME            <span class="built_in">TYPE</span>       CLUSTER<span class="literal">-IP</span>      EXTERNAL<span class="literal">-IP</span>   PORT(S)        AGE</span><br><span class="line">service/nginx   NodePort   <span class="number">10.109</span>.<span class="number">57.248</span>   &lt;none&gt;        <span class="number">80</span>:<span class="number">31136</span>/TCP   <span class="number">35</span>s</span><br></pre></td></tr></table></figure>

<p><strong>3 部署HPA</strong></p>
<p>创建<code>pc-hpa.yaml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">autoscaling/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">HorizontalPodAutoscaler</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-hpa</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">minReplicas:</span> <span class="number">1</span>  <span class="comment">#最小pod数量</span></span><br><span class="line">  <span class="attr">maxReplicas:</span> <span class="number">10</span> <span class="comment">#最大pod数量</span></span><br><span class="line">  <span class="attr">targetCPUUtilizationPercentage:</span> <span class="number">3</span> <span class="comment"># CPU使用率指标</span></span><br><span class="line">  <span class="attr">scaleTargetRef:</span>   <span class="comment"># 指定要控制的nginx信息</span></span><br><span class="line">    <span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line">    <span class="attr">kind:</span> <span class="string">Deployment</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">nginx</span>  </span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建hpa</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl create -f pc-hpa.yaml</span></span><br><span class="line">horizontalpodautoscaler.autoscaling/pc<span class="literal">-hpa</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看hpa</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> <span class="number">1.8</span>+]<span class="comment"># kubectl get hpa -n dev</span></span><br><span class="line">NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">62</span>s</span><br></pre></td></tr></table></figure>

<p><strong>4 测试</strong></p>
<p>使用压测工具对service地址<code>192.168.109.100:31136</code>进行压测，然后通过控制台查看hpa和pod的变化</p>
<p><code>hpa变化</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get hpa -n dev -w</span></span><br><span class="line">NAME     REFERENCE          TARGETS   MINPODS   MAXPODS   REPLICAS   AGE</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">4</span>m11s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">5</span>m19s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">22</span>%/<span class="number">3</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">6</span>m50s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">22</span>%/<span class="number">3</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">4</span>          <span class="number">7</span>m5s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">22</span>%/<span class="number">3</span>%    <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">7</span>m21s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">6</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">7</span>m51s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">9</span>m6s</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">8</span>          <span class="number">13</span>m</span><br><span class="line">pc<span class="literal">-hpa</span>   Deployment/nginx   <span class="number">0</span>%/<span class="number">3</span>%     <span class="number">1</span>         <span class="number">10</span>        <span class="number">1</span>          <span class="number">14</span>m</span><br></pre></td></tr></table></figure>

<p><code>deployment变化</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get deployment -n dev -w</span></span><br><span class="line">NAME    READY   UP<span class="literal">-TO-DATE</span>   AVAILABLE   AGE</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">11</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">4</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">13</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">4</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">1</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">2</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">2</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">3</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">3</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">4</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">4</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">5</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">5</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">6</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">6</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">7</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">7</span>           <span class="number">14</span>m</span><br><span class="line">nginx   <span class="number">8</span>/<span class="number">8</span>     <span class="number">8</span>            <span class="number">8</span>           <span class="number">15</span>m</span><br><span class="line">nginx   <span class="number">8</span>/<span class="number">1</span>     <span class="number">8</span>            <span class="number">8</span>           <span class="number">20</span>m</span><br><span class="line">nginx   <span class="number">8</span>/<span class="number">1</span>     <span class="number">8</span>            <span class="number">8</span>           <span class="number">20</span>m</span><br><span class="line">nginx   <span class="number">1</span>/<span class="number">1</span>     <span class="number">1</span>            <span class="number">1</span>           <span class="number">20</span>m</span><br></pre></td></tr></table></figure>

<p><code>pod变化</code></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx<span class="literal">-7df9756ccc-bh8dr</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">11</span>m</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">0</span>/<span class="number">1</span>     Pending   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">19</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">30</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">21</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">47</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">33</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">48</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">66</span>s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-fgst7</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-8zhwk</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">7</span>m5s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-cpgrv</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">7</span>m5s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-g56qb</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-rr9bn</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">7</span>m5s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-m9gsj</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br><span class="line">nginx<span class="literal">-7df9756ccc-sl9c6</span>   <span class="number">1</span>/<span class="number">1</span>     Terminating         <span class="number">0</span>          <span class="number">6</span>m50s</span><br></pre></td></tr></table></figure>


<h2 id="4-DaemonSet-DS"><a href="#4-DaemonSet-DS" class="headerlink" title="4. DaemonSet(DS)"></a>4. DaemonSet(DS)</h2><p>DaemonSet类型的控制器可以保证在集群中的每一台（或指定）节点上都运行一个副本。一般适用于日志收集、节点监控等场景。也就是说，如果一个Pod提供的功能是节点级别的（每个节点都需要且只需要一个），那么这类Pod就适合使用DaemonSet类型的控制器创建。</p>
<p><img src="https://img-blog.csdnimg.cn/a4dffd89cb05434ea89a128e394420aa.png" alt="在这里插入图片描述"><br>DaemonSet控制器的特点：</p>
<ul>
<li>每当向集群中添加一个节点时，指定的 Pod 副本也将添加到该节点上</li>
<li>当节点从集群中移除时，Pod 也就被垃圾回收了</li>
</ul>
<p>下面先来看下DaemonSet的资源清单文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">daemonset</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留历史版本</span></span><br><span class="line">  <span class="attr">updateStrategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 滚动更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">1</span> <span class="comment"># 最大不可用状态的 Pod 的最大值，可以为百分比，也可以为整数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">nginx-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>创建<code>pc-daemonset.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-daemonset</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span> </span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.17.1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建daemonset</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f  pc-daemonset.yaml</span></span><br><span class="line">daemonset.apps/pc<span class="literal">-daemonset</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看daemonset</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get ds -n dev -o wide</span></span><br><span class="line">NAME        DESIRED  CURRENT  READY  UP<span class="literal">-TO-DATE</span>  AVAILABLE   AGE   CONTAINERS   IMAGES         </span><br><span class="line">pc<span class="literal">-daemonset</span>   <span class="number">2</span>        <span class="number">2</span>        <span class="number">2</span>      <span class="number">2</span>           <span class="number">2</span>        <span class="number">24</span>s   nginx        nginx:<span class="number">1.17</span>.<span class="number">1</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod,发现在每个Node上都运行一个pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment">#  kubectl get pods -n dev -o wide</span></span><br><span class="line">NAME                 READY   STATUS    RESTARTS   AGE   IP            NODE    </span><br><span class="line">pc<span class="literal">-daemonset-9bck8</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s   <span class="number">10.244</span>.<span class="number">1.43</span>   node1     </span><br><span class="line">pc<span class="literal">-daemonset-k224w</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">37</span>s   <span class="number">10.244</span>.<span class="number">2.74</span>   node2      </span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除daemonset</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-daemonset.yaml</span></span><br><span class="line">daemonset.apps <span class="string">&quot;pc-daemonset&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="5-Job"><a href="#5-Job" class="headerlink" title="5. Job"></a>5. Job</h2><p>Job，主要用于负责批量处理(一次要处理指定数量任务)短暂的一次性(每个任务仅运行一次就结束)任务。Job特点如下：</p>
<ul>
<li>当Job创建的pod执行成功结束时，Job将记录成功结束的pod数量</li>
<li>当成功结束的pod达到指定的数量时，Job将完成执行</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2a9578a3220c4e24b0738cc21a767113.png" alt="在这里插入图片描述"><br>Job的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">job</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">completions:</span> <span class="number">1</span> <span class="comment"># 指定job需要成功运行Pods的次数。默认值: 1</span></span><br><span class="line">  <span class="attr">parallelism:</span> <span class="number">1</span> <span class="comment"># 指定job在任一时刻应该并发运行Pods的数量。默认值: 1</span></span><br><span class="line">  <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span> <span class="comment"># 指定job可运行的时间期限，超过时间还未结束，系统将会尝试进行终止。</span></span><br><span class="line">  <span class="attr">backoffLimit:</span> <span class="number">6</span> <span class="comment"># 指定job失败后进行重试的次数。默认是6</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span> <span class="comment"># 是否可以使用selector选择器选择pod，默认是false</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，通过它指定该控制器管理哪些pod</span></span><br><span class="line">    <span class="attr">matchLabels:</span>      <span class="comment"># Labels匹配规则</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">matchExpressions:</span> <span class="comment"># Expressions匹配规则</span></span><br><span class="line">      <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># 模板，当副本数量不足时，会根据下面的模板创建pod副本</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span> <span class="comment"># 重启策略只能设置为Never或者OnFailure</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 2;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">关于重启策略设置的说明：</span><br><span class="line"><span class="code">    如果指定为OnFailure，则job会在pod出现故障时重启容器，而不是创建pod，failed次数不变</span></span><br><span class="line"><span class="code">    如果指定为Never，则job会在pod出现故障时创建新的pod，并且故障pod不会消失，也不会重启，failed次数加1</span></span><br><span class="line"><span class="code">    如果指定为Always的话，就意味着一直重启，意味着job任务会重复去执行了，当然不对，所以不能设置为Always</span></span><br></pre></td></tr></table></figure>

<p>创建<code>pc-job.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span>      </span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-job</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-job.yaml</span></span><br><span class="line">job.batch/pc<span class="literal">-job</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get job -n dev -o wide  -w</span></span><br><span class="line">NAME     COMPLETIONS   DURATION   AGE   CONTAINERS   IMAGES         SELECTOR</span><br><span class="line">pc<span class="literal">-job</span>   <span class="number">0</span>/<span class="number">1</span>           <span class="number">21</span>s        <span class="number">21</span>s   counter      busybox:<span class="number">1.30</span>   app=counter<span class="literal">-pod</span></span><br><span class="line">pc<span class="literal">-job</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">31</span>s        <span class="number">79</span>s   counter      busybox:<span class="number">1.30</span>   app=counter<span class="literal">-pod</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过观察pod状态可以看到，pod在运行完毕任务后，就会变成Completed状态</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME           READY   STATUS     RESTARTS      AGE</span><br><span class="line">pc<span class="literal">-job-rxg96</span>   <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>            <span class="number">29</span>s</span><br><span class="line">pc<span class="literal">-job-rxg96</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>            <span class="number">33</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来，调整下pod运行的总数量和并行数量 即：在spec下设置下面两个选项</span></span><br><span class="line"><span class="comment">#  completions: 6 # 指定job需要成功运行Pods的次数为6</span></span><br><span class="line"><span class="comment">#  parallelism: 3 # 指定job并发运行Pods的数量为3</span></span><br><span class="line"><span class="comment">#  然后重新运行job，观察效果，此时会发现，job会每次运行3个pod，总共执行了6个pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev -w</span></span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pc<span class="literal">-job-684ft</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>s</span><br><span class="line">pc<span class="literal">-job-jhj49</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>s</span><br><span class="line">pc<span class="literal">-job-pfcvh</span>   <span class="number">1</span>/<span class="number">1</span>     Running   <span class="number">0</span>          <span class="number">5</span>s</span><br><span class="line">pc<span class="literal">-job-684ft</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">11</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     Pending     <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     Pending     <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-jhj49</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">11</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-pfcvh</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">11</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     Pending             <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     ContainerCreating   <span class="number">0</span>          <span class="number">0</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">2</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">1</span>/<span class="number">1</span>     Running             <span class="number">0</span>          <span class="number">3</span>s</span><br><span class="line">pc<span class="literal">-job-fhwf7</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">12</span>s</span><br><span class="line">pc<span class="literal">-job-v7rhr</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">12</span>s</span><br><span class="line">pc<span class="literal">-job-5vg2j</span>   <span class="number">0</span>/<span class="number">1</span>     Completed           <span class="number">0</span>          <span class="number">12</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl delete -f pc-job.yaml</span></span><br><span class="line">job.batch <span class="string">&quot;pc-job&quot;</span> deleted</span><br></pre></td></tr></table></figure>

<h2 id="6-CronJob-CJ"><a href="#6-CronJob-CJ" class="headerlink" title="6. CronJob(CJ)"></a>6. CronJob(CJ)</h2><p>CronJob控制器以Job控制器资源为其管控对象，并借助它管理pod资源对象，Job控制器定义的作业任务在其控制器资源创建之后便会立即执行，但CronJob可以以类似于Linux操作系统的周期性任务作业计划的方式控制其运行<strong>时间点</strong>及<strong>重复运行</strong>的方式。也就是说，<strong>CronJob可以在特定的时间点(反复的)去运行job任务</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/2f5daffd251d4859b61b672b026768b8.png" alt="在这里插入图片描述"><br>CronJob的资源清单文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span> <span class="comment"># 类型       </span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="comment"># rs名称 </span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="comment"># 所属命名空间 </span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment">#标签</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 详情描述</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="comment"># cron格式的作业调度运行时间点,用于控制任务在什么时间执行</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="comment"># 并发执行策略，用于定义前一次作业运行尚未完成时是否以及如何运行后一次的作业</span></span><br><span class="line">  <span class="attr">failedJobHistoryLimit:</span> <span class="comment"># 为失败的任务执行保留的历史记录数，默认为1</span></span><br><span class="line">  <span class="attr">successfulJobHistoryLimit:</span> <span class="comment"># 为成功的任务执行保留的历史记录数，默认为3</span></span><br><span class="line">  <span class="attr">startingDeadlineSeconds:</span> <span class="comment"># 启动作业错误的超时时长</span></span><br><span class="line">  <span class="attr">jobTemplate:</span> <span class="comment"># job控制器模板，用于为cronjob控制器生成job对象;下面其实就是job的定义</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">completions:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">activeDeadlineSeconds:</span> <span class="number">30</span></span><br><span class="line">      <span class="attr">backoffLimit:</span> <span class="number">6</span></span><br><span class="line">      <span class="attr">manualSelector:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">matchExpressions:</span> <span class="string">规则</span></span><br><span class="line">          <span class="bullet">-</span> &#123;<span class="attr">key:</span> <span class="string">app</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">counter-pod</span>]&#125;</span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">metadata:</span></span><br><span class="line">          <span class="attr">labels:</span></span><br><span class="line">            <span class="attr">app:</span> <span class="string">counter-pod</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span> </span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 20;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight md"><table><tr><td class="code"><pre><span class="line">需要重点解释的几个选项：</span><br><span class="line">schedule: cron表达式，用于指定任务的执行时间</span><br><span class="line"><span class="code">	*/1    *      *    *     *</span></span><br><span class="line"><span class="code">	&lt;分钟&gt; &lt;小时&gt; &lt;日&gt; &lt;月份&gt; &lt;星期&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="code">    分钟 值从 0 到 59.</span></span><br><span class="line"><span class="code">    小时 值从 0 到 23.</span></span><br><span class="line"><span class="code">    日 值从 1 到 31.</span></span><br><span class="line"><span class="code">    月 值从 1 到 12.</span></span><br><span class="line"><span class="code">    星期 值从 0 到 6, 0 代表星期日</span></span><br><span class="line"><span class="code">    多个时间可以用逗号隔开； 范围可以用连字符给出；*可以作为通配符； /表示每...</span></span><br><span class="line"><span class="code">concurrencyPolicy:</span></span><br><span class="line"><span class="code">	Allow:   允许Jobs并发运行(默认)</span></span><br><span class="line"><span class="code">	Forbid:  禁止并发运行，如果上一次运行尚未完成，则跳过下一次运行</span></span><br><span class="line"><span class="code">	Replace: 替换，取消当前正在运行的作业并用新作业替换它</span></span><br></pre></td></tr></table></figure>

<p>创建<code>pc-cronjob.yaml</code>，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pc-cronjob</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">controller:</span> <span class="string">cronjob</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;*/1 * * * *&quot;</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">counter</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.30</span></span><br><span class="line">            <span class="attr">command:</span> [<span class="string">&quot;bin/sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;for i in 9 8 7 6 5 4 3 2 1; do echo $i;sleep 3;done&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建cronjob</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl create -f pc-cronjob.yaml</span></span><br><span class="line">cronjob.batch/pc<span class="literal">-cronjob</span> created</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看cronjob</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get cronjobs -n dev</span></span><br><span class="line">NAME         SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE</span><br><span class="line">pc<span class="literal">-cronjob</span>   */<span class="number">1</span> * * * *   False     <span class="number">0</span>        &lt;none&gt;          <span class="number">6</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看job</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get jobs -n dev</span></span><br><span class="line">NAME                    COMPLETIONS   DURATION   AGE</span><br><span class="line">pc<span class="literal">-cronjob-1592587800</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">28</span>s        <span class="number">3</span>m26s</span><br><span class="line">pc<span class="literal">-cronjob-1592587860</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">28</span>s        <span class="number">2</span>m26s</span><br><span class="line">pc<span class="literal">-cronjob-1592587920</span>   <span class="number">1</span>/<span class="number">1</span>           <span class="number">28</span>s        <span class="number">86</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看pod</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl get pods -n dev</span></span><br><span class="line">pc<span class="literal">-cronjob-1592587800-x4tsm</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">2</span>m24s</span><br><span class="line">pc<span class="literal">-cronjob-1592587860-r5gv4</span>   <span class="number">0</span>/<span class="number">1</span>     Completed   <span class="number">0</span>          <span class="number">84</span>s</span><br><span class="line">pc<span class="literal">-cronjob-1592587920-9dxxq</span>   <span class="number">1</span>/<span class="number">1</span>     Running     <span class="number">0</span>          <span class="number">24</span>s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除cronjob</span></span><br><span class="line">[<span class="type">root</span>@<span class="type">master</span> ~]<span class="comment"># kubectl  delete -f pc-cronjob.yaml</span></span><br><span class="line">cronjob.batch <span class="string">&quot;pc-cronjob&quot;</span> deleted</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
  </entry>
</search>
